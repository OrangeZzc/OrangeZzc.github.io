<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java语法（高级） | Orange's Blog</title><meta name="author" content="OrangeZzc"><meta name="copyright" content="OrangeZzc"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="世界上最好的编程语言">
<meta property="og:type" content="article">
<meta property="og:title" content="Java语法（高级）">
<meta property="og:url" content="https://orangezzc.github.io/2023/04/26/Java%E8%AF%AD%E6%B3%95%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/index.html">
<meta property="og:site_name" content="Orange&#39;s Blog">
<meta property="og:description" content="世界上最好的编程语言">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://orangezzc.github.io/imgs/javayufafenmian.jpg">
<meta property="article:published_time" content="2023-04-26T10:51:27.000Z">
<meta property="article:modified_time" content="2023-04-27T08:06:16.628Z">
<meta property="article:author" content="OrangeZzc">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://orangezzc.github.io/imgs/javayufafenmian.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://orangezzc.github.io/2023/04/26/Java%E8%AF%AD%E6%B3%95%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":30},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: OrangeZzc","link":"链接: ","source":"来源: Orange's Blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java语法（高级）',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-27 16:06:16'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avater.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 学无止境</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: transparent"><nav id="nav"><span id="blog-info"><a href="/" title="Orange's Blog"><span class="site-name">Orange's Blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 学无止境</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java语法（高级）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-04-26T10:51:27.000Z" title="发表于 2023-04-26 18:51:27">2023-04-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-04-27T08:06:16.628Z" title="更新于 2023-04-27 16:06:16">2023-04-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java%E8%AF%AD%E6%B3%95/">Java语法</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">38.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>134分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java语法（高级）"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="三、Java高级编程"><a href="#三、Java高级编程" class="headerlink" title="三、Java高级编程"></a>三、Java高级编程</h1><h2 id="1、多线程"><a href="#1、多线程" class="headerlink" title="1、多线程"></a>1、多线程</h2><h3 id="A-基本概念"><a href="#A-基本概念" class="headerlink" title="A.基本概念"></a>A.基本概念</h3><h4 id="①程序"><a href="#①程序" class="headerlink" title="①程序"></a>①程序</h4><p>​	是为完成特定任务、用某种语言编写的一组指令的集合。即指一段静态的代码，静态对象。</p>
<h4 id="②进程"><a href="#②进程" class="headerlink" title="②进程"></a>②进程</h4><p>​	正在运行的一个程序。是一个动态的过程：有它自身的产生、存在和消亡的过程——生命周期。</p>
<h4 id="③线程"><a href="#③线程" class="headerlink" title="③线程"></a>③线程</h4><p>​	进程可进一步细化为多个线程，是一个程序内部的一条执行路径。若一个进程同一时间并行执行多个线程，就是支持多线程的。一个进程最少有一个线程。</p>
<p>​	说明：线程作为调度和执行的最小单位</p>
<h4 id="④进程、线程在JVM中的内存分配情况"><a href="#④进程、线程在JVM中的内存分配情况" class="headerlink" title="④进程、线程在JVM中的内存分配情况"></a>④进程、线程在JVM中的内存分配情况</h4><p>​	一个进程只能拥有一个堆和一个方法区。一个线程独立拥有一个虚拟机栈（也就是我们常说的栈）和一个程序计算器。一个进程中的多个线程共享该进程中的堆和方法区。</p>
<p><img src="/../../imgs/image-20230426175853003.png" alt="image-20230426175853003"></p>
<p>​	多个线程操作共享的系统资源可能就会带来安全的隐患。</p>
<h4 id="⑤单核与多核CPU"><a href="#⑤单核与多核CPU" class="headerlink" title="⑤单核与多核CPU"></a>⑤单核与多核CPU</h4><p>​	<strong>单核CPU</strong>，其实是一种假的多线程，因为在一个时间单元内，也只能执行一个线程的任务。例如：虽然电脑有多个程序同时运行着，其实CPU是先执行一个线程一段时间，再执行另一个线程一段时间，……但是因为CPU时间单元特别短，因此以为是多线程的。</p>
<p>​	<strong>多核CPU</strong>在同一时间内可以执行多个线程，因此多核CPU才能更好的发挥多线程的效率（现在的服务器都是多核的）。</p>
<h4 id="⑥并行与并发"><a href="#⑥并行与并发" class="headerlink" title="⑥并行与并发"></a>⑥并行与并发</h4><p>​	<strong>并行：</strong>多个CPU同时执行多个任务。比如：多个人同时做不同的事。</p>
<p>​	<strong>并发：</strong>一个CPU(采用时间片)“同时”执行多个任务。</p>
<h4 id="⑦多线程的好处"><a href="#⑦多线程的好处" class="headerlink" title="⑦多线程的好处"></a>⑦多线程的好处</h4><ul>
<li>提高应用程序的响应。对图形化界更有意义，可增强用户体验</li>
<li>提高计算机系统CPU的利用率</li>
<li>改善程序结构。将既长又复杂的进程分为多个线程，独立运行，利于理解和修改</li>
</ul>
<h4 id="⑧何时使用多线程"><a href="#⑧何时使用多线程" class="headerlink" title="⑧何时使用多线程"></a>⑧何时使用多线程</h4><ul>
<li>程序需要同时执行两个或多个任务。</li>
<li>程序需要实现一些需要等待的任务时，如：用户输入、文件读写操作、网络操作、搜索等。</li>
<li>需要一些后台运行的程序时。</li>
</ul>
<h3 id="B-线程的创建和使用"><a href="#B-线程的创建和使用" class="headerlink" title="B.线程的创建和使用"></a>B.线程的创建和使用</h3><h4 id="①多线程创建–方式一"><a href="#①多线程创建–方式一" class="headerlink" title="①多线程创建–方式一"></a>①多线程创建–方式一</h4><p>​	A.创建一个继承于Thread类的子类</p>
<p>​	B.重写Thread类的run()方法 –&gt; 将此线程执行的操作声明在run()方法中</p>
<p>​	C.创建Thread类的子类的对象</p>
<p>​	D.提高此对象调用start()方法。start()方法里做两件事：①启动当前线程 ②调用当前线程的run()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWrold</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadTest</span> <span class="variable">threadTest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadTest</span>();</span><br><span class="line">        threadTest.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">              System.out.println(<span class="string">&quot;******main()******&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadTest</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	一开始是在主线程（即main方法）中执行第3、4行代码，当执行完第4行代码后，就创建另一个线程了。该线程执行了线程对象中的run()方法，与此同时主线程中调用start()方法之后的代码也会同时执行，所以体现了多线程的概念。由于是同时执行，加上涉及到输出语句时，所以其运行的结果每次都不一样。</p>
<p>​	<strong>注意：</strong></p>
<p>​	①我们不能通过直接调用run()的方式启动线程。只能通过调用start()方法来启动线程。</p>
<p>​	②如果想启动多个线程，只能先造多个线程对象，然后再各自调用start()方法。</p>
<p>​	③当线程之间执行的事情不一样时，就得造不同的Thread类的子类。</p>
<p>​	④上面的创建方式可以更简洁———创建Thread类的匿名子类</p>
<p>​	因为创建的Thread子类的对象只使用一次，导致其类也只使用一次，所以就产生了这种写法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">25</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i % <span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">             System.out.println(<span class="string">&quot;******main()******&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="②多线程创建–方式二"><a href="#②多线程创建–方式二" class="headerlink" title="②多线程创建–方式二"></a>②多线程创建–方式二</h4><p>​	<strong>创建步骤：</strong></p>
<ol>
<li>创建一个实现了Runnable接口的类</li>
<li>实现类去实现Runnable中的抽象方法：run()</li>
<li>创建实现类的对象</li>
<li>将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象</li>
<li>通过Thread类的对象调用start()，start方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWrold</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(myThread);</span><br><span class="line">        t1.start();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Thread t2 = new Thread(myThread);</span></span><br><span class="line">        <span class="comment">//t2.start();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;<span class="comment">//写线程要执行的代码</span></span><br><span class="line">        System.out.println(<span class="string">&quot;12&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	</p>
<p>​	如果用这种方式创建多个线程，并且这些线程执行的内容是一样的，那只需要这样做就行：上面的第7、8行代码</p>
<p>​	补充：</p>
<p><img src="/../../imgs/image-20230426175945309.png" alt="image-20230426175945309"></p>
<p>​	此时三个线程t1、t2、t3共用一个Window1对象w，因此这三个线程也就共用Window1对象w里的属性。因此<strong>定义在实现类里的属性为共享数据</strong>。</p>
<h4 id="③方式一-amp-方式二的对比"><a href="#③方式一-amp-方式二的对比" class="headerlink" title="③方式一&amp;方式二的对比"></a>③方式一&amp;方式二的对比</h4><p>开发中：优先选择：实现Runnable接口的方式</p>
<p>原因：①实现的方式没有类的单继承性的局限性</p>
<p>​		   ②实现的方式更合适来处理多个线程有共享数据的情况</p>
<p>两者联系：class Thread implements Runnable</p>
<p>相同点：两种方式都需要重写run()，将线程要执行的逻辑声明在run()中。</p>
<hr>
<h3 id="C-Thread类常用方法的使用"><a href="#C-Thread类常用方法的使用" class="headerlink" title="C.Thread类常用方法的使用"></a>C.Thread类常用方法的使用</h3><h4 id="①start"><a href="#①start" class="headerlink" title="①start()"></a>①start()</h4><p>​	start()方法的作用：启动当前线程；调用当前线程的run()</p>
<p>​	谁调用start()方法，谁就是线程。t1.start()，t1就是线程。</p>
<h4 id="②run"><a href="#②run" class="headerlink" title="②run()"></a>②run()</h4><p>​	通常需要重写Thread类中的此方法，将创建的线程要执行的操作声明在此方法中</p>
<h4 id="③currentThread"><a href="#③currentThread" class="headerlink" title="③currentThread()"></a>③currentThread()</h4><p>​	该方法属于静态方法，返回执行当前代码的线程</p>
<p>​	使用：Thread.currentThread()</p>
<h4 id="④getName"><a href="#④getName" class="headerlink" title="④getName()"></a>④getName()</h4><p>​	获取当前线程的名字</p>
<p>​	使用：</p>
<p>​			①通过Thread类的子类的对象调用 </p>
<p>​			②Thread.currentThread().getName()调用</p>
<h4 id="⑤setName"><a href="#⑤setName" class="headerlink" title="⑤setName()"></a>⑤setName()</h4><p>​	设置当前线程的名字</p>
<p>​	使用：</p>
<p>​			①通过Thread类的子类的对象调用 ，只能在调用start方法前调用。</p>
<p>​			②Thread.currentThread().setName()调用。如果想要修改主线程（main线程）的名字，只能通过此方法修改</p>
<p>​	补充：</p>
<p>​			也可以通过构造器的方式给线程命名</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadTest</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hhhh&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//通过构造器给线程命名</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadTest</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="⑥yield"><a href="#⑥yield" class="headerlink" title="⑥yield()"></a>⑥yield()</h4><p>​	该方法是static方法</p>
<p>​	释放当前cpu的执行权。释放后，可能被其他线程抢到了执行权，也可能还是刚才的线程抢到执行权。</p>
<p>​	说明：</p>
<ul>
<li>在Thread类的子类里可以直接使用该方法，否则得通过Thread.currentThread().yield()或Thread.yield()调用</li>
</ul>
<h4 id="⑦join"><a href="#⑦join" class="headerlink" title="⑦join()"></a>⑦join()</h4><p>​	在线程 a 中调用线程 b 的 join() 方法，即让b线程加入到a线程中，此时线程 a 进入阻塞状态，直到线程 b 执行完run()方法为止，线程 a才继续执行剩下的代码。</p>
<p>​	应用：当线程a需要另一个线程b中的数据时，就可以让线程b加入（join）到线程a中执行。等线程b执行完后，就有数据了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用法：在线程a中使用b.join();</span></span><br></pre></td></tr></table></figure>

<p>​	注意：该方法本身会抛出异常，所以得使用try-catch-finally或throws对其进行处理。</p>
<h4 id="⑧stop"><a href="#⑧stop" class="headerlink" title="⑧stop()"></a>⑧stop()</h4><p>​	执行此方法时，强制结束当前线程。不推荐使用。（因为已经过时）</p>
<h4 id="⑨sleep-long-millis"><a href="#⑨sleep-long-millis" class="headerlink" title="⑨sleep(long millis)"></a>⑨sleep(long millis)</h4><p>​	millis的单位为毫秒，1000毫秒等于1秒。该方法是静态方法，可通过Thread调用</p>
<p>​	让当前线程“睡眠”指定的millis毫秒。在指定的millis毫秒时间内，当前线程是阻塞状态（即不执行）。过了指定的时间后，就等CPU分配资源，分配到资源后该线程才继续执行。</p>
<p>​	注意：该方法本身会抛出异常，所以得使用try-catch-finally或throws对其进行处理。如果是在run()方法里调用sleep()方法，那只能使用try-catch-finally进行异常处理，因为父类中的run()方法在声明时并没有用throws。</p>
<h4 id="⑩isAlive"><a href="#⑩isAlive" class="headerlink" title="⑩isAlive()"></a>⑩isAlive()</h4><p>​	判断当前线程是否存活。是，返回true；否则返回false。</p>
<h3 id="D-线程调度"><a href="#D-线程调度" class="headerlink" title="D.线程调度"></a>D.线程调度</h3><h4 id="①调度策略"><a href="#①调度策略" class="headerlink" title="①调度策略"></a>①调度策略</h4><p>​		<strong>时间片：</strong>每个线程都执行固定的一段时间</p>
<p>​		<strong>抢占式：</strong></p>
<p>​		根据线程的优先级来调度，优先级越高，先被CPU调度的概率越大。</p>
<p>​		<strong>线程的优先级：</strong></p>
<p>​		MIN_PRIORITY &#x3D; 1</p>
<p>​		NORM_PRIORITY &#x3D; 5   – 默认优先级</p>
<p>​		MAX_PRIORITY &#x3D; 10</p>
<p>​		以上属性都声明在Thread类里，且这些属性都为静态属性，可以通过Thread来调用</p>
<p>​		<strong>说明：</strong>高优先级的线程要抢占低优先级线程CPU的执行权。但是只是从概论上讲，高优先级的线程高概率的情况下被执行。并不意味着只有当高优先级的线程执行完以后，低优先级的线程才执行。</p>
<h4 id="②如何获取和设置当前线程的优先级"><a href="#②如何获取和设置当前线程的优先级" class="headerlink" title="②如何获取和设置当前线程的优先级"></a>②如何获取和设置当前线程的优先级</h4><ul>
<li>getPriority()：获取线程优先级p</li>
<li>setPriority(int p)：设置线程的优先级</li>
</ul>
<h3 id="E-线程的生命周期"><a href="#E-线程的生命周期" class="headerlink" title="E.线程的生命周期"></a>E.线程的生命周期</h3><p>​	记住线程生命周期里的几种状态及各状态之间是怎么转换的</p>
<img src="/../../imgs/image-20230426180016170.png" alt="image-20230426180016170" style="zoom: 50%;" />

<p>​	线程只有唯一的最终状态：死亡</p>
<p>​	</p>
<h3 id="F-线程同步"><a href="#F-线程同步" class="headerlink" title="F.线程同步"></a>F.线程同步</h3><h4 id="①引言"><a href="#①引言" class="headerlink" title="①引言"></a>①引言</h4><p>​	当多个线程操作共享数据时，就可能会出现线程安全问题。</p>
<p>​	<strong>出现线程安全问题的原因：</strong></p>
<p>​	当某个线程操作共享数据的过程中，尚未操作完成，其他线程参与进来，也操作共享数据。</p>
<p>​	<strong>如何解决线程安全问题：</strong></p>
<p>​	当一个线程a在操作共享数据的时候，其他线程不能参与进来。直到线程a操作完共享数据时，其他线程才可以开始操作共享数据。这种情况即使线程a出现了阻塞，也不能改变。</p>
<p>​	<strong>同步机制</strong></p>
<p>​	在Java中，我们通过同步机制，来解决线程的安全问题。</p>
<h4 id="②实现同步机制的方式一：同步代码块"><a href="#②实现同步机制的方式一：同步代码块" class="headerlink" title="②实现同步机制的方式一：同步代码块"></a>②实现同步机制的方式一：同步代码块</h4><p>​	<strong>格式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(同步监视器)&#123;</span><br><span class="line">	<span class="comment">//需要被同步的代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//快捷键alt + shift + j</span></span><br></pre></td></tr></table></figure>

<p>​	<strong>说明：</strong></p>
<ol>
<li><p>操作共享数据的代码，即为需要同步的代码 –&gt; 不能包含代码多了，也不能包含代码少了。</p>
</li>
<li><p>共享数据：多个线程共同操作的变量。</p>
</li>
<li><p>同步监视器，俗称：锁。任何一个类的对象，都可以充当锁。但要注意：<strong>多个线程必须要共用一把锁</strong>。如果还出现线程不安全问题，大部分是因为没有共用一把锁。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="comment">//通常就用obj来充当锁了</span></span><br><span class="line"><span class="comment">/*拓展：</span></span><br><span class="line"><span class="comment">如果是在多线程的创建方式二（即：实现Runnable接口的方式）里使用同步机制一，那么锁可以考虑用this代替，如：synchronized(this)&#123;&#125;，最终能不能用this，还得看是否造了唯一的一个实现类的对象，是则可以使用this</span></span><br><span class="line"><span class="comment">如果是在多线程的创建方式一（即：继承Thread类的方式）里使用同步机制一，就不可以用this来代替锁。可以使用“继承Thread类的类名.class”,这涉及到反射的知识，后面再讲。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p> ​</p>
</li>
</ol>
<p>			</p>
<h4 id="③实现同步机制—方式二"><a href="#③实现同步机制—方式二" class="headerlink" title="③实现同步机制—方式二"></a>③实现同步机制—方式二</h4><p>​	<strong>同步方法</strong></p>
<p>​	如果操作共享数据的代码完整的声明在一个方法中，我们不妨将此方法声明为同步方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//格式：在void前加上synchronized即可</span></span><br><span class="line"><span class="comment">//run()方法也可以声明为同步方法，但得看声明为同步方法之后实际的逻辑合不合理</span></span><br></pre></td></tr></table></figure>

<p>​	实现Runnable()接口的方式创建线程，然后想使用同步方法的形式解决线程安全问题,做法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">前提：所有操作共享数据的代码都在同步方法里</span></span><br><span class="line"><span class="comment">然后在 “返回值” 前加上synchronized即可</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>​	继承Thread类的形式创建线程，然后想使用同步方法的形式解决线程安全问题,做法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">前提：所有操作共享数据的代码都在同步方法里</span></span><br><span class="line"><span class="comment">然后在 “返回值” 前加上synchronized，并将该方法声明为static的</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>​	说明：</p>
<ol>
<li><p>同步方法仍然涉及到同步监视器，只是不需要我们显示的声明</p>
</li>
<li><p>非静态的同步方法，同步监视器是：this</p>
<p> 静态的同步方法，同步监视器是：当前类本身，即：类名.class</p>
</li>
</ol>
<h4 id="④如何判定锁只有一把"><a href="#④如何判定锁只有一把" class="headerlink" title="④如何判定锁只有一把"></a>④如何判定锁只有一把</h4><p>​	A.当用实现Runnable()接口的方式创建线程时，你只需要看该实现类是否只创建了一个对象。是，则大概率是只有一把锁。</p>
<p>​	B.用继承Thread类的方式创建线程的情况就比较容易判断出来，故不再赘述。</p>
<p>​	C.this出现在一个类里，则代表当前类的对象，如：this出现在MyThread类里，this则代表MyThread的对象，如果MyThread类的对象只创建了一个，则this就指那唯一的一个MyThread类的对象</p>
<p>​	<strong>总结</strong></p>
<p>​	如果不确定是否只有一把锁，那么这样做准没错：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用同步代码块的方式：</span></span><br><span class="line"><span class="comment">synchronized(当前类的类名.class)&#123;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">使用同步方法的方式：</span></span><br><span class="line"><span class="comment">在void前加synchronized且将此方法声明为static</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h4 id="⑤线程的死锁问题"><a href="#⑤线程的死锁问题" class="headerlink" title="⑤线程的死锁问题"></a>⑤线程的死锁问题</h4><p>​	<strong>定义</strong></p>
<p><img src="/../../imgs/image-20230426180047132.png" alt="image-20230426180047132"></p>
<p>​	<strong>说明</strong></p>
<p><img src="/../../imgs/image-20230426180101680.png" alt="image-20230426180101680"></p>
<p>​	我们在写同步时，要避免死锁。</p>
<p>​	<strong>解决方法</strong></p>
<p><img src="/../../imgs/image-20230426180112273.png" alt="image-20230426180112273"></p>
<p>​	</p>
<h4 id="⑥实现同步机制–方式三"><a href="#⑥实现同步机制–方式三" class="headerlink" title="⑥实现同步机制–方式三"></a>⑥实现同步机制–方式三</h4><p>​	<strong>Lock锁</strong> - - - JDK5.0新增，Lock是一个接口，其实现类为ReentrantLock()</p>
<p>​	<strong>实现步骤</strong></p>
<ol>
<li>在run()方法外面创建ReentrantLock()对象</li>
<li>将需要被同步的代码用try包起来，再在try{ }后面加上finally</li>
<li>在try结构的开头用ReentrantLock()对象调用锁定方法：lock()</li>
<li>在finally结构中用ReentrantLock()对象调用解锁方法：unlock()</li>
</ol>
<p>​	<strong>说明</strong></p>
<ol>
<li><p>调用lock()方法之后的代码就只能同一时间只有一个线程执行，从而达到了线程安全的目的，当执行到unlock()时，就解锁了。</p>
</li>
<li><p>如果在实现Runnable()接口的方式里用Lock的方式解决线程安全问题，则ReentrantLock()对象就不用加static，因为这种创建线程的方式本身就有共享属性的特性，导致同步锁也只有创建了一把，符合要求，因此不用加static。</p>
</li>
<li><p>而如果在继承Thread的方式里用Lock的方式解决线程安全问题，则ReentrantLock()对象需要加static，如果不加static就会各自的ReentrantLock()对象，导致调用lock()时每个线程都各自有一把锁，这就不符合唯一一把锁的原则。所有得加static。</p>
</li>
</ol>
<h4 id="⑦synchronized-与-Lock的异同"><a href="#⑦synchronized-与-Lock的异同" class="headerlink" title="⑦synchronized 与 Lock的异同"></a>⑦synchronized 与 Lock的异同</h4><p><img src="/../../imgs/image-20230426180146360.png" alt="image-20230426180146360"></p>
<h3 id="G-线程的通信"><a href="#G-线程的通信" class="headerlink" title="G.线程的通信"></a>G.线程的通信</h3><h4 id="①涉及到的三个方法"><a href="#①涉及到的三个方法" class="headerlink" title="①涉及到的三个方法"></a>①涉及到的三个方法</h4><ol>
<li>wait()：一旦执行此方法，当前线程就会进入阻塞状态，并释放其占有的同步监视器。</li>
<li>notify：一旦执行此方法，就会唤醒被wait的一个线程。如果有多个线程被wait，就唤醒优先级高的那个，如果优先级一样，则随机唤醒。</li>
<li>notifyAll()：：一旦执行此方法，就会唤醒所有被wait的线程。</li>
</ol>
<h4 id="②注意"><a href="#②注意" class="headerlink" title="②注意"></a>②注意</h4><ol>
<li>上面三个方法必须使用在同步代码块或同步方法中</li>
<li>上面三个方法的调用者必须是同步代码块或同步方法中的同步监视器。否则，会出现IllegalMonitorStateException异常。如：如果同步监视器为obj，则想调用这三个方法，只能通过obj来调用；如果同步监视器为this，则想调用这三个方法，只能通过this来调用。</li>
<li>上面三个方法是定义在java.lang.Object类中。</li>
</ol>
<h4 id="③线程通信例子"><a href="#③线程通信例子" class="headerlink" title="③线程通信例子"></a>③线程通信例子</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//notify()和wait()的应用例子</span></span><br><span class="line"><span class="comment">//实现两个线程互相对话，输入1结束通信</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread2</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread2</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(thread2);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(thread2);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (MyThread2.class)&#123;</span><br><span class="line">                MyThread2.class.notify();</span><br><span class="line">                System.out.println(<span class="string">&quot;请&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;输入相应的内容，输入1结束此次输入&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">                <span class="keyword">if</span> (Integer.parseInt(s1) != <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        MyThread2.class.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../../imgs/image-20230426180206120.png" alt="image-20230426180206120"></p>
<h3 id="H-sleep-和wait-的异同"><a href="#H-sleep-和wait-的异同" class="headerlink" title="H.sleep()和wait()的异同"></a>H.sleep()和wait()的异同</h3><p>​	<strong>相同点</strong></p>
<p>​	一旦执行方法，都可以使得当前的线程进入阻塞状态。</p>
<p>​	<strong>不同点</strong></p>
<ol>
<li>两个方法声明的位置不同：sleep()声明在Thread类中，wait()声明在Object类中</li>
<li>调用的要求不同：sleep()可以在任何需要的场景下调用，wait()必须使用在同步代码块或同步方法中。</li>
<li>关于是否释放同步监视器：如果两个方法都使用在同步代码块或同步方法中，sleep()不会释放同步监视器，而wait()会释放同步监视器。</li>
</ol>
<h3 id="I-JDK5-0新增线程创建方式–实现Callable接口"><a href="#I-JDK5-0新增线程创建方式–实现Callable接口" class="headerlink" title="I.JDK5.0新增线程创建方式–实现Callable接口"></a>I.JDK5.0新增线程创建方式–实现Callable接口</h3><h4 id="①实现步骤"><a href="#①实现步骤" class="headerlink" title="①实现步骤"></a>①实现步骤</h4><ol>
<li><p>创建一个实现Callable接口的实现类</p>
</li>
<li><p>在实现类中实现call方法，将此线程需要执行的操作声明在call()中。</p>
<p> — |  该call()方法有返回值，可以返回基本数据类型（因为基本数据类型可以转换为包装类），如果不需要返回值，则return null。</p>
<p> — |  该call()方法声明在Callable接口时就可以throws异常，因此重写的时候也可以抛异常</p>
</li>
<li><p>创建Callable接口实现类的对象</p>
</li>
<li><p>将此Callable接口实现类的对象作为参数传递到FutureTask构造器中，创建FutureTask的对象</p>
</li>
<li><p>将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用Thread对象调用start()方法。</p>
<p> 如果对call()方法中的返回值感兴趣，则执行步骤6，否则执行到步骤5即可</p>
</li>
<li><p>获取Callable方法的返回值。用刚才FutureTask类创建的对象调用get()方法。</p>
<p> — | get()返回值即为FutureTask构造器参数Callable实现类重写的call()的返回值，即call()的返回值。</p>
<p> — | get()方法本身有异常，可以用try-catch-finally来处理</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Object 变量名=FutureTask的对象.get();</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="②补充"><a href="#②补充" class="headerlink" title="②补充"></a>②补充</h4><ol>
<li><p>什么情况下需要Callable方法的返回值呢？</p>
<p> ​	当一个线程需要用到另一个线程的运行结果时，就需要返回值</p>
</li>
<li><p>实现Runnable接口和Callable接口的比较</p>
</li>
</ol>
<p><img src="/../../imgs/image-20230426180302882.png" alt="image-20230426180302882"></p>
<h3 id="J-JDK5-0新增线程创建方式—使用线程池"><a href="#J-JDK5-0新增线程创建方式—使用线程池" class="headerlink" title="J.JDK5.0新增线程创建方式—使用线程池"></a>J.JDK5.0新增线程创建方式—使用线程池</h3><p>​	实际开发中最常用的线程创建方式—–线程池</p>
<h4 id="①思路"><a href="#①思路" class="headerlink" title="①思路"></a>①思路</h4><p>​	提前创建好多个线程，放入线程池中，使用时直接获取，使用完后不是直接销毁而是放回池中。可以避免频繁创建销毁、实现重复利用。</p>
<h4 id="②使用线程池的好处"><a href="#②使用线程池的好处" class="headerlink" title="②使用线程池的好处"></a>②使用线程池的好处</h4><p><em>&gt;</em> 提高响应速度（减少了创建新线程的时间）</p>
<p><em>&gt;</em> 降低资源消耗（重复利用线程池中线程，不需要每次都创建）</p>
<p>*&gt;*便于线程管理，如：corePoolSize：核心池的大小；maximumPoolSize：最大线程数；keepAliveTime：线程没有任务时最多保持多长时间后会终止；…..</p>
<h4 id="③实现步骤"><a href="#③实现步骤" class="headerlink" title="③实现步骤"></a>③实现步骤</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Thread1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWrold</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">    <span class="comment">//1.提供指定线程数量的线程池</span></span><br><span class="line">  <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//2.启动一个线程。调用execute()或submit()</span></span><br><span class="line">        service.execute(<span class="keyword">new</span> <span class="title class_">Thread1</span>());</span><br><span class="line">	   <span class="comment">//3.关闭连接池</span></span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="④补充说明："><a href="#④补充说明：" class="headerlink" title="④补充说明："></a>④补充说明：</h4><ol>
<li><p>调用execute()时需要传递一个参数，该参数为实现Runnable接口的实现类的对象。因为在造线程池时，并没有指定线程要干什么，所以就得往该方法中传递参数，明确当前线程干什么。该方法就是用来启动线程的。</p>
</li>
<li><p>调用submit()时需要递一个参数，该参数为实现Callable接口的实现类的对象。为什么要传参数？原因同上。</p>
</li>
<li><p>execute()或submit()方法一次只能启动一个线程</p>
</li>
<li><p>如果每个线程干的事情都不一样，那么就得造不同的Runnable或Callable的实现类，然后再造不同的实现类对象。</p>
</li>
<li><p>如果想获取call()方法的返回值，直接在调用submit()方法的时候在后面加上“.get()”即可，如：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> service.submit(t2).get();</span><br><span class="line"><span class="comment">//别忘了get()本身是带有异常的，因此要用try-catch-finally或throws进行处理</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="⑤设置线程池的属性"><a href="#⑤设置线程池的属性" class="headerlink" title="⑤设置线程池的属性"></a>⑤设置线程池的属性</h4><ol>
<li>将上面实现步骤1中得到的对象（service）强转为ThreadPoolExecutor类型</li>
<li>将强转后的得到的对象调用相应属性的set方法即可，如：setKeepAliveTime，setCoorePoolSize等</li>
</ol>
<h3 id="L-小结"><a href="#L-小结" class="headerlink" title="L.小结"></a>L.小结</h3><h4 id="①释放锁的操作"><a href="#①释放锁的操作" class="headerlink" title="①释放锁的操作"></a>①释放锁的操作</h4><p><img src="/../../imgs/image-20230426180327646.png" alt="image-20230426180327646"></p>
<h4 id="②不会释放锁的操作"><a href="#②不会释放锁的操作" class="headerlink" title="②不会释放锁的操作"></a>②不会释放锁的操作</h4><p><img src="/../../imgs/image-20230426180343935.png" alt="image-20230426180343935"></p>
<hr>
<h2 id="2、常用类"><a href="#2、常用类" class="headerlink" title="2、常用类"></a>2、常用类</h2><h3 id="A-String类"><a href="#A-String类" class="headerlink" title="A.String类"></a>A.String类</h3><h4 id="①给字符串赋值的方式有两种"><a href="#①给字符串赋值的方式有两种" class="headerlink" title="①给字符串赋值的方式有两种"></a>①给字符串赋值的方式有两种</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.通过字面量的方式</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="comment">//2.通过new的方式</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;123&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="②概述"><a href="#②概述" class="headerlink" title="②概述"></a>②概述</h4><p>​		a.String声明为final的，不可被继承</p>
<p>​		b.String实现了Serializable接口：表示字符串是支持序列化的。即：该对象可以通过网络进行传输。</p>
<p>​					实现了Comparable接口，表示字符串可以比较大小。</p>
<p>​		c.String内部定义了final char[] value用于存储字符串数据</p>
<p>​		d.通过字面量的方式给一个字符串赋值，此时的字符串值声明在方法区中的字符串常量池中。</p>
<p>​		e.字符串常量池中是不会存储相同内容的字符串的。</p>
<p>​		f.String代表不可变的字符序列，简称不可变性。即：无论对字符串进行什么操作都不能改变其值，都得重新造。体现：</p>
<ol>
<li>当对字符串重新赋值时，需要重新指定内存区，不能使用原有的value进行赋值。如:</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s1=<span class="string">&quot;abc&quot;</span>;</span><br><span class="line">String s2=<span class="string">&quot;abc&quot;</span>;</span><br><span class="line">s1=<span class="string">&quot;Hello&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>此时的内存结构如下：</p>
<p><img src="/../../imgs/image-20230426180423655.png" alt="image-20230426180423655"></p>
<pre><code> 2.当对现有的字符串进行连接操作时，也需要重新指定内存区，不能使用原有的value进行赋值。
</code></pre>
<p>​	3.当调用String的replace（）方法修改指定字符或字符串时，也需要重新指定内存区，不能使用原有的value进行赋值。</p>
<h4 id="③字符串两种赋值方式的区别"><a href="#③字符串两种赋值方式的区别" class="headerlink" title="③字符串两种赋值方式的区别"></a>③字符串两种赋值方式的区别</h4><p>​	<img src="/../../imgs/image-20230426180439112.png" alt="image-20230426180439112" style="zoom:67%;" /></p>
<p>​	如果将str2改成def，则内存中先会在字符串常量池中造个def，然后将此def的地址赋给value。</p>
<h4 id="④面试题"><a href="#④面试题" class="headerlink" title="④面试题"></a>④面试题</h4><p>​	<img src="/../../imgs/image-20230426180457385.png" alt="image-20230426180457385"></p>
<h4 id="⑤字面量赋值的细节"><a href="#⑤字面量赋值的细节" class="headerlink" title="⑤字面量赋值的细节"></a>⑤字面量赋值的细节</h4><ul>
<li><p>常量与常量的拼接结果在常量池。且常量池中不会存在相同内容的常量。</p>
</li>
<li><p>只要其中有一个是变量，就是在堆空间中创建一个对象，该对象再指向方法区中的字符串常量池中的字符串 。</p>
</li>
</ul>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;world&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;helloworld&quot;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span> + <span class="string">&quot;world&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> s1 + <span class="string">&quot;world&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> s1 + s2;</span><br><span class="line">System.out.println(s3 == s4);<span class="comment">//truue</span></span><br><span class="line">System.out.println(s3 == s5);<span class="comment">//false</span></span><br><span class="line">System.out.println(s3 == s6);<span class="comment">//false</span></span><br><span class="line">System.out.println(s5 == s6);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>​	内存解析：</p>
<img src="/../../imgs/image-20230426180516170.png" alt="image-20230426180516170" style="zoom:67%;" />

<h4 id="⑥intern"><a href="#⑥intern" class="headerlink" title="⑥intern()"></a>⑥intern()</h4><p>​	使用：字符串变量调用</p>
<p>​	intern()返回的是调用该方法的字符串在字符串常量池中的地址值。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;456&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> s1.intern();<span class="comment">//返回的是“123”在字符串常量池中的地址值。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> (s1 + s2).intern();<span class="comment">//返回的是“123456”在字符串常量池中的地址值。</span></span><br></pre></td></tr></table></figure>



<h4 id="⑦-String类常用方法"><a href="#⑦-String类常用方法" class="headerlink" title="⑦.String类常用方法"></a>⑦.String类常用方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="type">int</span> <span class="title function_">length</span><span class="params">()</span>：返回字符串的长度： <span class="keyword">return</span> value.length</span><br><span class="line">&gt; <span class="type">char</span> <span class="title function_">charAt</span><span class="params">(<span class="type">int</span> index)</span>： 返回某索引处的字符<span class="keyword">return</span> value[index] 索引从<span class="number">0</span>开始</span><br><span class="line">&gt; <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>：判断是否是空字符串：<span class="keyword">return</span> value.length == <span class="number">0</span></span><br><span class="line">&gt; String <span class="title function_">toLowerCase</span><span class="params">()</span>：使用默认语言环境，将String 中的所有字符转换为小写</span><br><span class="line">&gt; String <span class="title function_">toUpperCase</span><span class="params">()</span>：使用默认语言环境，将 String 中的所有字符转换为大写</span><br><span class="line">&gt; String <span class="title function_">trim</span><span class="params">()</span>：返回字符串的副本，将该字符串的首个字符前的空格、最后一个字符后面的空格去掉</span><br><span class="line">&gt; <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>：比较字符串的内容是否相同</span><br><span class="line">&gt; <span class="type">boolean</span> <span class="title function_">equalsIgnoreCase</span><span class="params">(String anotherString)</span>：与equals方法类似，忽略大小写</span><br><span class="line">&gt; String <span class="title function_">concat</span><span class="params">(String str)</span>：将指定字符串连接到此字符串的结尾。 等价于用“+”</span><br><span class="line">&gt; <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(String anotherString)</span>：比较两个字符串内容的大小</span><br><span class="line">&gt; String <span class="title function_">substring</span><span class="params">(<span class="type">int</span> beginIndex)</span>：返回一个新的字符串，它是此字符串的从beginIndex开始截取到最后的一个子字符串。</span><br><span class="line">&gt; String <span class="title function_">substring</span><span class="params">(<span class="type">int</span> beginIndex, <span class="type">int</span> endIndex)</span> ：返回一个新字符串，它是此字符串从beginIndex开始截取到endIndex(不包含)的一个子字符串。</span><br><span class="line">&gt; <span class="type">boolean</span> <span class="title function_">endsWith</span><span class="params">(String suffix)</span>：测试此字符串是否以指定的后缀结束，suffix可以是多个字符、一个字符。区分大小写</span><br><span class="line">&gt; <span class="type">boolean</span> <span class="title function_">startsWith</span><span class="params">(String prefix)</span>：测试此字符串是否以指定的前缀开始，区分大小写</span><br><span class="line">&gt; <span class="type">boolean</span> <span class="title function_">startsWith</span><span class="params">(String prefix, <span class="type">int</span> toffset)</span>：测试此字符串从指定索引开始的子字符串是否以指定前缀开始</span><br><span class="line">&gt; <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(CharSequence s)</span>：当且仅当此字符串包含指定的 <span class="type">char</span> 值序列时，返回 <span class="literal">true</span></span><br><span class="line">&gt; <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(String str)</span>：返回指定子字符串在此字符串中第一次出现处的索引</span><br><span class="line">&gt; <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(String str, <span class="type">int</span> fromIndex)</span>：返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始找</span><br><span class="line">&gt; <span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(String str)</span>：返回指定子字符串在此字符串中最右边出现处的索引</span><br><span class="line">&gt; <span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(String str, <span class="type">int</span> fromIndex)</span>：返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始从右往左找</span><br><span class="line"><span class="comment">//注：indexOf和lastIndexOf方法如果未找到都是返回-1</span></span><br><span class="line"></span><br><span class="line">&gt; String <span class="title function_">replace</span><span class="params">(<span class="type">char</span> oldChar, <span class="type">char</span> newChar)</span>：返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。</span><br><span class="line">&gt; String <span class="title function_">replace</span><span class="params">(CharSequence target, CharSequence replacement)</span>：将字符串中所有出现target的地方全替换成replacement</span><br><span class="line">&gt; String <span class="title function_">replaceAll</span><span class="params">(String regex, String replacement)</span> ： 使 用 给 定 的replacement 替换此字符串所有满足给定的正则表达式的子字符串。</span><br><span class="line">&gt; String <span class="title function_">replaceFirst</span><span class="params">(String regex, String replacement)</span> ： 使 用 给 定 的replacement 替换此字符串满足给定的正则表达式的第一个子字符串。</span><br><span class="line">&gt; <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(String regex)</span>：告知此字符串是否满足给定的正则表达式。</span><br><span class="line">&gt; String[] split(String regex)：根据给定正则表达式的匹配拆分此字符串。</span><br><span class="line">&gt; String[] split(String regex, <span class="type">int</span> limit)：根据匹配给定的正则表达式来拆分此字符串，最多不超过limit个，如果超过了，剩下的全部都放到最后一个元素中。</span><br></pre></td></tr></table></figure>



<h4 id="⑧String-与-char-之间的转换"><a href="#⑧String-与-char-之间的转换" class="headerlink" title="⑧String 与 char[]之间的转换"></a>⑧String 与 char[]之间的转换</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//String --&gt; char[]：调用String的toCharArray()</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">char</span>[] c1 = s1.toCharArray();</span><br><span class="line"><span class="comment">//char[] --&gt; String：调用String的构造器</span></span><br><span class="line"><span class="type">char</span>[] c2 = <span class="keyword">new</span> <span class="title class_">char</span>[]&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(c2);<span class="comment">//s2: &quot;abc&quot;</span></span><br></pre></td></tr></table></figure>



<h4 id="⑨String-与byte-之间的转换"><a href="#⑨String-与byte-之间的转换" class="headerlink" title="⑨String 与byte[]之间的转换"></a>⑨String 与byte[]之间的转换</h4><p>编码：字符串 —&gt; 字节或字节数组（通俗来讲：看得懂 —&gt; 看不懂的二进制数据）</p>
<p>解码：编码的逆过程，字节 —&gt; 字符串（通俗来讲：看不懂的二进制数据 —&gt; 看得懂）</p>
<p><strong>编码：</strong>String —&gt; byte[ ]：调用String的getBytes()</p>
<p><strong>解码：</strong>byte[ ] —&gt; String：调用String的构造器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//String ---&gt; byte[]</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">byte</span>[] b1 = s1.getBytes();<span class="comment">//getBytes可以选择不同的参数，如果不选参数，意味着：在转换为byte时使用默认的编码集（如果IDEA设置的编码集为UTF-8，则转换时就用UTF-8进行编码），如果选择带参的，此参数为你要指定的编码集，如：s1.getBytes(&quot;gbk&quot;)</span></span><br><span class="line"><span class="comment">//byte[] ---&gt; String</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(b1);<span class="comment">//使用默认的编码集进行解码</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(b1,<span class="string">&quot;gbk&quot;</span>);<span class="comment">//使用指定的编码集进行解码</span></span><br></pre></td></tr></table></figure>

<p>​	<strong>注意：</strong></p>
<p>​	编码和解码要使用相同的编码集，不然会出现乱码</p>
<h4 id="⑩String-和-StringBuffer、StringBuilder的转换"><a href="#⑩String-和-StringBuffer、StringBuilder的转换" class="headerlink" title="⑩String 和 StringBuffer、StringBuilder的转换"></a>⑩String 和 StringBuffer、StringBuilder的转换</h4><p>​	A.String –&gt; StringBuffer、StringBuilder</p>
<p>​		调用StringBuffer、StringBuilder构造器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(s1);</span><br></pre></td></tr></table></figure>

<p>​	B.StringBuffer、StringBuilder –&gt; String</p>
<p>​		调用String构造器；StringBuffer、StringBuilder的toString()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(sb1);<span class="comment">//调用String构造器</span></span><br></pre></td></tr></table></figure>



<hr>
<h3 id="B-StringBuffer类"><a href="#B-StringBuffer类" class="headerlink" title="B.StringBuffer类"></a>B.StringBuffer类</h3><h4 id="①创建格式"><a href="#①创建格式" class="headerlink" title="①创建格式"></a>①创建格式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;abc&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="②常用方法"><a href="#②常用方法" class="headerlink" title="②常用方法"></a>②常用方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; StringBuffer <span class="title function_">append</span><span class="params">(xxx)</span>：提供了很多的append()方法，用于对原有的字符串进行添加，“xxx”可以是任意多个字符</span><br><span class="line">&gt; StringBuffer <span class="title function_">delete</span><span class="params">(<span class="type">int</span> start,<span class="type">int</span> end)</span>：删除指定位置的内容，原有的数据会改变，删除的内容不包含end位置上的字符</span><br><span class="line">&gt; StringBuffer <span class="title function_">replace</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end, String str)</span>：把[start,end)位置替换为str，str的长度可以是任意的。</span><br><span class="line">&gt; StringBuffer <span class="title function_">insert</span><span class="params">(<span class="type">int</span> offset, xxx)</span>：在指定位置插入xxx</span><br><span class="line">&gt; StringBuffer <span class="title function_">reverse</span><span class="params">()</span> ：把当前字符序列逆转</span><br><span class="line"></span><br><span class="line">此外，还定义了如下的方法：（同String）</span><br><span class="line"></span><br><span class="line">&gt; <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(String str)</span></span><br><span class="line">&gt; <span class="keyword">public</span> String <span class="title function_">substring</span><span class="params">(<span class="type">int</span> start,<span class="type">int</span> end)</span>，注意：要获取其返回的值</span><br><span class="line">&gt; <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">length</span><span class="params">()</span></span><br><span class="line">&gt; <span class="keyword">public</span> <span class="type">char</span> <span class="title function_">charAt</span><span class="params">(<span class="type">int</span> n )</span></span><br><span class="line">&gt; <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCharAt</span><span class="params">(<span class="type">int</span> n ,<span class="type">char</span> ch)</span></span><br><span class="line"><span class="comment">//上面的方法都是通过StringBuffer对象来调用</span></span><br></pre></td></tr></table></figure>

<p>​	总结：</p>
<p>​	增：append(xxx)</p>
<p>​	删：delete(int start,int end)</p>
<p>​	改：setCharAt(int n,char ch) &#x2F; replace(int start, int end, String str)</p>
<p>​	查：charAt(int n)</p>
<p>​	插：insert(int offset,xxx)</p>
<p>​	长度：length()</p>
<p>​	遍历：toString</p>
<h4 id="③补充"><a href="#③补充" class="headerlink" title="③补充"></a>③补充</h4><p>​	如果在开发中需要频繁地对字符串进行修改，可以使用StringBuffer(int capacity) 来指定大点char数组的初始长度，进而避免对char数组进行多次扩容造执行效率下降。</p>
<h3 id="C-StringBuilder类"><a href="#C-StringBuilder类" class="headerlink" title="C.StringBuilder类"></a>C.StringBuilder类</h3><h4 id="①创建格式-1"><a href="#①创建格式-1" class="headerlink" title="①创建格式"></a>①创建格式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;abc&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="②常用方法-1"><a href="#②常用方法-1" class="headerlink" title="②常用方法"></a>②常用方法</h4><p>与StringBuffer中的常用方法一样，只是StringBuilder中的方法线程不安全，StringBuffer中的方法线程安全。所以参考StringBuffer的常用方法即可。</p>
<h4 id="③补充-1"><a href="#③补充-1" class="headerlink" title="③补充"></a>③补充</h4><p>​	如果在开发中需要频繁地对字符串进行修改，可以使用StringBuilder(int capacity)来指定大点char数组的初始长度，进而避免对char数组进行多次扩容造执行效率下降。</p>
<h3 id="D-String-StringBuffer-StringBuilder三者异同"><a href="#D-String-StringBuffer-StringBuilder三者异同" class="headerlink" title="D.String StringBuffer StringBuilder三者异同"></a>D.String StringBuffer StringBuilder三者异同</h3><p><strong>String：</strong>不可变的字符序列；底层使用char[]数组存储。<br><strong>StringBuffer：</strong>可变的字符序列；线程安全的，效率低；底层使用char[]数组存储。<br><strong>StringBuilder：</strong>jdk5.0新增的；可变的字符序列；线程不安全的，效率高；底层使用char[]数组存储。</p>
<p>它们底层都是用char数组进行存储的，为什么StringBuffer和StringBuilder就是可变字符序列呢？</p>
<p>源码分析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>();<span class="comment">//char value[] = new char[0];</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);<span class="comment">//char value[] = new char[]&#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();<span class="comment">//char value[] = new char[16];底层创建了一个长度是16的char型数组</span></span><br><span class="line">sb1.append(<span class="string">&#x27;a&#x27;</span>);<span class="comment">//value[0] = &#x27;a&#x27;;</span></span><br><span class="line">sb1.append(<span class="string">&#x27;b&#x27;</span>);<span class="comment">//value[1] = &#x27;b&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb2</span> <span class="operator">=</span> <span class="keyword">new</span> 	<span class="title class_">StringBuffer</span>(<span class="string">&quot;abc&quot;</span>);<span class="comment">//char value[] = new char[&quot;abc&quot;.length() + 16];底层创建了一个长度为19的char数组</span></span><br></pre></td></tr></table></figure>

<p>​	问题1：sb2.length()是指sb2字符串的长度，因此为3</p>
<p>​	问题2：扩容问题：如果要添加的数据底层数组盛不下了，那就需要扩容底层得到数组。默认情况下，扩容为原来容量的2倍 + 2，同时将原有的元素复制到新的数组中。</p>
<p>三者效率排序：StringBuilder &gt; StringBuffer &gt; String</p>
<h3 id="E-JDK8之前日期时间API"><a href="#E-JDK8之前日期时间API" class="headerlink" title="E.JDK8之前日期时间API"></a>E.JDK8之前日期时间API</h3><h4 id="①java-lang-System类"><a href="#①java-lang-System类" class="headerlink" title="①java.lang.System类"></a>①java.lang.System类</h4><p>System类提供的public static long currentTimeMillis()用来返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差。称为<strong>时间戳</strong>。</p>
<p>此方法适于计算时间差、或用来表示订单号</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">System.out.println(time);</span><br></pre></td></tr></table></figure>



<h4 id="②java-util-Date类"><a href="#②java-util-Date类" class="headerlink" title="②java.util.Date类"></a>②java.util.Date类</h4><ol>
<li><p>两个构造器的使用</p>
<p> 构造器一：Date()：创建一个对应当前时间的Date对象</p>
<p> 构造器二：Date(long date)：创建指定时间戳的Date对象，实参一定记得加L，因为是long型数据</p>
</li>
<li><p>两个方法的使用</p>
<p> toString()：显示当前的年、月、日、时、分、秒</p>
<p> getTime()：获取当前Date对象对应的毫秒数（即：当前Date对象的时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差）。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//上面的方法都是通过Date对象来调用</span></span><br></pre></td></tr></table></figure></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">System.out.println(date);<span class="comment">//Sun Aug 14 11:17:23 CST 2022</span></span><br></pre></td></tr></table></figure>



<h4 id="③java-sql-Date类"><a href="#③java-sql-Date类" class="headerlink" title="③java.sql.Date类"></a>③java.sql.Date类</h4><p>​	该类是java.util.Date类的子类。其对应着数据库中的日期类型的变量。日常中，我们通常用java.util.Date，涉及到数据库的时候再用java.sql.Date</p>
<p>​	A.如何实例化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.sql.<span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.sql.Date(<span class="number">12345678L</span>);</span><br><span class="line"><span class="comment">//其构造器中放时间戳</span></span><br><span class="line">System.out.println(date);<span class="comment">//输出年月日</span></span><br></pre></td></tr></table></figure>

<p>​	B.java.until.Date –&gt; java.sql.Date</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如何将java.until.Date的对象转换为java.sql.Date对象</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">java.sql.<span class="type">Date</span> <span class="variable">date2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.sql.Date(date1.getTime());</span><br></pre></td></tr></table></figure>



<h4 id="④-SimpleDateFormat"><a href="#④-SimpleDateFormat" class="headerlink" title="④.SimpleDateFormat"></a>④.SimpleDateFormat</h4><p>​	<strong>概述</strong></p>
<p>​	SimpleDateFormat属于java.text包下的一个类。</p>
<p>​	SimpleDateFormat的使用：SimpleDateFormat是对日期Date类的格式化和解析。</p>
<p>​	格式化：日期 —&gt; 字符串</p>
<p>​	解析：格式化的 逆过程，字符串 —&gt; 日期</p>
<p>​	格式化和解析是都调用非静态的方法，因此想用得先实例化SimpleDateFormat。</p>
<p>​	<strong>具体实现</strong></p>
<p>​	实例化：</p>
<ul>
<li><p>使用空参的构造器（使用默认的方式格式化和解析），开发中不用</p>
</li>
<li><p>使用带参的构造器（用指定的方式格式化和解析）</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开发中一般使用这种指定的方式的构造器</span></span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);</span><br><span class="line"><span class="comment">//参数可以自己搭配，y -- year;M --&gt; month;d --&gt; day</span></span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">格式化：</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">- 用SimpleDateFormat对象调用format(Date date)方法</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">解析：</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">- 用SimpleDateFormat对象调用parse(String str)方法，该方法返回的是util下Date的对象</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">注意：①parse方法本身会抛异常，因此需对此进行异常处理。②如果使用空参的构造器，那么参数str就得按照默认的格式来写；使用带参的构造器，那么参数str就得按照你指定的格式来写。不然抛异常。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//****************使用默认的方式格式化和解析***************</span></span><br><span class="line"><span class="comment">//1.实例化SimpleDateFormat()</span></span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.格式化：日期 --&gt; 字符串</span></span><br><span class="line"> <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();<span class="comment">//</span></span><br><span class="line"> <span class="type">String</span> <span class="variable">format</span> <span class="operator">=</span> sdf.format(date);</span><br><span class="line">System.out.println(format);<span class="comment">//22-8-14 上午10:28</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.解析：字符串 ---&gt; 日期</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;22-8-14 上午10:28&quot;</span>;</span><br><span class="line"><span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> sdf.parse(s1);<span class="comment">//使用默认的方式格式化，那么解析时字符串就得符合默认方式的格式（像s1的这种格式），不然会报错。</span></span><br></pre></td></tr></table></figure>



<p>​	<strong>练习</strong></p>
<p><img src="/../../imgs/image-20230426180656067.png" alt="image-20230426180656067"></p>
<h4 id="⑤Calendar日历类"><a href="#⑤Calendar日历类" class="headerlink" title="⑤Calendar日历类"></a>⑤Calendar日历类</h4><p>​	<strong>概述</strong> </p>
<p>​	Date类表示的时间不通用（就有些国家的人看不懂），且其中的有些方法已经过时了，所以我们引入Calendar类。</p>
<p>​	Calender是一个抽象类</p>
<p>​	<strong>实列化</strong></p>
<ul>
<li><p>方式一：创建其子类（GregorianCalendar）的对象，这种方法少用</p>
</li>
<li><p>方式二：调用Calender的静态方法getInstance()。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Calendar</span> <span class="variable">instance</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line"><span class="comment">//instance：当前时间的对象</span></span><br><span class="line"><span class="comment">//getInstance()方法实际上返回的是GregorianCalendar类的对象</span></span><br></pre></td></tr></table></figure>

<p>  <strong>常用方法</strong></p>
<p>  下面的方法通过Calendar对象来调用</p>
</li>
</ul>
<p>​	A.get()</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">获取Calendar类中的一些属性，如：</span><br><span class="line"></span><br><span class="line">YEAR、MONTH、DAY_OF_WEEK、HOUR_OF_DAY 、MINUTE、SECOND、DAY_OF_MONTH、DAY_OF_YEAR</span><br><span class="line">//这些属性都是静态的，通过Calendar类就可以调用。然后把这些属性放进get()方法的（）中即可获取。</span><br><span class="line">/*属性含义：</span><br><span class="line">DAY_OF_WEEK：当前时间是这个星期的第几天</span><br><span class="line">HOUR_OF_DAY：当前时间是一天中的第几个小时</span><br><span class="line">DAY_OF_YEAR：当前时间是一年中的第几天</span><br><span class="line">DAY_OF_MONTH：当前时间是一个月中的第几天</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<p>​	B.set()</p>
<p>​		修改Calendar类的对象中的属性，set()方法的形参放Calender类的属性和修改的值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Calendar</span> <span class="variable">instance</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">instance.set(Calendar.DAY_OF_MONTH,<span class="number">22</span>);</span><br></pre></td></tr></table></figure>

<p>​	C.add()</p>
<p>​		对Calendar类的对象中的属性值进行加减操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Calendar</span> <span class="variable">instance</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">instance.set(Calendar.DAY_OF_MONTH,<span class="number">3</span>);<span class="comment">//如：DAY_OF_MONTH 本来为22，加3后，DAY_OF_MONTH = 25；修第二个形参可以为负数</span></span><br></pre></td></tr></table></figure>

<p>​	D.getTime()</p>
<p>​		该方法的作用：Calendat类—&gt; Date类，返回一个Date类的对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Calendar</span> <span class="variable">instance</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> instance.getTime();</span><br></pre></td></tr></table></figure>

<p>​	E.setTime()</p>
<p>​		该方法的作用：Date类 —&gt; Calendar类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="type">Calendar</span> <span class="variable">instance</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">instance.setTime(date1);<span class="comment">//将date对象对应的时间赋给Calendar类对象instance，因此这两对象的对应的时间是一样的</span></span><br></pre></td></tr></table></figure>

<p>​	F.补充：</p>
<p>​	获取月份时：一月是0，二月是1，以此类推，12月是11</p>
<p>​	获取星期时，周日是1，周一是2，周二是3，。。。。。周六是7</p>
<hr>
<h3 id="H-JDK8中新日期时间API"><a href="#H-JDK8中新日期时间API" class="headerlink" title="H.JDK8中新日期时间API"></a>H.JDK8中新日期时间API</h3><h4 id="①引言-1"><a href="#①引言-1" class="headerlink" title="①引言"></a>①引言</h4><p>​	为什么需要新的时间API？</p>
<p>​	因为旧的时间API存在以下问题：</p>
<p><img src="/../../imgs/image-20230426180720647.png" alt="image-20230426180720647"></p>
<p>​	</p>
<h4 id="②LocalDate、LocalTime、LocalDateTime的使用"><a href="#②LocalDate、LocalTime、LocalDateTime的使用" class="headerlink" title="②LocalDate、LocalTime、LocalDateTime的使用"></a>②LocalDate、LocalTime、LocalDateTime的使用</h4><p>​	A.实例化</p>
<p>​		方式一：调用now()，根据当前时间创建日期对象、时间对象、日期时间对象。该方法是静态方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">LocalDate</span> <span class="variable">localDate</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line"> <span class="type">LocalTime</span> <span class="variable">localTime</span> <span class="operator">=</span> LocalTime.now();</span><br><span class="line"> <span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line"> </span><br><span class="line"> System.out.println(localDate);<span class="comment">//2022-08-15</span></span><br><span class="line"> System.out.println(localTime);<span class="comment">//12:17:21.771</span></span><br><span class="line"> System.out.println(localDateTime);</span><br><span class="line"><span class="comment">//2022-08-15T12:17:21.771</span></span><br></pre></td></tr></table></figure>

<p>​		说明：</p>
<ul>
<li>LocalDateTime相较于LocalDate、LocalTime，使用频率要高。</li>
</ul>
<p>​		方式二：调用of()，返回指定时间的日期对象、时间对象、日期时间对象。该方法是静态方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以LocalDate类举例：</span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">localDate</span> <span class="operator">=</span> LocalDate.of(<span class="number">2022</span>, <span class="number">8</span>, <span class="number">10</span>);</span><br><span class="line">System.out.println(localDate);<span class="comment">//2022-08-10</span></span><br></pre></td></tr></table></figure>

<p>​	</p>
<p>​	B.getXxx()</p>
<p>​		通过这三个类的对象进行调用，获取相关的属性。获取的属性值是没有偏移量的，不像Calendar类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以LocalDateTime类为例：</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line"></span><br><span class="line">System.out.println(localDateTime.getDayOfYear());<span class="comment">//227</span></span><br><span class="line">System.out.println(localDateTime.getDayOfMonth());<span class="comment">//15</span></span><br><span class="line">System.out.println(localDateTime.getDayOfWeek());<span class="comment">//MONDAY</span></span><br></pre></td></tr></table></figure>



<p>​	C.withXxx()</p>
<p>​		通过对象来调用，修改对象的属性值。</p>
<p>​		说明：</p>
<ul>
<li>修改后，会返回一个修改后的对象，原对象的属性值并没有发生变化。体现了不可变性。</li>
</ul>
<p>​	D.plusXxxx(要加的值)</p>
<p>​		在属性值上加上某个值。</p>
<p>​		说明：</p>
<ul>
<li>该方法通过对象调用。</li>
<li>该方法返回一个加上值后的对象，原有对象的属性值不变。体现不可变性。</li>
</ul>
<p>​	E.minusXxx(要减的值)</p>
<p>​		在属性值上减去某个值</p>
<p>​		说明：</p>
<ul>
<li>该方法通过对象调用。</li>
<li>该方法返回一个减去值后的对象，原有对象的属性值不变。体现不可变性。</li>
</ul>
<hr>
<h4 id="③Instant"><a href="#③Instant" class="headerlink" title="③Instant"></a>③Instant</h4><p>​	Instant类似于java.util下的Date类</p>
<p>​	A.实例化</p>
<p>​		<strong>方式一：</strong>调用now方法，该方法为静态方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Instant</span> <span class="variable">instant</span> <span class="operator">=</span> Instant.now();</span><br><span class="line">System.out.println(instant);<span class="comment">//2022-08-15T05:34:02.810Z</span></span><br></pre></td></tr></table></figure>

<p>​		<strong>说明：</strong></p>
<ul>
<li><p>now()：获取的是本初子午线对应的标准时间</p>
</li>
<li><p>需要获取我们现在的时间（东八区），就要这么做：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加时间的偏移量</span></span><br><span class="line"><span class="type">OffsetDateTime</span> <span class="variable">offsetDateTime</span> <span class="operator">=</span> instant.atOffset(ZoneOffset.ofHours(<span class="number">8</span>));</span><br><span class="line">System.out.println(offsetDateTime);</span><br><span class="line"><span class="comment">//2022-08-15T13:34:02.810+08:00</span></span><br></pre></td></tr></table></figure>

<p>  <strong>方式二：</strong>调用 ofEpochMilli(long epochMilli)</p>
<p>  <strong>说明：</strong></p>
<ul>
<li>属于静态方法。其返回指定毫秒数的Instant类的对象。</li>
</ul>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Instant</span> <span class="variable">instant1</span> <span class="operator">=</span> Instant.toEpochMilli(<span class="number">15550475314878L</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>​	B.toEpochMilli()</p>
<p>​		<strong>说明：</strong></p>
<ul>
<li><p>该方法通过对象调用</p>
</li>
<li><p>返回1970-01-01 00:00:00到当前时间的毫秒数，即为时间戳。当前时间是本初子午线的那个时间</p>
</li>
<li><p>与Date类中的getTime()方法类似，都是获取时间戳</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Instant</span> <span class="variable">instant</span> <span class="operator">=</span> Instant.now();</span><br><span class="line"><span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> instant.toEpochMilli();</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="④DateTimeFormatter"><a href="#④DateTimeFormatter" class="headerlink" title="④DateTimeFormatter"></a>④DateTimeFormatter</h4><p>​	DateTimeFormatter的作用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作为LocalDate、LocalTime、LocalDateTime 与 String 之间转换的桥梁。类似于SimpleDateFormat</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>​	A.实例化</p>
<p>​		<strong>方式一、二：</strong>这两种方式少用</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://blog.csdn.net/Hhuaahua/article/details/108993426</span><br></pre></td></tr></table></figure>

<p>​		<strong>方式三：</strong>自定义的格式</p>
<p>​		调用ofPattern(你想要的格式)方法，该方法为静态方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">d1</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>​	B.格式化：LocalDate、LocalTime、LocalDateTime –&gt; String</p>
<p>​		调用DateTimeFormatter对象的format(参数)方法，参数为LocalDate、LocalTime、LocalDateTime的对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDate</span> <span class="variable">ld</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> d1.format(ld);</span><br><span class="line">System.out.println(s1);<span class="comment">//2022-08-15</span></span><br></pre></td></tr></table></figure>

<p>​	C.解析：String –&gt; 日期类</p>
<p>​		调用DateTimeFormatter对象的parse(String str)方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;2022-12-23&quot;</span>;</span><br><span class="line"><span class="type">TemporalAccessor</span> <span class="variable">accessor</span> <span class="operator">=</span> dateTimeFormatter.parse(s1);</span><br></pre></td></tr></table></figure>

<p>​		<strong>注意：</strong>被解析的字符串要符合你自定义的格式样式，不然会抛出异常</p>
<hr>
<h4 id="⑤其他与时间相关的API"><a href="#⑤其他与时间相关的API" class="headerlink" title="⑤其他与时间相关的API"></a>⑤其他与时间相关的API</h4><p><img src="/../../imgs/image-20230426180806503.png" alt="image-20230426180806503"></p>
<p>​	<strong>应用：</strong></p>
<img src="/../../imgs/image-20230426180818947.png" alt="image-20230426180818947" style="zoom:67%;" />

<p><img src="/../../imgs/image-20230426180832689.png" alt="image-20230426180832689" style="zoom:67%;" /><img src="/../../imgs/image-20230426180844742.png" alt="image-20230426180844742"></p>
<p><img src="/../../imgs/image-20230426180844742.png" alt="image-20230426180844742"></p>
<p><img src="/imgs/image-20230426180934085.png" alt="image-20230426180934085"></p>
<hr>
<h3 id="J-Java比较器"><a href="#J-Java比较器" class="headerlink" title="J.Java比较器"></a>J.Java比较器</h3><h4 id="①引言-2"><a href="#①引言-2" class="headerlink" title="①引言"></a>①引言</h4><p>​	Java中的对象，正常情况下，只能进行比较：&#x3D;&#x3D; 或 !&#x3D; 。不能使用 &gt; 或 &lt; ，但是在开发场景中，我们经常会涉及到对象数组的排序问题，言外之意，就需要比较对象的大小。如何实现？使用两个接口中的任何一个：Comparable 或 Comparator</p>
<h4 id="②Comparable自然排序"><a href="#②Comparable自然排序" class="headerlink" title="②Comparable自然排序"></a>②Comparable自然排序</h4><p>​	Comparable接口的使用举例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.像String、包装类等实现了 Comparable接口，重写了compareTo(Object obj)方法，给出了比较两个对象大小的方法。</span><br><span class="line">2.像String、包装类等重写的compareTo(Object obj)方法里，进行的是从小到大的排列。</span><br><span class="line">3.重写compareTo(Object obj)的规则：</span><br><span class="line">① 如果当前对象this大于形参对象obj，则返回正整数，</span><br><span class="line">② 如果当前对象this小于形参对象obj，则返回负整数，</span><br><span class="line">③ 如果当前对象this等于形参对象obj，则返回零。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String arr[] = <span class="keyword">new</span> <span class="title class_">String</span>[] &#123;<span class="string">&quot;AA&quot;</span>,<span class="string">&quot;CC&quot;</span>,<span class="string">&quot;KK&quot;</span>,<span class="string">&quot;MM&quot;</span>,<span class="string">&quot;DD&quot;</span>&#125;;</span><br><span class="line">Arrays.sort(arr);<span class="comment">//按照String类中重写的compareTo方法进行排序</span></span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br><span class="line"><span class="comment">//输出结果为：AA,CC,DD,KK,MM</span></span><br></pre></td></tr></table></figure>

<p>​	对于自定义来说，如果需要排序，我们可以让自定义类实现Comparable接口，重写compareTo(Object obj)方法，在compareTo(Object obj)方法中指明如何排序。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Goods)&#123;</span><br><span class="line">        <span class="type">Goods</span> <span class="variable">goods</span> <span class="operator">=</span> (Goods)o;</span><br><span class="line">        <span class="comment">//方式一：</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.price &gt; goods.price)&#123;</span><br><span class="line">        	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.price &lt; goods.price)&#123;</span><br><span class="line">        	<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        方式二：</span></span><br><span class="line"><span class="comment">        return Integer.compare(this.price,goods.price);</span></span><br><span class="line"><span class="comment">        调用包装类中的compare方法</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">   		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;不属于商品无法比较&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="③Comparator-定制排序"><a href="#③Comparator-定制排序" class="headerlink" title="③Comparator 定制排序"></a>③Comparator 定制排序</h4><p>​	<strong>引言：</strong></p>
<p>​	当元素的类型没有实现java.lang.Comparable接口而又不方便修改代码，或者实现了java.lang.Comparable接口的排序规则不适合当前的操作，那么可以考虑使用 Comparator 的对象来排序。</p>
<p>​	<strong>comparator 接口的使用举例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">重写compare(Object o1,Object o2)方法，比较o1和o2的大小：</span><br><span class="line">如果方法返回正整数，则表示o1大于o2；</span><br><span class="line">如果返回0，表示相等；</span><br><span class="line">返回负整数，表示o1小于o2。	</span><br><span class="line">例子：</span><br></pre></td></tr></table></figure>

<p>​	<strong>实现步骤：</strong></p>
<ol>
<li><p>调用Arrays的sort()方法</p>
</li>
<li><p>往sort()方法传两个参数，一个为要被排序的对象，另一个为实现Comparator接口的实现类对象（由于排序只用到一次，因此就用匿名类的匿名对象了）。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">String[] str = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;b&quot;</span>&#125;;</span><br><span class="line">Arrays.sort(str, <span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">	 <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (o1 <span class="keyword">instanceof</span> String &amp;&amp; o2 <span class="keyword">instanceof</span> String)&#123;</span><br><span class="line">         <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> (String)o1;</span><br><span class="line">         <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> (String)o2;</span><br><span class="line">         <span class="keyword">return</span> s1.compareTo(s2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;类型不一致&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//执行完2-12行代码之后，str数组就排好序了</span></span><br><span class="line">System.out.println(Arrays.toString(str));<span class="comment">//[a, b, c]</span></span><br><span class="line"><span class="comment">//上面的输出结果是按照从小到大的方式排序的，如果想从大到小排序，将第八行代改成“return -s1.compareTo(s2)”即可。</span></span><br></pre></td></tr></table></figure>

<p> compare方法中写你需要的排序方式</p>
</li>
</ol>
<h4 id="④总结"><a href="#④总结" class="headerlink" title="④总结"></a>④总结</h4><ol>
<li><p>以后只有涉及到对象的排序，就会用到这两个接口。</p>
</li>
<li><p>Comparable、Comparator两者的比较</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Comparable接口的方式一旦确定，保证Comparable接口实现类的对象在任何位置都可以比较大小。</span><br><span class="line">comparator 接口属于临时性的比较。下一次比较的时候就得重新编写。</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="K-System类"><a href="#K-System类" class="headerlink" title="K.System类"></a>K.System类</h3><h4 id="①概述"><a href="#①概述" class="headerlink" title="①概述"></a>①概述</h4><ol>
<li>该类位于java.lang包。</li>
<li>由于该类的构造器是private的，所以无法创建该类的对象，但其内部的成员变量和成员方法都是static的，所以也可以很方便的进行调用。</li>
</ol>
<h4 id="②成员变量"><a href="#②成员变量" class="headerlink" title="②成员变量"></a>②成员变量</h4><p>​	System类内部包含in、out和err三个成员变量，分别代表标准输入流(键盘输入)，标准输出流(显示器)和标准错误输出流(显示器)。</p>
<h4 id="③成员方法"><a href="#③成员方法" class="headerlink" title="③成员方法"></a>③成员方法</h4><ol>
<li><p>native long currentTimeMillis()： 该方法的作用是返回当前的计算机时间，时间的表达格式为当前计算机时间和GMT时间(格林威治时间)1970年1月1号0时0分0秒所差的毫秒数。</p>
</li>
<li><p>void exit(int status)： 该方法的作用是退出程序。其中status的值为0代表正常退出，非零代表异常退出。使用该方法可以在图形界面编程中实现程序的退出功能等。</p>
</li>
<li><p>void gc()： 该方法的作用是请求系统进行垃圾回收。至于系统是否立刻回收，则取决于系统中垃圾回收算法的实现以及系统执行时的情况。</p>
</li>
<li><p>String getProperty(String key)： 该方法的作用是获得系统中属性名为key的属性对应的值。系统中常见的属性名以及属性的作用如下表所示：</p>
<p> <img src="/imgs/image-20230426181028332.png" alt="image-20230426181028332"></p>
<p> <img src="/imgs/image-20230426181045470.png" alt="image-20230426181045470"></p>
</li>
</ol>
<h3 id="L-Math类"><a href="#L-Math类" class="headerlink" title="L.Math类"></a>L.Math类</h3><p><img src="/imgs/image-20230426181100532.png" alt="image-20230426181100532"></p>
<h3 id="M-BigInteger与BigDecimal（了解）"><a href="#M-BigInteger与BigDecimal（了解）" class="headerlink" title="M.BigInteger与BigDecimal（了解）"></a>M.BigInteger与BigDecimal（了解）</h3><h4 id="①BigInteger的基本知识"><a href="#①BigInteger的基本知识" class="headerlink" title="①BigInteger的基本知识"></a>①BigInteger的基本知识</h4><ol>
<li><p>Integer类作为int的包装类，能存储的最大整型值为2^31-1， Long类也是有限的，最大为2^63-1。如果要表示再大的整数，不管是基本数据类型还是他们的包装类都无能为力，更不用说进行运算了。因此我们引入java.math包的BigInteger。</p>
</li>
<li><p>BigIntegerr可以表示不可变的任意精度的整数。BigInteger 提供所有 Java 的基本整数操作符的对应物，并提供java.lang.Math 的所有相关方法。另外，BigInteger 还提供以下运算：模算术、GCD 计算、质数测试、素数生成、位操作以及一些其他操作。</p>
</li>
<li><p>构造器：BigInteger(String val)：根据字符串构建BigInteger对象</p>
</li>
</ol>
<h4 id="②BigInteger的常用方法"><a href="#②BigInteger的常用方法" class="headerlink" title="②BigInteger的常用方法"></a>②BigInteger的常用方法</h4><p><img src="/imgs/image-20230426181119309.png" alt="image-20230426181119309"></p>
<h4 id="③BigDecimal的基本知识"><a href="#③BigDecimal的基本知识" class="headerlink" title="③BigDecimal的基本知识"></a>③BigDecimal的基本知识</h4><p>​	一般的Float类和Double类可以用来做科学计算或工程计算，但在商业计算中，要求数字精度比较高，故用到java.math.BigDecimal类。BigDecimal类支持不可变的、任意精度的有符号十进制定点数。</p>
<p>​	<strong>构造器：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">BigDecimal</span><span class="params">(<span class="type">double</span> val)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">BigDecimal</span><span class="params">(String val)</span>;</span><br></pre></td></tr></table></figure>

<h4 id="④BigDecimal的常用方法"><a href="#④BigDecimal的常用方法" class="headerlink" title="④BigDecimal的常用方法"></a>④BigDecimal的常用方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> BigDecimal <span class="title function_">add</span><span class="params">(BigDecimal augend)</span><span class="comment">//加</span></span><br><span class="line"><span class="keyword">public</span> BigDecimal <span class="title function_">subtract</span><span class="params">(BigDecimal subtrahend)</span><span class="comment">//减</span></span><br><span class="line"><span class="keyword">public</span> BigDecimal <span class="title function_">multiply</span><span class="params">(BigDecimal multiplicand)</span><span class="comment">//乘</span></span><br><span class="line"><span class="keyword">public</span> BigDecimal <span class="title function_">divide</span><span class="params">(BigDecimal divisor, <span class="type">int</span> scale, <span class="type">int</span> roundingMode)</span><span class="comment">//除，精度为scale,处理方式为：roundingMode（是四舍五入。。。。。）</span></span><br></pre></td></tr></table></figure>



<hr>
<h3 id="N-JDK8之前-amp-JDK8之后时间API的对应关系"><a href="#N-JDK8之前-amp-JDK8之后时间API的对应关系" class="headerlink" title="N.JDK8之前&amp;JDK8之后时间API的对应关系"></a>N.JDK8之前&amp;JDK8之后时间API的对应关系</h3><p><img src="/imgs/image-20230426181134561.png" alt="image-20230426181134561"></p>
<hr>
<h2 id="3、枚举类"><a href="#3、枚举类" class="headerlink" title="3、枚举类"></a>3、枚举类</h2><h3 id="A-枚举类的理解"><a href="#A-枚举类的理解" class="headerlink" title="A.枚举类的理解"></a>A.枚举类的理解</h3><ol>
<li>当类的对象只有有限个，并且每个对象都是确定的，我们称此类为枚举类。</li>
<li>当需要定义一组常量时，强烈建议使用枚举类。如：如星期：Monday(星期一)、…、Sunday(星期天) ， 性别：Man(男)、Woman(女)。</li>
<li>若枚举只有一个对象, 则可以作为一种单例模式的实现方式。</li>
</ol>
<h3 id="B-如何定义枚举类"><a href="#B-如何定义枚举类" class="headerlink" title="B.如何定义枚举类"></a>B.如何定义枚举类</h3><h4 id="方式一：自定义枚举类（少用）"><a href="#方式一：自定义枚举类（少用）" class="headerlink" title="方式一：自定义枚举类（少用）"></a>方式一：自定义枚举类（少用）</h4><p>​		JDK5.0之前需要自定义枚举类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Season</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//1. 对象如果有实例变量，应该声明为private final，并在构造器中初始化</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String SEASONNAME;<span class="comment">//季节的名称</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String SEASONDESC;<span class="comment">//季节的描述</span></span><br><span class="line">	</span><br><span class="line"><span class="comment">//2. 私有化类的构造器，保证不能在类的外部创建其对象(否则对象个数不确定）</span></span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Season</span><span class="params">(String seasonName,String seasonDesc)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">this</span>.SEASONNAME = seasonName;</span><br><span class="line">		<span class="built_in">this</span>.SEASONDESC = seasonDesc; </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"><span class="comment">//3. 提供当前枚举类的多个对象。声明为：public static final </span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SPRING</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;春天&quot;</span>, <span class="string">&quot;春暖花开&quot;</span>);</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SUMMER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;夏天&quot;</span>, <span class="string">&quot;夏日炎炎&quot;</span>);</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">AUTUMN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;秋天&quot;</span>, <span class="string">&quot;秋高气爽&quot;</span>);</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">WINTER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;冬天&quot;</span>, <span class="string">&quot;白雪皑皑&quot;</span>);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//4.其他诉求①：获取枚举类对象的属性</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SEASONNAME;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonDesc</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SEASONDESC;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//4.其他诉求②：提供toString方法，直接alt + shift + s 调用提供的toString方法 </span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	<strong>测试：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Season</span> <span class="variable">season</span> <span class="operator">=</span> Season.AUTUMN;</span><br><span class="line">        System.out.println(season.getSeasonDesc());</span><br><span class="line">        System.out.println(season.getSeasonName());</span><br><span class="line">        System.out.println(season);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="方式二：使用enum关键字定义枚举类（常用）"><a href="#方式二：使用enum关键字定义枚举类（常用）" class="headerlink" title="方式二：使用enum关键字定义枚举类（常用）"></a>方式二：使用enum关键字定义枚举类（常用）</h4><p>​		JDK5.0之后可以使用enum关键字定义枚举类</p>
<p>​		<strong>实现步骤：</strong>在方式一上按如下步骤进行改造，即可得到enum关键字定义枚举类。</p>
<ol>
<li>将class 替换为 enum</li>
<li>将方式一中声明多个对象的步骤提至最前面，然后把“public static final 枚举类类名” 和 “ &#x3D; new 枚举类类名” 都删掉。</li>
<li>各对象之间用 “,” 逗号隔开，末尾对象 “;” 结束</li>
<li>其他部分与方法一相同</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span>  <span class="title class_">Season</span>&#123;</span><br><span class="line"><span class="comment">//1.提供当前枚举类的对象，多个对象之间用&quot;,&quot;隔开，末尾对象&quot;;&quot;结束</span></span><br><span class="line">    SPTING(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;春暖花开&quot;</span>),</span><br><span class="line">    SUMMER(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;夏日炎炎&quot;</span>),</span><br><span class="line">    AUTUMN(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;秋高气爽&quot;</span>),</span><br><span class="line">    WINTER(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;白雪皑皑&quot;</span>);</span><br><span class="line"><span class="comment">//2.对象如果有实例变量，应该声明为private final，并在构造器中初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.私有化类的构造器，保证不能在类的外部创建其对象(否则对象个数不确定）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season</span><span class="params">(String seasonName,String seasonDesc)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.seasonName = seasonName;</span><br><span class="line">        <span class="built_in">this</span>.seasonDesc = seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//4.其他诉求①：获取枚举类对象的属性</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seasonName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		<strong>说明：</strong></p>
<ol>
<li><p>对象前面虽然没有了public static final ，但对象还是属于public static final 的。</p>
</li>
<li><p>实例变量前的关键字都不可以省略</p>
</li>
<li><p>使用enum定义的枚举类默认继承于java.lang.Enum类，因此枚举类中可以不用重写toString方法。如果不重写toString方法，其输出结果为：对象名（即：常量名）。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Season</span> <span class="variable">season</span> <span class="operator">=</span> Season.AUTUMN;</span><br><span class="line">System.out.println(season);<span class="comment">//AUTUMN</span></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="C-Enum类中的常用方法"><a href="#C-Enum类中的常用方法" class="headerlink" title="C.Enum类中的常用方法"></a>C.Enum类中的常用方法</h3><p><code>1.values()方法：</code><br>通过枚举类的类名来调用，返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值。</p>
<p><code>2.valueOf(String str)：</code><br>通过枚举类的类名来调用。可以把一个字符串转为对应的枚举类对象。要求字符串必须是枚举类对象的“名字”。如不是，会有运行时异常：IllegalArgumentException。</p>
<p><code>3.toString()：</code><br>返回当前枚举类对象（即：常量）的名称。</p>
<h3 id="D-使用enum关键字定义的枚举类实现接口的情况"><a href="#D-使用enum关键字定义的枚举类实现接口的情况" class="headerlink" title="D.使用enum关键字定义的枚举类实现接口的情况"></a>D.使用enum关键字定义的枚举类实现接口的情况</h3><h4 id="情况一"><a href="#情况一" class="headerlink" title="情况一"></a>情况一</h4><p>​	实现接口，在enum类中实现抽象方法，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">info</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">enum</span>  <span class="title class_">Season</span> <span class="keyword">implements</span> <span class="title class_">info</span>&#123;</span><br><span class="line">    SPTING,</span><br><span class="line">    SUMMER;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;一年四季&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Season</span> <span class="variable">season</span> <span class="operator">=</span> Season.SPTING;</span><br><span class="line">        <span class="type">Season</span> <span class="variable">season1</span> <span class="operator">=</span> Season.SUMMER;</span><br><span class="line">        season.show();<span class="comment">//一年四季</span></span><br><span class="line">        season1.show();<span class="comment">//一年四季</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	这种实现方式导致每个枚举类对象都是调用同一个show()方法。</p>
<h4 id="情况二"><a href="#情况二" class="headerlink" title="情况二"></a>情况二</h4><p>​	让枚举类的对象分别实现接口中的抽象方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">info</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">enum</span>  <span class="title class_">Season</span> <span class="keyword">implements</span> <span class="title class_">info</span>&#123;</span><br><span class="line">    SPTING&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这就是春天啊！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    SUMMER&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;夏天到啦！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Season</span> <span class="variable">season</span> <span class="operator">=</span> Season.SPTING;</span><br><span class="line">        <span class="type">Season</span> <span class="variable">season1</span> <span class="operator">=</span> Season.SUMMER;</span><br><span class="line">        season.show();<span class="comment">//这就是春天啊！</span></span><br><span class="line">        season1.show();<span class="comment">//夏天到啦！</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>​	这种方式就会让不同的对象输出不同的内容。</p>
<hr>
<h2 id="4、注解-Annotation"><a href="#4、注解-Annotation" class="headerlink" title="4、注解(Annotation)"></a>4、注解(Annotation)</h2><h3 id="A-概述"><a href="#A-概述" class="headerlink" title="A.概述"></a>A.概述</h3><ol>
<li>注解是JDK5.0新增的特性。</li>
<li>Annotation 其实就是代码里的特殊标记, 这些标记可以在编译, 类加载, 运行时被读取, 并执行相应的处理。通过使用 Annotation, 程序员可以在不改变原有逻辑的情况下, 在源文件中嵌入一些补充信息。代码分析工具、开发工具和部署工具可以通过这些补充信息进行验证或者进行部署。</li>
<li>Annotation 可以像修饰符一样被使用, 可用于修饰包,类, 构造器, 方 法, 成员变量, 参数, 局部变量的声明，这些信息被保存在 Annotation 的 “name&#x3D;value” 对中。</li>
<li>在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在JavaEE&#x2F;Android中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替JavaEE旧版中所遗留的繁冗代码和XML配置等。</li>
<li>未来的开发模式都是基于注解的，JPA是基于注解的，Spring2.5以上都是基于注解的，Hibernate3.x以后也是基于注解的，现在的Struts2有一部分也是基于注解的了，注解是一种趋势，一定程度上可以说：<strong>框架 &#x3D; 注解 + 反射 + 设计模式</strong>。</li>
</ol>
<h3 id="B-注解的使用示例"><a href="#B-注解的使用示例" class="headerlink" title="B.注解的使用示例"></a>B.注解的使用示例</h3><ol>
<li><p>生成文档相关的注解，如：@author、@version。。。。。</p>
</li>
<li><p>在编译时进行格式检查（JDK内置的三个基本注解）</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">@Override:被修饰的方法会被当作是重写的方法，在编译的时候就会对其进行校验看是否是满足重写的要求，不满足，则报错, 该注解只能用于方法</span></span><br><span class="line"><span class="comment">@Deprecated: 用于表示所修饰的元素(类, 方法等)已过时。通常是因为所修饰的结构危险或存在更好的选择。过时的结构仍可以使用。</span></span><br><span class="line"><span class="comment">@SuppressWarnings: 抑制编译器警告。如：当声明一个变量没使用时，就会出现“变量未使用”的警告，如果你想此警告不出现，可以使用这个注解来抑制该警告的出现。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>跟踪代码依赖性，实现替代配置文件功能</p>
</li>
</ol>
<h3 id="C-如何自定义注解"><a href="#C-如何自定义注解" class="headerlink" title="C.如何自定义注解"></a>C.如何自定义注解</h3><p><img src="/imgs/image-20230426181248641.png" alt="image-20230426181248641"></p>
<p>一般我们在自定义注解时会指明两个元注解：Retention、Target</p>
<h3 id="D-JDK中的元注解"><a href="#D-JDK中的元注解" class="headerlink" title="D.JDK中的元注解"></a>D.JDK中的元注解</h3><h4 id="①理解"><a href="#①理解" class="headerlink" title="①理解"></a>①理解</h4><p>​	元注解：对现有的注解进行解释说明的注解</p>
<h4 id="②四个基本元注解—-Retention"><a href="#②四个基本元注解—-Retention" class="headerlink" title="②四个基本元注解—-Retention"></a>②四个基本元注解—-Retention</h4><p>​	其只能用于修饰一个 Annotation 定义, 用于指定该 Annotation 的生命周期。</p>
<p>​	格式：@Retention(参数)，使用时必须指明其参数值，下面三个值中选一个：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.RetentionPolicy.SOURCE:</span></span><br><span class="line"><span class="comment">表明该注解只在源文件中有效，而在编译时被丢弃</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2.RetentionPolicy.CLASS:</span></span><br><span class="line"><span class="comment">表明该注解编译的时候有，但运行时不加载到内存中。这是默认值，即：某个注解没有被该注解显示修饰时，其默认是被&quot;@Retention(RetentionPolicy.CLASS)&quot;修饰的</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3.RetentionPolicy.RUNTIME:</span></span><br><span class="line"><span class="comment">在运行时有效（即运行时保留），当运行 Java 程序时, JVM 会保留注释。程序可以通过反射获取该注释。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>​	<strong>只有声明为RUNTIME生命周期的注解，才能通过反射获取。</strong></p>
<h4 id="③四个基本元注解—-Target"><a href="#③四个基本元注解—-Target" class="headerlink" title="③四个基本元注解—-Target"></a>③四个基本元注解—-Target</h4><p>​	用于修饰 Annotation 定义, 用于指定被修饰的 Annotation 能用于修饰程序中的哪些结构。</p>
<p>​	格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;类型1，类型2，类型3,..&#125;)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">类型可以选择：</span></span><br><span class="line"><span class="comment">TYPE：类、接口、枚举类</span></span><br><span class="line"><span class="comment">FIELD：属性</span></span><br><span class="line"><span class="comment">METHOD：方法</span></span><br><span class="line"><span class="comment">PARAMETER：参数</span></span><br><span class="line"><span class="comment">CONSTRUCTOR：构造器</span></span><br><span class="line"><span class="comment">LOCAL_VARIABLE：局部变量</span></span><br><span class="line"><span class="comment">ANNOTATION_TYPE：注解类型</span></span><br><span class="line"><span class="comment">PACKAGE：包</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>​	如果注解没有被该元注解修饰，则表明该注解可以使用在任何地方。</p>
<p>​	以下两个注解在开中2使用频率较低</p>
<h4 id="④四个基本元注解—-Documented"><a href="#④四个基本元注解—-Documented" class="headerlink" title="④四个基本元注解—-Documented"></a>④四个基本元注解—-Documented</h4><p>​	用于指定被该元 Annotation 修饰的 Annotation 类将被javadoc 工具提取成文档。默认情况下，javadoc是不包括注解的。</p>
<h4 id="⑤四个基本元注解—-Inherited"><a href="#⑤四个基本元注解—-Inherited" class="headerlink" title="⑤四个基本元注解—-Inherited"></a>⑤四个基本元注解—-Inherited</h4><p>​	被它修饰的 Annotation 将具有继承性。如果某个类使用了被@Inherited 修饰的 Annotation, 则其子类将自动具有该注解。</p>
<hr>
<h3 id="E-通过反射获取注解信息"><a href="#E-通过反射获取注解信息" class="headerlink" title="E.通过反射获取注解信息"></a>E.通过反射获取注解信息</h3><p>​	到反射再讲</p>
<h3 id="F-JDK-8中注解的新特性"><a href="#F-JDK-8中注解的新特性" class="headerlink" title="F.JDK 8中注解的新特性"></a>F.JDK 8中注解的新特性</h3><h4 id="①可重复注解"><a href="#①可重复注解" class="headerlink" title="①可重复注解"></a>①可重复注解</h4><p>​	可重复注解：即可以在某个程序结构中声明多个类型相同的注解。如：</p>
<p><img src="/imgs/image-20230426181539055.png" alt="image-20230426181539055"></p>
<p>​	实现步骤：</p>
<p>​	例子：</p>
<ol>
<li>在MyAnnotation上声明@Repeatable，成员值为MyAnnotations.class。</li>
<li>MyAnnotation的Target和Retention等元注解与MyAnnotations的相同。即MyAnnotation有的元注解，MyAnnotations也得有（除了@Repeatable）并且得一样。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repeatable(MyAnnotations.class)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;TYPE,FIELD,METHOD,PARAMETER,CONSTRUCTOR,LOCAL_VARIABLE&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation</span><br><span class="line">&#123;</span><br><span class="line">	String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;TYPE,FIELD,METHOD,PARAMETER,CONSTRUCTOR,LOCAL_VARIABLE&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotations</span><br><span class="line">&#123;</span><br><span class="line">	MyAnnotation[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="②类型注解"><a href="#②类型注解" class="headerlink" title="②类型注解"></a>②类型注解</h4><p>​	ElementType.TYPE_PARAMETER 表示该注解能写在类型变量的声明语句中（如：用来修饰泛型类型）。<br>​	ElementType.TYPE_USE 表示该注解能写在使用类型的任何语句中。</p>
<p>​	上面两个属性属于元注解Target里的，使用时不用加ElementType</p>
<hr>
<h2 id="5、Java集合"><a href="#5、Java集合" class="headerlink" title="5、Java集合"></a>5、Java集合</h2><h3 id="A-集合框架的概述"><a href="#A-集合框架的概述" class="headerlink" title="A.集合框架的概述"></a>A.集合框架的概述</h3><ol>
<li>集合、数组都是对多个数据进行存储操作的结构，简称Java容器。<ul>
<li>说明：此时的存储，主要指的是内存层面的存储，不涉及到持久化的存储（如：.text，.jpg，.avi，数据库中）。</li>
</ul>
</li>
<li>数组在存储多个数据方面的特点：<ul>
<li>数组初始化以后，长度就确定了。</li>
<li>数组一旦定义好，其元素的类型也就确定了。</li>
</ul>
</li>
<li>数组在存储多个数据方面的缺点：<ul>
<li>一旦初始化以后，其长度就不可修改。</li>
<li>数组中提供的方法非常有限，对于添加、删除、插入数据等操作，非常不便，同时效率不高。</li>
<li>获取数组中实际元素的个数的需求，数组没有现成的属性或方法可用。</li>
<li>数组存储数据的特点：有序、可重复。对于无序、不可重复的需求，不能满足。</li>
</ul>
</li>
</ol>
<h3 id="B-集合框架"><a href="#B-集合框架" class="headerlink" title="B.集合框架"></a>B.集合框架</h3><p><img src="/imgs/image-20230426181604214.png" alt="image-20230426181604214"></p>
<p>​	key与value是映射关系，key就相当于函数中的自变量，value就相当于因变量。一个key不可以对应多个value，多个key可用对应同一个value值。</p>
<h3 id="C-Collection接口中的方法"><a href="#C-Collection接口中的方法" class="headerlink" title="C.Collection接口中的方法"></a>C.Collection接口中的方法</h3><p>​	<strong>以下方法都是通过对象进行调用。</strong></p>
<h4 id="①-add-Object-obj"><a href="#①-add-Object-obj" class="headerlink" title="① add(Object obj)"></a>① add(Object obj)</h4><p>​		将元素obj添加到当前集合中</p>
<h4 id="②-addAll-Collection-coll"><a href="#②-addAll-Collection-coll" class="headerlink" title="② addAll(Collection coll)"></a>② addAll(Collection coll)</h4><p>​		将coll集合中的所有元素添加到当前的集合中。</p>
<h4 id="③size"><a href="#③size" class="headerlink" title="③size()"></a>③size()</h4><p>​		获取集合中元素的个数</p>
<h4 id="④clear"><a href="#④clear" class="headerlink" title="④clear()"></a>④clear()</h4><p>​		清空当前集合中的元素</p>
<h4 id="⑤isEmpty"><a href="#⑤isEmpty" class="headerlink" title="⑤isEmpty()"></a>⑤isEmpty()</h4><p>​		判断当前集合中是否有元素。有，返回false；没有，返回true。</p>
<h4 id="⑥contains-Object-obj"><a href="#⑥contains-Object-obj" class="headerlink" title="⑥contains(Object obj)"></a>⑥contains(Object obj)</h4><p>​		判断当前集合中是否包含obj，在判断时会调用obj对象所在类的equals()。返回true或false。</p>
<h4 id="⑦containsAll-Collection-coll1"><a href="#⑦containsAll-Collection-coll1" class="headerlink" title="⑦containsAll(Collection coll1)"></a>⑦containsAll(Collection coll1)</h4><p>​		判断形参coll1中的<strong>所有元素是否都存在</strong>于当前集合中。返回true、或false。</p>
<h4 id="⑧remove-Object-obj"><a href="#⑧remove-Object-obj" class="headerlink" title="⑧remove(Object obj)"></a>⑧remove(Object obj)</h4><p>​		从当前集合中移除obj元素。</p>
<p>​		底层的实现方式是：调用obj所在类的equals()方法，看该集合是否包含obj，包含则删除返回true，否则返回false。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    list.add(<span class="number">123</span>);</span><br><span class="line">    list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    list.remove(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    <span class="comment">//list.remove(123); //会报错，因为123会被认为是索引</span></span><br><span class="line">    list.remove(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">123</span>));<span class="comment">//想要删除整数123，就得先把123变成包装类。</span></span><br><span class="line">    System.out.println(list);<span class="comment">//[b]</span></span><br><span class="line">&#125;       </span><br></pre></td></tr></table></figure>



<h4 id="⑨removeAll-Collection-coll1"><a href="#⑨removeAll-Collection-coll1" class="headerlink" title="⑨removeAll(Collection coll1)"></a>⑨removeAll(Collection coll1)</h4><p>​		从当前集合中删除coll1中所有的元素。</p>
<p>​		底层的实现方式是：还是会调用equals()来判断该集合是否含有要删除的元素，有则删除。</p>
<h4 id="⑩retainAll-Collection-coll1"><a href="#⑩retainAll-Collection-coll1" class="headerlink" title="⑩retainAll(Collection coll1)"></a>⑩retainAll(Collection coll1)</h4><p>​		获取当前集合coll和coll1集合的交集，并返回给当前集合coll，即当前集合中的元素变为两集合中的交集的元素。</p>
<h4 id="11-equals-Object-obj"><a href="#11-equals-Object-obj" class="headerlink" title="11.equals(Object obj)"></a>11.equals(Object obj)</h4><p>​		要想返回true，<strong>需要当前集合和形参集合的元素都相同。</strong></p>
<p>​		底层的实现方式：调用obj所在类的equals()方法。</p>
<h4 id="12-hashCode"><a href="#12-hashCode" class="headerlink" title="12.hashCode()"></a>12.hashCode()</h4><p>​		返回当前对象的哈希值。</p>
<h4 id="13-toArray-、数组集合互转"><a href="#13-toArray-、数组集合互转" class="headerlink" title="13.toArray()、数组集合互转"></a>13.toArray()、数组集合互转</h4><p>​		实现的操作：集合 –&gt; 数组。返回Object[ ]。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test6</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    coll.add(<span class="number">123</span>);</span><br><span class="line">    coll.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Object[] array = coll.toArray();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">    System.out.println(array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果：123，aaa</span></span><br></pre></td></tr></table></figure>

<p>​	<strong>补充：</strong></p>
<p>​		数组 —&gt; 集合：调用Arrays类的静态方法asList()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test6</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//可以直接在asList()的参数里写数组元素值</span></span><br><span class="line">	<span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> Arrays.asList(<span class="number">123</span>,<span class="number">456</span>);<span class="comment">//写其他基本数据类型的数据也行</span></span><br><span class="line">    System.out.println(list);<span class="comment">//[123,456]</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果想在asList()的参数里传一个现有的数组，那就要将该数组转换为对应的包装类的数组（除了String不用转，其他基本数据类型都要转），然后将包装类的数组名传到在asList()里</span></span><br><span class="line">    <span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">123</span>,<span class="number">456</span>&#125;;</span><br><span class="line">    Integer[] arr = <span class="keyword">new</span> <span class="title class_">Integer</span>[a.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> Arrays.asList(arr);</span><br><span class="line">    System.out.println(list);<span class="comment">//[123,456]</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    如果不转换为对应的包装类，而是直接：</span></span><br><span class="line"><span class="comment">    System.out.println(a);</span></span><br><span class="line"><span class="comment">    输出的结果为：[[I@22927a81]</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>​		</p>
<h4 id="14-iterator"><a href="#14-iterator" class="headerlink" title="14.iterator()"></a>14.iterator()</h4><p>​		返回Iterator接口的实例，该实例用于遍历集合Collection中的元素。</p>
<p>​		调用iterator()时，还会生成一个指针，该指针指向集合中第一个元素的前一个位置。</p>
<p>​		Iterator：迭代器。其里面有两个方法：</p>
<ol>
<li>hasNext()：判断当前指针的下一个位置上还有没有集合元素，返回布偶值。</li>
<li>next()：调用该方法时：①指针下移 ②将下移以后集合位置上的元素返回。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test6</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    coll.add(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    coll.add(<span class="number">456</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> coll.iterator();</span><br><span class="line">    <span class="comment">//方法一：不推荐，这种方法也可以将集合中的元素输出</span></span><br><span class="line">    <span class="comment">//System.out.println(iterator.next());</span></span><br><span class="line">    <span class="comment">//System.out.println(iterator.next());</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方式二：推荐，开发中常用</span></span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		</p>
<p>​		Iterator迭代器里还有一个方法：remove()，可以在遍历的时候，删除集合中的元素。此方法不同于集合直接调用remove()方法。例子：</p>
<img src="/imgs/image-20230426181825742.png" alt="image-20230426181825742" style="zoom:67%;" />





<hr>
<h3 id="D-foreach"><a href="#D-foreach" class="headerlink" title="D.foreach"></a>D.foreach</h3><p>​	jdk 5.0新增了foreach循环（又称增强for循环），用于遍历集合和数组。</p>
<h4 id="①格式"><a href="#①格式" class="headerlink" title="①格式"></a>①格式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">for(集合中元素的类型 变量名 : 集合对象)&#123;</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="②原理"><a href="#②原理" class="headerlink" title="②原理"></a>②原理</h4><p>​	每次都从集合对象或数组中取一个元素赋给变量。直到所有元素都取完。</p>
<h4 id="③例子"><a href="#③例子" class="headerlink" title="③例子"></a>③例子</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test6</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        coll.add(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        coll.add(<span class="number">456</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Object obj : coll)&#123;</span><br><span class="line">            System.out.println(obj);</span><br><span class="line">        &#125;<span class="comment">//123，456</span></span><br><span class="line">	</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//for(数组元素类型 变量名 : 数组名)&#123;&#125;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : arr)&#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;<span class="comment">//1，2，3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="E-Collection子接口之一：List接口"><a href="#E-Collection子接口之一：List接口" class="headerlink" title="E.Collection子接口之一：List接口"></a>E.Collection子接口之一：List接口</h3><p>​	List接口有三个实现类，分别为：ArrayList、LinkedList、Vector</p>
<h4 id="①三个实现类的区别"><a href="#①三个实现类的区别" class="headerlink" title="①三个实现类的区别"></a>①三个实现类的区别</h4><ol>
<li><strong>ArrayList：</strong>作为List接口的主要实现类；线程不安全的，效率高；底层使用Object[ ]  elementData 存储；</li>
<li><strong>LinkedList：</strong>对于频繁的插入、删除操作，使用此类效率比ArrayList高；底层使用双向链表存储；</li>
<li><strong>Vector：</strong>作为List接口的古老实现类；线程安全的，效率低；底层使用Object[ ] elementData 存储；此实现类少用。就算ArrayList线程不安全，也不会用Vector。因为还有工具类Collections中有方法可以将ArrayList转换为线程安全的ArrayList。</li>
<li>三者的相同点：都实现了List接口，存储数据的特点相同——存储有序、可重复的数据</li>
</ol>
<h4 id="②底层源码分析之ArrayList"><a href="#②底层源码分析之ArrayList" class="headerlink" title="②底层源码分析之ArrayList"></a>②底层源码分析之ArrayList</h4><p>​		<strong>jdk 7情况下的源码分析：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"><span class="comment">//底层创建了一个长度为10的Object[]数组elementData</span></span><br><span class="line">list.add(<span class="number">123</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">每次调用add方法时，都会先判断当前的数据能不能放入elementData数组中，如果放不下就会扩容。默认情况下，扩容为原来容量的1.5倍，同时需要将原有数组中的数据复制到新的数组中。然后再将数据添加到新的数组中。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>​		结论：如果开发中知道大概要放多少个数据，那么建议使用带参的构造器：**ArrayList list &#x3D; new ArrayList(int capacity)**。这样可以减少多次扩容，提高效率。底层创建了一个长度为capacity的Object[ ]数组elementData。</p>
<p>​		<strong>jdk 8中ArrayList 的变化：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"><span class="comment">//底层Object[] elementData初始化为&#123;&#125;，并没有创建长度为10的数组</span></span><br><span class="line"></span><br><span class="line">list.add(<span class="number">123</span>);<span class="comment">//第一次调用add()时，底层才创建了长度为10的数组，并将数据123添加到elementData[0]</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">//后续的添加和扩容操作与jdk 7相同</span></span><br></pre></td></tr></table></figure>

<p>​		<strong>小结：</strong></p>
<p><img src="/imgs/image-20230426181901321.png" alt="image-20230426181901321"></p>
<hr>
<h4 id="③底层源码分析之LinkedList"><a href="#③底层源码分析之LinkedList" class="headerlink" title="③底层源码分析之LinkedList"></a>③底层源码分析之LinkedList</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LinkedList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line"><span class="comment">//内部声明了Node类型的first和last属性，分别用于记录链表头和链表尾，默认值都为null</span></span><br><span class="line">list.add(<span class="number">123</span>);<span class="comment">//将123封装到Node，创建Node对象。Node为链表中的结点</span></span><br><span class="line"><span class="comment">//add()的实现方式与数据结构中双向链表的添加结点操作一样</span></span><br></pre></td></tr></table></figure>



<h4 id="④底层源码分析之Vector"><a href="#④底层源码分析之Vector" class="headerlink" title="④底层源码分析之Vector"></a>④底层源码分析之Vector</h4><p>​	jdk7和jdk8中通过Vector()构造器创建对象时，底层都创建了长度为10的数组。</p>
<p>​	在扩容方面，默认扩容为原来的数组长度的2倍。</p>
<hr>
<h3 id="F-List接口中的常用方法"><a href="#F-List接口中的常用方法" class="headerlink" title="F.List接口中的常用方法"></a>F.List接口中的常用方法</h3><p>①void <strong>add</strong>(int index, Object ele)：在index位置插入ele元素<br>②boolean <strong>addAll</strong>(int index, Collection eles)：从index位置开始将eles中的所有元素添加进来。eles可以为Collection的任何子类对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        list.add(<span class="number">123</span>);</span><br><span class="line">        list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">list1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        list1.add(<span class="string">&quot;您&quot;</span>);</span><br><span class="line"></span><br><span class="line">        list.addAll(<span class="number">1</span>,list1);</span><br><span class="line">        System.out.println(list);<span class="comment">//[123, 您, a, b]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>③Object <strong>get</strong>(int index):获取指定index位置的元素。</p>
<p>④int <strong>indexOf</strong>(Object obj):返回obj在集合中首次出现的位置。没有找到该元素，则返回-1。</p>
<p>⑤int <strong>lastIndexOf</strong>(Object obj):返回obj在当前集合中最后一次出现的位置。没有找到该元素，则返回-1。</p>
<p>⑥Object <strong>remove</strong>(int index):移除指定index位置的元素，并返回此元素。</p>
<p>⑦Object <strong>set</strong>(int index, Object ele):设置指定index位置的元素为ele。</p>
<p>⑧List <strong>subList</strong>(int fromIndex, int toIndex):返回从fromIndex到toIndex（不包括toIndex）位置的子集合。原集合中的元素不变。</p>
<h6 id="总结：常用方法"><a href="#总结：常用方法" class="headerlink" title="总结：常用方法"></a>总结：常用方法</h6><p>​	增：add(Object obj)          —&gt;这里的增是指在末尾添加元素</p>
<p>​	删：remove(int index) \ remove(Object obj)</p>
<p>​	改：set(int index,Object ele)</p>
<p>​	查：get(int index)</p>
<p>​	插：add(int index,Object ele)</p>
<p>​	长度：size()</p>
<p>​	遍历：①Iterator迭代器方式；②增强for循环；③普通for循环</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用普通for循环遍历</span></span><br><span class="line"><span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">list.add(<span class="number">123</span>);</span><br><span class="line">list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; list.size();i++)&#123;</span><br><span class="line">    System.out.println(list.get(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="G-Collection子接口之二：Set接口"><a href="#G-Collection子接口之二：Set接口" class="headerlink" title="G.Collection子接口之二：Set接口"></a>G.Collection子接口之二：Set接口</h3><h4 id="①概述-1"><a href="#①概述-1" class="headerlink" title="①概述"></a>①概述</h4><p>​	Set接口：存储无序的、不可重复的数据 —&gt; 相当于高中讲的“集合”</p>
<p>​	无序性和不可重复性的说明：以HashSet为例进行解释说明</p>
<ul>
<li><p><strong>无序性</strong>：不等于随机性。存储的数据在底层数组中并非按照数组索引的顺序添加，而是根据数据的哈希值决定的。</p>
</li>
<li><p><strong>不可重复性</strong>：保证添加的元素按照equals()判断时（equals方法要重写），不能返回true。即：相同的元素只能添加一个。</p>
</li>
</ul>
<h4 id="②元素的添加过程"><a href="#②元素的添加过程" class="headerlink" title="②元素的添加过程"></a>②元素的添加过程</h4><p>​	以HashSet为例：</p>
<p>​	我们向HashSet中添加元素a，首先调用元素a所在类的hasCode()方法，计算元素a的哈希值，此哈希值接着通过某种算法计算出在HashSet底层数组中的存放位置（即：索引位置），判断数组此位置上是否已经有元素：</p>
<p>​	如果此位置上没有其他元素，则元素a添加成功。 —-&gt; 情况1</p>
<p>​	如果此位置上有其他元素b（或以链表形式存在的多个元素），则比较元素a与元素b等其他元素的哈希值。</p>
<p>​	|——&gt;如果哈希值不同，则元素a添加成功。  —-&gt; 情况2</p>
<p>​	|——&gt;如果哈希值相同，进而想要调用元素a所在类的equals()方法</p>
<p>​			 |—-&gt; equals()返回true，元素a添加失败</p>
<p>​			 |—-&gt; equals()返回false，则元素a添加成功 —-&gt; 情况3</p>
<p> 对于添加成功的情况2和情况3而言：元素a 与已经存在指定索引位置上数据以链表的方式存储。而jdk7 和jdk8的存储方式又不太一样</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jdk 7：元素a 放到数组中，指向原来的元素；</span><br><span class="line">jdk 8：原来的元素在数组中，指向元素 a 。</span><br><span class="line">总结：七上八下</span><br></pre></td></tr></table></figure>

<p>​	补充：hasCode()方法中计算哈希值时，会涉及到属性值。</p>
<p><strong>HashSet底层：数组+单链表的结构</strong></p>
<p><img src="/imgs/image-20230426181924687.png" alt="image-20230426181924687"></p>
<h4 id="③LinkedHashSet的底层结构"><a href="#③LinkedHashSet的底层结构" class="headerlink" title="③LinkedHashSet的底层结构"></a>③LinkedHashSet的底层结构</h4><p>​	LinkedHashSet作为HashSet的子类，添加数据的过程一样，但不同的是在添加数据的同时，每个数据还维护了两个引用，记录此数据前一个数据和后一个数据。这使得可以按照添加的顺序遍历输出集合。</p>
<p><img src="/imgs/image-20230426181948380.png" alt="image-20230426181948380"></p>
<p><strong>LinkedHashSet底层使用：数组+双向链表进行存储。</strong></p>
<h4 id="④三个实现类的区别"><a href="#④三个实现类的区别" class="headerlink" title="④三个实现类的区别"></a>④三个实现类的区别</h4><p>​	<strong>HashSet</strong>：作为Set接口的主要实现类；线程不安全的；可以存储null值。底层使用数组+单链表进行存储。</p>
<p>​	<strong>LinkedHashSet</strong>：作为HashSet的子类；遍历其内部数据时，可以按照添加的顺序遍历。对于频繁的遍历操作，LinkedHashSet效率高于HashSet。底层使用数组+双向链表进行存储。</p>
<p>​	<strong>TreeSet</strong>：可以按照添加对象的指定属性，进行排序。底层使用红黑树进行存储。向TreeSet中添加的数据，要求是<strong>相同类的对象</strong>。</p>
<h4 id="⑤TreeSet的两种排序方式"><a href="#⑤TreeSet的两种排序方式" class="headerlink" title="⑤TreeSet的两种排序方式"></a>⑤TreeSet的两种排序方式</h4><ol>
<li><strong>自然排序</strong>：TreeSet 会调用集合元素的 compareTo(Object obj) 方法来比较元素之间的大小关系，然后将集合元素按升序(默认情况)排列。比较两个对象是否相同的标准为 compareTo( )返回0，而不是equals( )。compareTo( )返回0代表两对象相等，就不能添加到集合中。</li>
<li><strong>定制排序</strong>：通过Comparator接口来实现。比较两个对象是否相同的标准为 compare( )返回0，而不是equals( )。compare( )返回0代表两对象相等，就不能添加到集合中。</li>
</ol>
<p>说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.如果声明TreeSet对象时使用空参的构造器，则代表使用的是自然排序的方式进行排序，此时得在相应的类中继承comparable接口并重写compareTo方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2.如果声明TreeSet对象时使用带参构造器</span></span><br><span class="line"><span class="comment">TreeSet set = new TreeSet(Comparator com);</span></span><br><span class="line"><span class="comment">则代表排序的时候就使用“定制排序”</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h3 id="H-List和Set的使用总结"><a href="#H-List和Set的使用总结" class="headerlink" title="H.List和Set的使用总结"></a>H.List和Set的使用总结</h3><p>​	向Collection接口的实现类的对象中添加数据obj时，要求obj所在类要重写equals()。</p>
<h4 id="①List的使用总结"><a href="#①List的使用总结" class="headerlink" title="①List的使用总结"></a>①List的使用总结</h4><h4 id="②Set的使用总结"><a href="#②Set的使用总结" class="headerlink" title="②Set的使用总结"></a>②Set的使用总结</h4><ol>
<li>Set接口中没有额外定义新的方法，使用的都是Collection中声明过的方法。</li>
<li>向实现类HashSet、LinkedHashSet中添加的数据，该数据所在的类一定要重写hashCode()和equals()。直接使用：alt + shift + s 调用equals和hashCode即可。</li>
<li>向TreeSet中添加的数据，该数据所在的类一定要实现自然排序或定制排序。不用重写hashCode()和equals()。向TreeSet中添加的数据，必须是相同类的对象。</li>
<li>当调用remove(Object obj)时，先计算Obj的哈希值，根据哈希值找到底层数组中对应的索引位置，如果该位置上没有数据则删除失败，如果有数据，则判断哈希值是否相同，相同进而用equals()判断，equals()判断相同则删除该数据，不相同则删除失败；哈希值不一样，也删除失败。</li>
</ol>
<h3 id="J-练习"><a href="#J-练习" class="headerlink" title="J.练习"></a>J.练习</h3><h4 id="①在List内去除重复数值值"><a href="#①在List内去除重复数值值" class="headerlink" title="①在List内去除重复数值值"></a>①在List内去除重复数值值</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SetTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List <span class="title function_">toSet</span><span class="params">(List list)</span>&#123;</span><br><span class="line">        <span class="type">TreeSet</span> <span class="variable">treeSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeSet</span>();</span><br><span class="line">        treeSet.addAll(list);<span class="comment">//添加时会调用当前数据所在类的hashCode()和equals()</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>(treeSet);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">2</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">2</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">List</span> <span class="variable">list1</span> <span class="operator">=</span> toSet(list);</span><br><span class="line">        <span class="keyword">for</span> (Object o1 : list1)&#123;</span><br><span class="line">            System.out.println(o1);</span><br><span class="line">        &#125;<span class="comment">//1，2，3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="K-Map接口"><a href="#K-Map接口" class="headerlink" title="K.Map接口"></a>K.Map接口</h3><h4 id="①概述-2"><a href="#①概述-2" class="headerlink" title="①概述"></a>①概述</h4><p>​	Map：双列数据，存储key-value对的数据  –&gt; 类似于高中的函数：y&#x3D;f(x)</p>
<p>​	 | — HashMap：作为Map的主要实现类；线程不安全，效率高；可以存储null的key和value。底层：数组+单链表(jdk7.0及之前)，数组+单向链表+红黑树(jdk8)</p>
<p>​	        | — LinkedHashMap：保证在遍历map元素时，可以按照添加的顺序实现遍历。原因：在原有的HashMap底层结构基础上，添加了一对指针，指向前一个和后一个元素。<strong>对于频繁的遍历操作，此类执行效率高于HashMap。</strong>该类是HashMap的子类。</p>
<p>​	| — TreeMap：保证添加的key-value对进行排序，<strong>实现排序遍历</strong>。此时<strong>考虑key的自然排序或定制排序</strong>。底层使用红黑树。</p>
<p>​	| — Hashtable：作为古老的实现类；线程安全的，效率低；不能存储值为null的key和value。</p>
<p>​			| — Properties：是Hashtable的子类。常用来处理配置文件。key和value都是String类型。</p>
<hr>
<h4 id="②Map结构的理解"><a href="#②Map结构的理解" class="headerlink" title="②Map结构的理解"></a>②Map结构的理解</h4><p>Map中的key：无序的、不可重复的，使用Set存储所有的key 。</p>
<p>Map中的value：无序的、可重复的，使用Collection存储所有的value。–&gt; value所在的类要重写equals()</p>
<p>一个键值对：key-value 构成了一个Entry 对象。key、value为Entry对象的两个属性。</p>
<p>Map中的entry：无序的、不可重复的，使用Set存储所有的Entry。</p>
<p><strong>注意：</strong></p>
<ol>
<li><p>为保证添加的数据中key的值是不可重复的。我们想要进行如下操作：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">①如果key属于HashMap里的key，则要用HashSet去存储，为保证不可重复性，就要在添加数据所在类里重写equals()和hashCode()。</span></span><br><span class="line"><span class="comment">②如果如果key属于LinkedHashMap里的key，则要用LinkedHashSet去存储，为保证不可重复性，就要在添加数据所在类里重写equals()和hashCode()。</span></span><br><span class="line"><span class="comment">③如果key属于TreeMap里的key，则要用TreeSet去存储，为保证不可重复性，要在添加数据所在类里实现coparable接口或定制排序</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="③HashMap的底层实现原理"><a href="#③HashMap的底层实现原理" class="headerlink" title="③HashMap的底层实现原理"></a>③HashMap的底层实现原理</h4><p>​	<strong>以jdk7为例说明：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HashMap</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>()</span><br></pre></td></tr></table></figure>

<p>在实例化以后，底层创建了长度为16的一维数组Entry[ ] table。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可能已经执行过多次put</span></span><br><span class="line">map.put(key1,value1);</span><br></pre></td></tr></table></figure>

<p>当执行put时：</p>
<p>首先，调用key1所在类的hashCode()计算key1哈希值，此哈希值经过某种算法计算以后，得到在Entry数组中的存放位置。</p>
<p>如果此位置上的数据为空，此时的key1-value1添加成功。– &gt; 情况1</p>
<p>如果此位置上的数据不为空，（意味着此位置上存在一个或多个数据(以链表形式存在)），比较key1和已经存在的一个或多个数据的key的哈希值：</p>
<p>|—-如果key1的哈希值与已存在的数据的哈希值都不相同，此时key1-value1添加成功。 – &gt; 情况2</p>
<p>|—-如果key1的哈希值和已经存在的某一个数据(key2-value2)的哈希值相同。继续比较：调用key1所在类的equals(key2)方法，比较：</p>
<p>​		|—–如果equals()返回false：此时key1-value1添加成功。 —&gt; 情况3</p>
<p>​		|—–如果equals()返回true：使用value1替换value2。</p>
<p><strong>补充：</strong></p>
<ol>
<li>关于情况2和情况3，此时key1-value1和原来的数据以链表的方式存储。</li>
<li>在不断的添加过程中，会涉及到扩容问题，当超出临界值（且要存放的位置非空）时，扩容。默认的扩容方式：扩容为原来容量的2倍，并将原有的数据复制过来。复制时，要重新计算每个数据的key的哈希值，根据新的哈希值得出该元素在数组中新存放的位置。</li>
</ol>
<p>jdk8 相较于jdk7在底层实现方面的不同：</p>
<ol>
<li>new HashMap()：底层没有创建一个长度为16的数组。</li>
<li>jdk 8 底层的数组是 Node[ ]，而非 Entry[ ] 。Node本质上就是Entry[ ]。</li>
<li>首次调用put（）方法时，底层创建长度为16的数组。</li>
<li>jdk 7 底层结构只有：数组+链表。jdk 8 中底层结构：数组+链表+红黑树。当数组的某一个索引位置上的元素以链表形式存在的数据个数&gt;8 且当数组的长度&gt;64时，此时此索引位置上的所有数据改为使用红黑树存储。使用红黑树的好处：提高查找效率。如果数组的长度&lt;64，则进行扩容。</li>
<li>形成链表时，七上八下（jdk7：新的元素指向旧的元素。jdk8：旧的元素指向新的元素）</li>
</ol>
<h4 id="④HashMap源码中的重要常量"><a href="#④HashMap源码中的重要常量" class="headerlink" title="④HashMap源码中的重要常量"></a>④HashMap源码中的重要常量</h4><p><strong>DEFAULT_INITIAL_CAPACITY</strong>：HashMap的默认容量，16；<br><strong>DEFAULT_LOAD_FACTOR</strong>：HashMap的默认加载因子：0.75；加载因子影响的是扩容的临界值。如果加载因子太小，数组中的位置还没充分利用就扩容了，如果加载原子太大，就可能会形成许多链表，不利于遍历。<br><strong>threshold</strong>：扩容的临界值，&#x3D;容量 × 加载因子：16 * 0.75&#x3D;12；当要添加当前数据后超过threshold时，先判断要添加的位置上是否有元素，有则需要扩容；没有，则将当前元素放进去该位置。<br><strong>TREEIFY_THRESHOLD</strong>:Bucket中链表长度大于该默认值，转化为红黑树：8；<br><strong>MIN_TREEIFY_CAPACITY</strong>：桶中的Node被树化时最小的hash表容量：64</p>
<h4 id="⑤LinkedHashMap的底层实现"><a href="#⑤LinkedHashMap的底层实现" class="headerlink" title="⑤LinkedHashMap的底层实现"></a>⑤LinkedHashMap的底层实现</h4><p>​	与HashMap的实现原理一样，只是LinkedHashMap中的Entry多了两个属性：before、after,用于记录后一个元素和前一个元素。这样的结构就形成双向链表。</p>
<h4 id="⑥TreeMap的使用"><a href="#⑥TreeMap的使用" class="headerlink" title="⑥TreeMap的使用"></a>⑥TreeMap的使用</h4><p>​	向TreeMap中添加key-value，要求key必须是由同一个类创建的对象。因为要按照key进行排序：自然排序、定制排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当使用空参的构造器声明TreeMap时，意味着使用的是自然排序</span></span><br><span class="line"><span class="type">TreeMap</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeMap</span>();</span><br><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">12</span>);</span><br><span class="line"><span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jerry&quot;</span>,<span class="number">22</span>);</span><br><span class="line">t1.put(p1,<span class="number">100</span>);</span><br><span class="line">t1.put(p2,<span class="number">90</span>);</span><br><span class="line"><span class="comment">//要求key所在类要实现Comparable接口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当使用带参的构造器TreeMap(Comparator com)时，意味着使用的是定制排序</span></span><br><span class="line"><span class="type">Comparator</span> <span class="variable">com</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o1 <span class="keyword">instanceof</span> Person &amp;&amp; o2 <span class="keyword">instanceof</span> Person)&#123;</span><br><span class="line">            <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> (Person)o1;</span><br><span class="line">            <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> (Person)o2;</span><br><span class="line">            <span class="keyword">return</span> Integer.compare(p1.getAge(),p2.getAge());</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;类型不一致&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">TreeMap</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeMap</span>(com);</span><br><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">32</span>);</span><br><span class="line"><span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jerry&quot;</span>,<span class="number">22</span>);</span><br><span class="line">t1.put(p1,<span class="number">100</span>);</span><br><span class="line">t1.put(p2,<span class="number">90</span>);</span><br></pre></td></tr></table></figure>



<h4 id="⑦Properties的使用"><a href="#⑦Properties的使用" class="headerlink" title="⑦Properties的使用"></a>⑦Properties的使用</h4><p>​	Properties里的方法：</p>
<ul>
<li>load()：加载流对应的文件</li>
<li>getProperty(key)：获取配置文件中对应key的value</li>
</ul>
<p>实现方式一：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Properties</span> <span class="variable">pro</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line"><span class="comment">//如果写相对路径的方式，则文件默认存放在当前module下</span></span><br><span class="line">fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;jdbc.properties&quot;</span>);</span><br><span class="line">pro.load(fis);<span class="comment">//加载流对应的文件</span></span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> pro.getProperty(<span class="string">&quot;name&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>实现方式二：使用ClassLoader</p>
<p>ClassLoader属于反射中的知识</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Properties</span> <span class="variable">pro</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line"><span class="comment">//当前类的类名.class.getClassLoader(),获取加载当前类的系统类加载器</span></span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> ClassLoaderTest.clas.getClassLoader();</span><br><span class="line"><span class="comment">//如果以相对路径的方式写（如下），则默认文件存放在当前module的src下</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> classLoader.getResourceAsStream(<span class="string">&quot;jdbc.properties&quot;</span>);</span><br><span class="line">pro.load(is);</span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> pro.getProperty(<span class="string">&quot;name&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：如果配置文件存放在当前module下，当部署到tomcat上时会丢失，所以配置文件要放在当前module的src下</p>
<h5 id="L-Map中定义的方法"><a href="#L-Map中定义的方法" class="headerlink" title="L.Map中定义的方法"></a>L.Map中定义的方法</h5><h4 id="①添加、删除、修改操作"><a href="#①添加、删除、修改操作" class="headerlink" title="①添加、删除、修改操作"></a>①添加、删除、修改操作</h4><ul>
<li>Object <strong>put</strong>(Object key,Object value)：将指定key-value添加到(或修改)当前map对象中</li>
<li>void <strong>putAll</strong>(Map m):将m中的所有key-value对存放到当前map中 </li>
<li>Object <strong>remove</strong>(Object key)：移除指定key的key-value对，并返回value。找不到要删除的元素，则返回null。</li>
<li>void <strong>clear</strong>()：清空当前map中的所有数据，与map &#x3D; null 操作不同</li>
</ul>
<h4 id="②元素查询的操作"><a href="#②元素查询的操作" class="headerlink" title="②元素查询的操作"></a>②元素查询的操作</h4><ul>
<li>Object <strong>get</strong>(Object key)：获取指定key对应的value，如果找不到该key，则返回null</li>
<li>boolean <strong>containsKey</strong>(Object key)：是否包含指定的key</li>
<li>boolean <strong>containsValue</strong>(Object value)：是否包含指定的value，如果有多个相同的value值，找到第一个后就不再往下找了</li>
<li>int <strong>size</strong>()：返回map中key-value对的个数</li>
<li>boolean <strong>isEmpty</strong>()：判断当前map是否为空，即判断当前map中是否没有元素</li>
<li>boolean <strong>equals</strong>(Object obj)：判断当前map和参数对象obj是否相等。注意：obj必须是map类型，只要元素要一模一样就返回true</li>
</ul>
<h4 id="③元视图操作的方法（即遍历Map）"><a href="#③元视图操作的方法（即遍历Map）" class="headerlink" title="③元视图操作的方法（即遍历Map）"></a>③元视图操作的方法（即遍历Map）</h4><ul>
<li>Set <strong>keySet</strong>()：返回所有key构成的Set集合</li>
<li>Collection <strong>values</strong>()：返回所有value构成的Collection集合</li>
<li>Set <strong>entrySet</strong>()：返回所有key-value对构成的Set集合</li>
</ul>
<p>map没有iterator方法，遍历时可以用以上方法得到set或者Collection，再用他们的iterator方法，即可实现遍历。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">HashMap</span> <span class="variable">map1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map1.put(<span class="string">&quot;aa&quot;</span>,<span class="number">2</span>);</span><br><span class="line">        map1.put(<span class="string">&quot;cc&quot;</span>,<span class="number">3</span>);</span><br><span class="line">        map1.put(<span class="string">&quot;bb&quot;</span>,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历map1当中的key</span></span><br><span class="line">        <span class="type">Set</span> <span class="variable">keySet</span>  <span class="operator">=</span> map1.keySet();</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> keySet.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历map1当中的value</span></span><br><span class="line">        <span class="type">Collection</span> <span class="variable">collection</span> <span class="operator">=</span> map1.values();</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator1</span> <span class="operator">=</span> collection.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator1.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator1.next());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历map1当中的key-value对，方式一：</span></span><br><span class="line">        <span class="type">Set</span> <span class="variable">entrySet</span> <span class="operator">=</span> map1.entrySet();</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator2</span> <span class="operator">=</span> entrySet.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator2.hasNext())&#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> iterator2.next();</span><br><span class="line">            <span class="comment">//取出来的数据都是Entry类型</span></span><br><span class="line">            Map.Entry entry= (Map.Entry)o;</span><br><span class="line">            System.out.println(entry.getKey() + <span class="string">&quot;--&quot;</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">//遍历map1当中的key-value对，方式二：</span></span><br><span class="line">    	<span class="type">Set</span> <span class="variable">keySet1</span> <span class="operator">=</span> map1.keySet();</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator3</span> <span class="operator">=</span> keySet1.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator3.hasNext())&#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">key</span> <span class="operator">=</span> iterator3.next();</span><br><span class="line">            <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> map1.get(key);</span><br><span class="line"></span><br><span class="line">            System.out.println(key + <span class="string">&quot;==&quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/imgs/image-20230426182040928.png" alt="image-20230426182040928" style="zoom:67%;" />



<p>遍历的应用：将Map中的一条条数据取出来放到数据库中</p>
<h4 id="④常用方法总结"><a href="#④常用方法总结" class="headerlink" title="④常用方法总结"></a>④常用方法总结</h4><p><img src="/imgs/image-20230426182101409.png" alt="image-20230426182101409"></p>
<h3 id="M-Collections工具类"><a href="#M-Collections工具类" class="headerlink" title="M.Collections工具类"></a>M.Collections工具类</h3><p>Collections：操作Collection、Map的工具类</p>
<h4 id="①反转"><a href="#①反转" class="headerlink" title="①反转"></a>①反转</h4><p>**reverse(List)**：反转List中元素的顺序，该方法没有返回值</p>
<h4 id="②排序"><a href="#②排序" class="headerlink" title="②排序"></a>②排序</h4><ol>
<li>shuffle(List)：对List集合元素进行随机排序，该方法没有返回值</li>
<li>sort(List)：调用List元素里的comparTO方法对指定的List集合元素进行自然排序（即按升序排序）。</li>
<li>sort(List,Comparator)：根据指定的Comparator产生的顺序对List集合元素进行排序</li>
<li>swap(List,int,int)：将指定 list 集合中的 i 处元素和 j 处元素进行交换</li>
</ol>
<h4 id="③求最值"><a href="#③求最值" class="headerlink" title="③求最值"></a>③求最值</h4><ol>
<li>Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素。自然排序：调用的是集合中元素所在类的compareTo方法。</li>
<li>Object max(Collection，Comparator)：根据 Comparator 指定的顺序，返回给定集合中的最大元素</li>
<li>Object min(Collection)：根据元素的自然顺序，返回给定集合中的最小元素。自然排序：调用的是集合中元素所在类的compareTo方法。</li>
<li>Object min(Collection，Comparator)</li>
</ol>
<h4 id="④计算某元素出现的次数"><a href="#④计算某元素出现的次数" class="headerlink" title="④计算某元素出现的次数"></a>④计算某元素出现的次数</h4><p><code>int frequency(Collection，Object)</code>：返回指定集合中指定元素的出现次数</p>
<h4 id="⑤复制"><a href="#⑤复制" class="headerlink" title="⑤复制"></a>⑤复制</h4><p><code>void copy(List dest,List src)</code>：将src中的内容复制到dest中 </p>
<p><img src="/imgs/image-20230426182125855.png" alt="image-20230426182125855"></p>
<h4 id="⑥替换"><a href="#⑥替换" class="headerlink" title="⑥替换"></a>⑥替换</h4><p><code>boolean replaceAll(List list，Object oldVal，Object newVal)</code>：使用新值替换List 对象的所有旧值</p>
<h4 id="⑦将线程不安全的集合变成线程安全集合"><a href="#⑦将线程不安全的集合变成线程安全集合" class="headerlink" title="⑦将线程不安全的集合变成线程安全集合"></a>⑦将线程不安全的集合变成线程安全集合</h4><p>Collections类中提供了多个synchronizedXxx( )方法，该方法可使将指定集合包装成线程安全的集合，从而可以解决多线程并发访问集合时的线程安全问题，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();<span class="comment">//list存在线程不安全问题</span></span><br><span class="line"><span class="comment">//返回的list1即为线程安全的List</span></span><br><span class="line"><span class="type">List</span> <span class="variable">list1</span> <span class="operator">=</span> Collections.synchronizedList(list);</span><br></pre></td></tr></table></figure>

<p>当多个线程共同操作list1时，就不再发生线程安全问题。</p>
<hr>
<h2 id="6、泛型"><a href="#6、泛型" class="headerlink" title="6、泛型"></a>6、泛型</h2><h3 id="A-引入"><a href="#A-引入" class="headerlink" title="A.引入"></a>A.引入</h3><p>​		我们可以往集合中存放任何的数据类型，这其实是集合的一个缺点，就比如：用集合去存储学生的成绩，在添加数据的时候对数据的类型并没有要求，所以可以添加除int以外的类型数据，这并不是我们希望的，因此我们就引入了泛型。其作用是：表明该集合只能存放泛型中声明的数据类型，不能存放其他数据类型。</p>
<p>​		泛型是jdk5.0的新特性。</p>
<h3 id="B-在集合中使用泛型"><a href="#B-在集合中使用泛型" class="headerlink" title="B.在集合中使用泛型"></a>B.在集合中使用泛型</h3><ol>
<li><p>集合接口或集合类在jdk5.0时都修改为带泛型的结构。 —&gt;前提。如果没有在定义接口或类时声明为带泛型的结构，那么接口内或类内就不能使用泛型。</p>
</li>
<li><p>在实例化集合类时，可以指明具体的泛型类型（只能写类 类型，不能写基本数据类型，要想用基本数据类型—&gt;包装类）</p>
</li>
<li><p>指明完以后，在集合类或接口中凡是定义类或接口时，内部结构（如：方法、构造器、属性等）使用到类的泛型的位置，都指定为实例化的泛型类型。如：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">&quot;hhhhh&quot;</span>);<span class="comment">//此时add方法中的参数变为(String s1),不再是(Object obj)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果实例化时，没有指明泛型的类型（即没使用泛型时）。默认类型为 Java.lang.Object 类型。</p>
</li>
</ol>
<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ol>
<li><p>如果集合中使用泛型声明为Integer，则使用add方法时，仍可以这么写：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list1.add(<span class="number">12</span>);<span class="comment">//仍可以写12</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>集合、比较器（Comparable、Comparator）都可以使用泛型</p>
</li>
<li><p>添加了泛型之后，集合的遍历操作与原来的操作一样，直接调用对应的方法，然后“alt + enter”自动补充即可。生成的代码会有点不同（21行代码）</p>
</li>
</ol>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    list.add(<span class="string">&quot;hhhhh&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;123&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//**********************************</span></span><br><span class="line">    HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;Tom&quot;</span>,<span class="number">12</span>);</span><br><span class="line">    map.put(<span class="string">&quot;Jerry&quot;</span>,<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entrySet = map.entrySet();</span><br><span class="line">    Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iterator1 = entrySet.iterator();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (iterator1.hasNext())&#123;</span><br><span class="line">        Map.Entry&lt;String, Integer&gt; entry = iterator1.next();</span><br><span class="line">        <span class="comment">//现在不用将next方法得到的对象强转为Entry类型</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">        System.out.println(key + <span class="string">&quot;---&quot;</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  <img src="/imgs/image-20230426182151547.png" alt="image-20230426182151547"></p>
<h3 id="C-自定义泛型结构–泛型类"><a href="#C-自定义泛型结构–泛型类" class="headerlink" title="C.自定义泛型结构–泛型类"></a>C.自定义泛型结构–泛型类</h3><p>​	自定义泛型结构有：泛型类、泛型接口、泛型方法</p>
<h4 id="①实现方式"><a href="#①实现方式" class="headerlink" title="①实现方式"></a>①实现方式</h4><p>​	在类名后面加上”<T>“即可，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&lt;T&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	如果定义了泛型类，实例化没有指明类的泛型，则认为此泛型类型为Object类型。要求：如果定义了类是带泛型的，建议在实例化时要指明类的类型。  </p>
<h4 id="②继承关系中的泛型"><a href="#②继承关系中的泛型" class="headerlink" title="②继承关系中的泛型"></a>②继承关系中的泛型</h4><p>​	如果父类为泛型类，则子类有两种情况：</p>
<p>​		情况1：子类明确父类中泛型的类型，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&lt;T&gt;&#123;</span><br><span class="line">    String name;</span><br><span class="line">    T order;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将父类中的泛型明确为String，此时属性order的类型为String</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Man</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&lt;String&gt;&#123;<span class="comment">//Man就不属于泛型类，那么Man再实例化的时候就不能写泛型，只能像普通的类那样实例化</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	情况2：子类也无法确定父类中的泛型具体是哪种类 类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&lt;T&gt;&#123;</span><br><span class="line">    String name;</span><br><span class="line">    T order;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Man</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Person</span>&lt;T&gt;&#123;<span class="comment">//Man属于泛型类</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Man&lt;String&gt; m = <span class="keyword">new</span> <span class="title class_">Man</span>&lt;&gt;();<span class="comment">//此时order为String类型</span></span><br></pre></td></tr></table></figure>

<p>​	</p>
<h4 id="③细节说明"><a href="#③细节说明" class="headerlink" title="③细节说明"></a>③细节说明</h4><ol>
<li><p>泛型类可能有多个参数，此时应将多个参数一起放在尖括号内。比如：&lt;E1,E2,E3&gt;。实例化时应都要指明其具体的泛型类型。</p>
</li>
<li><p>泛型类的构造器如下：public GenericClass(){}。而下面是错误的：public GenericClass&lt; E&gt;(){}</p>
</li>
<li><p>泛型不同的引用不能相互赋值。</p>
<p> <img src="/imgs/image-20230426182213650.png" alt="image-20230426182213650"></p>
<p> 因为赋值之后，list1指向的是list2堆空间中的对象，当调用list1的add方法时添加的是String类型数据，而list2里只能存Integer类型数据，这就发生了冲突，所以不能赋值。</p>
</li>
<li><p>在普通的静态方法中不能使用类的泛型。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(T order)</span>&#123;<span class="comment">//报错</span></span><br><span class="line">	System.out.println(order);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 因为泛型类型是在创建对象的时候再确定的，而静态方法是在类的加载的时候就加载的，这时候就需要用到这里的泛型数据，而泛型类型没确定，就不行。</p>
</li>
<li><p>异常体系结构下的类，不能是泛型类。</p>
</li>
<li><p>try-catch，catch后面的小括号里不能使用泛型。</p>
</li>
<li><p>如果用泛型造个数组，得这样写：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误:</span></span><br><span class="line">T[] arr1 = <span class="keyword">new</span> <span class="title class_">T</span>[<span class="number">10</span>];</span><br><span class="line"><span class="comment">//正确</span></span><br><span class="line">T[] arr = (T[]) <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">10</span>];<span class="comment">//只能往该数组里存放T或T的子类数据</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>继承关系中的泛型详解</p>
<p> <img src="/imgs/image-20230426182234739.png" alt="image-20230426182234739"></p>
<p> <img src="/imgs/image-20230426182248143.png" alt="image-20230426182248143"></p>
<p> <strong>A、B是子类自己的泛型</strong></p>
</li>
</ol>
<h4 id="④应用"><a href="#④应用" class="headerlink" title="④应用"></a>④应用</h4><ol>
<li>当类中的某个属性的类型不确定时，就可以使用泛型类，如：</li>
</ol>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&lt;T&gt;&#123;</span><br><span class="line">	String name;</span><br><span class="line">    T personT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>对数据库中的表进行操作的类中可以声明为泛型类，因为该类可能操作不同的表，每个表又不同，所以就用泛型，让子类去继承该类时再明确泛型类型（即明确操作的是哪种表）。</p>
</li>
<li></li>
</ol>
<hr>
<h3 id="D-自定义泛型结构–泛型接口"><a href="#D-自定义泛型结构–泛型接口" class="headerlink" title="D.自定义泛型结构–泛型接口"></a>D.自定义泛型结构–泛型接口</h3><h4 id="①实现方式-1"><a href="#①实现方式-1" class="headerlink" title="①实现方式"></a>①实现方式</h4><p>​	在接口名后面加上“<T>“即可，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Dog</span>&lt;T&gt;&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="E-自定义泛型结构–泛型方法"><a href="#E-自定义泛型结构–泛型方法" class="headerlink" title="E.自定义泛型结构–泛型方法"></a>E.自定义泛型结构–泛型方法</h3><h4 id="①定义"><a href="#①定义" class="headerlink" title="①定义"></a>①定义</h4><p>​	泛型方法：在方法中出现了泛型的结构，泛型参数与类的泛型参数没有任何关系。换句话说，泛型方法属于的类是不是泛型类都没有关系。</p>
<h4 id="②格式"><a href="#②格式" class="headerlink" title="②格式"></a>②格式</h4><p>​	在返回值类型前加上“<T>”即可。</p>
<h4 id="③使用"><a href="#③使用" class="headerlink" title="③使用"></a>③使用</h4><p>​	调用泛型方法时，往该泛型方法中传递的参数的类型决定了该泛型方法泛型的类型。</p>
<h4 id="④注意"><a href="#④注意" class="headerlink" title="④注意"></a>④注意</h4><p>​	泛型方法，可以声明为静态的。原因：泛型参数是在调用方法时确实的，并非在实例化时确定。</p>
<h3 id="F-泛型在继承方面的体现"><a href="#F-泛型在继承方面的体现" class="headerlink" title="F.泛型在继承方面的体现"></a>F.泛型在继承方面的体现</h3><p>①</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//虽然类A是类B的父类，但是G&lt;A&gt; 和 G&lt;B&gt;二者不具备字父类关系，二者是并列关系。G可以是任意的数据类型，如：集合</span></span><br><span class="line">ArrayList&lt;Person&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">ArrayList&lt;Man&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Man&gt;();</span><br><span class="line">list = list1;<span class="comment">//不具备子父类关系，不能相互赋值</span></span><br></pre></td></tr></table></figure>

<p>②</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类A是类B的父类父接口，A&lt;G&gt; 是 B&lt;G&gt;的父类或父接口，泛型的类型要一样</span></span><br><span class="line">HashSet&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">LinkedHashSet&lt;String&gt; set1 = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">set = set1;<span class="comment">//存在子父类关系，可以赋值</span></span><br></pre></td></tr></table></figure>



<h3 id="E-通配符的使用"><a href="#E-通配符的使用" class="headerlink" title="E.通配符的使用"></a>E.通配符的使用</h3><h4 id="①定义-1"><a href="#①定义-1" class="headerlink" title="①定义"></a>①定义</h4><p>​	通配符：?</p>
<p>类A是类B的父类，G&lt; A &gt; 和 G&lt; B &gt; 是并列关系，二者共同的父类是：G&lt; ? &gt;</p>
<h4 id="②应用例子"><a href="#②应用例子" class="headerlink" title="②应用例子"></a>②应用例子</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span>&#123;</span><br><span class="line">    ArrayList&lt;Person&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    ArrayList&lt;Man&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">12</span>));</span><br><span class="line">    printList(list);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历集合</span></span><br><span class="line"><span class="comment">//把ArrayList&lt;?&gt;替换为List&lt;?&gt;也行</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printList</span><span class="params">(ArrayList&lt;?&gt; list)</span>&#123;</span><br><span class="line">    Iterator&lt;?&gt; iterator = list.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="③使用-1"><a href="#③使用-1" class="headerlink" title="③使用"></a>③使用</h4><p>A.对于List&lt;?&gt;就不能向其内部添加数据，除了添加null之外。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;?&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list2.add(<span class="string">&quot;sf&quot;</span>);<span class="comment">//报错</span></span><br></pre></td></tr></table></figure>

<p>B.允许读取List&lt;?&gt;的对象list2中的元素，读取的数据类型为Object类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Person&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">12</span>));</span><br><span class="line">List&lt;?&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list2 = list;</span><br><span class="line">System.out.println(list2.get(<span class="number">0</span>));<span class="comment">//Person&#123;name=&#x27;Tom&#x27;, age=12&#125;</span></span><br></pre></td></tr></table></figure>



<h4 id="④有限制条件的通配符"><a href="#④有限制条件的通配符" class="headerlink" title="④有限制条件的通配符"></a>④有限制条件的通配符</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有限制条件的通配符：</span></span><br><span class="line">? <span class="keyword">extends</span> <span class="title class_">A</span></span><br><span class="line">? <span class="built_in">super</span> A</span><br></pre></td></tr></table></figure>

<p>G&lt;? extends A&gt; 可以作为G&lt; A &gt;和G&lt; B &gt;的父类，其中B是A的子类。extends相当于 “&lt;&#x3D;”，G为带泛型的任意一种数据类型，如：集合</p>
<p>G&lt;? superA&gt; 可以作为G&lt; A &gt;和G&lt; B &gt;的父类，，其中B是A的父类。super相当于 “&gt;&#x3D;”，G为带泛型的任意一种数据类型，如：集合</p>
<p><strong>A</strong>.对于G&lt;? extends A&gt;声明的对象，我们是可以获取该对象里的数据的，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Person&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">12</span>));</span><br><span class="line">List&lt;? <span class="keyword">extends</span> <span class="title class_">Person</span>&gt; list2 = <span class="literal">null</span>;</span><br><span class="line">list2 = list;</span><br><span class="line">System.out.println(list2.get(<span class="number">0</span>));<span class="comment">//Person&#123;name=&#x27;Tom&#x27;, age=12&#125;</span></span><br></pre></td></tr></table></figure>

<p>对于G&lt;? superA&gt; 声明的对象也一样可以获取该对象里的数据。</p>
<p><strong>B</strong>.</p>
<p>对于**G&lt;? extends A&gt;**声明的对象，我们不能对其进行添加数据操作，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Person&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">12</span>));</span><br><span class="line">List&lt;? <span class="keyword">extends</span> <span class="title class_">Person</span>&gt; list2 = <span class="literal">null</span>;</span><br><span class="line">list2 = list;</span><br><span class="line"><span class="comment">//报错</span></span><br><span class="line">list2.add();<span class="comment">//无论括号里放什么数据都会报错</span></span><br></pre></td></tr></table></figure>

<p>对于<strong>G&lt;? super A&gt;</strong> 声明的对象，我们可以对其进行添加数据的操作，但只能添加类A或类A的子类的数据，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Person&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;? <span class="built_in">super</span> Person&gt; list3 = <span class="literal">null</span>;</span><br><span class="line">list3 = list;</span><br><span class="line">list3.add(<span class="keyword">new</span> <span class="title class_">Man</span>());</span><br></pre></td></tr></table></figure>



<h4 id="⑤其他"><a href="#⑤其他" class="headerlink" title="⑤其他"></a>⑤其他</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &lt;T extend Person&gt;&#123;</span><br><span class="line">    T order;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里的T只能取Person类或Person类的子类</span></span><br><span class="line"><span class="comment">//如果Person是一个接口，那T只能是该接口的实现类</span></span><br></pre></td></tr></table></figure>



<hr>
<h2 id="7、IO流"><a href="#7、IO流" class="headerlink" title="7、IO流"></a>7、IO流</h2><h3 id="A-File类的使用"><a href="#A-File类的使用" class="headerlink" title="A.File类的使用"></a>A.File类的使用</h3><h4 id="①概述-3"><a href="#①概述-3" class="headerlink" title="①概述"></a>①概述</h4><ul>
<li>File类的一个对象，代表一个文件或一个文件目录（俗称：文件夹）</li>
<li>File类声明在java.io包下</li>
</ul>
<p>​	</p>
<h4 id="②预备知识"><a href="#②预备知识" class="headerlink" title="②预备知识"></a>②预备知识</h4><p>​	<strong>路径</strong>：</p>
<ul>
<li><p>相对路径：相较于某个路径下，指明的路径，如：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>绝对路径：包含盘符在内的文件或文件目录的路径</p>
</li>
</ul>
<p>说明：</p>
<ol>
<li><p><strong>IDEA</strong>中：如果大家开发使用JUnit中的单元测试方法测试，相对路径即为当前Module下。如果大家使用main()测试，相对路径即为当前的Project下。</p>
</li>
<li><p><strong>Eclipse</strong>中：不管使用单元测试方法还是使用mian()测试，相对路径都是当前的Project下。</p>
</li>
<li><p>如何准确的写出文件路径？</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.获取当前代码所在路径</span></span><br><span class="line">System.out.println(System.getProperty(<span class="string">&quot;user.dir&quot;</span>));</span><br><span class="line"><span class="comment">//2.打开显示的路径，在此路径下找到要找的文件</span></span><br><span class="line"><span class="comment">//3.复制找到文件的路径，但不包括1中显示的路径。</span></span><br><span class="line"><span class="comment">//4.完成</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>​	<strong>路径分隔符和系统的关系</strong></p>
<ul>
<li>windows和DOS系统默认使用“ \ ” 来表示</li>
<li>UNIX和URL使用“ &#x2F; ” 来表示</li>
<li>补充：Java中路径分隔符用两个 “ \ ” 表示，目的是区分Java中的转译符” \ “</li>
</ul>
<h4 id="③如何实例化"><a href="#③如何实例化" class="headerlink" title="③如何实例化"></a>③如何实例化</h4><p>​	有以下几种构造器：</p>
<p>​	A.<strong>File(String filePath)</strong></p>
<p>​		filePath：可以是相对路径，也可以是绝对路径</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(hello.txt);</span><br><span class="line"><span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(D:\\hello.txt);</span><br><span class="line"><span class="comment">//此时造了两个File对象，还没涉及到对文件进行操作，所以填入的文件不存在也没事。</span></span><br></pre></td></tr></table></figure>

<p>​	B.<strong>File(String parentPath,String childPath)</strong></p>
<p>​		parentPath：该文件或文件夹的上一级目录</p>
<p>​		childPath：该文件夹名或文件名</p>
<p>​	C.<strong>File(File parentFile,String childPath)</strong></p>
<p>​		parentFile：该文件或文件夹的上一级目录</p>
<p>​		childPath：该文件夹名或文件名</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\java\\exer&quot;</span>);</span><br><span class="line"><span class="type">File</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(f1,<span class="string">&quot;file.txt&quot;</span>);</span><br><span class="line"><span class="comment">//该file.txt文件的绝对路径为：D:\java\exer\file.txt</span></span><br></pre></td></tr></table></figure>



<h3 id="B-File类的常用方法"><a href="#B-File类的常用方法" class="headerlink" title="B.File类的常用方法"></a>B.File类的常用方法</h3><p>​	以下方法是内存层面的调用，还没涉及到硬盘层面的调用。</p>
<h4 id="①获取相应信息"><a href="#①获取相应信息" class="headerlink" title="①获取相应信息"></a>①获取相应信息</h4><ul>
<li><p>public String getAbsolutePath()：获取绝对路径</p>
</li>
<li><p><strong>public String getPath()</strong> ：获取路径，显示的是你声明对象时指明的路径</p>
</li>
<li><p><strong>public String getName()</strong> ：获取名称</p>
</li>
<li><p>**public String getParent()**：获取上层文件目录路径。若无，返回null</p>
</li>
<li><p><strong>public long length()</strong> ：获取文件长度（即：字节数）。不能获取目录的长度。 只有真实存在的文件才能获取到长度，不然返回默认值：0。</p>
</li>
<li><p><strong>public long lastModified()</strong> ：获取最后一次的修改时间，毫秒值。只有真实存在的文件或文件目录才返回相应的值，否则返回默认值：0。</p>
<p>  下面两个方法适用于文件目录：（<strong>且指定的目录要真实存在，不然报错</strong>）</p>
</li>
<li><p><strong>public String[] list()</strong> ：获取指定目录下的所有文件或者文件目录的名称数组</p>
</li>
<li><p><strong>public File[] listFiles()</strong> ：获取指定目录下的所有文件或者文件目录的File数组（绝对路径）</p>
</li>
</ul>
<h4 id="②重命名功能"><a href="#②重命名功能" class="headerlink" title="②重命名功能"></a>②重命名功能</h4><p>​	public boolean renameTo(File dest)：把文件重命名为指定的文件路径</p>
<p>​	比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"><span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\java\\hi.txt&quot;</span>);</span><br><span class="line">file1.renameTo(file2);</span><br><span class="line"><span class="comment">//要想保证返回true，需要file1在硬盘中是存在的，且file2不能在硬盘中存在</span></span><br></pre></td></tr></table></figure>

<p>​	<strong>说明</strong>：</p>
<ol>
<li>file1、file2中的路径是相对路径、还是绝对路径，都没有关系。</li>
<li>运行的效果是：根据file2的路径在硬盘中创建相应的文件，然后把hello.txt里的内容复制到file2的那个文件里，最后hello.txt文件被删除。</li>
</ol>
<h4 id="③判断功能"><a href="#③判断功能" class="headerlink" title="③判断功能"></a>③判断功能</h4><ul>
<li>public boolean isDirectory()：判断是否是文件目录</li>
<li><strong>public boolean isFile()</strong> ：判断是否是文件</li>
<li><strong>public boolean exists()</strong> ：判断硬盘上是否存在该文件或文件目录</li>
<li><strong>public boolean canRead()</strong> ：判断是否可读</li>
<li><strong>public boolean canWrite()</strong> ：判断是否可写</li>
<li><strong>public boolean isHidden()</strong> ：判断是否隐藏</li>
</ul>
<p>如果在硬盘中没有该文件或文件目录，这些方法都会返回默认值：false</p>
<h4 id="④在硬盘中创建对应的文件或文件目录"><a href="#④在硬盘中创建对应的文件或文件目录" class="headerlink" title="④在硬盘中创建对应的文件或文件目录"></a>④在硬盘中创建对应的文件或文件目录</h4><ul>
<li><strong>public boolean createNewFile()</strong> ：创建文件。若文件存在，则不创建，返回false。该方法本身会报异常，我们需要对其进行throws或try-catch-finally</li>
<li><strong>public boolean mkdir()</strong> ：创建文件目录。如果此文件目录存在，就不创建了。如果此文件目录的上层目录不存在，也不创建。 </li>
<li><strong>public boolean mkdirs()</strong> ：创建文件目录。如果上层文件目录不存在，一并创建。</li>
</ul>
<h4 id="⑤删除硬盘中的文件或文件目录"><a href="#⑤删除硬盘中的文件或文件目录" class="headerlink" title="⑤删除硬盘中的文件或文件目录"></a>⑤删除硬盘中的文件或文件目录</h4><ul>
<li>public boolean delete()：删除文件或者文件夹</li>
</ul>
<p>注意：Java中的删除不走回收站。 要删除一个文件目录，请注意该文件目录内不能包含文件或者文件目录。</p>
<h4 id="⑥总结"><a href="#⑥总结" class="headerlink" title="⑥总结"></a>⑥总结</h4><ol>
<li>File类中涉及到关于文件或文件目录的创建、删除、重命名、获取修改时间、获取文件大小等方法，并未涉及到写入或读取文件内容的操作。如果需要读取或写入文件内容，必须使用IO流来完成。</li>
<li>后续File类的对象常作为参数传递到流的构造器中，指明要读取或写入的文件。</li>
</ol>
<h3 id="C-IO流原理"><a href="#C-IO流原理" class="headerlink" title="C.IO流原理"></a>C.IO流原理</h3><h4 id="①概述-4"><a href="#①概述-4" class="headerlink" title="①概述"></a>①概述</h4><ul>
<li><p>I&#x2F;O即：Input&#x2F;Output。数据从一个地方传送到另一个地方，就形成数据流，但我们通常不叫数据流，而是叫I&#x2F;O流。</p>
</li>
<li><p>输入：读取外部数据（磁盘、光盘等存储设备的数据）到程序（内存）中。</p>
<p>  输出：将程序（内存）数据输出到磁盘、光盘等存储设备中。</p>
</li>
</ul>
<h4 id="②流的分类"><a href="#②流的分类" class="headerlink" title="②流的分类"></a>②流的分类</h4><ul>
<li><p>按操作数据单位不同分为：字节流(8 bit)，字符流(16 bit)。</p>
<ul>
<li>字节流：一个字节一个字节地存储数据，存的是二进制数据。适用于：非文本文件，如：照片、视频等。</li>
<li>字符流：读取的是一个一个字符（char），存的也是一个一个char(字符)，适用于从文本文件中读取数据。</li>
</ul>
</li>
<li><p>按数据流的流向不同分为：输入流，输出流。</p>
</li>
<li><p>按流的角色的不同分为：节点流，处理流。</p>
<ul>
<li>节点流：直接作用在文件上的流叫节点流，即：可以直接处理File对象的流。</li>
<li>处理流：作用在已有流基础上的流叫处理流</li>
</ul>
</li>
</ul>
<p><img src="/imgs/image-20230426182344717.png" alt="image-20230426182344717"></p>
<h4 id="③四个抽象基类"><a href="#③四个抽象基类" class="headerlink" title="③四个抽象基类"></a>③四个抽象基类</h4><p>​	Java的IO流共涉及40多个类，这些类都是从如下4个抽象基类派生的。（基类：基础类的意思）。</p>
<p>​	InputStream、OutputStream属于操作字节流的类，Reader、Writer属于操作字符流的类。</p>
<p><img src="/imgs/image-20230426182403777.png" alt="image-20230426182403777"></p>
<p>​	</p>
<h4 id="④IO流体系结构"><a href="#④IO流体系结构" class="headerlink" title="④IO流体系结构"></a>④IO流体系结构</h4><img src="/imgs/image-20230426182421252.png" alt="image-20230426182421252" style="zoom:80%;" />

<p>​	注：第二行中的流属于节点流，第二行及以后的流属于处理流。蓝色标注的流属于重点学习和掌握的。</p>
<p>​	简化版：</p>
<p><img src="/imgs/image-20230426182441435.png" alt="image-20230426182441435"></p>
<p>​	补充：除了RandomAccessFile不是由四个基类派生而来的，其他的流都是由四个派生基类继承来的。</p>
<h3 id="E-节点流的使用"><a href="#E-节点流的使用" class="headerlink" title="E.节点流的使用"></a>E.节点流的使用</h3><h4 id="①如何从硬盘读入数据"><a href="#①如何从硬盘读入数据" class="headerlink" title="①如何从硬盘读入数据"></a>①如何从硬盘读入数据</h4><p>​	<strong>实现步骤：</strong></p>
<p>​	(读数据和写数据的操作步骤都是下面的4步，由于使用的流不一样，步骤2会不同；是读还是写，导致步骤3不一样，其他地方都一样)</p>
<ol>
<li><p>造File类的对象，指明要操作的文件。文件一定要存在。</p>
</li>
<li><p>根据需要选择具体的流，然后造流的对象，File类的对象作为参数传到流的构造器中。</p>
</li>
<li><p>数据的读入，用流的对象取调用read方法。read()：返回读入的一个字符，如果到达文件末尾，返回-1。</p>
</li>
<li><p>流的关闭操作。流的对象调用close()方法</p>
<p> <strong>注意：</strong></p>
</li>
</ol>
<ul>
<li>造流的对象和调用read方法时，都会抛异常，因此需要用try-catach-finally来处理。用try将这些代码包起来。快捷键：选中需要抱起来的代码   –&gt; alt+shift+z –&gt; try-catch-finally</li>
<li>调用close()方法时，也会抛异常。首先将关闭流的操作放在finally里（因为流声明完，不再使用时，不关闭会出现内存泄漏，使用<strong>必须关闭</strong>），然后再将close操作用try-catch-finally包起来，最后在close这行代码的上面加上判断语句（判断当前流的对象是否为null）。</li>
<li>读入的文件一定要存在，否则就会报FileNotFoundException</li>
</ul>
<p>​	<strong>如何形象理解上面的三个实现步骤：</strong></p>
<p>​	比如我们需要从一个水池里取水，怎么取呢？首先我们得知道水池的位置（即造File对象的步骤），然后我们就要造水管了(即：造流的对象)，但水管具体要安装在哪，我们就需要把File类的对象传到流的构造器中告诉它水管安装在哪，然后就开闸放水（即调用read方法）。</p>
<h4 id="②读入：read方法"><a href="#②读入：read方法" class="headerlink" title="②读入：read方法"></a>②读入：read方法</h4><ol>
<li><code>read()</code>：每次读取一个char或一个byte数据，如果到达文件末尾，返回-1。</li>
<li><code>read(char[] a)</code> \ <code>read(byte[] a)</code>：将文件当中的内容读到数组a当中，每次读的长度为数组的长度，下一次读取时将原有的内容覆盖掉，而不是将数组中原有的内容先清除掉再添加。该方法返回的是，放入数组中字符\字节的个数，当返回-1时，代表读取完毕。<code>数组a的长度一般为1024</code>。如：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(file);</span><br><span class="line"><span class="type">char</span>[] a = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> length;</span><br><span class="line"><span class="keyword">while</span>((length = fr.read(a)) != -<span class="number">1</span>)&#123;<span class="comment">//read会抛异常，需要try-catch-finally，这里省略。</span></span><br><span class="line">    <span class="comment">//方式一：</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; length;i++)&#123;</span><br><span class="line">        System.out.print(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//方式二：</span></span><br><span class="line">    <span class="comment">//String str = new String(a,0,length);//从数组a的0索引处开始取length个数据</span></span><br><span class="line">    <span class="comment">//System.out.print(str);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="③从内存写入数据到硬盘"><a href="#③从内存写入数据到硬盘" class="headerlink" title="③从内存写入数据到硬盘"></a>③从内存写入数据到硬盘</h4><p>​	<strong>实现步骤</strong>：</p>
<ol>
<li>造File类的对象，指明要写入到的文件</li>
<li>根据需要选择具体的流，然后造流的对象，File类的对象作为参数传到流的构造器中。</li>
<li>数据的写入，用流的对象调用write()方法。</li>
<li>流的关闭操作。流的对象调用close()方法</li>
</ol>
<p>​	<strong>说明</strong>：</p>
<ul>
<li>输出操作，对应的File可以不存在。并不会报异常。File的上级目录一定要存在，不然报错。</li>
<li>File对应的硬盘中的文件如果不存在，在输出的过程中，会自动创建此文件。</li>
<li>File对应的硬盘中的文件如果存在：<ul>
<li>如果流使用的构造器是：FileWriter(file,false) &#x2F; FileWriter(file)：对原有文件的覆盖。 &#x2F;&#x2F;第2个参数是指是否能追加内容</li>
<li>如果流使用的构造器是：FileWriter(file,true)：不会对原有文件覆盖，而是在原有文件基础上追加内容。</li>
</ul>
</li>
</ul>
<h4 id="④写出：write方法"><a href="#④写出：write方法" class="headerlink" title="④写出：write方法"></a>④写出：write方法</h4><p>​	<code>write(String s)</code>：将字符串s写入到硬盘中</p>
<p>​	<code>write(char[] a,int index,length)</code>：从数组a中索引为index的位置开始取长度为：length的数据写入到硬盘中。</p>
<h4 id="⑤注意"><a href="#⑤注意" class="headerlink" title="⑤注意"></a>⑤注意</h4><ol>
<li>对于文本文件（.txt，.java，.c，.cpp），使用字符流（ Reader、Writer）处理。字符流不能处理字节数据。</li>
<li>）对于非文本文件（.jpg，.mp3，.mp4，.avi，.doc，.ppt，……）使用字节流（InputStream、OutputStream）处理。用字节流去实现文本文件的复制是没问题的，但在复制过程中对内容进行输出就可能出现乱码。</li>
</ol>
<h4 id="⑥补充"><a href="#⑥补充" class="headerlink" title="⑥补充"></a>⑥补充</h4><p>​	节点流的构造器除了有放File类对象的构造器，还有放String的构造器。</p>
<p>​	放String的构造器，以FileReader为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"><span class="comment">//传的是该文件的相对路径或绝对路径。</span></span><br><span class="line"><span class="comment">//这种声明方式实际上也是造了一个File类的对象，然后将此对象放到FileReader构造器中。</span></span><br></pre></td></tr></table></figure>



<h3 id="F-缓冲流"><a href="#F-缓冲流" class="headerlink" title="F. 缓冲流"></a>F. 缓冲流</h3><h4 id="①概述-5"><a href="#①概述-5" class="headerlink" title="①概述"></a>①概述</h4><p>​	缓冲流属于处理流的一种。处理流：对现有流进行包装的流，其作用在现有流上。</p>
<p>​	缓冲流：提高流的读写效率，开发中常用缓冲流。</p>
<p><img src="/imgs/image-20230426182510700.png" alt="image-20230426182510700"></p>
<h4 id="②缓冲流的使用"><a href="#②缓冲流的使用" class="headerlink" title="②缓冲流的使用"></a>②缓冲流的使用</h4><p>​	<strong>用缓冲流实现读写操作，实现步骤</strong>：</p>
<ol>
<li>造File类对象，指明要读入 (或写入)的文件</li>
<li>造相应的节点流的对象，把File类的对象作为参数传递到节点流的构造器中</li>
<li>根据节点流的类型选择对应的缓冲流并造其对象，把上面节点流的对象作为参数传递到缓冲流的构造器中。</li>
<li>用缓冲流的对象调用read()方法（或write()方法）。</li>
<li>流的关闭。要求：先关外层的流，再关内层的流。同一层的流，先关哪个都行。<ul>
<li>说明：关闭外层流的同时，内层流也会自动的进行关闭。关于内层流的关闭，我们可以省略。</li>
</ul>
</li>
</ol>
<p>​	注意：</p>
<ul>
<li>造流的对象、调用read()、调用write()都会抛异常，所以要用try-catch-finally来处理。将步骤1-4用try包起来。流的关闭操作放在finally里。</li>
</ul>
<p>​	<strong>以上实现步骤的形象理解</strong>：</p>
<p>​	我们需要从一个池子中快速地把水抽出来。首先，我们得知道水池的位置（即造File类的对象，指明池子的位置），然后由于缓冲流是作用在现有流的基础上，所以得造节点流的对象（就相当于造了根水管），接着把File类的对象传到节点流的构造器中（即指明水管安装的位置），再接着造缓冲流的对象（相当于弄了台增压水泵），把节点流的对象作为参数传递到缓冲流的构造器中（相当于告诉增压水泵安装到哪根水管）。这些步骤执行完后，用缓冲流的对象调用read()方法（或write()方法）。</p>
<h4 id="③readLine"><a href="#③readLine" class="headerlink" title="③readLine()"></a>③readLine()</h4><p>​	<strong>BufferedReader</strong>中提供了一个**readLine()**方法，该方法每次从文件中读取一行数据，并以String的形式返回。当读到文件末尾时，返回null。</p>
<p>​	注意：</p>
<ul>
<li>该方法提高流的对象调用</li>
<li>该方法返回的内容不包含换行符。如果想换行，可以用流的对象调用newLine()，实现换行操作。</li>
</ul>
<h4 id="④为什么缓冲流能提高速度"><a href="#④为什么缓冲流能提高速度" class="headerlink" title="④为什么缓冲流能提高速度"></a>④为什么缓冲流能提高速度</h4><p>​	缓冲流内部提供了一个大小为8192个字节（8kb）的缓冲区，每次从文件中读取的数据都会先放在缓冲区中，当存放的容量达到8192时，就会调用flush()方法将缓冲区中的内容写出到另一个文件并清空缓冲区。这样就减少了与文件的交互次数，从而提高了读写效率。</p>
<h3 id="G-转换流"><a href="#G-转换流" class="headerlink" title="G.转换流"></a>G.转换流</h3><h4 id="①概述-6"><a href="#①概述-6" class="headerlink" title="①概述"></a>①概述</h4><ul>
<li><p>转换流是处理流中的一种。</p>
</li>
<li><p>转换流：提供了在字节流和字符流之间的转换。</p>
</li>
<li><p>Java中提供了两个转换流：</p>
<ul>
<li>InputStreamReader：将一个字节的输入流转换为字符的输入流</li>
<li>OutputStreamWriter：将一个字符的输出流转换为字节的输出流</li>
<li>上面两个流属于字符流</li>
<li>这两个流<strong>只能操作文本文件。</strong></li>
</ul>
</li>
<li><p>解码：字节、字节数组 —&gt; 字符数组、字符串</p>
<p>  编码：字符数组、字符串 —&gt; 字节、字节数组</p>
</li>
</ul>
<h4 id="②InputStreamReader"><a href="#②InputStreamReader" class="headerlink" title="②InputStreamReader"></a>②InputStreamReader</h4><p>​	InputStreamReader的使用，实现了字节的输入流到字符的输入流的转换</p>
<p>​	</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;dbcp.txt&quot;</span>);</span><br><span class="line"><span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(fis);<span class="comment">//使用系统默认的字符集</span></span><br><span class="line"><span class="comment">//InputStreamReader isr = new InputStreamReader(fis,&quot;UTF-8&quot;);//参数2指明了字符集，集体使用哪个字符集，取决于文件dbcp.txt保存时使用的字符集</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>[] cbuf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"><span class="keyword">while</span>((len = isr.read(cbuf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(cbuf,<span class="number">0</span>,len);</span><br><span class="line">    System.out.print(str);</span><br><span class="line">&#125;</span><br><span class="line">isr.close();</span><br><span class="line"><span class="comment">//注意：此代码还没有用try-catch-finally进行异常处理</span></span><br></pre></td></tr></table></figure>



<h4 id="②OutputStreamWriter"><a href="#②OutputStreamWriter" class="headerlink" title="②OutputStreamWriter"></a>②OutputStreamWriter</h4><p><img src="/imgs/image-20230426182535497.png" alt="image-20230426182535497"></p>
<p>上述过程的代码实现：</p>
<p><img src="/imgs/image-20230426182551864.png" alt="image-20230426182551864"></p>
<p>​	注意：上面代码并没有用try-catch-finally处理异常，自己写的时候要补上。</p>
<h3 id="H-字符集"><a href="#H-字符集" class="headerlink" title="H.字符集"></a>H.字符集</h3><h4 id="①编码表"><a href="#①编码表" class="headerlink" title="①编码表"></a>①编码表</h4><p>​	计算机只能识别二进制数据，早期由来是电信号。为了方便应用计算机，让它可以识别各个国家的文字。就将各个国家的文字用数字来表示，并一一对应，形成一张表。这就是编码表。</p>
<h4 id="②常见编码表"><a href="#②常见编码表" class="headerlink" title="②常见编码表"></a>②常见编码表</h4><ul>
<li>ASCII：美国标准信息交换码。 用一个字节的7位可以表示。</li>
<li>ISO8859-1：拉丁码表。欧洲码表用一个字节的8位表示。</li>
<li>GB2312：中国的中文编码表。最多两个字节编码所有字符。兼容了ASCII，因为ASCII用一个字节就可以表示，不用用两个字节表示，这样可以节省空间。<ul>
<li>那怎么识别是一个字节表示一个字符还是两个字节表示一个字符呢？看字节中最左边的那位，如果是1，则表示它还有一个字节，即两个字节表示一个字符；如果是0，则一个字节表示一个字符。GBK也采用这种方式识别。</li>
</ul>
</li>
<li>GBK：中国的中文编码表升级，融合了更多的中文文字符号。最多两个字节编码。兼容了ASCII。</li>
<li>Unicode：国际标准码，融合了目前人类使用的所有字符。为每个字符分配唯一的字符码。所有的文字都用两个字节来表示。</li>
<li>UTF-8：变长的编码方式，可用1-4个字节来表示一个字符。（中文用3个字节存储。）UTF-8是Unicode的一种具体实现。</li>
</ul>
<h4 id="③启示"><a href="#③启示" class="headerlink" title="③启示"></a>③启示</h4><p>​	客户端、浏览器  &lt;—&gt; 后台 &lt;—-&gt; 数据库</p>
<p>​	为了保证不乱码，这三个部分都要统一字符集。 </p>
<h3 id="I-标准输入、输出流-了解"><a href="#I-标准输入、输出流-了解" class="headerlink" title="I.标准输入、输出流(了解)"></a>I.标准输入、输出流(了解)</h3><ul>
<li>标准输入、输出流是处理流中的一种。</li>
<li>in、out是System里的两个属性。</li>
<li>System.in和System.out分别代表了系统标准的输入和输出。</li>
<li>System.in：默认从键盘输入，字节流；System.out：默认从控制台（显示器）输出。</li>
<li>通过System类的setIn(InputStream is)，setOut(PrintStream ps)方法重新指定输入和输出的流。PrintStream是OutputStream的子类。</li>
</ul>
<h3 id="J-打印流-了解"><a href="#J-打印流-了解" class="headerlink" title="J.打印流(了解)"></a>J.打印流(了解)</h3><ul>
<li>打印流是处理流中的一种。</li>
<li>实现将基本数据类型的数据格式转化为字符串输出。</li>
<li>打印流：PrintStream（字节输出流）和PrintWriter（字符输出流）。</li>
<li>它们提供了一系列重载的print()和println()方法，用于多种数据类型的输出。为什么我们能通过print()就能接收不同类型的数据并输出，是因为调用了PrintStream中重载的print \ println方法。</li>
<li>System.out返回的是PrintStream的实例</li>
</ul>
<h4 id="①把控制台中输出的内容保存到文件"><a href="#①把控制台中输出的内容保存到文件" class="headerlink" title="①把控制台中输出的内容保存到文件"></a>①把控制台中输出的内容保存到文件</h4><p>​	步骤：</p>
<ol>
<li>创建FileOutputStream的对象，构造器中放File类的对象或直接放文件的路径。（指明要写入的文件）</li>
<li>因为打印流属于处理流，创建PrintStream类的对象时，将FileOutputStream的对象放进去构造器中。</li>
<li>用 if 判断打印流的对象是否为null，不为null，则System.setOut(打印流对象);</li>
<li>接下来写你想写的内容。</li>
<li>流的关闭操作。</li>
</ol>
<p>注意：要用try-catch-finally将1-4包起来</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">PrintStream</span> <span class="variable">pw</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;h.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//指明写入到的文件</span></span><br><span class="line">        pw = <span class="keyword">new</span> <span class="title class_">PrintStream</span>(fr,<span class="literal">true</span>);</span><br><span class="line">  <span class="comment">//创建打印输出流，设置为自动刷新模式（写入换行或&#x27;\n&#x27;时都会刷新输出缓冲区）</span></span><br><span class="line">        <span class="keyword">if</span> (pw != <span class="literal">null</span>)&#123;</span><br><span class="line">            System.setOut(pw);</span><br><span class="line">            <span class="comment">//把标准输出流（控制台输出）改成输出到指定文件</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="number">123</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pw != <span class="literal">null</span>)</span><br><span class="line">            pw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="K-数据流-了解"><a href="#K-数据流-了解" class="headerlink" title="K.数据流(了解)"></a>K.数据流(了解)</h3><h4 id="①概述-7"><a href="#①概述-7" class="headerlink" title="①概述"></a>①概述</h4><ul>
<li>数据流属于处理流的一种。</li>
<li>数据流：DataInputStream 和 DataOutputStream</li>
<li>分别“套接”在 InputStream 和 OutputStream 子类的流上。</li>
<li>数据流的作用：读取或写出基本数据类型的变量或字符串</li>
</ul>
<h4 id="②数据流中的方法"><a href="#②数据流中的方法" class="headerlink" title="②数据流中的方法"></a>②数据流中的方法</h4><p><img src="/imgs/image-20230426182615099.png" alt="image-20230426182615099"></p>
<h4 id="③数据流的使用"><a href="#③数据流的使用" class="headerlink" title="③数据流的使用"></a>③数据流的使用</h4><p>​	练习：将内存中的字符串、基本数据类型的变量写出到文件中。</p>
<p>​	注意：下面代码中并没用try-catch-finally对异常进行处理，写的时候要补上。</p>
<p>​				打开写出的数据文件，里面乱码是正常的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//1.创建数据流的对象，DataOutputStream的构造器需要传一个OutputStream子类的对象</span></span><br><span class="line">    <span class="type">DataOutputStream</span> <span class="variable">dis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;data.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.写入操作</span></span><br><span class="line">    dis.writeUTF(<span class="string">&quot;Tom&quot;</span>);<span class="comment">//writeUTF(String s):写入字符串</span></span><br><span class="line">    dis.flush();<span class="comment">//调用flush()将内存中的数据写入到文件中</span></span><br><span class="line">    dis.writeInt(<span class="number">12</span>);</span><br><span class="line">    dis.flush();</span><br><span class="line">    dis.writeBoolean(<span class="literal">true</span>);</span><br><span class="line">    dis.flush();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//流的关闭</span></span><br><span class="line">    dis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	</p>
<p>​	练习：将文件中存储的基本数据类型变量和字符串读取到内存中，然后再保存在变量中。</p>
<p>​	注意：面代码中并没用try-catch-finally对异常进行处理，写的时候要补上。</p>
<p>​				读数据的时候要与写数据时的顺序一样，不然报异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//1.造数据流的对象，其构造器中需要出入InputStream子类的对象</span></span><br><span class="line">    <span class="type">DataInputStream</span> <span class="variable">dis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;data.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.写数据的操作</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> dis.readUTF();</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> dis.readInt();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">c</span> <span class="operator">=</span> dis.readBoolean();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;name:&quot;</span> + s + <span class="string">&quot;ID:&quot;</span> + i + <span class="string">&quot;是否男&quot;</span> + c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.流的关闭</span></span><br><span class="line">    dis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="L-对象流"><a href="#L-对象流" class="headerlink" title="L.对象流"></a>L.对象流</h3><h4 id="①概述-8"><a href="#①概述-8" class="headerlink" title="①概述"></a>①概述</h4><p>​	<strong>对象流</strong>：用于存储和读取<strong>基本数据类型</strong>数据或<strong>对象</strong>的处理流。它的强大之处是可以把Java中的对象写入到数据源（如：文件）中，也能把对象从数据源中还原回来。</p>
<p>​	<strong>序列化</strong>：将内存中的Java对象保存到磁盘中或通过网络传输出去。使用ObjectOutputStream实现</p>
<p>​	<strong>逆序列化</strong>：将磁盘文件中的对象还原为内存中的一个Java对象。使用ObjectInputStream实现</p>
<p>​	<strong>对象流</strong>：<strong>ObjectInputStream</strong>、<strong>ObjectOutputStream</strong>，属于处理流的一种</p>
<p>​	<strong>对象能序列化、逆序列化的前提是其所在类必须是可序列化的。</strong></p>
<p>​	</p>
<h4 id="②对象序列化机制"><a href="#②对象序列化机制" class="headerlink" title="②对象序列化机制"></a>②对象序列化机制</h4><p>​	允许把内存中的Java对象转换成平台无关的二进制流，从而允许把这种二进制流持久地保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点（序列化）。当其它程序获取了这种二进制流，就可以恢复成原来的Java对象（逆序列化）。</p>
<p>​	实际上对象序列化机制就是描述了一下序列化和逆序列化。</p>
<h4 id="③对象流的使用"><a href="#③对象流的使用" class="headerlink" title="③对象流的使用"></a>③对象流的使用</h4><p>​	A.ObjectOutputStream的使用</p>
<p>​	实现步骤：</p>
<ol>
<li><p>造ObjectOutputStream对象。</p>
<p> 但该构造器需要传OutputStream的子类，因此造FileOutputStream的对象放进去。将要写入的文件放到FileOutputStream构造器中。</p>
</li>
<li><p>调用writeObject(要写入的对象)，将对象写入文件中</p>
</li>
<li><p>流的关闭</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.造ObjectOutputStream对象</span></span><br><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;object.dat&quot;</span>));</span><br><span class="line"><span class="comment">//2.写入数据</span></span><br><span class="line">oos.writeObject(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;123&quot;</span>));</span><br><span class="line">oos.flush();</span><br><span class="line"><span class="comment">//关闭流</span></span><br><span class="line">oos.close();</span><br></pre></td></tr></table></figure>

<p>注意：上面代码存在异常，需要try-catch-finally进行异常处理</p>
<p>​	B.ObjectInputStream的使用</p>
<p>​	实现步骤：</p>
<ol>
<li><p>造ObjectInputStream对象。</p>
<p> 但该构造器需要传InputStream的子类，因此造FileInputStream的对象放进去。将要读入的文件放到FileInputStream构造器中。</p>
</li>
<li><p>调用readObject()，从文件中读取对象</p>
</li>
<li><p>流的关闭</p>
</li>
</ol>
<p>​	注意：上面代码存在异常，需要try-catch-finally进行异常处理</p>
<h4 id="④自定义类可序列化"><a href="#④自定义类可序列化" class="headerlink" title="④自定义类可序列化"></a>④自定义类可序列化</h4><p>​	要想自定义类能够保存在磁盘或从磁盘读出到内存，该对象所在类必须是可序列化的。具体实现步骤为：</p>
<ol>
<li><p>需要实现接口：Serializable</p>
</li>
<li><p>当前类提供一个全局常量：serialVersionUID，该常量为Long型，值可以为随意的一个值。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1234567L</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>除当前类需要实现Serializable接口外，还必须保证其内部所有属性也是可序列化的。（基本数据类型、String：本身就已经是可序列化）</p>
</li>
<li><p>补充：ObjectOutputStream和ObjectInputStream不能序列化static和transient修饰的成员变量。即：被这两个关键字修饰的属性其值是不能被保存到文件中的，当我们用ObjectInputStream去读这些属性时，读出来的是默认值。</p>
</li>
</ol>
<p>​	为什么需要serialVersionUID？用于表识该对象属于哪个类。如果没有显示使用serialVersionUID，系统会根据类中的细节自动生成一个serialVersionUID，序列化的时候就把当时的serialVersionUID也存到磁盘中了；逆序列化的时候就拿着这个serialVersionUID去比对，如果修改了当前类的内容，类的serialVersionUID就会发生改变，此时对象中的serialVersionUID与类的serialVersionUID就对不上了，就会导致对象还原不回去。因此我们需要显示指明serialVersionUID。</p>
<hr>
<h3 id="M-随机存取文件流（了解）"><a href="#M-随机存取文件流（了解）" class="headerlink" title="M.随机存取文件流（了解）"></a>M.随机存取文件流（了解）</h3><h4 id="①概述-9"><a href="#①概述-9" class="headerlink" title="①概述"></a>①概述</h4><ul>
<li>RandomAccessFile直接继承于Java.lang.Object类，它没有继承那四个抽象基类。</li>
<li>RandomAccessFile实现了DataInput、DataOutput这两个接口，因此它既可以作为一个输入流，又可以作为一个输出流。</li>
</ul>
<h4 id="②RandomAccessFile的使用"><a href="#②RandomAccessFile的使用" class="headerlink" title="②RandomAccessFile的使用"></a>②RandomAccessFile的使用</h4><p>​	<strong>构造器</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">RandomAccessFile</span><span class="params">(File file,String mode)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">RandomAccessFile</span><span class="params">(String name,String mode)</span></span><br><span class="line"><span class="comment">//name:指明要写入或读入的文件，可以写文件的相对路径或文件的绝对路径（其本质上还是造了一个File类的对象）</span></span><br><span class="line"><span class="comment">//mode:指定RandomAccessFile的访问模式：见下图，普通的写操作选rw就行</span></span><br></pre></td></tr></table></figure>

<p><img src="/imgs/image-20230426182644414.png" alt="image-20230426182644414"></p>
<p>​	使用例子：（注：下面代码没有用try-catch-finally对异常进行处理，写的时候要补上）</p>
<p><img src="/imgs/image-20230426182717471.png" alt="image-20230426182717471"></p>
<p>​	虽然此类既可以是输入流，也可以是输出流。对于读写操作，我们还是得造两个对象来分别处理读操作、写操作。</p>
<h4 id="③说明"><a href="#③说明" class="headerlink" title="③说明"></a>③说明</h4><ul>
<li>进行写出操作时，如果该文件不存在，就会造一个新的文件。<ul>
<li>如果文件存在，则会对原有文件内容进行覆盖。（默认情况下，从头覆盖）</li>
</ul>
</li>
<li>write()：该方法实现的效果为对文件内容的覆盖（在文件原本存在的情况下）</li>
</ul>
<h4 id="④方法"><a href="#④方法" class="headerlink" title="④方法"></a>④方法</h4><ol>
<li>seek(long pos)：该方法的作用是将指针调到文件中角标为pos的位置，角标从0开始。</li>
</ol>
<p>  <img src="/imgs/image-20230426182749614.png" alt="image-20230426182749614"></p>
<p>  从角标为3的位置开始对文件内容进行覆盖。</p>
<p>  如果想在文件末尾进行添加数据，则将pos设置为当前文件的大小（调用File类中的length方法即可），再使用write方法。</p>
<h4 id="⑤应用"><a href="#⑤应用" class="headerlink" title="⑤应用"></a>⑤应用</h4><p>​	该类可应用于文件的断点续传操作。</p>
<h3 id="N-NIO-2中Path、Paths、Files类的使用（了解）"><a href="#N-NIO-2中Path、Paths、Files类的使用（了解）" class="headerlink" title="N.NIO.2中Path、Paths、Files类的使用（了解）"></a>N.NIO.2中Path、Paths、Files类的使用（了解）</h3><h4 id="①理解-1"><a href="#①理解-1" class="headerlink" title="①理解"></a>①理解</h4><ul>
<li>Java NIO (New IO，Non-Blocking IO)是从Java 1.4版本开始引入的一套新的IO API，可以替代标准</li>
<li>Java IO API。NIO与原来的IO有同样的作用和目的，但是使用的方式完全不同，NIO支持面向缓冲区的(IO是面向流的)、基于通道的IO操作。NIO将以更加高效的方式进行文件的读写操作。</li>
<li>随着 JDK 7 的发布，Java对NIO进行了极大的扩展，增强了对文件处理和文件系统特性的支持，以至于我们称他们为 NIO.2。</li>
</ul>
<h4 id="②Path"><a href="#②Path" class="headerlink" title="②Path"></a>②Path</h4><p>​	<strong>引入</strong>：</p>
<p>​	早期的Java只提供了一个File类来访问文件系统，但File类的功能比较有限，所提供的方法性能也不高。而且，大多数方法在出错时仅返回失败，并不会提供异常信息。NIO. 2为了弥补这种不足，引入了Path接口。<strong>实际上，Path可以看成是File类的升级版本，实际引用的资源也可以不存在。</strong></p>
<p><img src="/imgs/image-20230426182811781.png" alt="image-20230426182811781"></p>
<p>​	Path中的常用方法：</p>
<p><img src="/imgs/image-20230426182830615.png" alt="image-20230426182830615"></p>
<h4 id="③Paths"><a href="#③Paths" class="headerlink" title="③Paths"></a>③Paths</h4><p>​	Paths是一个类，用于创建Path对象的。</p>
<p>​	Paths类提供的静态get()方法用来获取Path对象</p>
<p><img src="/imgs/image-20230426182845928.png" alt="image-20230426182845928"></p>
<h4 id="④Files"><a href="#④Files" class="headerlink" title="④Files"></a>④Files</h4><p>​	用于操作文件或文件目录的工具类	</p>
<p>​	常用方法：</p>
<p><img src="/imgs/image-20230426182914902.png" alt="image-20230426182914902"></p>
<p><img src="/imgs/image-20230426182927164.png" alt="image-20230426182927164"></p>
<h3 id="O-ByteArrayOutputStream"><a href="#O-ByteArrayOutputStream" class="headerlink" title="O.ByteArrayOutputStream"></a>O.ByteArrayOutputStream</h3><h4 id="①概述-10"><a href="#①概述-10" class="headerlink" title="①概述"></a>①概述</h4><p>​	该流可用于存储字节流数据，并将字符流数据保存到 byte[ ] 数组中。如：</p>
<h4 id="②toString"><a href="#②toString" class="headerlink" title="②toString()"></a>②toString()</h4><p>​	该方法可以将ByteArrayOutputStream底层中的 byte[ ] 转换为字符串</p>
<h4 id="③getBytes"><a href="#③getBytes" class="headerlink" title="③getBytes()"></a>③getBytes()</h4><p>​	该方法属于String类中的方法，可以将字符串转换为一个byte数组</p>
<h4 id="④例子"><a href="#④例子" class="headerlink" title="④例子"></a>④例子</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//h.txt文件中存放了abc,现在想将此文件中的英文字母全转为大写再输出到文件uph.txt中</span></span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;h.txt&quot;</span>);</span><br><span class="line"><span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line"><span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造器不需要形参</span></span><br><span class="line"><span class="keyword">while</span>((len = fis.read(buffer)) != <span class="literal">null</span>)&#123;</span><br><span class="line">    baos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">toUpperCase</span> <span class="operator">=</span> baos.toString().toUpperCase();</span><br><span class="line"></span><br><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;uph.txt&quot;</span>);</span><br><span class="line"><span class="comment">//因为fos属于字节流，只能向里面添加字节流数据，因此需要将字符串转换为byte数组再写入到文件中</span></span><br><span class="line">fos.write(toUpperCase.getBytes());</span><br></pre></td></tr></table></figure>



<h2 id="8、网络编程"><a href="#8、网络编程" class="headerlink" title="8、网络编程"></a>8、网络编程</h2><h3 id="①网络编程概述"><a href="#①网络编程概述" class="headerlink" title="①网络编程概述"></a>①网络编程概述</h3><h4 id="A-网络编程的目的"><a href="#A-网络编程的目的" class="headerlink" title="A.网络编程的目的"></a>A.网络编程的目的</h4><ul>
<li>直接或间接地通过网络协议与其它计算机实现数据交换，进行通讯。</li>
</ul>
<h4 id="B-网络编程中有两个主要的问题"><a href="#B-网络编程中有两个主要的问题" class="headerlink" title="B.网络编程中有两个主要的问题"></a>B.网络编程中有两个主要的问题</h4><ol>
<li><p>如何准确地定位网络上一台或多台主机；定位主机上的特定的应用。</p>
<ul>
<li>IP：区分主机。</li>
<li>端口号：区分一个主机上不同的应用程序。</li>
</ul>
</li>
<li><p>找到主机后如何可靠高效地进行数据传输。</p>
<p> 一定的规则（即网络通信协议，有两套参考模型）：</p>
<ul>
<li>OSI参考模型：模型过于理想化，未能在因特网上广泛推广。</li>
<li>TCP&#x2F;IP参考模型：事实上的国际标准。</li>
</ul>
<p> <img src="/imgs/image-20230426182951359.png" alt="image-20230426182951359"></p>
<p> 层与层之间是可以进行数据传输的，如：</p>
</li>
</ol>
<p><img src="/imgs/image-20230426183009751.png" alt="image-20230426183009751"></p>
<p>​	</p>
<h4 id="C-通信要素1–IP和端口号"><a href="#C-通信要素1–IP和端口号" class="headerlink" title="C.通信要素1–IP和端口号"></a>C.通信要素1–IP和端口号</h4><p>​	<strong>IP</strong>：</p>
<ul>
<li><p>Java中用InetAddress类来表示IP，一个具体的InetAddress对象就是一个具体的IP地址。</p>
</li>
<li><p>IP分类：IPV4 和 IPV6；公网地址(万维网使用)和私有地址(局域网使用)</p>
</li>
<li><p>域名：如：<code>www.baidu.com</code>、<code>www.vip.com</code>等，本质上对应着一个IP地址。</p>
<ul>
<li>当我们在网站中输入一个域名时，先会去找主机host下是否有这个域名存在，没有则发送给域名解析服务器（DNS），让其解析域名并向主机返回该域名对应的IP地址，主机就拿着这个IP地址去访问相应的网站了。</li>
</ul>
</li>
<li><p>本机IP地址：127.0.0.1 ；对应的域名为：Localhost</p>
</li>
<li><p>实例化 InetAddress 两个方法：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.getByName（String host）</span></span><br><span class="line"><span class="type">InetAddress</span> <span class="variable">inet</span> <span class="operator">=</span> InetAddress.getByName(String host);<span class="comment">//返回的是对应域名或IP的对象。注意：该方法会抛异常，我们需要try-catch-finally</span></span><br><span class="line"><span class="comment">//host可以是具体的一个IP地址或域名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.getLocalHost（）</span></span><br><span class="line"><span class="type">InetAddress</span> <span class="variable">inet1</span> <span class="operator">=</span> InetAddress.getLocalHost();<span class="comment">//获取本机的IP地址</span></span><br></pre></td></tr></table></figure>

<p>  两个常用方法：获取域名getHostName()，获取IP地址getHostAddress()</p>
</li>
</ul>
<p>​	<strong>端口号</strong>：</p>
<ul>
<li>端口号用来标识正在计算机上运行的进程（程序）；不同的进程有不同的端口号。被规定为一个 16 位的整数 0~65535。</li>
<li>端口号分类（了解）<ul>
<li>公认端口：0~1023。被预先定义的服务通信占用（如：HTTP占用端口80，FTP占用端口21，Telnet占用端口23）</li>
<li>注册端口：1024~49151。分配给用户进程或应用程序。（如：Tomcat占用端口8080，MySQL占用端口3306，Oracle占用端口1521等）。</li>
<li>动态&#x2F;私有端口：49152~65535。</li>
</ul>
</li>
<li>端口号与IP地址的组合得出一个网络套接字：Socket。</li>
</ul>
<h4 id="D-通信要素2–网络协议"><a href="#D-通信要素2–网络协议" class="headerlink" title="D.通信要素2–网络协议"></a>D.通信要素2–网络协议</h4><p>​	<strong>引入</strong>：我们知道了IP和端口号后，就可以进行数据传输了，但怎么传涉及到了网络协议。</p>
<p>​	<strong>TCP</strong></p>
<ul>
<li><p>使用TCP协议前，须先建立TCP连接，形成传输数据通道。</p>
</li>
<li><p>传输前，采用“三次握手”方式，点对点通信，是可靠的。</p>
</li>
<li><p>TCP协议进行通信的两个应用进程：客户端、服务端。</p>
</li>
<li><p>在连接中可进行大数据量的传输。</p>
</li>
<li><p>传输完毕，需释放已建立的连接，效率低（相较于UDP）。</p>
</li>
<li><p><strong>三次握手</strong></p>
<p>  <img src="/imgs/image-20230426183031938.png" alt="image-20230426183031938"></p>
<p>  形象理解：<br>  A：你在吗，我是A<br>  B：我在呢，我是B<br>  A：你在就行跟你说个事，我是A</p>
<ul>
<li><strong>四次挥手</strong></li>
</ul>
</li>
</ul>
<p><img src="/imgs/image-20230426183107420.png" alt="image-20230426183107420"></p>
<p>​	“四次挥手”即终止TCP连接。</p>
<p>​		形象理解：像结婚要双方同意才可以。A向B请求断开连接，B反馈。B再向A请求断开连接，A再反馈。两方都断开才是真正的断开。</p>
<p>​	<strong>UDP</strong>：</p>
<ul>
<li>将数据、源、目的封装成数据包，<strong>不需要建立连接</strong>。</li>
<li>每个数据报的大小限制在64K内 。数据比较大时，需要分多个包发送。</li>
<li>发送不管对方是否准备好，接收方收到也不确认，故是<strong>不可靠</strong>的。</li>
<li>发送数据结束时无需释放资源，开销小，速度快。</li>
</ul>
<h3 id="②TCP网络编程"><a href="#②TCP网络编程" class="headerlink" title="②TCP网络编程"></a>②TCP网络编程</h3><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><ul>
<li>创建Socket对象，指明服务器端的IP和端口号。</li>
<li>用Socket对象调用getOutputStream()方法，获取一个输出流。用于给客户端发送信息。</li>
<li>拿着输出流调用write()进行数据输出操作。</li>
<li>Socket、流的关闭。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">client</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//1.创建Socket对象，指明服务器端的IP与端口号</span></span><br><span class="line">	<span class="type">InetAddress</span> <span class="variable">inet</span> <span class="operator">=</span>InetAddress.getByName(<span class="string">&quot;127.0.0.1);//服务端的IP地址</span></span><br><span class="line"><span class="string">	Socket socket=new Socket(inet,8899);//端口号8899</span></span><br><span class="line"><span class="string">	</span></span><br><span class="line"><span class="string">//2.获取一个输出流，用于输出数据</span></span><br><span class="line"><span class="string">	OutputStream os=socket.getOutputStream();</span></span><br><span class="line"><span class="string">	</span></span><br><span class="line"><span class="string">//3.写出数据</span></span><br><span class="line"><span class="string">	os.write(&quot;</span>你好，我是客户端<span class="string">&quot;);</span></span><br><span class="line"><span class="string">	</span></span><br><span class="line"><span class="string">//4.资源关闭</span></span><br><span class="line"><span class="string">	os.close();</span></span><br><span class="line"><span class="string">	socket.close();</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>​	注意：上面代码存在异常，需要用try-catch-finally对其进行异常处理</p>
<h4 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h4><ul>
<li>创建服务器端的ServerSocket，指明服务器的端口号。</li>
<li>用上面创建的对象去调用accept()，接收来自客户端的socket。</li>
<li>用获取到的socket对象去调用getInputStream()，获取输入流。</li>
<li>用流的对象去调用read()方法，进行相应的读操作。</li>
<li>关闭ServerSocket、socket、流</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务端</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">server</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//1.创建Socket对象，指明自己的端口号</span></span><br><span class="line">	ServerSocket s=<span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8899</span>);</span><br><span class="line"><span class="comment">//2.调用accept()表示接收来自于客户端的socket</span></span><br><span class="line">	Socket socket=s.acept();</span><br><span class="line"><span class="comment">//3.获取输入流</span></span><br><span class="line">	InputStream is=socket.getInputStream();</span><br><span class="line">	</span><br><span class="line"><span class="comment">//不建议这样写，一个中文3个字节，5太小，两个中文时，第二个字被分开存会出现乱码</span></span><br><span class="line">	<span class="comment">/*byte[] buffer=new byte[5];</span></span><br><span class="line"><span class="comment">	int len;</span></span><br><span class="line"><span class="comment">	while((len=is.read(buffer))!=-1)</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		String str=new String(buffer,0,len);</span></span><br><span class="line"><span class="comment">		System.out.print(str);</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"><span class="comment">//建议如下写：</span></span><br><span class="line"><span class="comment">//4.读取输入流中的数据</span></span><br><span class="line">	ByteArrayOutputStream baos=<span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();<span class="comment">//这时写入的内容在ByteArrayOutputStream的数组里，不会每5个就还原，而是等所有的输完后整体转换，所以不会出现乱码。</span></span><br><span class="line">	<span class="type">byte</span>[] buffer=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span>];</span><br><span class="line">	<span class="type">int</span> len;</span><br><span class="line">	<span class="keyword">while</span>((len=is.read(buffer))!=-<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		baos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.print(baos.toString());</span><br><span class="line">	</span><br><span class="line"><span class="comment">//5.资源关闭</span></span><br><span class="line">	baos.close();</span><br><span class="line">	is.close();</span><br><span class="line">	socket.close();</span><br><span class="line">	ss.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	上面代码会抛异常，我们需要用try把除关闭操作外的代码包起来，将关闭操作的代码放到finally里。</p>
<h3 id="③UDP网络编程（了解）"><a href="#③UDP网络编程（了解）" class="headerlink" title="③UDP网络编程（了解）"></a>③UDP网络编程（了解）</h3><p>（1）类 DatagramSocket 和 DatagramPacket 实现了基于 UDP 协议网络程序。</p>
<p>（2）UDP数据报通过数据报套接字 DatagramSocket 发送和接收，系统不保证UDP数据报一定能够安全送到目的地，也不能确定什么时候可以抵达。</p>
<p>（3）DatagramPacket 对象封装了UDP数据报，在数据报中包含了发送端的IP地址和端口号以及接收端的IP地址和端口号。</p>
<p>（4）UDP协议中每个数据报都给出了完整的地址信息，因此无须建立发送方和接收方的连接。如同发快递包裹一样。</p>
<h3 id="④URL编程"><a href="#④URL编程" class="headerlink" title="④URL编程"></a>④URL编程</h3><h4 id="A-URL"><a href="#A-URL" class="headerlink" title="A.URL"></a>A.URL</h4><p>​	<strong>URL</strong>：统一资源定位符，它表示 Internet 上某一资源的地址。</p>
<p>​	<strong>URL的基本结构由5部分组成</strong>：&lt;传输协议&gt;:&#x2F;&#x2F;&lt;主机名&gt;:&lt;端口号&gt;&#x2F;&lt;文件名&gt;#片段名?参数列表   </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/examples/beauty.jpg?usernam=Tom</span><br><span class="line">协议   主机名    端口号 资源地址            参数列表 </span><br><span class="line">主机名：相当于IP </span><br></pre></td></tr></table></figure>

<p>​	</p>
<h4 id="B-实例化URL对象"><a href="#B-实例化URL对象" class="headerlink" title="B.实例化URL对象"></a>B.实例化URL对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://localhost:8080/examples/beauty.jpg?usernam=Tom&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="C-常用方法"><a href="#C-常用方法" class="headerlink" title="C.常用方法"></a>C.常用方法</h4><p><img src="/imgs/image-20230426183516989.png" alt="image-20230426183516989"></p>
<h4 id="D-用于"><a href="#D-用于" class="headerlink" title="D.用于"></a>D.用于</h4><p>编程实现对网络资源的获取并进行保存</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://localhost:8080/examples/beauty.jpg?usernam=Tom&quot;</span>);</span><br><span class="line">        <span class="comment">//下面两行代码获取与服务器的连接</span></span><br><span class="line">        <span class="type">HttpURLConnection</span> <span class="variable">connection</span> <span class="operator">=</span> (HttpURLConnection) url.openConnection();</span><br><span class="line">        connection.connect();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取到连接后就可以将网站中的资源读取进来了</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">stream</span> <span class="operator">=</span> connection.getInputStream();</span><br><span class="line">        <span class="comment">//下面就是对流的读取操作（略）</span></span><br><span class="line">        <span class="comment">//关闭流</span></span><br><span class="line">	<span class="comment">//关闭与服务器的连接</span></span><br><span class="line">        connection.disconnection();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	上面代码要用try-catch-finally进行处理</p>
<h2 id="9、反射"><a href="#9、反射" class="headerlink" title="9、反射"></a>9、反射</h2><p>本节重点：红色字部分+笔记⑤体会反射的动态性+笔记⑦调用运行时类的指定结构+笔记⑥中的重点关注</p>
<p><img src="/imgs/image-20230426183538459.png" alt="image-20230426183538459"></p>
<h3 id="①引入"><a href="#①引入" class="headerlink" title="①引入"></a>①引入</h3><p>​	后端运行起来后，当前端发送一个登录操作的URL给后端时，后端就会根据登录来造登录的对象，再通过对象调用相应方法实现登录操作；前端发送注册操作的URL给后端，后端就造注册的对象，再调用相应方法实现注册。我们运行时才知道造哪个类的对象，这就需要用到反射了。</p>
<h3 id="②反射概述"><a href="#②反射概述" class="headerlink" title="②反射概述"></a>②反射概述</h3><h4 id="A-Java是准动态语言"><a href="#A-Java是准动态语言" class="headerlink" title="A.Java是准动态语言"></a>A.Java是准动态语言</h4><p>​	反射具有动态的特性，从而让Java有了一定的动态性，所以Java属于准动态语言。</p>
<h4 id="B-反射提供的功能"><a href="#B-反射提供的功能" class="headerlink" title="B.反射提供的功能"></a>B.反射提供的功能</h4><ul>
<li>在运行时判断任意一个对象所属的类</li>
<li>在运行时构造任意一个类的对象</li>
<li>在运行时判断任意一个类所具有的成员变量和方法</li>
<li>在运行时获取泛型信息</li>
<li>在运行时调用任意一个对象的成员变量和方法</li>
<li>在运行时处理注解</li>
<li>生成动态代理</li>
</ul>
<h4 id="C-相关主要API"><a href="#C-相关主要API" class="headerlink" title="C.相关主要API"></a>C.相关主要API</h4><ul>
<li>java.lang.Class:代表一个类</li>
<li>java.lang.reflect.Method:代表类的方法</li>
<li>java.lang.reflect.Field:代表类的成员变量</li>
<li>java.lang.reflect.Constructor:代表类的构造器</li>
</ul>
<p>注：如果用到了最后三个API，需要导包</p>
<h3 id="③关于java-lang-Class类的理解"><a href="#③关于java-lang-Class类的理解" class="headerlink" title="③关于java.lang.Class类的理解"></a>③关于java.lang.Class类的理解</h3><p>​	任何的反射操作都要先造Class类的对象，所以Class类被称为反射源。</p>
<h4 id="A-类的加载过程"><a href="#A-类的加载过程" class="headerlink" title="A.类的加载过程"></a>A.类的加载过程</h4><p>​	程序经过javac.exe命令后，会生成一个或多个字节码文件（.class结尾，一个类对应一个字节码文件）。<br>​	接着使用java.exe命令对某个字节码文件进行解释运行。相当于将某个字节码文件加载到内存中。此过程就称为<strong>类的加载</strong>。加载到内存中的类，称为<strong>运行时类</strong>，此运行时类，就作为<strong>class的一个实例</strong>。</p>
<p>​	换句话说，<strong>Class的实例就对应着一个运行时类</strong>。</p>
<h4 id="B-获取Class的实例的方式（前三种方式需要掌握）"><a href="#B-获取Class的实例的方式（前三种方式需要掌握）" class="headerlink" title="B.获取Class的实例的方式（前三种方式需要掌握）"></a>B.获取Class的实例的方式（前三种方式需要掌握）</h4><p>​	Class是一个泛型类，在声明时可以指明其泛型类型，指明后就可以在后续操作中不用强转。</p>
<ol>
<li><p>方式一：调用运行时类的属性：.class</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz1</span> <span class="operator">=</span> Person.class;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方式二：通过运行时类的对象，调用getClass()</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz2</span> <span class="operator">=</span> p1.getClass();</span><br><span class="line"><span class="comment">//getClass()：获取该对象是由哪个类造的</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>方式三：调用Class的静态方法：forName(String classPath)</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz3</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.atguigu.java.Person&quot;</span>);</span><br><span class="line"><span class="comment">//该方法会抛异常</span></span><br><span class="line"><span class="comment">//这种创建方式体现了反射的动态性</span></span><br></pre></td></tr></table></figure>

<p>   classPath：被称为全类名，即：写出该类是属于哪个包下的类</p>
<p>   这种方式在开发中<strong>使用频率最高</strong>。</p>
</li>
<li><p>方式四(了解)：使用类的加载器：ClassLoader</p>
</li>
</ol>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">ClassLoader classLoaser = </span></span><br><span class="line"><span class="comment">当前写代码的类的类名.class.getClassLoader();</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz4</span> <span class="operator">=</span> classLoader.loadClass(<span class="string">&quot;要加载的类的全类名&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="C-注意"><a href="#C-注意" class="headerlink" title="C.注意"></a>C.注意</h4><p>​	以上四个Class类的对象都是指向同一个运行时类（Person）。</p>
<h4 id="D-补充（了解）"><a href="#D-补充（了解）" class="headerlink" title="D.补充（了解）"></a>D.补充（了解）</h4><p>​	<img src="/imgs/image-20230426183608748.png" alt="image-20230426183608748"></p>
<p>​	例子：</p>
<p><img src="/imgs/image-20230426183629372.png" alt="image-20230426183629372"></p>
<h4 id="E-类的加载器"><a href="#E-类的加载器" class="headerlink" title="E.类的加载器"></a>E.类的加载器</h4><p>​	类的加载器的作用：将class文件字节码内容加载到内存中，然后在堆中生成一个Class类的实例。</p>
<p>​	<strong>类的加载器的分类</strong>：（了解）</p>
<ul>
<li>(Bootstap Classloader)<strong>引导类加载器</strong>：是JVM自带的类加载器，负责Java平台核心库，用来装载核心类库中的类。该加载器无法直接获取。</li>
<li>(Extension Classloader)<strong>扩展类加载器</strong>：负责jre&#x2F;lib&#x2F;ext目录下的jar包或 –D java.ext.dirs 指定目录下的jar包装入工作库。jar包：将class文件打包</li>
<li>(System Classloader)<strong>系统类加载器</strong>：负责加载自定义类</li>
</ul>
<h3 id="④创建运行时类的对象"><a href="#④创建运行时类的对象" class="headerlink" title="④创建运行时类的对象"></a>④创建运行时类的对象</h3><p>用<strong>Class</strong>类的对象去调用<strong>newIstance()<strong>方法（</strong>该方法会抛异常</strong>），该方法内部调用了运行时类的空参构造器。要想此方法正常的创建运行时类的对象，要求：</p>
<ul>
<li>运行时类必须提供空参的构造器</li>
<li>空参的构造器的权限修饰符要大于private。通常，设置为public。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;<span class="comment">//clazz指向了方法区中的Person类，因此造对象的时候也只能造Person类的对象，不能造其他类的对象。</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> (Person)o;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果在创建Class类的对象时指明泛型类型，就可以省略第3行代码</span></span><br><span class="line">Class&lt;Person&gt; clazz1 = Person.class;</span><br><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> clazz1.newInstance();<span class="comment">//直接返回Person类的对象。</span></span><br></pre></td></tr></table></figure>

<p>​	如果想调用带参数的构造器也是可以的，表不过通常都是调用空参的构造器。</p>
<h3 id="⑤体会反射的动态性"><a href="#⑤体会反射的动态性" class="headerlink" title="⑤体会反射的动态性"></a>⑤体会反射的动态性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> num=<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">3</span>);</span><br><span class="line">	String classPath=<span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="keyword">switch</span>(num)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">			classPath=<span class="string">&quot;java.util.Date&quot;</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">			classPath=<span class="string">&quot;java.lang.Object&quot;</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">			classPath=<span class="string">&quot;com.attang.java.Person&quot;</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Object obj=getInstance(classPath);</span><br><span class="line">	System.out.println(obj);</span><br><span class="line"></span><br><span class="line">	Public Object <span class="title function_">getInstance</span><span class="params">(String classPath)</span></span><br><span class="line">	&#123;</span><br><span class="line">		Class clazz=Class.forName(classPath);</span><br><span class="line">		<span class="keyword">return</span> class.newInstance();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	<strong>只有在运行时才能确定造的是哪个对象。</strong></p>
<h3 id="⑥获取运行时类的完整结构（了解）"><a href="#⑥获取运行时类的完整结构（了解）" class="headerlink" title="⑥获取运行时类的完整结构（了解）"></a>⑥获取运行时类的完整结构（了解）</h3><h4 id="A-获取属性结构"><a href="#A-获取属性结构" class="headerlink" title="A.获取属性结构"></a>A.获取属性结构</h4><p>​	通过Class类的对象去调用。</p>
<p>​	getFields()：获取当前运行时类及其父类中声明为public访问权限的属性。</p>
<p>​	getDeclaredFields()：获取当前运行时类中声明的所有属性。（不包括父类中声明的属性）</p>
<p>​	拿到一个属性后，我们还可以获取当前属性的数据类型、权限修饰符、属性名等信息。</p>
<h4 id="B-获取方法结构"><a href="#B-获取方法结构" class="headerlink" title="B.获取方法结构"></a>B.获取方法结构</h4><p>​	通过Class类的对象去调用。</p>
<p>​	getMethods()：获取当前运行时类及其所有父类中声明为public权限的方法</p>
<p>​	getDeclaredMethods()：获取当前运行时类中声明的所有方法。（不包含父类中声明的方法）</p>
<p>​	获取到具体的一个方法之后，我们可以接着获取该方法的权限修饰符、返回值类型、方法名、形参列表、注解、抛出异常类型。</p>
<h4 id="C-获取构造器结构"><a href="#C-获取构造器结构" class="headerlink" title="C.获取构造器结构"></a>C.获取构造器结构</h4><p>​	通过Class类的对象去调用。</p>
<p>​	getConstructors()：获取当前运行时类中声明为public的构造器。（不包括父类中的构造器）</p>
<p>​	getDeclaredConstructors()：获取当前运行时类中声明的所有构造器。（不包括父类中的构造器）</p>
<h4 id="D-获取运行时类的父类"><a href="#D-获取运行时类的父类" class="headerlink" title="D.获取运行时类的父类"></a>D.获取运行时类的父类</h4><p>​	通过Class类的对象去调用。</p>
<p>​	getSuperclass()：获取当前运行类的父类</p>
<p>​	getGenericSuperclass()：获取当前运行类的父类（带泛型的父类）</p>
<h4 id="E-获取当前运行时类的父类的泛型"><a href="#E-获取当前运行时类的父类的泛型" class="headerlink" title="E.获取当前运行时类的父类的泛型"></a>E.获取当前运行时类的父类的泛型</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line"><span class="type">Type</span> <span class="variable">genericSuperclass</span> <span class="operator">=</span> clazz.getGenericSuperclass();</span><br><span class="line"><span class="type">ParameterizedType</span> <span class="variable">paramType</span> <span class="operator">=</span> (ParameterizedType)genericSuperclass;</span><br><span class="line">Type[] actualTypeArguments = paramType.getActualTypeArguments();</span><br><span class="line">System.out.print(actualTypeArguments[<span class="number">0</span>].getTypeName());</span><br></pre></td></tr></table></figure>

<h4 id="F-获取当前运行时类实现的接口"><a href="#F-获取当前运行时类实现的接口" class="headerlink" title="F.获取当前运行时类实现的接口"></a>F.获取当前运行时类实现的接口</h4><p>​	通过Class类的对象去调用。</p>
<p>​	getInterfaces()：获取当前运行时类实现的接口（不包括父类的接口，要想获取父类实现的接口，就先得获取父类，再接着调用getInterfaces()）</p>
<h4 id="G-获取当前运行时类所在的包"><a href="#G-获取当前运行时类所在的包" class="headerlink" title="G.获取当前运行时类所在的包"></a>G.获取当前运行时类所在的包</h4><p>​	通过Class类的对象去调用。</p>
<p>​	getPackage()：获取当前运行时类所在的包</p>
<h4 id="H-获取运行时类声明的注解"><a href="#H-获取运行时类声明的注解" class="headerlink" title="H.获取运行时类声明的注解"></a>H.获取运行时类声明的注解</h4><p>​	通过Class类的对象去调用。</p>
<p>​	getAnnotations()：读取当前运行时类的注解</p>
<h4 id="需要重点了解的是"><a href="#需要重点了解的是" class="headerlink" title="需要重点了解的是"></a>需要重点了解的是</h4><p>​	E、F、H</p>
<hr>
<h3 id="⑦调用运行时类的指定结构"><a href="#⑦调用运行时类的指定结构" class="headerlink" title="⑦调用运行时类的指定结构"></a>⑦调用运行时类的指定结构</h3><p>​	这里我们重点关注：属性、方法、构造器</p>
<h4 id="A-如何操作运行时类中指定的属性"><a href="#A-如何操作运行时类中指定的属性" class="headerlink" title="A.如何操作运行时类中指定的属性"></a>A.如何操作运行时类中指定的属性</h4><p>​	实现步骤：</p>
<ol>
<li>造Class类的对象</li>
<li>创建运行时类的对象</li>
<li>用Class类的对象去调用getDeclaredField(String fieldName)，获取运行时类中指定变量名的属性（注意：<strong>获取不了父类中的属性</strong>）</li>
<li>用获取到的属性调用setAccessible(true)方法，保证当前属性是可访问的（如果不调用该方法，就不能对声明为private的属性进行赋值或获取操作）</li>
<li>用获取到的属性调用set(Object obj,Object value)实现赋值操作，调用get(Object   obj)实现获取属性值操作。其中：obj为要对哪个对象进行操作，value：属性值要设置多少</li>
</ol>
<p>补充：<strong>如果获取的是静态的属性</strong>，则将步骤2去掉，步骤5中的obj写null或“当前运行时类.class”</p>
<p>​	代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="comment">//1.声明Class类的对象</span></span><br><span class="line">    Class&lt;Person&gt; clazz = (Class&lt;Person&gt;) Class.forName(<span class="string">&quot;com.zzc.javatest.Person&quot;</span>);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//2.创建运行时类的对象</span></span><br><span class="line">    <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.获取运行时类中指定变量名的属性</span></span><br><span class="line">    <span class="type">Field</span> <span class="variable">des</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.对获取到的属性进行赋值或获取操作</span></span><br><span class="line">    des.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    des.set(person,<span class="number">1001</span>);</span><br><span class="line">    System.out.println(des.get(person));</span><br><span class="line">    </span><br><span class="line"> <span class="comment">//第三行代码为什么需要强转？因为该forName方法本身返回的是Class&lt;?&gt;类型数据，而clazz是Class&lt;Person&gt;类型，所有就需要强转。Class&lt;?&gt;是Class&lt;Person&gt;的父类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="B-如何操作运行时类中指定的方法"><a href="#B-如何操作运行时类中指定的方法" class="headerlink" title="B.如何操作运行时类中指定的方法"></a>B.如何操作运行时类中指定的方法</h4><p>​	<strong>调用非静态的方法</strong>：</p>
<p>​	实现步骤：</p>
<ol>
<li>造Class的实例</li>
<li>造运行时类的对象</li>
<li>用Class类的对象去调用getDeclareMethod(String methodName,方法的形参列表)，参数1：指明获取的方法的名称，参数2：指明获取的方法的形参列表，没有就不用写，有则这样写：“数据类型.class”</li>
<li>用获取到的方法调用setAccessible(true)，保证当前方法是可访问的</li>
<li>调用方法的invoke()：参数1：方法的调用者，参数2：实参，invoke()的返回值即为对应类中调用的方法的返回值。如果没有返回值，则返回的是null。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="comment">//1.</span></span><br><span class="line">    Class&lt;Person&gt; clazz = (Class&lt;Person&gt;) Class.forName(<span class="string">&quot;com.zzc.javatest.Person&quot;</span>);</span><br><span class="line">    <span class="comment">//2.</span></span><br><span class="line">    <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line">    <span class="comment">//3.</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">show</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;show&quot;</span>);</span><br><span class="line">    <span class="comment">//4.</span></span><br><span class="line">    show.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">//5.</span></span><br><span class="line">    show.invoke(person);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>​	<strong>调用静态的方法</strong>：</p>
<p>​	<strong>实现步骤</strong>：</p>
<ol>
<li>造Class的实例</li>
<li>用Class类的对象去调用getDeclareMethod(String methodName,方法的形参列表)，参数1：指明获取的方法的名称，参数2：指明获取的方法的形参列表，没有就不用写</li>
<li>用获取到的方法调用setAccessible(true)，保证当前方法是可访问的</li>
<li>调用方法的invoke()：参数1：null或“当前运行时类.class”，参数2：实参，invoke()的返回值即为对应类中调用的方法的返回值。如果没有返回值，则返回的是null。</li>
</ol>
<h4 id="C-如何调用运行时类中指定的构造器"><a href="#C-如何调用运行时类中指定的构造器" class="headerlink" title="C.如何调用运行时类中指定的构造器"></a>C.如何调用运行时类中指定的构造器</h4><p>​	<strong>实现步骤</strong>：</p>
<ol>
<li>造Class的实例</li>
<li>用Class的对象去调用getDeclaredConstructor()：参数：指明构造器的参数列表，写参数的时候要这样写：“数据类型.class”。该方法会抛异常。</li>
<li>用获取到的构造器去调用setAccessible(true)，保证此构造器是可访问的</li>
<li>调用此构造器创建运行时类的对象，使用newInstance(实参)</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="comment">//1.</span></span><br><span class="line">    Class&lt;Person&gt; clazz = (Class&lt;Person&gt;) Class.forName(<span class="string">&quot;com.zzc.javatest.Person&quot;</span>);</span><br><span class="line">    <span class="comment">//2.</span></span><br><span class="line">    Constructor&lt;Person&gt; constructor = clazz.getDeclaredConstructor(String.class, <span class="type">int</span>.class);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.</span></span><br><span class="line">    constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">//4.</span></span><br><span class="line">    <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> constructor.newInstance(<span class="string">&quot;Tom&quot;</span>, <span class="number">12</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="⑧反射应用–动态代理"><a href="#⑧反射应用–动态代理" class="headerlink" title="⑧反射应用–动态代理"></a>⑧反射应用–动态代理</h3><h4 id="①概述-11"><a href="#①概述-11" class="headerlink" title="①概述"></a>①概述</h4><p>​	<strong>代理模式</strong>：通过代理类的对象来间接调用被代理类中的方法。</p>
<p>​	<strong>代理模式的具体实现</strong>：代理类和被代理类都实现同一个（堆）接口，然后通过代理类的对象来调用方法，如：show()方法，当调用该方法时，实际上调用的是被代理类里的show()方法。从而实现间接操作被代理中的方法。</p>
<p>​	<strong>动态代理</strong>：接口、被代理类要先造好，而代理类是动态创建。</p>
<h4 id="②静态代理实现"><a href="#②静态代理实现" class="headerlink" title="②静态代理实现"></a>②静态代理实现</h4><p>​	见：笔记12、面向对象中的其他关键字 —&gt; interface –&gt; ⑦</p>
<h4 id="③动态代理实现"><a href="#③动态代理实现" class="headerlink" title="③动态代理实现"></a>③动态代理实现</h4><p>​	基础阶段先了解，到框架部分再深入</p>
<hr>
<h2 id="10、Java8的一些新特性"><a href="#10、Java8的一些新特性" class="headerlink" title="10、Java8的一些新特性"></a>10、Java8的一些新特性</h2><h3 id="①概述-12"><a href="#①概述-12" class="headerlink" title="①概述"></a>①概述</h3><p>​	java8：</p>
<ul>
<li>速度更快</li>
<li>代码更少(增加了新的语法：Lambda 表达式)</li>
<li>强大的 Stream API</li>
<li>便于并行</li>
<li>最大化减少空指针异常：Optional</li>
<li>Nashorn引擎，允许在JVM上运行JS应用</li>
</ul>
<h3 id="②Lambda表达式"><a href="#②Lambda表达式" class="headerlink" title="②Lambda表达式"></a>②Lambda表达式</h3><h4 id="A-Lambda表达式的举例"><a href="#A-Lambda表达式的举例" class="headerlink" title="A.Lambda表达式的举例"></a>A.Lambda表达式的举例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(o1,o2) -&gt; Integer.compare(o1,o2);</span><br></pre></td></tr></table></figure>

<h4 id="B-格式"><a href="#B-格式" class="headerlink" title="B.格式"></a>B.格式</h4><p>​		-&gt; ：Lambda操作符 或 箭头操作符</p>
<p>​		操作符左边：Lambda形参列表（其实就是接口中的抽象方法的形参列表）</p>
<p>​		操作符右边：Lambda体（其实就是重写的抽象方法的方法体）</p>
<h4 id="C-Lambda表达式的使用"><a href="#C-Lambda表达式的使用" class="headerlink" title="C.Lambda表达式的使用"></a>C.Lambda表达式的使用</h4><p>​		Lambda表达式的本质：函数式接口的匿名实现类的对象。</p>
<p>​		总结：</p>
<ol>
<li>操作符左边：Lambda形参列表的参数类型可以省略（类型推断）；如果Lambda形参列表只有一个参数，其一对（）也可以省略。	</li>
<li>操作符右边：Lambda体应该使用一对{ }包裹：如果Lambda体只有一条执行语句（可能是return语句），可以省略这一对{}和return关键字（如果省略{ }，则return必须一起省略）。</li>
</ol>
<h4 id="D-注意"><a href="#D-注意" class="headerlink" title="D.注意"></a>D.注意</h4><p>​	Lambda表达式使用前提是：只能使用在接口，且该接口只能是函数式接口（即该接口里只有一个抽象方法）</p>
<h4 id="E-应用场景"><a href="#E-应用场景" class="headerlink" title="E.应用场景"></a>E.应用场景</h4><p>​	当函数式接口要创建一个匿名实现类的对象时，我们就可以使用Lambda表达式了。</p>
<hr>
<h3 id="③函数式接口"><a href="#③函数式接口" class="headerlink" title="③函数式接口"></a>③函数式接口</h3><h4 id="A-定义"><a href="#A-定义" class="headerlink" title="A.定义"></a>A.定义</h4><p>​	接口中只有一个抽象方法的接口，称为函数式接口。</p>
<p>​	我们可以在一个接口上使用 @FunctionalInterface 注解，这样做可以检查它是否是一个函数式接口。</p>
<h4 id="B-Java内置四大核心函数式接口"><a href="#B-Java内置四大核心函数式接口" class="headerlink" title="B.Java内置四大核心函数式接口"></a>B.Java内置四大核心函数式接口</h4><p><img src="/imgs/image-20230426183848389.png" alt="image-20230426183848389"></p>
<p>​	以后当见到上面的函数式接口时，我们都可以使用Lambda表达式来造函数式接口的实现类对象。</p>
<h4 id="C-如何使用给定的函数式接口"><a href="#C-如何使用给定的函数式接口" class="headerlink" title="C.如何使用给定的函数式接口"></a>C.如何使用给定的函数式接口</h4><p>​	如果我们开发中需要定义一个函数式接口，首先看看在已有的jdk提供的函数式接口是否提供了能满足需求的函数式接口。如果有，则直接调用即可，不需要自己再定义了。</p>
<hr>
<h3 id="④方法引用"><a href="#④方法引用" class="headerlink" title="④方法引用"></a>④方法引用</h3><h4 id="A-使用情景"><a href="#A-使用情景" class="headerlink" title="A.使用情景"></a>A.使用情景</h4><p>​	当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用。即：当Lambda体中只有一条语句，且这条语句是：通过对象或类调用了某个方法，像这种情况，我们就可以考虑使用方法引用了，具体能不能使用得看方法引用的使用规则。</p>
<p>​	方法引用，本质上就是Lambda表达式，而Lambda表达式作为函数式接口的实例。所以方法引用，也就是函数式接口的实例。</p>
<h4 id="B-格式-1"><a href="#B-格式-1" class="headerlink" title="B.格式"></a>B.格式</h4><p>​	格式：类（或对象） :: 方法名</p>
<p>​	具体可以分成如下三种情况：</p>
<ol>
<li><p>对象 :: 非静态方法</p>
</li>
<li><p>类 :: 静态方法</p>
</li>
<li><p>类 :: 非静态方法</p>
<p> 以上的方法只写方法名，不用写形参</p>
</li>
</ol>
<h4 id="C-方法引用使用规则"><a href="#C-方法引用使用规则" class="headerlink" title="C.方法引用使用规则"></a>C.方法引用使用规则</h4><ul>
<li>当Lambda体中调用的方法的形参列表和返回值类型与接口中的抽象方法的形参列表和返回值类型相同时，我们就可以使用格式中情况1或情况2来写方法引用，具体选哪个？<ul>
<li>当Lambda体中调用的方法为静态方法，则使用格式中的情况2来写方法引用。</li>
<li>当Lambda体中调用的方法为非静态方法，则使用格式中的情况1来写方法引用。</li>
</ul>
</li>
<li>当Lambda体中调用的方法属于非静态时，选择情况1还是选择情况3呢？<ul>
<li>当抽象方法中的形参为两个（t1,t2），而Lambda体中调用的方法的形参只有一个（t2）而t1作为方法引用的方法的调用者时，我们选择格式中的情况3。</li>
<li>当抽象方法中的形参为一个（t1），而Lambda体中调用的方法的形参为0个，而t1作为方法引用的方法的调用者时，我们选择格式中的情况3。</li>
</ul>
</li>
</ul>
<h4 id="D-具体举例"><a href="#D-具体举例" class="headerlink" title="D.具体举例"></a>D.具体举例</h4><p>​	①对象 :: 非静态方法</p>
<p>​		例一：</p>
<p>​	<img src="/imgs/image-20230426183913862.png" alt="image-20230426183913862"></p>
<p>​		例二：</p>
<p><img src="/imgs/image-20230426183928095.png" alt="image-20230426183928095"></p>
<p>​	②类::静态方法名</p>
<p>​		例一：</p>
<img src="/imgs/image-20230426183950931.png" alt="image-20230426183950931" style="zoom:67%;" />

<p>​		例二：</p>
<img src="/imgs/image-20230426184021408.png" alt="image-20230426184021408" style="zoom:67%;" />

<p>​	③类::实例方法名</p>
<p>​	第一个参数作为方法的调用者。</p>
<p>​		例一：</p>
<img src="/imgs/image-20230426184138306.png" alt="image-20230426184138306" style="zoom:67%;" />

<p>​		例二：</p>
<img src="/imgs/image-20230426184205628.png" alt="image-20230426184205628" style="zoom:67%;" />

<p>​	最后一句写错了，是pre2</p>
<p>​		例三：</p>
<img src="/imgs/image-20230426184226106.png" alt="image-20230426184226106" style="zoom:67%;" />



<hr>
<h3 id="⑤构造器引用"><a href="#⑤构造器引用" class="headerlink" title="⑤构造器引用"></a>⑤构造器引用</h3><h4 id="A-概述-1"><a href="#A-概述-1" class="headerlink" title="A.概述"></a>A.概述</h4><p>​	如果Lambda体中只有一条语句且该语句属于创建对象的语句，那么就可以考虑使用构造器引用，具体能不能使用得看看是否符合构造器引用规则。</p>
<h4 id="B-格式-2"><a href="#B-格式-2" class="headerlink" title="B.格式"></a>B.格式</h4><p>​	类名 :: new</p>
<h4 id="C-构造器引用规则"><a href="#C-构造器引用规则" class="headerlink" title="C.构造器引用规则"></a>C.构造器引用规则</h4><p>​	函数式接口的抽象方法的形参列表和构造器的形参列表一致。抽象方法的返回值类型即为构造器所属的类的类型。</p>
<h4 id="D-例子"><a href="#D-例子" class="headerlink" title="D.例子"></a>D.例子</h4><p>​	例一：</p>
<img src="/imgs/image-20230426184529162.png" alt="image-20230426184529162" style="zoom:67%;" />

<p>​	例二：</p>
<p><img src="/imgs/image-20230426184552027.png" alt="image-20230426184552027"></p>
<p>​	例三：</p>
<img src="/imgs/image-20230426184612836.png" alt="image-20230426184612836" style="zoom:67%;" />



<hr>
<h3 id="⑥数组引用（？）"><a href="#⑥数组引用（？）" class="headerlink" title="⑥数组引用（？）"></a>⑥数组引用（？）</h3><p>​	当Lambda体中只有一条语句且该语句属于创建数组的语句，像这种情况，我们就可以使用数组引用。</p>
<h4 id="A-格式"><a href="#A-格式" class="headerlink" title="A.格式"></a>A.格式</h4><p>​	数组类型[ ] :: new</p>
<h4 id="B-使用"><a href="#B-使用" class="headerlink" title="B.使用"></a>B.使用</h4><p>​	大家可以把数组看做是一个特殊的类，则写法与构造器引用一致。</p>
<p><img src="/imgs/image-20230426184638245.png" alt="image-20230426184638245"></p>
<hr>
<h2 id="11、Java8新特性—Stream-API"><a href="#11、Java8新特性—Stream-API" class="headerlink" title="11、Java8新特性—Stream API"></a>11、Java8新特性—Stream API</h2><h3 id="A-概述-2"><a href="#A-概述-2" class="headerlink" title="A.概述"></a>A.概述</h3><ol>
<li><p>Stream是用来对集合中的数据进行计算操作的API，与CPU打交道</p>
<p> 集合关注的是数据的存储，与内存打交道</p>
</li>
<li><p>为什么需要Stream API？</p>
<p> 通常像MySQL这些数据库属于强关系数据库，对数据的过滤操作（如：查询大于3的数据）都是在数据库中完成的，而像Radis、MongDB这些弱关系数据库，则需要在Java层面实现数据的过滤操作。</p>
</li>
<li><p><strong>注意</strong></p>
<ul>
<li>Stream 自己不会存储元素。</li>
<li>Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。</li>
<li>Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。</li>
</ul>
</li>
<li><p><strong>Stream执行流程</strong></p>
<p> ①Stream的实例化</p>
<p> ②一系列的中间操作（过滤、映射….）</p>
<p> ③终止操作</p>
</li>
<li><p><strong>说明</strong></p>
<ul>
<li>中间操作：一个中间操作链，对数据源的数据进行处理</li>
<li>终止操作(终端操作) ：一旦执行终止操作，就执行中间操作链，并产生结果。之后，<strong>Stram对象就不能再被使用。如果还想执行操作，得重新造Stream对象</strong>。</li>
</ul>
</li>
</ol>
<h3 id="B-Stream实例化"><a href="#B-Stream实例化" class="headerlink" title="B.Stream实例化"></a>B.Stream实例化</h3><h4 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h4><p>​		<strong>通过集合创建</strong></p>
<p>​		<strong>A</strong>.调用集合Collection中默认方法stream()来实例化</p>
<p>​			①先造Collection的实现类的对象</p>
<p>​			②通过上面造的对象调用stream()方法，该方法返回一个顺序流（读取到的数据顺序与集合中存储数据的顺序一样）</p>
<p>​		<strong>B</strong>.调用集合Collection中默认方法parallelStream()来实例化</p>
<p>​			①先造Collection的实现类的对象</p>
<p>​			②通过上面造的对象调用stream()方法，该方法返回一个并行流。（相当于用多个线程同时对集合中的数据进行读取）</p>
<h4 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h4><p>​		<strong>通过数组</strong></p>
<p>​		调用<strong>Arrays</strong>里的静态方法**stream()**，把数组放到方法的形参中，返回一个stream对象</p>
<h4 id="方式三"><a href="#方式三" class="headerlink" title="方式三"></a>方式三</h4><p>​		通过Stream的of()方法，通过显示值创建一个流，它可以接收任意数量任意类型的参数。</p>
<p>​		public static&lt; T &gt; Stream&lt; T &gt; of(T… values) : 返回一个流</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream = Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<p>​		该方法适用于：<strong>现造现用</strong>的情况</p>
<h4 id="方法四（了解）"><a href="#方法四（了解）" class="headerlink" title="方法四（了解）"></a>方法四（了解）</h4><p>​		创建无限流</p>
<p>​		可以使用静态方法 Stream.iterate() 和 Stream.generate(), 创建无限流。</p>
<hr>
<h3 id="C-中间操作–筛选与切片"><a href="#C-中间操作–筛选与切片" class="headerlink" title="C.中间操作–筛选与切片"></a>C.中间操作–筛选与切片</h3><h4 id="①filter-Predicate-p"><a href="#①filter-Predicate-p" class="headerlink" title="①filter(Predicate p)"></a>①filter(Predicate p)</h4><p>​			该方法的作用：从集合中排除某些元素，返回一个新的Stream对象</p>
<p>​			实现：</p>
<p>​			①用Stream的对象去调用filter()方法</p>
<p>​			②在该方法的形参里放Predicate接口的匿名实现类的对象（可以选择用Lambda表达式表示）</p>
<p>​			③在Predicate 接口的抽象方法test里写具体的过滤操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list1.add(<span class="number">1</span>);</span><br><span class="line">    list1.add(<span class="number">2</span>);</span><br><span class="line">    list1.add(<span class="number">3</span>);</span><br><span class="line">    list1.add(<span class="number">4</span>);</span><br><span class="line">	<span class="comment">//1.Stream的实例化</span></span><br><span class="line">    Stream&lt;Integer&gt; stream = list1.stream();</span><br><span class="line">	<span class="comment">//2.调用filter</span></span><br><span class="line">    stream.filter(<span class="keyword">new</span> <span class="title class_">Predicate</span>&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(Integer integer)</span> &#123;</span><br><span class="line">            <span class="comment">//3.写过滤条件</span></span><br><span class="line">            <span class="keyword">return</span> integer &gt; <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).forEach(System.out::println);</span><br><span class="line">    <span class="comment">//上面的写法可以改成用Lambda表达式写</span></span><br><span class="line"> <span class="comment">//stream.filter(integer -&gt; integer &gt; 2).forEach(System.out::println);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//运行结果为：3 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="②limit-n"><a href="#②limit-n" class="headerlink" title="②limit(n)"></a>②limit(n)</h4><p>​		截断流，使其元素不超过给定数量。即：从容器的开始端读取n个数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stream.limit(<span class="number">3</span>).forEach(System.out::println);<span class="comment">//1，2，3</span></span><br></pre></td></tr></table></figure>

<h4 id="③skip-n"><a href="#③skip-n" class="headerlink" title="③skip(n)"></a>③skip(n)</h4><p>​		跳过元素，返回一个扔掉了前n个元素的流。若流中元素不足n个，则返回一个空流。与limit(n)互补。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stream.skip(<span class="number">3</span>).forEach(System.out::println);<span class="comment">//4</span></span><br></pre></td></tr></table></figure>

<h4 id="④distinct"><a href="#④distinct" class="headerlink" title="④distinct()"></a>④distinct()</h4><p>​		筛选，通过流所生成元素的hasCode() 和 equals() 去除重复元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list1.add(<span class="number">1</span>);</span><br><span class="line">list1.add(<span class="number">2</span>);</span><br><span class="line">list1.add(<span class="number">3</span>);</span><br><span class="line">list1.add(<span class="number">4</span>);</span><br><span class="line">list1.add(<span class="number">4</span>);</span><br><span class="line">Stream&lt;Integer&gt; stream = list1.stream();</span><br><span class="line">stream.distinct().forEach(System.out::println);<span class="comment">//1，2，3，4</span></span><br></pre></td></tr></table></figure>



<h3 id="D-中间操作–映射"><a href="#D-中间操作–映射" class="headerlink" title="D.中间操作–映射"></a>D.中间操作–映射</h3><h4 id="①map-Function-f"><a href="#①map-Function-f" class="headerlink" title="①map(Function f)"></a>①map(Function f)</h4><p>​	map(Function f)：依次遍历Stream里的每一个元素，然后按照映射规则对元素进行操作。</p>
<p>​	实现：</p>
<p>​		①Stream对象调用map方法，往map方法的形参中传入实现Function接口的实现类的对象。</p>
<p>​		②在Function接口的抽象方法中写映射的规则</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"> list1.add(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line"> list1.add(<span class="string">&quot;bb&quot;</span>);</span><br><span class="line"> list1.add(<span class="string">&quot;cc&quot;</span>);</span><br><span class="line"> Stream&lt;String&gt; stream = list1.stream();</span><br><span class="line"> stream.map(<span class="keyword">new</span> <span class="title class_">Function</span>&lt;String, Object&gt;() &#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> Object <span class="title function_">apply</span><span class="params">(String string)</span> &#123;</span><br><span class="line">         <span class="comment">//映射规则</span></span><br><span class="line">         <span class="keyword">return</span> string.toUpperCase();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;).forEach(System.out::println);</span><br><span class="line"><span class="comment">//将6-12行代码用Lambda表达式表示</span></span><br><span class="line"><span class="comment">//stream.map(str -&gt; str.toUpperCase()).forEach(System.out::println);</span></span><br><span class="line"><span class="comment">//运行结果：AA,BB,CC</span></span><br></pre></td></tr></table></figure>



<h4 id="②flatMap-Function-f-不会"><a href="#②flatMap-Function-f-不会" class="headerlink" title="②flatMap(Function f)     不会"></a>②flatMap(Function f)     不会</h4><p>​		将流中的每个值都换成另一个流，然后把所有流连接成一个流</p>
<h3 id="E-中间操作–排序"><a href="#E-中间操作–排序" class="headerlink" title="E.中间操作–排序"></a>E.中间操作–排序</h3><p>​	对集合或数组中的元素进行排序操作</p>
<h4 id="①sorted-自然排序"><a href="#①sorted-自然排序" class="headerlink" title="①sorted()  自然排序"></a>①sorted()  自然排序</h4><p>​	使用要求：集合中的元素或数组中的元素所在类要实现Comparable接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    ArrayList&lt;Person&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">12</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jerry&quot;</span>,<span class="number">22</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jack&quot;</span>,<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    list.stream().sorted().forEach(System.out::println);</span><br><span class="line">    <span class="comment">//sorted方法实际上调用的是Person类里的compareTo方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="②sorted-Comparator-com-定制排序"><a href="#②sorted-Comparator-com-定制排序" class="headerlink" title="②sorted(Comparator com)  定制排序"></a>②sorted(Comparator com)  定制排序</h4><p>​	参数里放实现了Comparator接口的实现类的对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    ArrayList&lt;Person&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">12</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jerry&quot;</span>,<span class="number">22</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jack&quot;</span>,<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//定制排序</span></span><br><span class="line">    list.stream().sorted(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Person&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Person o1, Person o2)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> o1.getName().compareTo(o2.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//如果使用Lambda表达式则这样写：</span></span><br><span class="line"><span class="comment">//list.stream().sorted(((o1, o2) -&gt; o1.getName().compareTo(o2.getName()))).forEach(System.out::println);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="F-终结操作–匹配与查找"><a href="#F-终结操作–匹配与查找" class="headerlink" title="F.终结操作–匹配与查找"></a>F.终结操作–匹配与查找</h3><h4 id="①allMatch-Predicate-p"><a href="#①allMatch-Predicate-p" class="headerlink" title="①allMatch(Predicate p)"></a>①allMatch(Predicate p)</h4><ul>
<li>判断集合中或数组中的元素是否都满足Predicate接口中抽象方法里的操作，只有都返回true，allMatch才返回true。</li>
<li>匹配规则写在Predicate接口中的抽象方法里。</li>
</ul>
<h4 id="②anyMatch-Predicate-p"><a href="#②anyMatch-Predicate-p" class="headerlink" title="②anyMatch(Predicate p)"></a>②anyMatch(Predicate p)</h4><ul>
<li>判断集合或数组中的元素是否满足Predicate接口中的抽象方法里的匹配规则，只要有一个元素满足，则返回true。</li>
<li>匹配规则写在Predicate接口中的抽象方法里。</li>
</ul>
<h4 id="③noneMatch-Predicate-p"><a href="#③noneMatch-Predicate-p" class="headerlink" title="③noneMatch(Predicate p)"></a>③noneMatch(Predicate p)</h4><ul>
<li>检查数组或集合中是否没有匹配的元素，返回布偶值。</li>
<li>匹配规则写在Predicate接口中的抽象方法里。</li>
</ul>
<h4 id="④findFirst"><a href="#④findFirst" class="headerlink" title="④findFirst()"></a>④findFirst()</h4><ul>
<li>返回当前Stream里的第一个元素。</li>
</ul>
<h4 id="⑤findAny"><a href="#⑤findAny" class="headerlink" title="⑤findAny()"></a>⑤findAny()</h4><ul>
<li>返回当前流中的任意一个元素。</li>
</ul>
<h4 id="⑥count"><a href="#⑥count" class="headerlink" title="⑥count()"></a>⑥count()</h4><ul>
<li>返回流中元素的个数。</li>
</ul>
<h4 id="⑦max-Comparator-c"><a href="#⑦max-Comparator-c" class="headerlink" title="⑦max(Comparator c)"></a>⑦max(Comparator c)</h4><ul>
<li>返回流中最大值，将比较的规则写在Comparator接口里的抽象方法中。</li>
<li>Comparator属于函数式接口，可以使用Lambda表达式。</li>
</ul>
<h4 id="⑧min-Comparator-c"><a href="#⑧min-Comparator-c" class="headerlink" title="⑧min(Comparator c)"></a>⑧min(Comparator c)</h4><ul>
<li>返回流中最小值，将比较的规则写在Comparator接口里的抽象方法中。</li>
<li>Comparator属于函数式接口，可以使用Lambda表达式。</li>
</ul>
<h4 id="⑨forEach-Consumer-c"><a href="#⑨forEach-Consumer-c" class="headerlink" title="⑨forEach(Consumer c)"></a>⑨forEach(Consumer c)</h4><ul>
<li><p>内部迭代，通常这样写：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">forEach(System.out::print);<span class="comment">//对流中的元素进行遍历输出</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="G-终结操作–规约"><a href="#G-终结操作–规约" class="headerlink" title="G.终结操作–规约"></a>G.终结操作–规约</h3><p>​	规约：即求和操作</p>
<h4 id="①reduce-T-identity-BinaryOperator"><a href="#①reduce-T-identity-BinaryOperator" class="headerlink" title="①reduce(T identity,BinaryOperator)"></a>①reduce(T identity,BinaryOperator)</h4><p>​	将流中的元素反复累加起来，得到一个值。相当于求和操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算1-10的自然数的和</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>);</span><br><span class="line">    <span class="comment">//reduce里的第一个参数为：累加的初始值</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">reduce</span> <span class="operator">=</span> list.stream().reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line">    <span class="comment">//Integer::sum含义：调用Integer里的sum方法</span></span><br><span class="line">    System.out.println(reduce);<span class="comment">//55</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="②reduce-BinaryOperator"><a href="#②reduce-BinaryOperator" class="headerlink" title="②reduce(BinaryOperator)"></a>②reduce(BinaryOperator)</h4><p>​	将流中元素反复累加起来，得到一个值，返回Optional<T>。与上面的一样，只是少了一个参数identity来指定累加的初始值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算1-10的自然数的和</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">Integer</span> <span class="variable">reduce</span> <span class="operator">=</span> list.stream().reduce(Integer::sum);</span><br><span class="line">    <span class="comment">//Integer::sum含义：调用Integer里的sum方法</span></span><br><span class="line">    System.out.println(reduce);<span class="comment">//55</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="H-终结操作–收集"><a href="#H-终结操作–收集" class="headerlink" title="H.终结操作–收集"></a>H.终结操作–收集</h3><h4 id="①collect-Collector-c"><a href="#①collect-Collector-c" class="headerlink" title="①collect(Collector c)"></a>①collect(Collector c)</h4><p>​	<strong>方法作用</strong>：将Stream里的数据存储到集合（List、Map、set）中，并返回对应集合的对象。</p>
<p>​	Collector是接口，我们使用Collectors中的静态方法来返回一个Collector实现类的对象。</p>
<p>​	如果想将Stream里的数据放到：</p>
<ul>
<li>放到List中，将“Collectors.toList()”放到形参中即可</li>
<li>放到Set中，将“Collectors.toSet()”放到形参中即可</li>
<li>放到Map中2，将“Collectors.toMap()”放到形参中即可</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>);</span><br><span class="line">    List&lt;Integer&gt; list1 = list.stream().filter(i -&gt; i &gt; <span class="number">5</span>).collect(Collectors.toList());</span><br><span class="line">    System.out.println(list1);<span class="comment">//[6, 7, 8, 9, 10]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="12、Java8新特性—Optional类"><a href="#12、Java8新特性—Optional类" class="headerlink" title="12、Java8新特性—Optional类"></a>12、Java8新特性—Optional类</h2><h3 id="①概述-13"><a href="#①概述-13" class="headerlink" title="①概述"></a>①概述</h3><p>​	为了避免出现空指针异常的情况，我们引入了Optional类。 </p>
<p>​	Optional&lt; T t &gt; 类(java.util.Optional) 是一个容器类，它可以将 t 的地址值赋给Optional的属性value，代表这个值存在。或者仅仅保存null，表示这个值不存在。原来用 null 表示一个值不存在，现在 Optional 可以更好的表达这个概念。并且可以避免空指针异常。</p>
<h3 id="②Optional类的方法"><a href="#②Optional类的方法" class="headerlink" title="②Optional类的方法"></a>②Optional类的方法</h3><h4 id="A-创建Optional类对象的方法"><a href="#A-创建Optional类对象的方法" class="headerlink" title="A.创建Optional类对象的方法"></a>A.创建Optional类对象的方法</h4><p>​	→ Optional.of(T t) : 封装数据 t 生成Optional对象，并将数据 t 的地址值赋给Optional内部的value。要求 t 非空，否则报错  </p>
<p>​	→ Optional.empty() : 创建了一个Optional对象，但其内部的value &#x3D; null。</p>
<p>​	→ **Optional.ofNullable(T t)**：封装数据 t 并将数据 t 的地址值赋给Optional内部的value，生成Optional对象。不要求 t 非空。 </p>
<h4 id="B-常用方法"><a href="#B-常用方法" class="headerlink" title="B.常用方法"></a>B.常用方法</h4><ol>
<li><p><strong>T orElse(T t1)</strong>      —-&gt; 该方法与ofNullable(T t)搭配使用</p>
<ul>
<li>该方法通过Optional类的对象去调用，Optional内部封装的value值或 t1</li>
<li>如果的当前的Optional对象内部封装的 value 是非空的，则返回此value值 。<ul>
<li>如果内部的 value 是空的，则返回orElse()方法中的参数 t1 。</li>
</ul>
</li>
</ul>
</li>
<li><p>T get()    ——&gt; 该方法与of(T t)搭配使用</p>
<ul>
<li>该方法通过Optional类的对象去调用。</li>
<li>如果Optional封装的数据value为空，则get()报错。否则，value不为空时，返回value。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    Optional&lt;String&gt; optionalS = Optional.ofNullable(s);</span><br><span class="line">    System.out.println(optionalS.get());<span class="comment">//hello</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p>boolean isPresent()</p>
<ul>
<li>该方法通过Optional类的对象去调用。</li>
<li>判断当前的Optional对象内部封装的 value 是否有值，有值返回true。</li>
</ul>
</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://orangezzc.github.io/">OrangeZzc</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://orangezzc.github.io/2023/04/26/Java%E8%AF%AD%E6%B3%95%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/">https://orangezzc.github.io/2023/04/26/Java%E8%AF%AD%E6%B3%95%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://OrangeZzc.github.io" target="_blank">Orange's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post_share"><div class="social-share" data-image="/./imgs/javayufafenmian.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2023/04/24/%E5%BF%AB%E6%8D%B7%E9%94%AE/" title="快捷键"><img class="cover" src="/./imgs/kuaijiejianfenmian.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">快捷键</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/04/24/Java%E8%AF%AD%E6%B3%95%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/" title="Java语法（基础部分）"><img class="cover" src="/./imgs/javayufafenmian.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-24</div><div class="title">Java语法（基础部分）</div></div></a></div><div><a href="/2023/04/24/java%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0/" title="Java语法基础概述"><img class="cover" src="/./imgs/javayufafenmian.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-24</div><div class="title">Java语法基础概述</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avater.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">OrangeZzc</div><div class="author-info__description">欢迎来到我的博客!</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/OrangeZzc" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:3486484066@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #24292e;"></i></a><a class="social-icon" href="http://wpa.qq.com/msgrd?v=3&amp;uin=3486484066&amp;site=qq&amp;menu=yes" target="_blank" title="QQ"><i class="fab fa-qq"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">如果在阅读过程中遇到了问题，可以随时联系我，看到了会在第一时间给出回复（不负责DEBUG，除非我真的写的有问题）</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81Java%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B"><span class="toc-text">三、Java高级编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">1、多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#A-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">A.基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E7%A8%8B%E5%BA%8F"><span class="toc-text">①程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E8%BF%9B%E7%A8%8B"><span class="toc-text">②进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2%E7%BA%BF%E7%A8%8B"><span class="toc-text">③线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A3%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E5%9C%A8JVM%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%83%85%E5%86%B5"><span class="toc-text">④进程、线程在JVM中的内存分配情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A4%E5%8D%95%E6%A0%B8%E4%B8%8E%E5%A4%9A%E6%A0%B8CPU"><span class="toc-text">⑤单核与多核CPU</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A5%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%B9%B6%E5%8F%91"><span class="toc-text">⑥并行与并发</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A6%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-text">⑦多线程的好处</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A7%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">⑧何时使用多线程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="toc-text">B.线程的创建和使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E2%80%93%E6%96%B9%E5%BC%8F%E4%B8%80"><span class="toc-text">①多线程创建–方式一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E2%80%93%E6%96%B9%E5%BC%8F%E4%BA%8C"><span class="toc-text">②多线程创建–方式二</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2%E6%96%B9%E5%BC%8F%E4%B8%80-amp-%E6%96%B9%E5%BC%8F%E4%BA%8C%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-text">③方式一&amp;方式二的对比</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-Thread%E7%B1%BB%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">C.Thread类常用方法的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0start"><span class="toc-text">①start()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1run"><span class="toc-text">②run()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2currentThread"><span class="toc-text">③currentThread()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A3getName"><span class="toc-text">④getName()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A4setName"><span class="toc-text">⑤setName()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A5yield"><span class="toc-text">⑥yield()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A6join"><span class="toc-text">⑦join()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A7stop"><span class="toc-text">⑧stop()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A8sleep-long-millis"><span class="toc-text">⑨sleep(long millis)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A9isAlive"><span class="toc-text">⑩isAlive()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#D-%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="toc-text">D.线程调度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5"><span class="toc-text">①调度策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E5%92%8C%E8%AE%BE%E7%BD%AE%E5%BD%93%E5%89%8D%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-text">②如何获取和设置当前线程的优先级</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#E-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">E.线程的生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#F-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-text">F.线程同步</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E5%BC%95%E8%A8%80"><span class="toc-text">①引言</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E5%AE%9E%E7%8E%B0%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E7%9A%84%E6%96%B9%E5%BC%8F%E4%B8%80%EF%BC%9A%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-text">②实现同步机制的方式一：同步代码块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2%E5%AE%9E%E7%8E%B0%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E2%80%94%E6%96%B9%E5%BC%8F%E4%BA%8C"><span class="toc-text">③实现同步机制—方式二</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A3%E5%A6%82%E4%BD%95%E5%88%A4%E5%AE%9A%E9%94%81%E5%8F%AA%E6%9C%89%E4%B8%80%E6%8A%8A"><span class="toc-text">④如何判定锁只有一把</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A4%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98"><span class="toc-text">⑤线程的死锁问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A5%E5%AE%9E%E7%8E%B0%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E2%80%93%E6%96%B9%E5%BC%8F%E4%B8%89"><span class="toc-text">⑥实现同步机制–方式三</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A6synchronized-%E4%B8%8E-Lock%E7%9A%84%E5%BC%82%E5%90%8C"><span class="toc-text">⑦synchronized 与 Lock的异同</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#G-%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="toc-text">G.线程的通信</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E6%B6%89%E5%8F%8A%E5%88%B0%E7%9A%84%E4%B8%89%E4%B8%AA%E6%96%B9%E6%B3%95"><span class="toc-text">①涉及到的三个方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E6%B3%A8%E6%84%8F"><span class="toc-text">②注意</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E4%BE%8B%E5%AD%90"><span class="toc-text">③线程通信例子</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#H-sleep-%E5%92%8Cwait-%E7%9A%84%E5%BC%82%E5%90%8C"><span class="toc-text">H.sleep()和wait()的异同</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I-JDK5-0%E6%96%B0%E5%A2%9E%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F%E2%80%93%E5%AE%9E%E7%8E%B0Callable%E6%8E%A5%E5%8F%A3"><span class="toc-text">I.JDK5.0新增线程创建方式–实现Callable接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4"><span class="toc-text">①实现步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E8%A1%A5%E5%85%85"><span class="toc-text">②补充</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#J-JDK5-0%E6%96%B0%E5%A2%9E%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F%E2%80%94%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">J.JDK5.0新增线程创建方式—使用线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E6%80%9D%E8%B7%AF"><span class="toc-text">①思路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-text">②使用线程池的好处</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4"><span class="toc-text">③实现步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A3%E8%A1%A5%E5%85%85%E8%AF%B4%E6%98%8E%EF%BC%9A"><span class="toc-text">④补充说明：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A4%E8%AE%BE%E7%BD%AE%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-text">⑤设置线程池的属性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#L-%E5%B0%8F%E7%BB%93"><span class="toc-text">L.小结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E9%87%8A%E6%94%BE%E9%94%81%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-text">①释放锁的操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E4%B8%8D%E4%BC%9A%E9%87%8A%E6%94%BE%E9%94%81%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-text">②不会释放锁的操作</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E5%B8%B8%E7%94%A8%E7%B1%BB"><span class="toc-text">2、常用类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#A-String%E7%B1%BB"><span class="toc-text">A.String类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E7%BB%99%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%B5%8B%E5%80%BC%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E4%B8%A4%E7%A7%8D"><span class="toc-text">①给字符串赋值的方式有两种</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E6%A6%82%E8%BF%B0"><span class="toc-text">②概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%A4%E7%A7%8D%E8%B5%8B%E5%80%BC%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">③字符串两种赋值方式的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A3%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-text">④面试题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A4%E5%AD%97%E9%9D%A2%E9%87%8F%E8%B5%8B%E5%80%BC%E7%9A%84%E7%BB%86%E8%8A%82"><span class="toc-text">⑤字面量赋值的细节</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A5intern"><span class="toc-text">⑥intern()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A6-String%E7%B1%BB%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">⑦.String类常用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A7String-%E4%B8%8E-char-%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-text">⑧String 与 char[]之间的转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A8String-%E4%B8%8Ebyte-%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-text">⑨String 与byte[]之间的转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A9String-%E5%92%8C-StringBuffer%E3%80%81StringBuilder%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-text">⑩String 和 StringBuffer、StringBuilder的转换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-StringBuffer%E7%B1%BB"><span class="toc-text">B.StringBuffer类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E5%88%9B%E5%BB%BA%E6%A0%BC%E5%BC%8F"><span class="toc-text">①创建格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">②常用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2%E8%A1%A5%E5%85%85"><span class="toc-text">③补充</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-StringBuilder%E7%B1%BB"><span class="toc-text">C.StringBuilder类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E5%88%9B%E5%BB%BA%E6%A0%BC%E5%BC%8F-1"><span class="toc-text">①创建格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-1"><span class="toc-text">②常用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2%E8%A1%A5%E5%85%85-1"><span class="toc-text">③补充</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#D-String-StringBuffer-StringBuilder%E4%B8%89%E8%80%85%E5%BC%82%E5%90%8C"><span class="toc-text">D.String StringBuffer StringBuilder三者异同</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#E-JDK8%E4%B9%8B%E5%89%8D%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4API"><span class="toc-text">E.JDK8之前日期时间API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0java-lang-System%E7%B1%BB"><span class="toc-text">①java.lang.System类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1java-util-Date%E7%B1%BB"><span class="toc-text">②java.util.Date类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2java-sql-Date%E7%B1%BB"><span class="toc-text">③java.sql.Date类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A3-SimpleDateFormat"><span class="toc-text">④.SimpleDateFormat</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A4Calendar%E6%97%A5%E5%8E%86%E7%B1%BB"><span class="toc-text">⑤Calendar日历类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#H-JDK8%E4%B8%AD%E6%96%B0%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4API"><span class="toc-text">H.JDK8中新日期时间API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E5%BC%95%E8%A8%80-1"><span class="toc-text">①引言</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1LocalDate%E3%80%81LocalTime%E3%80%81LocalDateTime%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">②LocalDate、LocalTime、LocalDateTime的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2Instant"><span class="toc-text">③Instant</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A3DateTimeFormatter"><span class="toc-text">④DateTimeFormatter</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A4%E5%85%B6%E4%BB%96%E4%B8%8E%E6%97%B6%E9%97%B4%E7%9B%B8%E5%85%B3%E7%9A%84API"><span class="toc-text">⑤其他与时间相关的API</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#J-Java%E6%AF%94%E8%BE%83%E5%99%A8"><span class="toc-text">J.Java比较器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E5%BC%95%E8%A8%80-2"><span class="toc-text">①引言</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1Comparable%E8%87%AA%E7%84%B6%E6%8E%92%E5%BA%8F"><span class="toc-text">②Comparable自然排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2Comparator-%E5%AE%9A%E5%88%B6%E6%8E%92%E5%BA%8F"><span class="toc-text">③Comparator 定制排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A3%E6%80%BB%E7%BB%93"><span class="toc-text">④总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#K-System%E7%B1%BB"><span class="toc-text">K.System类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E6%A6%82%E8%BF%B0"><span class="toc-text">①概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-text">②成员变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-text">③成员方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#L-Math%E7%B1%BB"><span class="toc-text">L.Math类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#M-BigInteger%E4%B8%8EBigDecimal%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-text">M.BigInteger与BigDecimal（了解）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0BigInteger%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86"><span class="toc-text">①BigInteger的基本知识</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1BigInteger%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">②BigInteger的常用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2BigDecimal%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86"><span class="toc-text">③BigDecimal的基本知识</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A3BigDecimal%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">④BigDecimal的常用方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#N-JDK8%E4%B9%8B%E5%89%8D-amp-JDK8%E4%B9%8B%E5%90%8E%E6%97%B6%E9%97%B4API%E7%9A%84%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB"><span class="toc-text">N.JDK8之前&amp;JDK8之后时间API的对应关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="toc-text">3、枚举类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#A-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">A.枚举类的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="toc-text">B.如何定义枚举类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%B8%80%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9E%9A%E4%B8%BE%E7%B1%BB%EF%BC%88%E5%B0%91%E7%94%A8%EF%BC%89"><span class="toc-text">方式一：自定义枚举类（少用）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%BA%8C%EF%BC%9A%E4%BD%BF%E7%94%A8enum%E5%85%B3%E9%94%AE%E5%AD%97%E5%AE%9A%E4%B9%89%E6%9E%9A%E4%B8%BE%E7%B1%BB%EF%BC%88%E5%B8%B8%E7%94%A8%EF%BC%89"><span class="toc-text">方式二：使用enum关键字定义枚举类（常用）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-Enum%E7%B1%BB%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">C.Enum类中的常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#D-%E4%BD%BF%E7%94%A8enum%E5%85%B3%E9%94%AE%E5%AD%97%E5%AE%9A%E4%B9%89%E7%9A%84%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-text">D.使用enum关键字定义的枚举类实现接口的情况</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%83%85%E5%86%B5%E4%B8%80"><span class="toc-text">情况一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%83%85%E5%86%B5%E4%BA%8C"><span class="toc-text">情况二</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E6%B3%A8%E8%A7%A3-Annotation"><span class="toc-text">4、注解(Annotation)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#A-%E6%A6%82%E8%BF%B0"><span class="toc-text">A.概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-text">B.注解的使用示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3"><span class="toc-text">C.如何自定义注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#D-JDK%E4%B8%AD%E7%9A%84%E5%85%83%E6%B3%A8%E8%A7%A3"><span class="toc-text">D.JDK中的元注解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E7%90%86%E8%A7%A3"><span class="toc-text">①理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E5%9B%9B%E4%B8%AA%E5%9F%BA%E6%9C%AC%E5%85%83%E6%B3%A8%E8%A7%A3%E2%80%94-Retention"><span class="toc-text">②四个基本元注解—-Retention</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2%E5%9B%9B%E4%B8%AA%E5%9F%BA%E6%9C%AC%E5%85%83%E6%B3%A8%E8%A7%A3%E2%80%94-Target"><span class="toc-text">③四个基本元注解—-Target</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A3%E5%9B%9B%E4%B8%AA%E5%9F%BA%E6%9C%AC%E5%85%83%E6%B3%A8%E8%A7%A3%E2%80%94-Documented"><span class="toc-text">④四个基本元注解—-Documented</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A4%E5%9B%9B%E4%B8%AA%E5%9F%BA%E6%9C%AC%E5%85%83%E6%B3%A8%E8%A7%A3%E2%80%94-Inherited"><span class="toc-text">⑤四个基本元注解—-Inherited</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#E-%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E6%B3%A8%E8%A7%A3%E4%BF%A1%E6%81%AF"><span class="toc-text">E.通过反射获取注解信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#F-JDK-8%E4%B8%AD%E6%B3%A8%E8%A7%A3%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-text">F.JDK 8中注解的新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E5%8F%AF%E9%87%8D%E5%A4%8D%E6%B3%A8%E8%A7%A3"><span class="toc-text">①可重复注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3"><span class="toc-text">②类型注解</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81Java%E9%9B%86%E5%90%88"><span class="toc-text">5、Java集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#A-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E7%9A%84%E6%A6%82%E8%BF%B0"><span class="toc-text">A.集合框架的概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6"><span class="toc-text">B.集合框架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-Collection%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">C.Collection接口中的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0-add-Object-obj"><span class="toc-text">① add(Object obj)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1-addAll-Collection-coll"><span class="toc-text">② addAll(Collection coll)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2size"><span class="toc-text">③size()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A3clear"><span class="toc-text">④clear()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A4isEmpty"><span class="toc-text">⑤isEmpty()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A5contains-Object-obj"><span class="toc-text">⑥contains(Object obj)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A6containsAll-Collection-coll1"><span class="toc-text">⑦containsAll(Collection coll1)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A7remove-Object-obj"><span class="toc-text">⑧remove(Object obj)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A8removeAll-Collection-coll1"><span class="toc-text">⑨removeAll(Collection coll1)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A9retainAll-Collection-coll1"><span class="toc-text">⑩retainAll(Collection coll1)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-equals-Object-obj"><span class="toc-text">11.equals(Object obj)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-hashCode"><span class="toc-text">12.hashCode()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-toArray-%E3%80%81%E6%95%B0%E7%BB%84%E9%9B%86%E5%90%88%E4%BA%92%E8%BD%AC"><span class="toc-text">13.toArray()、数组集合互转</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-iterator"><span class="toc-text">14.iterator()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#D-foreach"><span class="toc-text">D.foreach</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E6%A0%BC%E5%BC%8F"><span class="toc-text">①格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E5%8E%9F%E7%90%86"><span class="toc-text">②原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2%E4%BE%8B%E5%AD%90"><span class="toc-text">③例子</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#E-Collection%E5%AD%90%E6%8E%A5%E5%8F%A3%E4%B9%8B%E4%B8%80%EF%BC%9AList%E6%8E%A5%E5%8F%A3"><span class="toc-text">E.Collection子接口之一：List接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E4%B8%89%E4%B8%AA%E5%AE%9E%E7%8E%B0%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">①三个实现类的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BArrayList"><span class="toc-text">②底层源码分析之ArrayList</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BLinkedList"><span class="toc-text">③底层源码分析之LinkedList</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A3%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BVector"><span class="toc-text">④底层源码分析之Vector</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#F-List%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">F.List接口中的常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">总结：常用方法</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#G-Collection%E5%AD%90%E6%8E%A5%E5%8F%A3%E4%B9%8B%E4%BA%8C%EF%BC%9ASet%E6%8E%A5%E5%8F%A3"><span class="toc-text">G.Collection子接口之二：Set接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E6%A6%82%E8%BF%B0-1"><span class="toc-text">①概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E5%85%83%E7%B4%A0%E7%9A%84%E6%B7%BB%E5%8A%A0%E8%BF%87%E7%A8%8B"><span class="toc-text">②元素的添加过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2LinkedHashSet%E7%9A%84%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84"><span class="toc-text">③LinkedHashSet的底层结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A3%E4%B8%89%E4%B8%AA%E5%AE%9E%E7%8E%B0%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">④三个实现类的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A4TreeSet%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%8E%92%E5%BA%8F%E6%96%B9%E5%BC%8F"><span class="toc-text">⑤TreeSet的两种排序方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#H-List%E5%92%8CSet%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93"><span class="toc-text">H.List和Set的使用总结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0List%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93"><span class="toc-text">①List的使用总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1Set%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93"><span class="toc-text">②Set的使用总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#J-%E7%BB%83%E4%B9%A0"><span class="toc-text">J.练习</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E5%9C%A8List%E5%86%85%E5%8E%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E6%95%B0%E5%80%BC%E5%80%BC"><span class="toc-text">①在List内去除重复数值值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#K-Map%E6%8E%A5%E5%8F%A3"><span class="toc-text">K.Map接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E6%A6%82%E8%BF%B0-2"><span class="toc-text">①概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1Map%E7%BB%93%E6%9E%84%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">②Map结构的理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2HashMap%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">③HashMap的底层实现原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A3HashMap%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84%E9%87%8D%E8%A6%81%E5%B8%B8%E9%87%8F"><span class="toc-text">④HashMap源码中的重要常量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A4LinkedHashMap%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-text">⑤LinkedHashMap的底层实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A5TreeMap%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">⑥TreeMap的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A6Properties%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">⑦Properties的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#L-Map%E4%B8%AD%E5%AE%9A%E4%B9%89%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">L.Map中定义的方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E6%B7%BB%E5%8A%A0%E3%80%81%E5%88%A0%E9%99%A4%E3%80%81%E4%BF%AE%E6%94%B9%E6%93%8D%E4%BD%9C"><span class="toc-text">①添加、删除、修改操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E5%85%83%E7%B4%A0%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-text">②元素查询的操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2%E5%85%83%E8%A7%86%E5%9B%BE%E6%93%8D%E4%BD%9C%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%88%E5%8D%B3%E9%81%8D%E5%8E%86Map%EF%BC%89"><span class="toc-text">③元视图操作的方法（即遍历Map）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A3%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93"><span class="toc-text">④常用方法总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#M-Collections%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-text">M.Collections工具类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E5%8F%8D%E8%BD%AC"><span class="toc-text">①反转</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E6%8E%92%E5%BA%8F"><span class="toc-text">②排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2%E6%B1%82%E6%9C%80%E5%80%BC"><span class="toc-text">③求最值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A3%E8%AE%A1%E7%AE%97%E6%9F%90%E5%85%83%E7%B4%A0%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0"><span class="toc-text">④计算某元素出现的次数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A4%E5%A4%8D%E5%88%B6"><span class="toc-text">⑤复制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A5%E6%9B%BF%E6%8D%A2"><span class="toc-text">⑥替换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A6%E5%B0%86%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E9%9B%86%E5%90%88%E5%8F%98%E6%88%90%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%9B%86%E5%90%88"><span class="toc-text">⑦将线程不安全的集合变成线程安全集合</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81%E6%B3%9B%E5%9E%8B"><span class="toc-text">6、泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#A-%E5%BC%95%E5%85%A5"><span class="toc-text">A.引入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-%E5%9C%A8%E9%9B%86%E5%90%88%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B"><span class="toc-text">B.在集合中使用泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E6%98%8E"><span class="toc-text">说明</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B%E7%BB%93%E6%9E%84%E2%80%93%E6%B3%9B%E5%9E%8B%E7%B1%BB"><span class="toc-text">C.自定义泛型结构–泛型类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-text">①实现方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E4%B8%AD%E7%9A%84%E6%B3%9B%E5%9E%8B"><span class="toc-text">②继承关系中的泛型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2%E7%BB%86%E8%8A%82%E8%AF%B4%E6%98%8E"><span class="toc-text">③细节说明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A3%E5%BA%94%E7%94%A8"><span class="toc-text">④应用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#D-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B%E7%BB%93%E6%9E%84%E2%80%93%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3"><span class="toc-text">D.自定义泛型结构–泛型接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F-1"><span class="toc-text">①实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#E-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B%E7%BB%93%E6%9E%84%E2%80%93%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-text">E.自定义泛型结构–泛型方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E5%AE%9A%E4%B9%89"><span class="toc-text">①定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E6%A0%BC%E5%BC%8F"><span class="toc-text">②格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2%E4%BD%BF%E7%94%A8"><span class="toc-text">③使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A3%E6%B3%A8%E6%84%8F"><span class="toc-text">④注意</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#F-%E6%B3%9B%E5%9E%8B%E5%9C%A8%E7%BB%A7%E6%89%BF%E6%96%B9%E9%9D%A2%E7%9A%84%E4%BD%93%E7%8E%B0"><span class="toc-text">F.泛型在继承方面的体现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#E-%E9%80%9A%E9%85%8D%E7%AC%A6%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">E.通配符的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E5%AE%9A%E4%B9%89-1"><span class="toc-text">①定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E5%BA%94%E7%94%A8%E4%BE%8B%E5%AD%90"><span class="toc-text">②应用例子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2%E4%BD%BF%E7%94%A8-1"><span class="toc-text">③使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A3%E6%9C%89%E9%99%90%E5%88%B6%E6%9D%A1%E4%BB%B6%E7%9A%84%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-text">④有限制条件的通配符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A4%E5%85%B6%E4%BB%96"><span class="toc-text">⑤其他</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81IO%E6%B5%81"><span class="toc-text">7、IO流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#A-File%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">A.File类的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E6%A6%82%E8%BF%B0-3"><span class="toc-text">①概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86"><span class="toc-text">②预备知识</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2%E5%A6%82%E4%BD%95%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="toc-text">③如何实例化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-File%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">B.File类的常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E8%8E%B7%E5%8F%96%E7%9B%B8%E5%BA%94%E4%BF%A1%E6%81%AF"><span class="toc-text">①获取相应信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E9%87%8D%E5%91%BD%E5%90%8D%E5%8A%9F%E8%83%BD"><span class="toc-text">②重命名功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2%E5%88%A4%E6%96%AD%E5%8A%9F%E8%83%BD"><span class="toc-text">③判断功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A3%E5%9C%A8%E7%A1%AC%E7%9B%98%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%AF%B9%E5%BA%94%E7%9A%84%E6%96%87%E4%BB%B6%E6%88%96%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95"><span class="toc-text">④在硬盘中创建对应的文件或文件目录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A4%E5%88%A0%E9%99%A4%E7%A1%AC%E7%9B%98%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E6%88%96%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95"><span class="toc-text">⑤删除硬盘中的文件或文件目录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A5%E6%80%BB%E7%BB%93"><span class="toc-text">⑥总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-IO%E6%B5%81%E5%8E%9F%E7%90%86"><span class="toc-text">C.IO流原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E6%A6%82%E8%BF%B0-4"><span class="toc-text">①概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E6%B5%81%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">②流的分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2%E5%9B%9B%E4%B8%AA%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BB"><span class="toc-text">③四个抽象基类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A3IO%E6%B5%81%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-text">④IO流体系结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#E-%E8%8A%82%E7%82%B9%E6%B5%81%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">E.节点流的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E5%A6%82%E4%BD%95%E4%BB%8E%E7%A1%AC%E7%9B%98%E8%AF%BB%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="toc-text">①如何从硬盘读入数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E8%AF%BB%E5%85%A5%EF%BC%9Aread%E6%96%B9%E6%B3%95"><span class="toc-text">②读入：read方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2%E4%BB%8E%E5%86%85%E5%AD%98%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE%E5%88%B0%E7%A1%AC%E7%9B%98"><span class="toc-text">③从内存写入数据到硬盘</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A3%E5%86%99%E5%87%BA%EF%BC%9Awrite%E6%96%B9%E6%B3%95"><span class="toc-text">④写出：write方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A4%E6%B3%A8%E6%84%8F"><span class="toc-text">⑤注意</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A5%E8%A1%A5%E5%85%85"><span class="toc-text">⑥补充</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#F-%E7%BC%93%E5%86%B2%E6%B5%81"><span class="toc-text">F. 缓冲流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E6%A6%82%E8%BF%B0-5"><span class="toc-text">①概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E7%BC%93%E5%86%B2%E6%B5%81%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">②缓冲流的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2readLine"><span class="toc-text">③readLine()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A3%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BC%93%E5%86%B2%E6%B5%81%E8%83%BD%E6%8F%90%E9%AB%98%E9%80%9F%E5%BA%A6"><span class="toc-text">④为什么缓冲流能提高速度</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#G-%E8%BD%AC%E6%8D%A2%E6%B5%81"><span class="toc-text">G.转换流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E6%A6%82%E8%BF%B0-6"><span class="toc-text">①概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1InputStreamReader"><span class="toc-text">②InputStreamReader</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1OutputStreamWriter"><span class="toc-text">②OutputStreamWriter</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#H-%E5%AD%97%E7%AC%A6%E9%9B%86"><span class="toc-text">H.字符集</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E7%BC%96%E7%A0%81%E8%A1%A8"><span class="toc-text">①编码表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E5%B8%B8%E8%A7%81%E7%BC%96%E7%A0%81%E8%A1%A8"><span class="toc-text">②常见编码表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2%E5%90%AF%E7%A4%BA"><span class="toc-text">③启示</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I-%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E3%80%81%E8%BE%93%E5%87%BA%E6%B5%81-%E4%BA%86%E8%A7%A3"><span class="toc-text">I.标准输入、输出流(了解)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#J-%E6%89%93%E5%8D%B0%E6%B5%81-%E4%BA%86%E8%A7%A3"><span class="toc-text">J.打印流(了解)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E6%8A%8A%E6%8E%A7%E5%88%B6%E5%8F%B0%E4%B8%AD%E8%BE%93%E5%87%BA%E7%9A%84%E5%86%85%E5%AE%B9%E4%BF%9D%E5%AD%98%E5%88%B0%E6%96%87%E4%BB%B6"><span class="toc-text">①把控制台中输出的内容保存到文件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#K-%E6%95%B0%E6%8D%AE%E6%B5%81-%E4%BA%86%E8%A7%A3"><span class="toc-text">K.数据流(了解)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E6%A6%82%E8%BF%B0-7"><span class="toc-text">①概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">②数据流中的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">③数据流的使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#L-%E5%AF%B9%E8%B1%A1%E6%B5%81"><span class="toc-text">L.对象流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E6%A6%82%E8%BF%B0-8"><span class="toc-text">①概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96%E6%9C%BA%E5%88%B6"><span class="toc-text">②对象序列化机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2%E5%AF%B9%E8%B1%A1%E6%B5%81%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">③对象流的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A3%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8F%AF%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-text">④自定义类可序列化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#M-%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%8F%96%E6%96%87%E4%BB%B6%E6%B5%81%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-text">M.随机存取文件流（了解）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E6%A6%82%E8%BF%B0-9"><span class="toc-text">①概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1RandomAccessFile%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">②RandomAccessFile的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2%E8%AF%B4%E6%98%8E"><span class="toc-text">③说明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A3%E6%96%B9%E6%B3%95"><span class="toc-text">④方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A4%E5%BA%94%E7%94%A8"><span class="toc-text">⑤应用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#N-NIO-2%E4%B8%ADPath%E3%80%81Paths%E3%80%81Files%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-text">N.NIO.2中Path、Paths、Files类的使用（了解）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E7%90%86%E8%A7%A3-1"><span class="toc-text">①理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1Path"><span class="toc-text">②Path</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2Paths"><span class="toc-text">③Paths</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A3Files"><span class="toc-text">④Files</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#O-ByteArrayOutputStream"><span class="toc-text">O.ByteArrayOutputStream</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E6%A6%82%E8%BF%B0-10"><span class="toc-text">①概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1toString"><span class="toc-text">②toString()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2getBytes"><span class="toc-text">③getBytes()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A3%E4%BE%8B%E5%AD%90"><span class="toc-text">④例子</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-text">8、网络编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A0%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%A6%82%E8%BF%B0"><span class="toc-text">①网络编程概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#A-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9A%84%E7%9B%AE%E7%9A%84"><span class="toc-text">A.网络编程的目的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%AD%E6%9C%89%E4%B8%A4%E4%B8%AA%E4%B8%BB%E8%A6%81%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">B.网络编程中有两个主要的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E9%80%9A%E4%BF%A1%E8%A6%81%E7%B4%A01%E2%80%93IP%E5%92%8C%E7%AB%AF%E5%8F%A3%E5%8F%B7"><span class="toc-text">C.通信要素1–IP和端口号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#D-%E9%80%9A%E4%BF%A1%E8%A6%81%E7%B4%A02%E2%80%93%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE"><span class="toc-text">D.通信要素2–网络协议</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A1TCP%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-text">②TCP网络编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-text">客户端</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF"><span class="toc-text">服务器端</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A2UDP%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-text">③UDP网络编程（了解）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A3URL%E7%BC%96%E7%A8%8B"><span class="toc-text">④URL编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#A-URL"><span class="toc-text">A.URL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-%E5%AE%9E%E4%BE%8B%E5%8C%96URL%E5%AF%B9%E8%B1%A1"><span class="toc-text">B.实例化URL对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">C.常用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#D-%E7%94%A8%E4%BA%8E"><span class="toc-text">D.用于</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81%E5%8F%8D%E5%B0%84"><span class="toc-text">9、反射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A0%E5%BC%95%E5%85%A5"><span class="toc-text">①引入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A1%E5%8F%8D%E5%B0%84%E6%A6%82%E8%BF%B0"><span class="toc-text">②反射概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#A-Java%E6%98%AF%E5%87%86%E5%8A%A8%E6%80%81%E8%AF%AD%E8%A8%80"><span class="toc-text">A.Java是准动态语言</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-%E5%8F%8D%E5%B0%84%E6%8F%90%E4%BE%9B%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-text">B.反射提供的功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E7%9B%B8%E5%85%B3%E4%B8%BB%E8%A6%81API"><span class="toc-text">C.相关主要API</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A2%E5%85%B3%E4%BA%8Ejava-lang-Class%E7%B1%BB%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">③关于java.lang.Class类的理解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#A-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="toc-text">A.类的加载过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-%E8%8E%B7%E5%8F%96Class%E7%9A%84%E5%AE%9E%E4%BE%8B%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%88%E5%89%8D%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%E9%9C%80%E8%A6%81%E6%8E%8C%E6%8F%A1%EF%BC%89"><span class="toc-text">B.获取Class的实例的方式（前三种方式需要掌握）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E6%B3%A8%E6%84%8F"><span class="toc-text">C.注意</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#D-%E8%A1%A5%E5%85%85%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-text">D.补充（了解）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#E-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-text">E.类的加载器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A3%E5%88%9B%E5%BB%BA%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-text">④创建运行时类的对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A4%E4%BD%93%E4%BC%9A%E5%8F%8D%E5%B0%84%E7%9A%84%E5%8A%A8%E6%80%81%E6%80%A7"><span class="toc-text">⑤体会反射的动态性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A5%E8%8E%B7%E5%8F%96%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E5%AE%8C%E6%95%B4%E7%BB%93%E6%9E%84%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-text">⑥获取运行时类的完整结构（了解）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#A-%E8%8E%B7%E5%8F%96%E5%B1%9E%E6%80%A7%E7%BB%93%E6%9E%84"><span class="toc-text">A.获取属性结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-%E8%8E%B7%E5%8F%96%E6%96%B9%E6%B3%95%E7%BB%93%E6%9E%84"><span class="toc-text">B.获取方法结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E8%8E%B7%E5%8F%96%E6%9E%84%E9%80%A0%E5%99%A8%E7%BB%93%E6%9E%84"><span class="toc-text">C.获取构造器结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#D-%E8%8E%B7%E5%8F%96%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E7%88%B6%E7%B1%BB"><span class="toc-text">D.获取运行时类的父类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#E-%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E7%88%B6%E7%B1%BB%E7%9A%84%E6%B3%9B%E5%9E%8B"><span class="toc-text">E.获取当前运行时类的父类的泛型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#F-%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="toc-text">F.获取当前运行时类实现的接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#G-%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E6%89%80%E5%9C%A8%E7%9A%84%E5%8C%85"><span class="toc-text">G.获取当前运行时类所在的包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#H-%E8%8E%B7%E5%8F%96%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E5%A3%B0%E6%98%8E%E7%9A%84%E6%B3%A8%E8%A7%A3"><span class="toc-text">H.获取运行时类声明的注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9C%80%E8%A6%81%E9%87%8D%E7%82%B9%E4%BA%86%E8%A7%A3%E7%9A%84%E6%98%AF"><span class="toc-text">需要重点了解的是</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A6%E8%B0%83%E7%94%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E6%8C%87%E5%AE%9A%E7%BB%93%E6%9E%84"><span class="toc-text">⑦调用运行时类的指定结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#A-%E5%A6%82%E4%BD%95%E6%93%8D%E4%BD%9C%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E4%B8%AD%E6%8C%87%E5%AE%9A%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-text">A.如何操作运行时类中指定的属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-%E5%A6%82%E4%BD%95%E6%93%8D%E4%BD%9C%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E4%B8%AD%E6%8C%87%E5%AE%9A%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">B.如何操作运行时类中指定的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E5%A6%82%E4%BD%95%E8%B0%83%E7%94%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E4%B8%AD%E6%8C%87%E5%AE%9A%E7%9A%84%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-text">C.如何调用运行时类中指定的构造器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A7%E5%8F%8D%E5%B0%84%E5%BA%94%E7%94%A8%E2%80%93%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-text">⑧反射应用–动态代理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E6%A6%82%E8%BF%B0-11"><span class="toc-text">①概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0"><span class="toc-text">②静态代理实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0"><span class="toc-text">③动态代理实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%E3%80%81Java8%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-text">10、Java8的一些新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A0%E6%A6%82%E8%BF%B0-12"><span class="toc-text">①概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A1Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">②Lambda表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#A-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E4%B8%BE%E4%BE%8B"><span class="toc-text">A.Lambda表达式的举例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-%E6%A0%BC%E5%BC%8F"><span class="toc-text">B.格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">C.Lambda表达式的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#D-%E6%B3%A8%E6%84%8F"><span class="toc-text">D.注意</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#E-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">E.应用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A2%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-text">③函数式接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#A-%E5%AE%9A%E4%B9%89"><span class="toc-text">A.定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-Java%E5%86%85%E7%BD%AE%E5%9B%9B%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-text">B.Java内置四大核心函数式接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E7%BB%99%E5%AE%9A%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-text">C.如何使用给定的函数式接口</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A3%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8"><span class="toc-text">④方法引用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#A-%E4%BD%BF%E7%94%A8%E6%83%85%E6%99%AF"><span class="toc-text">A.使用情景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-%E6%A0%BC%E5%BC%8F-1"><span class="toc-text">B.格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E4%BD%BF%E7%94%A8%E8%A7%84%E5%88%99"><span class="toc-text">C.方法引用使用规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#D-%E5%85%B7%E4%BD%93%E4%B8%BE%E4%BE%8B"><span class="toc-text">D.具体举例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A4%E6%9E%84%E9%80%A0%E5%99%A8%E5%BC%95%E7%94%A8"><span class="toc-text">⑤构造器引用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#A-%E6%A6%82%E8%BF%B0-1"><span class="toc-text">A.概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-%E6%A0%BC%E5%BC%8F-2"><span class="toc-text">B.格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E6%9E%84%E9%80%A0%E5%99%A8%E5%BC%95%E7%94%A8%E8%A7%84%E5%88%99"><span class="toc-text">C.构造器引用规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#D-%E4%BE%8B%E5%AD%90"><span class="toc-text">D.例子</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A5%E6%95%B0%E7%BB%84%E5%BC%95%E7%94%A8%EF%BC%88%EF%BC%9F%EF%BC%89"><span class="toc-text">⑥数组引用（？）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#A-%E6%A0%BC%E5%BC%8F"><span class="toc-text">A.格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-%E4%BD%BF%E7%94%A8"><span class="toc-text">B.使用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11%E3%80%81Java8%E6%96%B0%E7%89%B9%E6%80%A7%E2%80%94Stream-API"><span class="toc-text">11、Java8新特性—Stream API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#A-%E6%A6%82%E8%BF%B0-2"><span class="toc-text">A.概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-Stream%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="toc-text">B.Stream实例化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%B8%80"><span class="toc-text">方式一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%BA%8C"><span class="toc-text">方式二</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%B8%89"><span class="toc-text">方式三</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%9B%9B%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-text">方法四（了解）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E4%B8%AD%E9%97%B4%E6%93%8D%E4%BD%9C%E2%80%93%E7%AD%9B%E9%80%89%E4%B8%8E%E5%88%87%E7%89%87"><span class="toc-text">C.中间操作–筛选与切片</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0filter-Predicate-p"><span class="toc-text">①filter(Predicate p)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1limit-n"><span class="toc-text">②limit(n)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2skip-n"><span class="toc-text">③skip(n)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A3distinct"><span class="toc-text">④distinct()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#D-%E4%B8%AD%E9%97%B4%E6%93%8D%E4%BD%9C%E2%80%93%E6%98%A0%E5%B0%84"><span class="toc-text">D.中间操作–映射</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0map-Function-f"><span class="toc-text">①map(Function f)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1flatMap-Function-f-%E4%B8%8D%E4%BC%9A"><span class="toc-text">②flatMap(Function f)     不会</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#E-%E4%B8%AD%E9%97%B4%E6%93%8D%E4%BD%9C%E2%80%93%E6%8E%92%E5%BA%8F"><span class="toc-text">E.中间操作–排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0sorted-%E8%87%AA%E7%84%B6%E6%8E%92%E5%BA%8F"><span class="toc-text">①sorted()  自然排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1sorted-Comparator-com-%E5%AE%9A%E5%88%B6%E6%8E%92%E5%BA%8F"><span class="toc-text">②sorted(Comparator com)  定制排序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#F-%E7%BB%88%E7%BB%93%E6%93%8D%E4%BD%9C%E2%80%93%E5%8C%B9%E9%85%8D%E4%B8%8E%E6%9F%A5%E6%89%BE"><span class="toc-text">F.终结操作–匹配与查找</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0allMatch-Predicate-p"><span class="toc-text">①allMatch(Predicate p)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1anyMatch-Predicate-p"><span class="toc-text">②anyMatch(Predicate p)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2noneMatch-Predicate-p"><span class="toc-text">③noneMatch(Predicate p)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A3findFirst"><span class="toc-text">④findFirst()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A4findAny"><span class="toc-text">⑤findAny()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A5count"><span class="toc-text">⑥count()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A6max-Comparator-c"><span class="toc-text">⑦max(Comparator c)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A7min-Comparator-c"><span class="toc-text">⑧min(Comparator c)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A8forEach-Consumer-c"><span class="toc-text">⑨forEach(Consumer c)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#G-%E7%BB%88%E7%BB%93%E6%93%8D%E4%BD%9C%E2%80%93%E8%A7%84%E7%BA%A6"><span class="toc-text">G.终结操作–规约</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0reduce-T-identity-BinaryOperator"><span class="toc-text">①reduce(T identity,BinaryOperator)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1reduce-BinaryOperator"><span class="toc-text">②reduce(BinaryOperator)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#H-%E7%BB%88%E7%BB%93%E6%93%8D%E4%BD%9C%E2%80%93%E6%94%B6%E9%9B%86"><span class="toc-text">H.终结操作–收集</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0collect-Collector-c"><span class="toc-text">①collect(Collector c)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12%E3%80%81Java8%E6%96%B0%E7%89%B9%E6%80%A7%E2%80%94Optional%E7%B1%BB"><span class="toc-text">12、Java8新特性—Optional类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A0%E6%A6%82%E8%BF%B0-13"><span class="toc-text">①概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A1Optional%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">②Optional类的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#A-%E5%88%9B%E5%BB%BAOptional%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">A.创建Optional类对象的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">B.常用方法</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/04/26/Java%E8%AF%AD%E6%B3%95%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/" title="Java语法（高级）"><img src="/./imgs/javayufafenmian.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java语法（高级）"/></a><div class="content"><a class="title" href="/2023/04/26/Java%E8%AF%AD%E6%B3%95%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/" title="Java语法（高级）">Java语法（高级）</a><time datetime="2023-04-26T10:51:27.000Z" title="发表于 2023-04-26 18:51:27">2023-04-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/04/24/%E5%BF%AB%E6%8D%B7%E9%94%AE/" title="快捷键"><img src="/./imgs/kuaijiejianfenmian.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="快捷键"/></a><div class="content"><a class="title" href="/2023/04/24/%E5%BF%AB%E6%8D%B7%E9%94%AE/" title="快捷键">快捷键</a><time datetime="2023-04-24T13:16:22.000Z" title="发表于 2023-04-24 21:16:22">2023-04-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/04/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9F%A5%E8%AF%86/" title="计算机知识"><img src="/./imgs/jishuanjizhishifenmian.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机知识"/></a><div class="content"><a class="title" href="/2023/04/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9F%A5%E8%AF%86/" title="计算机知识">计算机知识</a><time datetime="2023-04-24T13:11:01.000Z" title="发表于 2023-04-24 21:11:01">2023-04-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/04/24/java%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0/" title="Java语法基础概述"><img src="/./imgs/javayufafenmian.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java语法基础概述"/></a><div class="content"><a class="title" href="/2023/04/24/java%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0/" title="Java语法基础概述">Java语法基础概述</a><time datetime="2023-04-24T10:27:36.000Z" title="发表于 2023-04-24 18:27:36">2023-04-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/04/24/git/" title="Git"><img src="/./imgs/gitfenmian.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Git"/></a><div class="content"><a class="title" href="/2023/04/24/git/" title="Git">Git</a><time datetime="2023-04-24T08:32:11.000Z" title="发表于 2023-04-24 16:32:11">2023-04-24</time></div></div></div></div></div></div></main><footer id="footer" style="background: rgba(255,255,255, .0)"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By OrangeZzc</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><b>We can't change our fate,but we can do our best!</b></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"></div><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>