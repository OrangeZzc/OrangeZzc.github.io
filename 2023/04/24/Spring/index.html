<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Spring | Orange's Blog</title><meta name="author" content="OrangeZzc"><meta name="copyright" content="OrangeZzc"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、概述1.为什么要学Spring 2.学什么​	学IoC、AOP技术（这两个技术用于简化开发）、事务处理；学Spring如何与MyBatis进行框架整合。  3.如何学​	 4.Spring家族和Spring发展史 Spring家族 Spring不单是一门技术而是一堆技术的总称，Spring里包括了这些技术，如：Spring Framework（Spring框架，它是其它Spring技术的基础）">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring">
<meta property="og:url" content="https://orangezzc.github.io/2023/04/24/Spring/index.html">
<meta property="og:site_name" content="Orange&#39;s Blog">
<meta property="og:description" content="一、概述1.为什么要学Spring 2.学什么​	学IoC、AOP技术（这两个技术用于简化开发）、事务处理；学Spring如何与MyBatis进行框架整合。  3.如何学​	 4.Spring家族和Spring发展史 Spring家族 Spring不单是一门技术而是一堆技术的总称，Spring里包括了这些技术，如：Spring Framework（Spring框架，它是其它Spring技术的基础）">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://orangezzc.github.io/img/avater.jpeg">
<meta property="article:published_time" content="2023-04-24T08:31:24.000Z">
<meta property="article:modified_time" content="2023-04-24T14:37:40.517Z">
<meta property="article:author" content="OrangeZzc">
<meta property="article:tag" content="Spring">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://orangezzc.github.io/img/avater.jpeg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://orangezzc.github.io/2023/04/24/Spring/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":30},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: OrangeZzc","link":"链接: ","source":"来源: Orange's Blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Spring',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-24 22:37:40'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avater.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">27</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 学无止境</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: transparent"><nav id="nav"><span id="blog-info"><a href="/" title="Orange's Blog"><span class="site-name">Orange's Blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 学无止境</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Spring</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-04-24T08:31:24.000Z" title="发表于 2023-04-24 16:31:24">2023-04-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-04-24T14:37:40.517Z" title="更新于 2023-04-24 22:37:40">2023-04-24</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/SSM/">SSM</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">11.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>38分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Spring"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><h4 id="1-为什么要学Spring"><a href="#1-为什么要学Spring" class="headerlink" title="1.为什么要学Spring"></a>1.为什么要学Spring</h4><p><img src="/imgs/image-20221209134713389.png" alt="image-20221209134713389"></p>
<h4 id="2-学什么"><a href="#2-学什么" class="headerlink" title="2.学什么"></a>2.学什么</h4><p>​	学IoC、AOP技术（这两个技术用于简化开发）、事务处理；学Spring如何与MyBatis进行框架整合。</p>
<p><img src="/imgs/image-20230424213113214.png" alt="image-20230424213113214"></p>
<h4 id="3-如何学"><a href="#3-如何学" class="headerlink" title="3.如何学"></a>3.如何学</h4><p>​	<img src="/imgs/image-20221209135618342.png" alt="image-20221209135618342"></p>
<h4 id="4-Spring家族和Spring发展史"><a href="#4-Spring家族和Spring发展史" class="headerlink" title="4.Spring家族和Spring发展史"></a>4.Spring家族和Spring发展史</h4><ul>
<li>Spring家族<ul>
<li>Spring不单是一门技术而是一堆技术的总称，Spring里包括了这些技术，如：Spring Framework（Spring框架，它是其它Spring技术的基础）、Spring Boot、Spring Cloud等。</li>
</ul>
</li>
<li>Spring发展史<ul>
<li>其是由IBM公司中的EJB思想发展而来的，2004年正式推出Spring1.0（使用配置文件开发），2006年推出Spring2.0（引入注解开发），2009年推出了Spring3.0（可以使用纯注解开发），2013年推出了Spring4.0（根据JDK的版本对部分API进行调整），2017年推出Spring5.0（其完全支持JDK8.0版本）</li>
</ul>
</li>
</ul>
<hr>
<h2 id="二、Spring-Framework"><a href="#二、Spring-Framework" class="headerlink" title="二、Spring Framework"></a>二、Spring Framework</h2><h3 id="1-框架及学路线"><a href="#1-框架及学路线" class="headerlink" title="(1).框架及学路线"></a>(1).框架及学路线</h3><h5 id="A-框架"><a href="#A-框架" class="headerlink" title="A.框架"></a>A.框架</h5><p><img src="/imgs/image-20221209170603105.png" alt="image-20221209170603105"></p>
<ul>
<li><p>核心层</p>
<p>  Core Container：核心容器，这个模块是Spring最核心的模块，其他的都需要依赖该模块。其装的是一个一个的对象。</p>
</li>
<li><p>AOP(Aspect Oriented Programming)：面向切面编程，它依赖核心层容器，目的是在不改变原有代码的前提下对其进行功能增强。</p>
</li>
<li><p>Aspects：AOP是思想，Aspects是对AOP思想的具体实现。</p>
</li>
<li><p>Data Access：数据访问，Spring全家桶中有对数据访问的具体实现技术。</p>
</li>
<li><p>Data Integration：数据集成，Spring支持整合其他的数据层解决方案，比如Mybatis。</p>
</li>
<li><p>Transactions：事务，Spring中事务管理是Spring AOP的一个具体实现，也是后期学习的重点内容。</p>
</li>
<li><p>Web层</p>
<p>  这一层的内容将在SpringMVC框架具体学习。</p>
</li>
<li><p>Test层</p>
<p>  Spring主要整合了Junit来完成单元测试和集成测试。</p>
</li>
</ul>
<h5 id="B-学习路线"><a href="#B-学习路线" class="headerlink" title="B.学习路线"></a>B.学习路线</h5><p>​		Spring Framework学习路线：① –&gt; ② –&gt; ③ –&gt; ④ </p>
<p><img src="/imgs/image-20221209171058140.png" alt="image-20221209171058140"></p>
<hr>
<h3 id="2-核心容器"><a href="#2-核心容器" class="headerlink" title="(2).核心容器"></a>(2).核心容器</h3><h4 id="1-IOC相关内容"><a href="#1-IOC相关内容" class="headerlink" title="1.IOC相关内容"></a>1.IOC相关内容</h4><h5 id="A-概念"><a href="#A-概念" class="headerlink" title="A.概念"></a>A.概念</h5><h6 id="①引入"><a href="#①引入" class="headerlink" title="①引入"></a>①引入</h6><p>​	想在业务逻辑层中使用新的BookDaoImpl2，只能将原来业务逻辑层中的BookDao bookDao &#x3D; new BookDaoImpl1() 替换成 BookDao bookDao &#x3D; new BookDaoImpl2()。要想项目发生改变，还得重新编译运行、再重新部署到Tomcat。这样一套操作下来就非常麻烦，所以就得降低业务层的耦合度。</p>
<p><img src="/imgs/image-20221222133627213.png" alt="image-20221222133627213"></p>
<h6 id="②Ioc、Ioc容器、DI"><a href="#②Ioc、Ioc容器、DI" class="headerlink" title="②Ioc、Ioc容器、DI"></a>②Ioc、Ioc容器、DI</h6><ul>
<li><p>Ioc（Inversion of Control）控制反转</p>
<p>  为降低耦合度，由主动new产生对象转为由<strong>外部</strong>提供对象，而此过程此过程中对象创建控制权由程序转移到外部，此思想称为控制反转。</p>
</li>
<li><p>Ioc容器</p>
<ul>
<li><p>Spring实现了这种思想。而Ioc概念中提到的外部就是指Spring的<strong>核心容器</strong>，因此核心容器又被称为Ioc容器。</p>
</li>
<li><p>我们将来将对象放到容器中，Ioc容器就会在我们需要的时候自动将对象给我们。</p>
</li>
<li><p>IOC容器负责对象的创建、初始化等一系列工作，其中包含了数据层和业务层的类对象，被创建或被管理的对象在IOC容器中统称为<strong>Bean</strong>。</p>
</li>
</ul>
</li>
<li><p>DI（Dependency Injection）依赖注入</p>
<p>  在容器中建立bean与bean之间的依赖关系的整个过程，称为依赖注入。如：</p>
<p>  <img src="/imgs/image-20221222140136077.png" alt="image-20221222140136077"></p>
<p>  service对象需要依赖dao对象，因此我们需要手动将service对象与dao对象进行捆绑，形成一种依赖关系，当我们使用service对象时，就会自动将dao对象也传给我们了。</p>
</li>
<li><p>  <img src="/imgs/image-20221222140853003.png" alt="image-20221222140853003"></p>
</li>
</ul>
<hr>
<h5 id="B-Ioc入门案例"><a href="#B-Ioc入门案例" class="headerlink" title="B.Ioc入门案例"></a>B.Ioc入门案例</h5><h6 id="①思路分析"><a href="#①思路分析" class="headerlink" title="①思路分析"></a>①思路分析</h6><img src="/imgs/image-20230424213158959.png" alt="image-20230424213158959" style="zoom:67%;" />



<h6 id="②实现步骤"><a href="#②实现步骤" class="headerlink" title="②实现步骤"></a>②实现步骤</h6><p>1.导入Spring依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>2.创建Spring配置文件，配置对应类作为Spring管理的bean</p>
<ol>
<li><p>在resource下右键 –&gt; new –&gt; spring config –&gt; 命名为：applicationContext.xml。</p>
</li>
<li><p>使用bean标签。其里面有两个属性：</p>
<ul>
<li><p>class：写需要放到Ioc容器里的对象的全类名</p>
</li>
<li><p>id：用于唯一标识该bean对象。</p>
</li>
<li><p>例子：</p>
<p>  <img src="/imgs/image-20221222162003002.png" alt="image-20221222162003002"></p>
</li>
</ul>
</li>
</ol>
<p>3.获取Ioc容器对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Spring配置文件文件名 对象名 = new ClassPathXml Spring配置文件文件名(&quot;&quot;spring 配置文件的文件名.xml&quot;&quot;);</span></span><br><span class="line"><span class="comment">//例子：</span></span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;spring 配置文件的文件名.xml&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>4.获取Ioc容器中的bean对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用Ioc容器对象中的getBean(&quot;bean对象的id&quot;)</span></span><br><span class="line"><span class="type">BookService</span> <span class="variable">bookService</span> <span class="operator">=</span> (BookService) context.getBean(<span class="string">&quot;bookService&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>5.至此Ioc快速入门结束。</p>
<hr>
<h5 id="C-DI快速入门"><a href="#C-DI快速入门" class="headerlink" title="C.DI快速入门"></a>C.DI快速入门</h5><h6 id="①思路分析-1"><a href="#①思路分析-1" class="headerlink" title="①思路分析"></a>①思路分析</h6><img src="/imgs/image-20230424213235698.png" alt="image-20230424213235698" style="zoom:67%;" />



<h6 id="②实现步骤-1"><a href="#②实现步骤-1" class="headerlink" title="②实现步骤"></a>②实现步骤</h6><ol>
<li><p>删除BookServiceImpl中使用new的方式创建的dao对象</p>
 <img src="/imgs/image-20230424213245221.png" alt="image-20230424213245221" style="zoom:67%;" />

 
</li>
<li><p>在BookServiceImpl中提供bookDao的setter方法</p>
 <img src="/imgs/image-20230424213307440.png" alt="image-20230424213307440" style="zoom:67%;" />

<p> setBookDao方法会被谁调用？答案：Ioc容器</p>
</li>
<li><p>在配置文件中添加依赖注入的配置</p>
<p> 由于是在BookServiceImpl中调用Dao对象，所以就在Spring配置文件中bean对象BookServiceImpl里绑定dao对象。</p>
<p> <img src="/imgs/image-20221222174813428.png" alt="image-20221222174813428"></p>
<p> 如果对property标签中的name属性和ref属性不清楚，可以看如下图：</p>
<p> <img src="/imgs/image-20221222175446854.png" alt="image-20221222175446854"></p>
</li>
<li><p>至此DI快速入门结束</p>
</li>
</ol>
<hr>
<h5 id="D-bean基础配置"><a href="#D-bean基础配置" class="headerlink" title="D.bean基础配置"></a>D.bean基础配置</h5><h6 id="①bean别名"><a href="#①bean别名" class="headerlink" title="①bean别名"></a>①bean别名</h6><img src="/imgs/image-20230424213336864.png" alt="image-20230424213336864" style="zoom:80%;" />



<h6 id="②bean作用范围"><a href="#②bean作用范围" class="headerlink" title="②bean作用范围"></a>②bean作用范围</h6><ol>
<li><p>什么是bean的作用范围？</p>
<p> 控制bean实例创建的数量，即：在获取bean对象时，此对象与上一次获取的对象的地址不一样，或与上一次获取的对象的地址值一样。</p>
</li>
<li><p>如何设置bean的作用范围</p>
<p> 通过在bean标签中添加scope属性</p>
 <img src="/imgs/image-20230424213354750.png" alt="image-20230424213354750" style="zoom:80%;" />

 
</li>
<li><p>为什么Spring中bean的作用范围默认为单例？</p>
<p> ①如果作用范围为非单例，则每一次获取bean对象，Ioc容器就会创建一次该bean对象的实例，这样就会导致容器中出现很多实例，容器容量就会受到挑战。</p>
<p> ②我们一般会将dao层（数据库层对象）的对象等放到Ioc容器中，我们一般只会调用这些dao层对象中的方法，因此也就没有必要造不同bean对象的多个实例。</p>
</li>
<li><p> <img src="/imgs/image-20221223130304673.png" alt="image-20221223130304673"></p>
<p> <img src="/imgs/image-20221223130854910.png" alt="image-20221223130854910"></p>
</li>
</ol>
<h5 id="E-bean实例化"><a href="#E-bean实例化" class="headerlink" title="E.bean实例化"></a>E.bean实例化</h5><h6 id="①方式一：空参构造器"><a href="#①方式一：空参构造器" class="headerlink" title="①方式一：空参构造器"></a>①方式一：空参构造器</h6><p>​	如果像下面那样格式配置bean对象，则Ioc容器在创建bean对象时，使用bean对象所在类的<strong>空参构造器</strong>来创建对象的。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>​	如果bean对象所在类没有提供空参构造器，那么程序在运行时会报<strong>BeanCreationException</strong>。</p>
<h6 id="②方式二：静态工厂（了解）"><a href="#②方式二：静态工厂（了解）" class="headerlink" title="②方式二：静态工厂（了解）"></a>②方式二：静态工厂（了解）</h6><p>​	如果bean对象是通过静态工厂的形式创建对象，</p>
<p><img src="/imgs/image-20221223162241746.png" alt="image-20221223162241746"></p>
<p>​	则在配置bean对象时，就得像下面那样写：</p>
<p><img src="/imgs/image-20221223162508462.png" alt="image-20221223162508462"></p>
<p>​	</p>
<h6 id="③方式三：实例工厂（了解）"><a href="#③方式三：实例工厂（了解）" class="headerlink" title="③方式三：实例工厂（了解）"></a>③方式三：实例工厂（了解）</h6><p>​	如果使用下图中实例工厂的方式创建对象，	<img src="/imgs/image-20221223164538675.png" alt="image-20221223164538675"></p>
<p>​	则在配置bean时，就得这样写：</p>
<p><img src="/imgs/image-20221223165503978.png" alt="image-20221223165503978"></p>
<p>​	测试：</p>
<p><img src="/imgs/image-20221223165612561.png" alt="image-20221223165612561"></p>
<h6 id="④方式四：实例工厂–改进（理解掌握）"><a href="#④方式四：实例工厂–改进（理解掌握）" class="headerlink" title="④方式四：实例工厂–改进（理解掌握）"></a>④方式四：实例工厂–改进（理解掌握）</h6><p>​		方式三中，在配置bean时，存在以下问题：</p>
<p><img src="/imgs/image-20230424213429597.png" alt="image-20230424213429597"></p>
<p>​		因此Spring针对这些问题，作出了改进。</p>
<p>​	实现步骤：</p>
<ol>
<li><p>重新造一个实例工厂。该工厂类需继承FactoryBean接口，并重写两个方法。</p>
<p> <img src="/imgs/image-20221223181639044.png" alt="image-20221223181639044"></p>
<p> FactoryBean接口中还有一个方法：isSingleton()</p>
<p> ​	①该方法可以不重写</p>
<p> ​	②该方法的作用：设置创建的bean对象是否为单例</p>
<p> ​		如果想设置为非单例，则需重写isSingleton()</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> ​		如果想设置为单例，则不需要重新该方法，因为该方法默认返回的就是true。</p>
</li>
<li><p>配置bean</p>
<p> <img src="/imgs/image-20221223181917283.png" alt="image-20221223181917283"></p>
</li>
<li><p>完成</p>
</li>
</ol>
<p>​	<strong>这种配置方式在Spring去整合其他框架的时候会被用到，所以这种方式需要我们理解掌握。</strong></p>
<hr>
<h5 id="F-bean生命周期"><a href="#F-bean生命周期" class="headerlink" title="F.bean生命周期"></a>F.bean生命周期</h5><h6 id="①bean生命周期"><a href="#①bean生命周期" class="headerlink" title="①bean生命周期"></a>①bean生命周期</h6><p>​		bean从创建到销毁的整个过程。</p>
<p><img src="/imgs/image-20221224155358902.png" alt="image-20221224155358902"></p>
<h6 id="②bean生命周期控制"><a href="#②bean生命周期控制" class="headerlink" title="②bean生命周期控制"></a>②bean生命周期控制</h6><p>​		bean生命周期控制：在bean创建后到销毁前做一些事请。</p>
<ul>
<li><p>实现方式一：配置文件</p>
<ol>
<li><p>在bean对象所在类，里写两个方法：init()、destory()，分别代表在bean对象创建后进行初始化处理、在bean对象销毁前进行的操作。</p>
<p> <img src="/imgs/image-20221224143350212.png" alt="image-20221224143350212"></p>
</li>
<li><p>在配置文件中设置</p>
<p> <img src="/imgs/image-20221224143434785.png" alt="image-20221224143434785"></p>
<p> 这样设置完后，init()、destory()就会自动执行。</p>
</li>
<li><p>测试</p>
<p> <img src="/imgs/image-20221224143744234.png" alt="image-20221224143744234"></p>
<p> 测试结果中并没有执行destory方法，这是因为：程序结束后并没给机会给bean对象进行销毁操作。要想执行我们定义的destory方法，得调用容器对象（图中的ctx）中的close方法，而close方法在ApplicationContext接口中并没有定义，只在其子类中有定义，所以上图中的代码就变成这样：</p>
<p> <img src="/imgs/image-20221224144150770.png" alt="image-20221224144150770"></p>
<p> 这样做就能执行我们定义的destory方法了。</p>
<p> 但调用close方法属于暴力关闭容器的方式，所以我们也可以调用容器对象中的注册钩子方法来实现。注册钩子方法：该方法的作用就是在程序关闭之前，先将容器关闭掉。</p>
<p> <img src="/imgs/image-20221224144708464.png" alt="image-20221224144708464"></p>
<p> 补充：我们可以在程序中的任意位置调用注册钩子的方法。</p>
</li>
</ol>
<p>  总结：将来Tomcat会帮我们完成关闭容器的操作，所以对于关闭容器的close方法、注册钩子方法，我们了解即可。</p>
</li>
<li><p>实现方式二（了解）：bean对象所在类实现InitializingBean, DisposableBean接口</p>
<p>  这种方式是对方式一的简化，省去了在bean标签中设置init-method、destroy-method。</p>
<p>  <img src="/imgs/image-20230424214750024.png" alt="image-20230424214750024"></p>
<p>  程序在设置完bean对象的属性后就会自动执行afterPropertiesSet()方法进行bean的初始化操作，在容器销毁时就会自动执行destory方法，进行相应操作。</p>
</li>
</ul>
<hr>
<h4 id="2-DI相关内容"><a href="#2-DI相关内容" class="headerlink" title="2.DI相关内容"></a>2.DI相关内容</h4><h5 id="A-概述"><a href="#A-概述" class="headerlink" title="A.概述"></a>A.概述</h5><img src="/imgs/image-20230424214835715.png" alt="image-20230424214835715" style="zoom:80%;" />



<h5 id="B-依赖注入方式–setter注入"><a href="#B-依赖注入方式–setter注入" class="headerlink" title="B.依赖注入方式–setter注入"></a>B.依赖注入方式–setter注入</h5><h6 id="①引用类型"><a href="#①引用类型" class="headerlink" title="①引用类型"></a>①引用类型</h6><p><img src="/imgs/image-20221224165425695.png" alt="image-20221224165425695"></p>
<h6 id="②简单类型"><a href="#②简单类型" class="headerlink" title="②简单类型"></a>②简单类型</h6><p>​	简单类型（基本数据类型+String）</p>
<p><img src="/imgs/image-20221224171527451.png" alt="image-20221224171527451"></p>
<hr>
<h5 id="C-依赖注入方式–构造器注入"><a href="#C-依赖注入方式–构造器注入" class="headerlink" title="C.依赖注入方式–构造器注入"></a>C.依赖注入方式–构造器注入</h5><h6 id="①引用类型-1"><a href="#①引用类型-1" class="headerlink" title="①引用类型"></a>①引用类型</h6><img src="/imgs/image-20230424214907555.png" alt="image-20230424214907555" style="zoom:80%;" />

<p>​	</p>
<h6 id="②简单类型-1"><a href="#②简单类型-1" class="headerlink" title="②简单类型"></a>②简单类型</h6><p>​		简单类型（基本数据类型+String）</p>
<p><img src="/imgs/image-20221224175210101.png" alt="image-20221224175210101"></p>
<p>​	</p>
<h5 id="D-依赖注入方式选择"><a href="#D-依赖注入方式选择" class="headerlink" title="D.依赖注入方式选择"></a>D.依赖注入方式选择</h5><p>​	如果使用别人写的bean，那就看别人写的bean中提供什么，如果提供了setter和构造器，那就选setter注入；如果只提供构造器，那就用构造器注入。</p>
<p>​	自己开发过程中就使用setter注入。</p>
<hr>
<h5 id="E-依赖自动装配"><a href="#E-依赖自动装配" class="headerlink" title="E.依赖自动装配"></a>E.依赖自动装配</h5><h6 id="①概述"><a href="#①概述" class="headerlink" title="①概述"></a>①概述</h6><p>​	引入：手动实现依赖注入比较麻烦，那有没有自动完成依赖注入的功能呢？答案是有的，Spring就实现了自动完成依赖注入的功能。</p>
<p>​	自动装配：IOC容器根据bean所依赖的资源在容器中<strong>自动查找并注入到bean</strong>中的过程称为<strong>自动装配</strong>。</p>
<p>​	自动装配方式：①按类型（这种方式常用） ②按名称</p>
<p>​	</p>
<h6 id="②实现"><a href="#②实现" class="headerlink" title="②实现"></a>②实现</h6><ol>
<li><p>在bean所在类写对应set方法。</p>
 <img src="/imgs/image-20230424215005517.png" alt="image-20230424215005517" style="zoom:80%;" />
</li>
<li><p>在bean标签中使用autowire属性。</p>
<ol>
<li><p>按类型装配（推荐使用）</p>
<p> <img src="/imgs/image-20230424215022495.png" alt="image-20230424215022495"></p>
<p> 注意：</p>
<ol>
<li>既然是按类型注入了，那么bean对象的id属性写不写都无所谓了。</li>
<li>需要注入属性的类中对应属性的 setter 方法不能省略。</li>
<li>被注入的对象必须要被Spring的IOC容器管理，不然自动装配失败。</li>
<li>按照类型在Spring的IOC容器中如果找到多个对象，会报 NoUniqueBeanDefinitionException。</li>
</ol>
</li>
<li><p>按名称装配（不推荐使用）</p>
<p> <img src="/imgs/image-20230424215031081.png" alt="image-20230424215031081"></p>
<p> 注意：</p>
<ol>
<li>根据类中属性的名字来查找Ioc容器中是否有与其一样的id bean对象。</li>
<li>当找不到时，会注入Nul。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h6 id="③补充说明"><a href="#③补充说明" class="headerlink" title="③补充说明"></a>③补充说明</h6><p><img src="/imgs/image-20230104173549292.png" alt="image-20230104173549292"></p>
<hr>
<h5 id="F-集合注入"><a href="#F-集合注入" class="headerlink" title="F.集合注入"></a>F.集合注入</h5><h6 id="①引入-1"><a href="#①引入-1" class="headerlink" title="①引入"></a>①引入</h6><p>​		数组和集合的注入是不能实现依赖自动装配的，所以我们得学如何利用setter注入的方式实现数组和集合注入。</p>
<h6 id="②实现-1"><a href="#②实现-1" class="headerlink" title="②实现"></a>②实现</h6><p>​		环境准备：</p>
<img src="/imgs/image-20230424215056586.png" alt="image-20230424215056586" style="zoom:67%;" />

<img src="/imgs/image-20230424215113111.png" alt="image-20230424215113111" style="zoom:67%;" />



<ul>
<li><p>数组注入</p>
<p>  <img src="/imgs/image-20230105142635082.png" alt="image-20230105142635082"></p>
</li>
<li><p>List注入</p>
<p>  <img src="/imgs/image-20230105142658517.png" alt="image-20230105142658517"></p>
</li>
<li><p>Set注入</p>
<p>  <img src="/imgs/image-20230105142729594.png" alt="image-20230105142729594"></p>
</li>
<li><p>Map注入</p>
<p>  <img src="/imgs/image-20230105142824050.png" alt="image-20230105142824050"></p>
</li>
<li><p>Properties注入</p>
<p>  <img src="/imgs/image-20230105142948020.png" alt="image-20230105142948020"></p>
</li>
</ul>
<h6 id="③说明"><a href="#③说明" class="headerlink" title="③说明"></a>③说明</h6><ol>
<li>集合中要添加引用类型，只需要把<code>&lt;value&gt;</code>标签改成<code>&lt;bean ref=&quot;beanid&quot;&gt;</code>标签，这种方式用的比较少。</li>
<li>总的来说，集合注入在开发中很少使用，一般都是在框架的初始化时使用。</li>
</ol>
<hr>
<h4 id="3-IOC-x2F-DI配置管理第三方bean"><a href="#3-IOC-x2F-DI配置管理第三方bean" class="headerlink" title="3.IOC&#x2F;DI配置管理第三方bean"></a>3.IOC&#x2F;DI配置管理第三方bean</h4><h5 id="A-管理思路"><a href="#A-管理思路" class="headerlink" title="A.管理思路"></a>A.管理思路</h5><ol>
<li>先在pom.xml文件中导入，bean对象所需依赖。</li>
<li>观察该bean对象中的构造器及set方法，来选择使用构造器注入还是setter注入。</li>
<li>在IOC容器中编写bean对象。（如果不知道该bean对象的名字，就上网查）</li>
</ol>
<h5 id="B-例子"><a href="#B-例子" class="headerlink" title="B.例子"></a>B.例子</h5><p>​	如：数据源Druid(德鲁伊)，其bean对象是：DruidDataSource。（如果不知道bean对象的名字，就上网查）</p>
<p>​	实现步骤：</p>
<ol>
<li><p>先在pom.xml文件中导入bean对象所依赖的jar包。</p>
<p> <img src="/imgs/image-20230424215147588.png" alt="image-20230424215147588"></p>
</li>
<li><p>看一下bean对象 DruidDataSource 中的源码，来判断将来使用的是setter注入还是构造器注入。</p>
<p> bean对象 DruidDataSource 中的构造器如下：</p>
<p> <img src="/imgs/image-20230105155558861.png" alt="image-20230105155558861"></p>
<p> Druid是用来连接数据库的，连接数据库就需要知道：url（连接哪个数据库）、username、password等信息，显然无法通过构造器的形式就能配置完连接数据库所需要的信息，因此将来只能使用setter注入。而bean对象 DruidDataSource 中确实通过了关于username、password等属性的set方法。</p>
</li>
<li><p>在IOC容器中编写bean对象。</p>
<p> <img src="/imgs/image-20230105160140296.png" alt="image-20230105160140296"></p>
</li>
<li><p>完成。</p>
</li>
</ol>
<h5 id="C-加载properties文件"><a href="#C-加载properties文件" class="headerlink" title="C.加载properties文件"></a>C.加载properties文件</h5><h6 id="①引入-2"><a href="#①引入-2" class="headerlink" title="①引入"></a>①引入</h6><p>​		上面的例子中，在编写bean对象时，我们直接将数据库的连接信息写到了bean对象中，而之前我们都是将数据库的连接信息写到一个配置文件中，那如何在bean对象里加载这些配置文件呢？</p>
<h6 id="②实现-2"><a href="#②实现-2" class="headerlink" title="②实现"></a>②实现</h6><p>​	环境准备：</p>
<p><img src="/imgs/image-20230424215214860.png" alt="image-20230424215214860"></p>
<p>​	</p>
<p>​	<strong>开始：</strong></p>
<ol>
<li><p>在spring配置文件中加载配置文件。</p>
<ol>
<li><p>在spring配置文件中开启一个新的空间 context。</p>
<p> <img src="/imgs/image-20230424215222865.png" alt="image-20230424215222865"></p>
</li>
<li><p>在新开启的空间中加载需要的配置文件</p>
<p> <img src="/imgs/image-20230424215229482.png" alt="image-20230424215229482"></p>
<p> 当有多个properties配置文件需要被加载，该如何配置？见下面 补充：2。</p>
</li>
</ol>
</li>
<li><p>使用属性占位符${ } 读取properties配置文件中的属性。</p>
<p> <img src="/imgs/image-20230424215235940.png" alt="image-20230424215235940"></p>
</li>
<li><p>完成。</p>
</li>
</ol>
<h6 id="③补充"><a href="#③补充" class="headerlink" title="③补充"></a>③补充</h6><p>​	1.</p>
<img src="/imgs/image-20230424215302964.png" alt="image-20230424215302964" style="zoom:67%;" />

<p>​	<img src="/imgs/image-20230424215312650.png" alt="image-20230424215312650" style="zoom: 80%;" /></p>
<p>​	</p>
<p>​	2.</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--方式一 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;jdbc.properties,jdbc2.properties&quot;</span> <span class="attr">system-properties-mode</span>=<span class="string">&quot;NEVER&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--方式二--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;*.properties&quot;</span> <span class="attr">system-properties-mode</span>=<span class="string">&quot;NEVER&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--方式三 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:*.properties&quot;</span> <span class="attr">system-properties-mode</span>=<span class="string">&quot;NEVER&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--方式四--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath*:*.properties&quot;</span> <span class="attr">system-properties-mode</span>=<span class="string">&quot;NEVER&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--system-properties-mode=&quot;NEVER&quot;的说明见 补充：1--&gt;</span></span><br></pre></td></tr></table></figure>

<p>​	说明：</p>
<ol>
<li>方式一：可以实现，如果配置文件多的话，则需要写很多东西。</li>
<li>方式二：*.properties 代表所有以properties结尾的文件都会被加载，可以解决方式一的问题，但是不标准。</li>
<li>方式三：方式二的标准写法。classpath：代表的是从根路径下开始查找，但是只能查询当前项目的根路径。</li>
<li>方式四：不仅可以加载当前项目还可以加载当前项目所依赖的所有项目的根路径下的properties配置文件。</li>
</ol>
<hr>
<h4 id="4-核心容器"><a href="#4-核心容器" class="headerlink" title="4.核心容器"></a>4.核心容器</h4><h5 id="A-获取容器对象的两种方式"><a href="#A-获取容器对象的两种方式" class="headerlink" title="A.获取容器对象的两种方式"></a>A.获取容器对象的两种方式</h5><p><img src="/imgs/image-20230424215354115.png" alt="image-20230424215354115"></p>
<h5 id="B-获取bean对象的三种方式"><a href="#B-获取bean对象的三种方式" class="headerlink" title="B.获取bean对象的三种方式"></a>B.获取bean对象的三种方式</h5><p><img src="/imgs/image-20230424215403796.png" alt="image-20230424215403796"></p>
<h5 id="C-容器类层次结构"><a href="#C-容器类层次结构" class="headerlink" title="C.容器类层次结构"></a>C.容器类层次结构</h5><p><img src="/imgs/image-20230424215423906.png" alt="image-20230424215423906"></p>
<p>总结：</p>
<ol>
<li>ApplicataionContext接口的顶层接口是BeanFactory。</li>
<li>我们也可以BeanFactory接口来获取容器对象（但现在已经不这样做了），BeanFactory创建完毕后，所有的bean对象均为延迟加载。</li>
<li>通过ApplicationContext接口创建容器对象时，所有的bean对象均为立即加载。</li>
</ol>
<h4 id="5-核心容器总结"><a href="#5-核心容器总结" class="headerlink" title="5.核心容器总结"></a>5.核心容器总结</h4><h5 id="A-容器相关"><a href="#A-容器相关" class="headerlink" title="A.容器相关"></a>A.容器相关</h5><p><img src="/imgs/image-20230108162435652.png" alt="image-20230108162435652"></p>
<h5 id="B-bean相关"><a href="#B-bean相关" class="headerlink" title="B.bean相关"></a>B.bean相关</h5><p><img src="/imgs/image-20230424215449208.png" alt="image-20230424215449208"></p>
<h5 id="C-依赖注入相关"><a href="#C-依赖注入相关" class="headerlink" title="C.依赖注入相关"></a>C.依赖注入相关</h5><p><img src="/imgs/image-20230424215508976.png" alt="image-20230424215508976"></p>
<p>​	如果不懂，详见笔记：“DI相关内容”。</p>
<hr>
<h3 id="3-IOC-x2F-DI注解开发"><a href="#3-IOC-x2F-DI注解开发" class="headerlink" title="(3).IOC&#x2F;DI注解开发"></a>(3).IOC&#x2F;DI注解开发</h3><h4 id="1-引入"><a href="#1-引入" class="headerlink" title="1.引入"></a>1.引入</h4><p>​	Spring的IOC&#x2F;DI对应的配置开发就已经讲解完成，但是使用起来相对来说还是比较复杂的，复杂的地方在<code>配置文件</code>。<br>Spring到底是如何简化代码开发的呢?<br>要想真正简化开发，就需要用到Spring的注解开发，Spring对注解支持的版本历程:</p>
<ul>
<li>2.0版开始支持注解</li>
<li>2.5版注解功能趋于完善</li>
<li>3.0版支持纯注解开发</li>
</ul>
<p>关于注解开发，这里会讲解两块内容注解开发定义bean和纯注解开发。<br>注解开发定义bean用的是2.5版提供的注解，纯注解开发用的是3.0版提供的注解。</p>
<hr>
<h4 id="2-注解开发定义bean"><a href="#2-注解开发定义bean" class="headerlink" title="2.注解开发定义bean"></a>2.注解开发定义bean</h4><h5 id="A-环境准备"><a href="#A-环境准备" class="headerlink" title="A.环境准备"></a>A.环境准备</h5><ol>
<li><p>创建一个maven项目。</p>
</li>
<li><p>在pom.xml里添加spring依赖。</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在resources文件下添加applicationContext.xml spring配置文件。</p>
<p> 在resource下右键 –&gt; new –&gt; spring config –&gt; 命名为：applicationContext.xml。</p>
</li>
</ol>
<h5 id="B-注解开发定义bean实现"><a href="#B-注解开发定义bean实现" class="headerlink" title="B.注解开发定义bean实现"></a>B.注解开发定义bean实现</h5><ol>
<li><p>在需要被IOC容器管理的bean对象所在类的上面<strong>使用 @Component 注解</strong>。</p>
<p> 格式：<code>@Component(&quot;写bean的id&quot;)</code></p>
<p> 如：</p>
<p> <img src="/imgs/image-20230424220825573.png" alt="image-20230424220825573"></p>
<p> 补充：</p>
<p> ①如果在写@Component注解时没有配bean的 id ，则默认其 id 为当前类名首字母小，然后通过默认的bean id来获取bean对象，当然也可以通过类型来获取bean对象（见笔记：核心容器 –&gt; 核心容器–&gt; 获取bean对象的三种方式）。</p>
<p> ②通过注解的方式定义bean就代替了原来在spring配置文件中定义bean的方式。</p>
</li>
<li><p>配置Spring的注解包扫描。</p>
<p> 为了让Spring框架能够扫描到写在类上的注解，需要在配置文件上进行包扫描。</p>
<p> <img src="/imgs/image-20230424220839841.png" alt="image-20230424220839841"></p>
<p> 注意：在配置注解包扫描之前要先配置一个新的空间 context（上图中的①），然后再配置注解包扫描（上图中的②）。</p>
<p> 说明：</p>
<ul>
<li>component：组件，Spring将管理的bean视作自己的一个组件。</li>
<li>scan：扫描</li>
<li>base-package指定Spring框架扫描的包路径，它会扫描指定包及其子包中的所有类上的注解。</li>
<li>包路径越多如：com.blog.dao.impl，扫描的范围越小速度越快</li>
<li>包路径越少如：com.blog，扫描的范围越大速度越慢</li>
<li>一般扫描到项目的组织名称即Maven的groupId下如：com.blog即可。</li>
</ul>
<p> 补充：</p>
<p> <img src="/imgs/image-20230424220850887.png" alt="image-20230424220850887"></p>
</li>
</ol>
<hr>
<h4 id="3-纯注解开发"><a href="#3-纯注解开发" class="headerlink" title="3.纯注解开发"></a>3.纯注解开发</h4><h5 id="A-引入"><a href="#A-引入" class="headerlink" title="A.引入"></a>A.引入</h5><p>​	为了进一步简化开发，我们将使用配置类来代替配置文件，达到简化开发目的，如何编写配置类呢？见下面。</p>
<h5 id="B-环境准备"><a href="#B-环境准备" class="headerlink" title="B.环境准备"></a>B.环境准备</h5><p>​	在pom.xml里添加spring依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h5 id="C-纯注解开发实现"><a href="#C-纯注解开发实现" class="headerlink" title="C.纯注解开发实现"></a>C.纯注解开发实现</h5><ol>
<li><p>在Java文件夹下，<strong>新建一个包com.zzc.config</strong>用于放配置文件。在该包下<strong>建一个类，命名为SpringConfig</strong>。</p>
</li>
<li><p>在刚才新建的类上面使用 @Configuration 注解、@ComponentScan注解</p>
<p> <img src="/imgs/image-20230424220901903.png" alt="image-20230424220901903"></p>
<p> 说明：</p>
<p> ①@Configuration注解，将其标识为一个配置类，用于替换掉applicationContext.XML配置文件。</p>
<p> ②@ComponentScan用于替换原配置文件中的包扫描&lt;context:component-scan base-package&#x3D;””&#x2F;&gt;。</p>
</li>
<li><p>使用注解开发定义bean。（不懂？见笔记IOC&#x2F;DI注解开发 –&gt; 注解开发定义bean）</p>
</li>
<li><p>获取容器对象。使用<strong>AnnotationConfigApplicationContext</strong>类获取容器对象。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AnnotationConfigApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(spring配置类类名.class);</span><br><span class="line"><span class="comment">//例子：</span></span><br><span class="line"><span class="type">AnnotationConfigApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取bean对象。（跟以前一样）</p>
</li>
<li><p>完成。</p>
</li>
</ol>
<p>​	补充说明：</p>
<p>​	<img src="/imgs/image-20230424220914757.png" alt="image-20230424220914757"></p>
<hr>
<h4 id="4-注解开发bean的作用范围和生命周期"><a href="#4-注解开发bean的作用范围和生命周期" class="headerlink" title="4.注解开发bean的作用范围和生命周期"></a>4.注解开发bean的作用范围和生命周期</h4><h5 id="A-bean的作用范围"><a href="#A-bean的作用范围" class="headerlink" title="A.bean的作用范围"></a>A.bean的作用范围</h5><p>​	bean的作用范围：规定bean是单例还是非单例</p>
<p>​	在bean对象所在类上面使用@scope注解即可。scope的值可以为：singleton（单例），prototype（非单例）。</p>
<p><img src="/imgs/image-20230424220923504.png" alt="image-20230424220923504"></p>
<p>​	如果不写@Sope注解或写@Scope注解但没标名是singleton、prototype，这种情况下默认是singleton。</p>
<h5 id="B-bean的生命周期"><a href="#B-bean的生命周期" class="headerlink" title="B.bean的生命周期"></a>B.bean的生命周期</h5><p>​	在bean对象所在类里声明两个方法。（这两个方法名可以随便取）</p>
<img src="C:\Users\橙子\AppData\Roaming\Typora\typora-user-images\image-20230110115439171.png" alt="image-20230110115439171" style="zoom:80%;" />

<p>​	然后分别在这两个方法上面<strong>使用@PostConstruct 和 @PreDestroy注解即可。用于表明这两个方法分别为初始化方法和销毁方法。</strong></p>
<img src="/imgs/image-20230424220953700.png" alt="image-20230424220953700" style="zoom:67%;" />



<h5 id="C-补充"><a href="#C-补充" class="headerlink" title="C.补充"></a>C.补充</h5><p><img src="/imgs/image-20230110120116362.png" alt="image-20230110120116362"></p>
<hr>
<h4 id="5-注解开发依赖注入"><a href="#5-注解开发依赖注入" class="headerlink" title="5.注解开发依赖注入"></a>5.注解开发依赖注入</h4><h5 id="A-引入-1"><a href="#A-引入-1" class="headerlink" title="A.引入"></a>A.引入</h5><p>​	在纯注解开发阶段，spring只提供了自动装配的注入方式，因为setter注入及构造器注入不再符合简化开发的理念，所以spring就把setter注入及构造器注入给阉割掉了。</p>
<h5 id="B-注解实现按照类型注入"><a href="#B-注解实现按照类型注入" class="headerlink" title="B.注解实现按照类型注入"></a>B.注解实现按照类型注入</h5><p>​	使用**@Autowired注解<strong>，并且</strong>不用写对应的set方法**，如：</p>
<img src="/imgs/image-20230424221008755.png" alt="image-20230424221008755" style="zoom:67%;" />

<p>​			<strong>注意：</strong>使用自动装配时，<strong>bean对象所在的类要提供无参的构造器</strong>，不然IOC容器无法创造该bean对象。</p>
<p><img src="/imgs/image-20230424221023146.png" alt="image-20230424221023146"></p>
<hr>
<h5 id="C-注解实现按照名称注入"><a href="#C-注解实现按照名称注入" class="headerlink" title="C.注解实现按照名称注入"></a>C.注解实现按照名称注入</h5><p>​	使用@Autowired 和 @Qualifier注解，并且也不需要对应的set方法，如：</p>
<img src="/imgs/image-20230424221036509.png" alt="image-20230424221036509" style="zoom:67%;" />

<p>​	注意：</p>
<p>​	①**@Qualifier不能独立使用，必须和@Autowired一起使用**</p>
<p>​	②<strong>注意：</strong>使用自动装配时，<strong>bean对象所在的类要提供无参的构造器</strong>，不然IOC容器无法创造该bean对象。</p>
<hr>
<h5 id="D-简单数据类型注入"><a href="#D-简单数据类型注入" class="headerlink" title="D.简单数据类型注入"></a>D.简单数据类型注入</h5><p>​	使用@value注解，如：</p>
<p><img src="/imgs/image-20230424221050237.png" alt="image-20230424221050237"></p>
<p>​	简单数据类型：int、string、char、boolean等。</p>
<hr>
<h5 id="E-注解读取properties配置文件"><a href="#E-注解读取properties配置文件" class="headerlink" title="E.注解读取properties配置文件"></a>E.注解读取properties配置文件</h5><h6 id="①环境准备"><a href="#①环境准备" class="headerlink" title="①环境准备"></a>①环境准备</h6><p>​	<img src="/imgs/image-20230424221100366.png" alt="image-20230424221100366" style="zoom:67%;" /></p>
<h6 id="②实现-3"><a href="#②实现-3" class="headerlink" title="②实现"></a>②实现</h6><ol>
<li><p>在<strong>spring配置类</strong>上面<strong>使用 @PropertySource 注解</strong>，再写上配置文件的路径（从resources下开始写）。</p>
<p> <img src="/imgs/image-20230424221119598.png" alt="image-20230424221119598"></p>
</li>
<li><p>使用 <strong>${ }</strong> 读取配置文件中的数据，如：</p>
<p> <img src="/imgs/image-20230424221126651.png" alt="image-20230424221126651"></p>
</li>
</ol>
<h6 id="③补充说明-1"><a href="#③补充说明-1" class="headerlink" title="③补充说明"></a>③补充说明</h6><img src="/imgs/image-20230424221140015.png" alt="image-20230424221140015" style="zoom:67%;" />



<hr>
<h4 id="6-IOC-x2F-DI注解开发管理第三方bean"><a href="#6-IOC-x2F-DI注解开发管理第三方bean" class="headerlink" title="6.IOC&#x2F;DI注解开发管理第三方bean"></a>6.IOC&#x2F;DI注解开发管理第三方bean</h4><h5 id="A-管理第三方bean"><a href="#A-管理第三方bean" class="headerlink" title="A.管理第三方bean"></a>A.管理第三方bean</h5><h6 id="①环境准备-1"><a href="#①环境准备-1" class="headerlink" title="①环境准备"></a>①环境准备</h6><p>​		在pom.xml文件中导入被管理bean所需要的jar包。如：此次需要管理的是阿里公司提供的数据源druid中的 DruidDataSource对象。</p>
<p><img src="/imgs/image-20230424221156814.png" alt="image-20230424221156814"></p>
<h6 id="②操作"><a href="#②操作" class="headerlink" title="②操作"></a>②操作</h6><ol>
<li><p>在java文件夹下的com.itheima.config包下新建一个配置类，命名为：xxxConfig。</p>
</li>
<li><p>在新建配置类里定义一个方法获取要管理的对象，<strong>方法名</strong>最好命名为：bean对象的id，返回值类型：该bean对象的类型，该方法不需要参数。在方法里通过new的方式造该bean对象，如果需要对该对象的属性进行赋值，就掉该对象相应的方法进行赋值。最后在该方法上面使用@bean注解（表明当前方法的返回值类型是一个bean）。</p>
<p> <img src="/imgs/image-20230424221211228.png" alt="image-20230424221211228"></p>
<p> ​	补充：通过@bean注解来声明bean对象的id，@bean(“bean 的id”)。</p>
</li>
<li><p>加载该配置类到spring配置文件中。</p>
<ul>
<li><p><strong>方式一：</strong>导入式（推荐使用）</p>
<p>  使用@Import(“新建配置类类名.class”)注解</p>
<p>  <img src="/imgs/image-20230424221222205.png" alt="image-20230424221222205"></p>
<p>  注意：</p>
<p>  <img src="/imgs/image-20230424221229170.png" alt="image-20230424221229170"></p>
</li>
<li><p><strong>方式二：</strong>包扫描（这种方式<strong>不推荐使用</strong>，因为在使用@ComponentScan注解扫描包时，不知道具体扫描了哪些配置类）</p>
<p>  ①在刚才新建的配置类上面加上 @Configuration注解。</p>
<p>  ②在spring配置类上面加个@ComponentScan(“新建配置类所在包的名字”) 注解</p>
<p>  <img src="/imgs/image-20230424221237332.png" alt="image-20230424221237332"></p>
</li>
</ul>
</li>
</ol>
<hr>
<h5 id="B-为第三方bean实现依赖注入"><a href="#B-为第三方bean实现依赖注入" class="headerlink" title="B.为第三方bean实现依赖注入"></a>B.为第三方bean实现依赖注入</h5><h6 id="①简单数据类型"><a href="#①简单数据类型" class="headerlink" title="①简单数据类型"></a>①简单数据类型</h6><p>​		使用<code>@Value</code>注解</p>
<img src="/imgs/image-20230424221246456.png" alt="image-20230424221246456" style="zoom:67%;" />

<p>​		</p>
<p>​		拓展：</p>
<p>​		现在的数据库连接四要素还是写在代码中，需要做的是将这些内容提取到jdbc.properties配置文件，在上面我们已经实现过了，这里再来复习一遍。</p>
<p><img src="/imgs/image-20230424221409552.png" alt="image-20230424221409552"></p>
<p><img src="/imgs/image-20230424221425302.png" alt="image-20230424221425302"></p>
<h6 id="②引用数据类型"><a href="#②引用数据类型" class="headerlink" title="②引用数据类型"></a>②引用数据类型</h6><p>​	假如上面的第三方bean dataSource里需要注入一个对象bookDao，那怎么做？</p>
<ol>
<li><p>首先IOC容器中有bookDao这个对象。</p>
<p> 当bookDao属于自己定义的bean时，使用@ComponentScan注解将其放到IOC容器，如果bookDao属于第三方bean，则使用@Import注解将其放到IOC容器中。</p>
</li>
<li><p>在获得dataSource bean对象的那个方法的形参中写参数如：</p>
<p> <img src="/imgs/image-20230424221447976.png" alt="image-20230424221447976"></p>
<p> 参数名可以随便起</p>
</li>
</ol>
<p><img src="/imgs/image-20230424221458680.png" alt="image-20230424221458680"></p>
<hr>
<h4 id="7-注解开发总结"><a href="#7-注解开发总结" class="headerlink" title="7.注解开发总结"></a>7.注解开发总结</h4><p><img src="/imgs/image-20230424221514445.png" alt="image-20230424221514445"></p>
<hr>
<h3 id="4-Spring整合"><a href="#4-Spring整合" class="headerlink" title="(4).Spring整合"></a>(4).Spring整合</h3><h4 id="1-Spring整合MyBatis"><a href="#1-Spring整合MyBatis" class="headerlink" title="1.Spring整合MyBatis"></a>1.Spring整合MyBatis</h4><h5 id="A-思路分析"><a href="#A-思路分析" class="headerlink" title="A.思路分析"></a>A.思路分析</h5><ol>
<li><p>Mybatis程序核心中哪些对象可以交给Spring进行管理呢？</p>
<p> 从图中可以获取到，真正需要交给Spring管理的是SqlSessionFactory。因为有了SqlSessionFactory才有SqlSession。</p>
 <img src="/imgs/image-20230424221527670.png" alt="image-20230424221527670" style="zoom:67%;" />

 
</li>
<li><p>SqlSessionFactory是怎么来的呢？</p>
<p> 其是由mybatis核心配置文件得来的，而mybatis核心配置文件中最重要的是下图中红色框部分。</p>
<p> <img src="/imgs/image-20230424221539305.png" alt="image-20230424221539305"></p>
</li>
</ol>
<h5 id="B-环境准备-1"><a href="#B-环境准备-1" class="headerlink" title="B.环境准备"></a>B.环境准备</h5><p>​	①在resources文件夹下建一个文件，命名为：jdbc.properties。</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jdbc.driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">jdbc.url</span>=<span class="string">jdbc:mysql://localhost:13306/spring_db</span></span><br><span class="line"><span class="attr">jdbc.username</span>=<span class="string">连接数据库的用户名</span></span><br><span class="line"><span class="attr">jdbc.password</span>=<span class="string">数据库密码</span></span><br></pre></td></tr></table></figure>

<p>​	</p>
<h5 id="C-实现"><a href="#C-实现" class="headerlink" title="C.实现"></a>C.实现</h5><ol>
<li><p>导入Spring整合MyBatis的相关依赖。</p>
<p> 在pom.xml文件中导入如下jar包：</p>
 <img src="/imgs/image-20230424221634238.png" alt="image-20230424221634238" style="zoom: 80%;" />

 <img src="/imgs/image-20230424221645538.png" alt="image-20230424221645538" style="zoom:80%;" />

<p> ​	说明：Spring整合其它框架时，都是由其它框架提供与Spring的整合包的，因为Spring并不懂其它框架的内容，因此Spring只需要提供一些接口，让其它框架按照这些接口制定整合包就行。</p>
</li>
<li><p>在Java文件夹下建com.zzc.config包，在该包下建Spring的配置类。</p>
<p> <img src="/imgs/image-20230115111501577.png" alt="image-20230115111501577"></p>
</li>
<li><p>将阿里公司提供的数据库连接池技术Druid中的对象<strong>DataSource</strong>放到IOC容器中。</p>
<p> ①在Java文件夹下的com.zzc.config包下建一个配置类，命名为JdbcConfig。</p>
<p> ②在Spring配置类上使用@PropertySource(“配置文件地址（从resources下开始些）”)，加载jdbc.properties配置文件。</p>
<p> ③编写该配置类。</p>
<p> <img src="/imgs/image-20230114204219460.png" alt="image-20230114204219460"></p>
<p> ④在Spring配置类上使用@Import注解将dataSource对象放到IOC容器中。</p>
<p> <img src="/imgs/image-20230114204446812.png" alt="image-20230114204446812"></p>
</li>
<li><p>将MyBatis核心程序中的<strong>SqlSessionFactory</strong>对象放到IOC容器中。</p>
</li>
</ol>
<p>  ①在com.zzc.config包下建一个配置类，类名为：MyBatisConfig。</p>
<p>  ②编写该配置类</p>
  <img src="/imgs/image-20230424221737721.png" alt="image-20230424221737721" style="zoom: 67%;" />

<p>  ​</p>
<p><code>说明：</code></p>
<ul>
<li><p>SqlSessionFactoryBean是FactoryBean的一个子类，在该类中将SqlSessionFactory的创建进行了封装，简化对象的创建，我们只需要将其需要的内容设置即可。</p>
</li>
<li><p>方法中有一个参数为dataSource，当前Spring容器中已经创建了Druid数据源，类型刚好是DataSource类型，此时在初始化SqlSessionFactoryBean这个对象的时候，发现需要使用DataSource对象，而容器中刚好有这么一个对象，就自动加载了DruidDataSource对象。</p>
</li>
<li><p>MyBatisConfig配置类中代码与MyBatis核心配置文件中代码的对应关系。</p>
<p>  <img src="/imgs/image-20230114211231900.png" alt="image-20230114211231900"></p>
<p>  <img src="/imgs/image-20230114212513308.png" alt="image-20230114212513308"></p>
<p>  说明：</p>
</li>
<li><p>这个MapperScannerConfigurer对象也是MyBatis提供的专用于整合的jar包中的类，用来处理原始配置文件中的mappers相关配置，<strong>加载数据层的Mapper接口类</strong>。</p>
</li>
<li><p>MapperScannerConfigurer有一个核心属性basePackage，就是用来设置所扫描的包路径。</p>
</li>
<li><p><img src="/imgs/image-20230224180743437.png" alt="image-20230224180743437"></p>
</li>
</ul>
<p>  ③将该bean对象放到IOC容器中。</p>
<p>  <img src="/imgs/image-20230114210118992.png" alt="image-20230114210118992"></p>
<ol start="5">
<li><p>修改Service层实现类中的部分代码</p>
<p>   未引入Spring框架时，Service层想调用数据层中的代码得这样写：</p>
<p>   <img src="/imgs/image-20230114233337396.png" alt="image-20230114233337396"></p>
<p>   但有了Spring之后，就可以这样写：</p>
<p> <img src="/imgs/image-20230114234840200.png" alt="image-20230114234840200"></p>
<p>  解释说明：</p>
<p>   为什么UserMapper对象可以通过@Autowired自动装配完成依赖注入？</p>
<p>   当执行到MyBatisConfig配置类中的如下代码时：</p>
<p>   <img src="/imgs/image-20230424221944044.png" alt="image-20230424221944044"></p>
<p>  Mapper包下的相关接口类就会全部加载，也就是说UserMapper这个对象就会被放到IOC容器中，因此就可以完成自动装配。</p>
<p> 自动代理出的实现类对象	</p>
</li>
<li><p>运行测试</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//加载Spring配置类，获取容器对象</span></span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> context.getBean(UserService.class);<span class="comment">//从IOC容器获取service对象</span></span><br><span class="line">        List&lt;User&gt; users = userService.selectAll();<span class="comment">//执行service对象中的方法</span></span><br><span class="line">        System.out.println(users);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p>将原来MyBatis核心配置文件删掉即可，完成。</p>
</li>
</ol>
<hr>
<h4 id="2-Spring整合JUnit"><a href="#2-Spring整合JUnit" class="headerlink" title="2.Spring整合JUnit"></a>2.Spring整合JUnit</h4><p>​	实现步骤：</p>
<p>​	①在pom.xml文件中导入JUnit依赖和Spring整合JUnit的依赖。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​	②在test文件夹下建一个com.zzc.service包专门用来放测试service层的类。</p>
<p>​		在该包下建一个AccountServiceTest测试类。</p>
<p><img src="/imgs/image-20230115135058631.png" alt="image-20230115135058631"></p>
<p>​	③编写AccountServiceTest测试类。</p>
<p>​		使用@RunWith和@ContextConfiguration注解</p>
<p><img src="/imgs/image-20230115135650844.png" alt="image-20230115135650844"></p>
<p>​	④编写测试方法。使用@Test注解。</p>
<p><img src="/imgs/image-20230424222132054.png" alt="image-20230424222132054"></p>
<p>​		<strong>注意:</strong></p>
<ul>
<li>单元测试，如果测试的是注解配置类，则使用@ContextConfiguration(classes &#x3D; 配置类.class)。</li>
<li>单元测试，如果测试的是配置文件，则使用@ContextConfiguration(locations&#x3D;{配置文件名,…})。</li>
<li>Spring整合Junit后，Junit运行后是基于Spring环境运行的，所以Spring提供了一个专用的类运行器，这个务必要设置，这个类运行器就在Spring的测试专用包中提供的，导入的坐标就是这个东西SpringJUnit4ClassRunner。</li>
<li>上面两个配置都是固定格式，当需要测试哪个bean时，使用自动装配加载对应的对象，下面的工作就和以前做Junit单元测试完全一样了</li>
</ul>
<hr>
<h3 id="5-AOP"><a href="#5-AOP" class="headerlink" title="(5).AOP"></a>(5).AOP</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h4><h5 id="A-引入-2"><a href="#A-引入-2" class="headerlink" title="A.引入"></a>A.引入</h5><p>​	前面我们在介绍Spring的时候说过，Spring有两个核心的概念，一个是<code>IOC/DI</code>，一个是<code>AOP</code>。</p>
<p>​	前面已经对<code>IOC/DI</code>进行了系统的学习，接下来要学习它的另一个核心内容，就是<code>AOP</code>。</p>
<h5 id="B-AOP简介"><a href="#B-AOP简介" class="headerlink" title="B.AOP简介"></a>B.AOP简介</h5><ul>
<li>AOP(Aspect Oriented Programming)是一种面向切面编程的思想。<ul>
<li>我们之前学的OOP(Object Oriented Programming)面向对象编程 也是一种编程思想。</li>
</ul>
</li>
<li>AOP作用：<strong>在不惊动原始设计的基础上为其进行功能增强。即：在不修改原始代码的情况下就能实现功能增强。</strong></li>
<li>“在不修改原始代码的情况下就能实现功能增强” 这体现了：Spring的 “无入侵式” 或 “无侵入式” 的思想。</li>
</ul>
<h5 id="C-AOP概念介绍"><a href="#C-AOP概念介绍" class="headerlink" title="C.AOP概念介绍"></a>C.AOP概念介绍</h5><h6 id="①引入-3"><a href="#①引入-3" class="headerlink" title="①引入"></a>①引入</h6><img src="/imgs/image-20230424222206394.png" alt="image-20230424222206394" style="zoom:67%;" />

<p>代码的内容很简单，就是测试一下万次执行的耗时<br>当在App类中从容器中获取bookDao对象后，分别执行其save，delete，update和select方法后会有如下的打印结果：</p>
<img src="/imgs/image-20230424222228517.png" alt="image-20230424222228517" style="zoom:67%;" />

<p><img src="/imgs/image-20230115164305908.png" alt="image-20230115164305908"></p>
<p><img src="/imgs/image-20230115164324854.png" alt="image-20230115164324854"></p>
<h6 id="②AOP概念"><a href="#②AOP概念" class="headerlink" title="②AOP概念"></a>②AOP概念</h6><ul>
<li><strong>通知</strong>：在上图中，我们把希望把其它方法也有的功能抽出来，重新写成一个方法，那么这个方法就被称为“通知”。</li>
<li><strong>连接点</strong>：上图右边所有的方法都被称为“连接点”。</li>
<li><strong>切入点</strong>：需要功能加强的方法就叫“切入点”。</li>
<li><strong>切面</strong>：将通知和切入点联系起来。哪些切入点需要用到哪些通知，就靠切面来联系。</li>
<li><strong>通知类</strong>：通知所在的类，就被称为 “通知类”。</li>
</ul>
<p>上面是个人理解（平时理解记这就行），下面是对这些概念的标准解释：</p>
<p><img src="/imgs/image-20230424222252943.png" alt="image-20230424222252943"></p>
<hr>
<h4 id="2-AOP实现"><a href="#2-AOP实现" class="headerlink" title="2.AOP实现"></a>2.AOP实现</h4><h5 id="A-需求分析"><a href="#A-需求分析" class="headerlink" title="A.需求分析"></a>A.需求分析</h5><p>​	测算接口执行效率，但是这个案例稍微复杂了点，我们对其进行简化。在方法执行前输出当前系统时间。</p>
<p><img src="/imgs/image-20230424222308482.png" alt="image-20230424222308482"></p>
<h5 id="B-环境准备-2"><a href="#B-环境准备-2" class="headerlink" title="B.环境准备"></a>B.环境准备</h5><p>​	<img src="/imgs/image-20230424222327630.png" alt="image-20230424222327630"><img src="/imgs/image-20230116131834694.png" alt="image-20230116131834694"></p>
<p><img src="/imgs/image-20230424222359126.png" alt="image-20230424222359126"></p>
<p><img src="/imgs/image-20230424222406657.png" alt="image-20230424222406657"></p>
<h5 id="C-实现-1"><a href="#C-实现-1" class="headerlink" title="C.实现"></a>C.实现</h5><ol>
<li><p>在pom.xml文件中导入依赖。</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p> 因为<code>spring-context</code>中已经导入了<code>spring-aop</code>，所以不需要再单独导入<code>spring-aop</code>。<br> 导入AspectJ的jar包，AspectJ是AOP思想的一个具体实现，Spring有自己的AOP实现，但是相比于AspectJ来说比较麻烦，所以我们直接采用Spring整合ApsectJ的方式进行AOP开发。</p>
</li>
<li><p>定义接口和实现类。</p>
<p> 准备环境的时候我们已经完成了。</p>
</li>
<li><p>定义通知类和通知。</p>
<p> 在java文件夹下建com.zzc.aop包，专门用来放通知类。</p>
<p> 通知就是将共性功能抽取出来后形成的方法，共性功能指的就是当前系统时间的打印。<br> <strong>类名和方法名没有要求，可以任意。</strong></p>
<p> <img src="/imgs/image-20230424222424561.png" alt="image-20230424222424561"></p>
</li>
<li><p>定义切入点。</p>
<p> 在通知类中定义一个私有、没有返回值、没有参数的方法（方法名可以随便起），在该方法上面使用@Pointcut(“execution(切入点方法的返回值类型 切入点的位置)”)</p>
<p> 如：BookDaoImpl中有两个方法，分别是update()和save()，我们要增强的是update方法，那么该如何定义呢？</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">    <span class="comment">//定义切入点：</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(void com.blog.dao.impl.BookDaoImpl.update())&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span> &#123; <span class="comment">//切入点定义依托一个不具有实际意义的方法进行，即无参数、无返回值、方法体无实际逻辑。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p>定义切面。</p>
<p> <img src="/imgs/image-20230116155111606.png" alt="image-20230116155111606"></p>
<p> 绑定切入点与通知关系，并指定通知添加到原始连接点的具体执行位置。</p>
<p> <strong>说明:</strong>@Before翻译过来是之前，也就是说通知会在切入点方法执行之前执行，除此之前还有其他四种类型，后面会讲。<br> 那这里就会在执行update()之前，来执行我们的method()，输出当前毫秒值。</p>
</li>
<li><p>将通知类配给容器并标识其为切面类。</p>
<p> <img src="/imgs/image-20230424222439108.png" alt="image-20230424222439108"></p>
</li>
<li><p>开启注解格式AOP功能。</p>
<p> 在Spring配置类上使用@EnableAspectJAutoProxy注解</p>
<p> <img src="/imgs/image-20230424222446312.png" alt="image-20230424222446312"></p>
</li>
<li><p>运行程序。</p>
<p> <img src="/imgs/image-20230424222452449.png" alt="image-20230424222452449"></p>
</li>
</ol>
<hr>
<h4 id="3-AOP工作流程"><a href="#3-AOP工作流程" class="headerlink" title="3.AOP工作流程"></a>3.AOP工作流程</h4><p><img src="/imgs/image-20230424222513789.png" alt="image-20230424222513789"></p>
<p><strong>SpringAOP的本质：其底层使用的是代理模式。</strong></p>
<hr>
<h4 id="4-AOP配置管理"><a href="#4-AOP配置管理" class="headerlink" title="4.AOP配置管理"></a>4.AOP配置管理</h4><h5 id="A-AOP切入点表达式"><a href="#A-AOP切入点表达式" class="headerlink" title="A.AOP切入点表达式"></a>A.AOP切入点表达式</h5><h6 id="①语法格式"><a href="#①语法格式" class="headerlink" title="①语法格式"></a>①语法格式</h6><p>​	首先明确两个概念：</p>
<ul>
<li>切入点：要进行增强的方法。</li>
<li>切入点表达式：要进行增强的方法的描述方式。</li>
</ul>
<p>​	<strong>切入点表达式标准格式：</strong></p>
<p><img src="/imgs/image-20230117153101811.png" alt="image-20230117153101811"></p>
<p>​		例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">execution(<span class="keyword">void</span> com.blog.dao.BookDao.update())</span><br><span class="line">execution(<span class="keyword">void</span> com.blog.dao.impl.BookDaoImpl.update())</span><br><span class="line"><span class="comment">//上面两种写法最终执行的结果都一样，因为调用接口方法的时候最终运行的还是其实现类的方法。</span></span><br></pre></td></tr></table></figure>

<p>​	</p>
<h6 id="②通配符"><a href="#②通配符" class="headerlink" title="②通配符"></a>②通配符</h6><p>​	引入：对于需要增强的方法，我们都需要对应地写一个切入点表达式，如果需要增强的方法有很多，那岂不是要写很多切入点表达式？有没有简化的方式呢？有的，那就是使用调配符。</p>
<p>​	通配符：</p>
<ul>
<li><p><code>*</code> ：单个独立的任意符号，可以独立出现，也可以作为前缀或者后缀的匹配符出现。</p>
<p>  如：</p>
<p>  <img src="/imgs/image-20230424222656355.png" alt="image-20230424222656355"></p>
</li>
<li><p><code>..</code> ：任意多个连续的任意符号，可以独立出现，常用于简化包名与参数的书写。</p>
<p>  如：</p>
<p>  <img src="/imgs/image-20230424222701908.png" alt="image-20230424222701908"></p>
</li>
<li><p><code>+</code> ：专用于匹配子类类型，其只能写在接口名或类名的后面。（<strong>此通配符少用</strong>）</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">execution(* *..*Service+.*(..))</span><br><span class="line"><span class="comment">//表示：任意包下以Service结尾的任意接口名或类名下的子类里的任意参数任意返回值类型的任意方法。</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h6 id="③书写技巧"><a href="#③书写技巧" class="headerlink" title="③书写技巧"></a>③书写技巧</h6><p>​	对于切入点表达式的编写其实是很灵活的，那么在编写的时候，有没有什么好的技巧让我们用用：</p>
<ul>
<li><strong>所有代码按照标准规范开发，否则以下技巧全部失效</strong>。</li>
<li>描述<strong>切入点通常描述接口</strong>，而不描述实现类，如果描述到实现类，就出现紧耦合了。</li>
<li>访问控制修饰符针对接口开发均采用public描述（写切入点表达式时，可省略访问控制修饰符描述）。</li>
<li>返回值类型对于增删改类使用精准类型加速匹配，对于查询类使用<code>*</code>通配快速描述。（增删改操作返回的都是boolean，使用准确的类型可以加速匹配；对于查询类其返回的类型不规定，适合使用 * 通配）</li>
<li><code>包名</code>书写尽量不使用<code>..</code>匹配，效率过低，常用<code>*</code>做单个包描述匹配，或精准匹配。</li>
<li><code>接口名/类名</code>书写名称与模块相关的采用<code>*</code>匹配，例如UserService书写成<code>*Service</code>，绑定业务层接口名。</li>
<li>方法名书写以<code>动词</code>进行<code>精准匹配</code>，名词采用<code>*</code>匹配，例如<code>getById</code>书写成<code>getBy*</code>，<code>selectAll</code>书写成<code>selectAll</code>。</li>
<li>参数规则较为复杂，根据业务方法灵活调整。</li>
<li>通常<strong>不使用异常作为匹配规则</strong>。</li>
</ul>
<hr>
<h5 id="B-AOP通知类型"><a href="#B-AOP通知类型" class="headerlink" title="B.AOP通知类型"></a>B.AOP通知类型</h5><h6 id="①类型介绍"><a href="#①类型介绍" class="headerlink" title="①类型介绍"></a>①类型介绍</h6><p>​	AOP通知描述了抽取的共性功能，根据共性功能抽取的位置不同，最终运行代码时要将其加入到合理的位置</p>
<p>那么具体可以将通知添加到哪里呢？一共提供了5种通知类型</p>
<ul>
<li>前置通知（在原始方法的前面实现功能增强）</li>
<li>后置通知（在原始方法的后面实现功能增强）</li>
<li>环绕通知（重点）（在原始方法的前面及后面实现功能增强）</li>
<li>返回后通知（了解）</li>
<li>抛出异常后通知（了解）</li>
</ul>
<h6 id="②环境准备"><a href="#②环境准备" class="headerlink" title="②环境准备"></a>②环境准备</h6><p>​	1.在pom.xml文件中导入：Spring、SpringAOP（导入Spring jar包时会同时导入SpringAO，因为Spring依赖于SpringAOP）、Aspect(不懂？见笔记：AOP –&gt; AOP实现 –&gt; 实现 –&gt; 导入依赖)</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Aspectjar包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​	2.添加BookDao和BookDaoImpl类</p>
<p><img src="/imgs/image-20230424222733195.png" alt="image-20230424222733195"></p>
<p><img src="/imgs/image-20230424222740815.png" alt="image-20230424222740815"></p>
<p>​	3.创建Spring配置类</p>
<p><img src="/imgs/image-20230424222750628.png" alt="image-20230424222750628"></p>
<p>​	4.添加通知类</p>
<p>​	<img src="/imgs/image-20230424222802565.png" alt="image-20230424222802565" style="zoom:67%;" /></p>
<h6 id="③通知类型的使用"><a href="#③通知类型的使用" class="headerlink" title="③通知类型的使用"></a>③通知类型的使用</h6><ul>
<li><p><strong>前置通知</strong></p>
<p>  如：想将通知类中的before通知方法添加到切入点update的前面执行</p>
<p>  在before通知方法前面<strong>使用@Before注解</strong></p>
<p>  <img src="/imgs/image-20230424222814463.png" alt="image-20230424222814463"></p>
<p>  运行结果：</p>
<p>  <img src="/imgs/image-20230424222835001.png" alt="image-20230424222835001"></p>
</li>
<li><p><strong>后置通知</strong></p>
<p>  如：想将通知类中的after通知方法添加到切入点update的后面执行</p>
<p>  在after通知方法前面使用**@After注解**</p>
<p>  <img src="/imgs/image-20230424222852490.png" alt="image-20230424222852490"></p>
<p>  运行结果：</p>
<p>  <img src="/imgs/image-20230424222902567.png" alt="image-20230424222902567"></p>
</li>
<li><p><strong>环绕通知</strong></p>
<p>  如：想要将arround通知方法中的内容加到切入点update的前后</p>
<p>  在arround通知方法上使用**@Around注解**</p>
<p>  <img src="/imgs/image-20230424222911023.png" alt="image-20230424222911023"></p>
<p>  运行结果：</p>
<p>  <img src="/imgs/image-20230424222917337.png" alt="image-20230424222917337"></p>
<p>  运行结果中，通知的内容打印出来，但是原始方法的内容却没有被执行。</p>
<p>  因为环绕通知需要在原始方法的前后进行增强，所以环绕通知就必须要能对原始操作进行调用，具体如何实现?</p>
<p>  在arround通知方法的参数中添加 ProceedingJoinPoint，同时在需要的位置使用proceed()调用原始操作。</p>
<p>  <img src="/imgs/image-20230424222928318.png" alt="image-20230424222928318"></p>
<p>  运行结果：</p>
<p>  <img src="/imgs/image-20230424222933296.png" alt="image-20230424222933296"></p>
<p>  <strong>注意：如果原始方法有返回值，则通知方法也要有返回值（通常设置为Object这样更通用），不然会报错。</strong></p>
<p>  <strong>关于 ProceedingJoinPoint的补充：</strong></p>
<p>  ProceedingJoinPoint：代表原始方法的执行对象，我们可以通过ProceedingJoinPoint中的方法getSignature()来获取一次签名的信息，签名信息中包含了此原始方法属于哪个类或接口、原始方法的方法名等，这些信息都是通过签名信息的对象中的方法获得。如：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around(&quot;servicePt()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runSpeed</span><span class="params">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="comment">//获取一次签名信息</span></span><br><span class="line">    <span class="type">Signature</span> <span class="variable">signature</span> <span class="operator">=</span> proceedingJoinPoint.getSignature();</span><br><span class="line">    <span class="comment">//通过通过签名信息的对象获取原始方法属于哪个接口或类</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">typeName</span> <span class="operator">=</span> signature.getDeclaringTypeName();</span><br><span class="line">    <span class="comment">//通过下面的方法就可以获得该原始方法具体属于哪个类或接口</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">typeName</span> <span class="operator">=</span> signature.getDeclaringType();</span><br><span class="line">    <span class="comment">//获取原始方法的方法名</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> signature.getName();</span><br><span class="line">    System.out.println(<span class="string">&quot;原始方法 &quot;</span> + typeName + <span class="string">&quot;.&quot;</span> + methodName + <span class="string">&quot; 耗时&quot;</span> + (end - start) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p><strong>返回后通知</strong>（了解）</p>
<p>  返回后通知：在原始方法正常结束后执行通知方法。如果原始方法中抛异常了，那就不能执行通知方法（因为原始方法不是正常结束）。</p>
<p>  <strong>操作：</strong>在通知上面使用<code>@AfterReturning注解</code>。如：</p>
<p>  <img src="/imgs/image-20230424223019749.png" alt="image-20230424223019749"></p>
<p>  其与后置通知的区别：</p>
<p>  后置通知：不管原始方法有没有抛出异常都会被执行。</p>
<p>  返回后通知：只会在原始方法不抛出异常的情况下执行。</p>
</li>
<li><p><strong>异常后通知</strong>（了解）</p>
<p>  <strong>异常后通知：</strong>只有当方法抛出异常后才执行。</p>
<p>  操作：在通知方法上面使用@AfterThrowing，如：</p>
<p>  <img src="/imgs/image-20230424223033013.png" alt="image-20230424223033013"></p>
</li>
</ul>
<h6 id="④环绕通知的注意事项"><a href="#④环绕通知的注意事项" class="headerlink" title="④环绕通知的注意事项"></a>④环绕通知的注意事项</h6><ol>
<li><strong>环绕通知必须依赖形参ProceedingJoinPoint才能实现对原始方法的调用</strong>，进而实现原始方法调用前后同时添加通知。</li>
<li><strong>通知中如果未使用ProceedingJoinPoint对原始方法进行调用将跳过原始方法的执行</strong>，形成隔离原始方法的效果。这种效果可以运用在权限隔离上，当判断符合某种权限后才执行原始方法。</li>
<li>对原始方法的调用可以不接收返回值，通知方法设置成void即可，如果接收返回值，最好设定为Object类型。</li>
<li>原始方法的返回值如果是void类型，通知方法的返回值类型可以设置成void,也可以设置成Object。</li>
<li>由于无法预知原始方法运行后是否会抛出异常，因此环绕通知方法必须要处理Throwable异常。</li>
</ol>
<hr>
<h5 id="C-AOP通知获取数据"><a href="#C-AOP通知获取数据" class="headerlink" title="C.AOP通知获取数据"></a>C.AOP通知获取数据</h5><h6 id="①获取切入点方法的实参"><a href="#①获取切入点方法的实参" class="headerlink" title="①获取切入点方法的实参"></a>①获取切入点方法的实参</h6><ol>
<li><p><strong>对于前置通知、后置通知、返回后通知及异常后通知</strong> 获取切入点方法的形参，在通知方法的参数上加上JoinPoint接口，然后在方法里调用JoinPoint的getArgs()方法就可以得到一个类型为Object的数组，数组里装的就是切入点方法中的形参值。</p>
<p> 如：</p>
<p> <img src="/imgs/image-20230424223043817.png" alt="image-20230424223043817"></p>
</li>
<li><p><strong>对于环绕通知。</strong>直接调用ProceedingJoinPoint接口中的getArgs()方法即可。补充：ProceedingJoinPoint接口是JoinPoint的子接口，所以getArgs()方法也是从ProceedingJoinPoint接口中继承而来。</p>
<p> 如：</p>
<p> <img src="/imgs/image-20230119134933061.png" alt="image-20230119134933061"></p>
<p> <strong>如果通知的参数中有多个参数，ProceedingJoinPoint一定要放到所有参数的前面。</strong></p>
<p> <strong>注意：</strong></p>
<ul>
<li><p>pjp.proceed()方法是有两个构造方法，分别是:</p>
</li>
<li><p>proceed()</p>
</li>
</ul>
</li>
</ol>
<ul>
<li><p>proceed(Object[] object)  参数是从pjp.getArgs()方法中自动获取的</p>
</li>
<li><p>调用无参数的proceed，当原始方法有参数，会在调用的过程中自动传入参数。</p>
</li>
<li><p>所以调用这两个方法的任意一个都可以完成功能。</p>
</li>
<li><p>但是当需要修改原始方法的参数时，就只能采用带有参数的方法，如下：</p>
<p>  <img src="/imgs/image-20230424223059637.png" alt="image-20230424223059637"></p>
<p>  有了这个特性后，我们就可以在环绕通知中对原始方法的参数进行拦截过滤，避免由于参数的问题导致程序无法正确运行，还可以根据参数来给予不同的权限，提高代码的健壮性。</p>
</li>
</ul>
<hr>
<h6 id="②获取切入点方法的返回值"><a href="#②获取切入点方法的返回值" class="headerlink" title="②获取切入点方法的返回值"></a>②获取切入点方法的返回值</h6><p>​		<strong>只有环绕通知和返回后通知可以实现获取切入点方法的返回值</strong>，其它通知类型不能获取。</p>
<ol>
<li><p><strong>环绕通知</strong></p>
<p> 环绕通知中，pjp.proceed()对原始方法的调用时，其返回的值就是切入点方法的返回值，我们可以对该返回值进行一些操作，然后再将操作完的值返回。</p>
<p> <img src="/imgs/image-20230424223135115.png" alt="image-20230424223135115"></p>
<p> ​	<strong>如果通知的参数中有多个参数，ProceedingJoinPoint一定要放到所有参数的前面。</strong></p>
</li>
<li><p><strong>返回后通知</strong><br> ①在返回后通知的形参中加一个形参，形参类型可以是Object类型也可以是其它类型（但要和切入点方法中形参类型对应上，），形参名随便起。<br> ②在@AfterReturning注解中加上returning &#x3D; “形参名”，表明如果原始方法（切入点方法）中有返回值，那就把原始方法的返回值赋给通知类中刚才起的参数。</p>
<p> 例子：</p>
<p> <img src="/imgs/image-20230424223142655.png" alt="image-20230424223142655"></p>
<p> ​	<strong>注意：</strong></p>
<ol>
<li>afterReturning方法参数类型的问题<br> 参数类型可以写成其它类型，但是为了能匹配更多的参数类型，建议写成Object类型</li>
<li>afterReturning方法参数的顺序问题<br> 如果存在JoinPoint参数，<strong>则必须将其放在第一位</strong>，否则运行将报错。</li>
</ol>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">(JoinPoint jp,Object res)</span></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h6 id="③获取切入点方法的异常（了解）"><a href="#③获取切入点方法的异常（了解）" class="headerlink" title="③获取切入点方法的异常（了解）"></a>③获取切入点方法的异常（了解）</h6><p>​		<strong>只有环绕通知和抛出异常后通知可以获取。</strong></p>
<ol>
<li><p>环绕通知</p>
 <img src="/imgs/image-20230424223155164.png" alt="image-20230424223155164" style="zoom:67%;" />

 
</li>
<li><p>抛出异常后通知</p>
<p> 在抛出异常后通知的参数中加入一个参数，参数名可以随便起；然后在@AfterThrowing注解中添加属性throwing，其值为：刚才添加的参数的名字。</p>
<p> <img src="/imgs/image-20230424223207500.png" alt="image-20230424223207500"></p>
</li>
</ol>
<hr>
<h4 id="5-案例"><a href="#5-案例" class="headerlink" title="5.案例"></a>5.案例</h4><h5 id="A-需求"><a href="#A-需求" class="headerlink" title="A.需求"></a>A.需求</h5><p><img src="/imgs/image-20230424223228449.png" alt="image-20230424223228449"></p>
<h5 id="B-分析"><a href="#B-分析" class="headerlink" title="B.分析"></a>B.分析</h5><p><img src="/imgs/image-20230424223233502.png" alt="image-20230424223233502"></p>
<h5 id="C-实现-2"><a href="#C-实现-2" class="headerlink" title="C.实现"></a>C.实现</h5><p><img src="/imgs/image-20230424223238920.png" alt="image-20230424223238920"></p>
<h5 id="D-总结"><a href="#D-总结" class="headerlink" title="D.总结"></a>D.总结</h5><p>​	如果开发中有相同的、大量使用的功能需要在很多地方加的话，AOP是不二之选。使用AOP开发能够减少许多共享功能的开发。</p>
<hr>
<h4 id="6-AOP总结"><a href="#6-AOP总结" class="headerlink" title="6.AOP总结"></a>6.AOP总结</h4><p><img src="/imgs/image-20230424223306273.png" alt="image-20230424223306273"></p>
<p>​	<code>切入点表达式：</code></p>
<p><img src="/imgs/image-20230424223318880.png" alt="image-20230424223318880"></p>
<p>​	<code>通知类型：</code></p>
<p><img src="/imgs/image-20230424223324689.png" alt="image-20230424223324689"></p>
<p>​	</p>
<p><img src="/imgs/image-20230424223329708.png" alt="image-20230424223329708"></p>
<hr>
<h3 id="6-AOP事务管理"><a href="#6-AOP事务管理" class="headerlink" title="(6)AOP事务管理"></a>(6)AOP事务管理</h3><h4 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1.概述"></a>1.概述</h4><h5 id="①Spring事务"><a href="#①Spring事务" class="headerlink" title="①Spring事务"></a>①Spring事务</h5><ul>
<li>事务作用：在数据层保障一系列的数据库操作同成功同失败</li>
<li>Spring事务作用：在<strong>数据层</strong>或<strong>业务层</strong>保障一系列的数据库操作同成功同失败。如：在转账业务中需要调用数据层中的转出操作和转入操作，我们需要保证这两个操作需同时成功或同时失败，因此就会用Spring事务。<strong>以后要求数据层中的一系列操作同时成功或失败，那就使用Spring事务。</strong></li>
</ul>
<h5 id="②Spring怎么实现事务"><a href="#②Spring怎么实现事务" class="headerlink" title="②Spring怎么实现事务"></a>②Spring怎么实现事务</h5><p>​	Spring为了管理事务，提供了一个平台事务管理器<strong>PlatformTransactionManager</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PlatformTransactionManager</span> <span class="keyword">extends</span> <span class="title class_">TransactionManager</span> &#123;</span><br><span class="line">    TransactionStatus <span class="title function_">getTransaction</span><span class="params">(<span class="meta">@Nullable</span> TransactionDefinition var1)</span> <span class="keyword">throws</span> TransactionException;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">(TransactionStatus var1)</span> <span class="keyword">throws</span> TransactionException;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">rollback</span><span class="params">(TransactionStatus var1)</span> <span class="keyword">throws</span> TransactionException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	commit是用来提交事务，rollback是用来回滚事务。</p>
<p>​	PlatformTransactionManager只是一个接口，Spring还为其提供了一个具体的实现类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceTransactionManager</span> <span class="keyword">extends</span> <span class="title class_">AbstractPlatformTransactionManager</span> <span class="keyword">implements</span> <span class="title class_">ResourceTransactionManager</span>, InitializingBean &#123;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> enforceReadOnly;</span><br><span class="line">···</span><br><span class="line">···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	从名称上可以看出，我们只需要给它一个DataSource对象，它就可以帮你去在业务层管理事务。<strong>其内部采用的是JDBC的事务</strong>。所以说如果你持久层采用的是JDBC相关的技术，就可以采用这个事务管理器来管理你的事务。而Mybatis内部采用的就是JDBC的事务，所以后期我们Spring整合Mybatis就采用的这个<strong>DataSourceTransactionManager</strong>事务管理器。</p>
<h4 id="2-实现"><a href="#2-实现" class="headerlink" title="2.实现"></a>2.实现</h4><p>​	①配置事务管理器。</p>
<p>​		JdbcConfig类中配置事务管理器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//配置事务管理器，mybatis使用的是jdbc事务</span></span><br><span class="line"><span class="meta">@Bean</span>   <span class="comment">//将其放到spring容器中管理</span></span><br><span class="line"><span class="keyword">public</span> PlatformTransactionManager <span class="title function_">platformTransactionManager</span><span class="params">(DataSource dataSource)</span>&#123;</span><br><span class="line">    <span class="type">DataSourceTransactionManager</span> <span class="variable">transactionManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>();</span><br><span class="line">    <span class="comment">//如果使用的不是jdbc事务，那就将第四、五行的代码换掉就行，其它代码不变。</span></span><br><span class="line">    transactionManager.setDataSource(dataSource);</span><br><span class="line">    <span class="keyword">return</span> transactionManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	②在Spring配置文件中开启事务注解@EnableTransactionManagement</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.blog&quot;)</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;jdbc.properties&quot;)</span></span><br><span class="line"><span class="comment">//开启事务注解:</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="meta">@Import(&#123;JdbcConfig.class, MyBatisConfig.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	③在需要开启事务的业务层方法对应的接口上使用<code>@Transactional</code>注解。</p>
<p>​		注意:<code>@Transactional</code>可以写在接口上、接口方法上、实现类上和实现类方法上</p>
<ul>
<li>写在接口上，该接口的所有实现类的所有方法都会有事务</li>
<li>写在接口方法上，该接口的所有实现类的该方法都会有事务</li>
<li>写在实现类上，该类中的所有方法都会有事务</li>
<li>写在实现类方法上，该方法上有事务</li>
</ul>
<p>​		</p>
<h4 id="3-例子"><a href="#3-例子" class="headerlink" title="3.例子"></a>3.例子</h4><p>​	见链接：<a target="_blank" rel="noopener" href="https://cyborg2077.github.io/2022/08/29/Spring/#AOP%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86">Spring | Kyle’s Blog (cyborg2077.github.io)</a></p>
<img src="/imgs/image-20230424223438942.png" alt="image-20230424223438942" style="zoom:67%;" />



<hr>
<h4 id="4-Spring事务角色"><a href="#4-Spring事务角色" class="headerlink" title="4.Spring事务角色"></a>4.Spring事务角色</h4><h5 id="①引入-4"><a href="#①引入-4" class="headerlink" title="①引入"></a>①引入</h5><p>​	Spring中是如何实现事务管理的呢？见下面。</p>
<h5 id="②"><a href="#②" class="headerlink" title="②"></a>②</h5><img src="/imgs/image-20230424223452220.png" alt="image-20230424223452220" style="zoom:67%;" />

<p><code>补充：</code></p>
<p><img src="/imgs/image-20230424223510296.png" alt="image-20230424223510296"></p>
<img src="/imgs/image-20230424223525584.png" alt="image-20230424223525584" style="zoom:67%;" />

<p><img src="/imgs/image-20230424223533090.png" alt="image-20230424223533090"></p>
<p><strong>注意：</strong>目前的事务管理是<strong>基于</strong><code>DataSourceTransactionManager</code>和<code>SqlSessionFactoryBean</code><strong>使用的是同一个数据源</strong>，如果不使用同一个数据源那将无法实现Spring事务管理。即：</p>
<p><img src="/imgs/image-20230424223545844.png" alt="image-20230424223545844"></p>
<p><img src="/imgs/image-20230424223553554.png" alt="image-20230424223553554"></p>
<hr>
<h4 id="5-Spring事务属性"><a href="#5-Spring事务属性" class="headerlink" title="5.Spring事务属性"></a>5.Spring事务属性</h4><h5 id="A-事务配置"><a href="#A-事务配置" class="headerlink" title="A.事务配置"></a>A.事务配置</h5><p><img src="/imgs/image-20230424223559424.png" alt="image-20230424223559424"></p>
<p>​	对上图的补充：</p>
<p><img src="/imgs/image-20230424223607443.png" alt="image-20230424223607443"></p>
<p>上面这些属性都可以在<code>@Transactional</code>注解的参数上进行设置。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(rollbackFor = &#123;IOException.class&#125;)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>readOnly：true只读事务，false读写事务，增删改要设为false,查询设为true。</li>
<li>timeout：设置超时时间单位秒，在多长时间之内事务没有提交成功就自动回滚，-1表示不设置超时时间。</li>
<li>rollbackFor：当出现指定异常进行事务回滚</li>
<li>noRollbackFor：当出现指定异常不进行事务回滚</li>
</ul>
<p>思考:出现异常事务会自动回滚，这个是我们之前就已经知道的</p>
<ul>
<li>noRollbackFor是设定对于指定的异常不回滚，这个好理解</li>
<li>rollbackFor是指定回滚异常，对于异常事务不应该都回滚么，为什么还要指定?<ul>
<li>事实上<strong>Spring的事务只会对<code>Error异常</code>和<code>RuntimeException异常</code>（运行时异常）及其子类进行事务回滚</strong>，其他的异常类型是不会回滚的。因此需要根据实际情况针对指定的异常进行回滚。</li>
</ul>
</li>
</ul>
<hr>
<h5 id="B-事务传播行为"><a href="#B-事务传播行为" class="headerlink" title="B.事务传播行为"></a>B.事务传播行为</h5><h6 id="①引入-5"><a href="#①引入-5" class="headerlink" title="①引入"></a>①引入</h6><p>​	见：<a target="_blank" rel="noopener" href="https://cyborg2077.github.io/2022/08/29/Spring/#Spring%E4%BA%8B%E5%8A%A1%E8%A7%92%E8%89%B2">Spring | Kyle’s Blog (cyborg2077.github.io)</a>	</p>
<p><img src="/imgs/image-20230424223647175.png" alt="image-20230424223647175"></p>
<h6 id="②实现-4"><a href="#②实现-4" class="headerlink" title="②实现"></a>②实现</h6><p>​	在使用@Transactional注解中的propagation属性，达到事务协调员是否加入事务管理员的事务及事务协调员是否自己开启新事务的目的。</p>
<p>​	propagation属性的值可以为：</p>
<p>​	<img src="/imgs/image-20230424223700452.png" alt="image-20230424223700452"></p>
<p>​	<code>说明：图中的 “无” 代表：无事务或不开启事务。“ T ”代表：事务T。</code></p>
<hr>
<h3 id="三、如何看Spring报错"><a href="#三、如何看Spring报错" class="headerlink" title="三、如何看Spring报错"></a>三、如何看Spring报错</h3><p>​	从最下面的报错开始看，看不懂再往前面看。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://orangezzc.github.io/">OrangeZzc</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://orangezzc.github.io/2023/04/24/Spring/">https://orangezzc.github.io/2023/04/24/Spring/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://OrangeZzc.github.io" target="_blank">Orange's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Spring/">Spring</a></div><div class="post_share"><div class="social-share" data-image="/img/avater.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/04/24/SpringMvc/" title="SpringMvc"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">SpringMvc</div></div></a></div><div class="next-post pull-right"><a href="/2023/04/24/Maven%EF%BC%88%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86%EF%BC%89/" title="Maven(基础部分)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Maven(基础部分)</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avater.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">OrangeZzc</div><div class="author-info__description">欢迎来到我的博客!</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">27</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/OrangeZzc" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:3486484066@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #24292e;"></i></a><a class="social-icon" href="http://wpa.qq.com/msgrd?v=3&amp;uin=3486484066&amp;site=qq&amp;menu=yes" target="_blank" title="QQ"><i class="fab fa-qq"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">如果在阅读过程中遇到了问题，可以随时联系我，看到了会在第一时间给出回复（不负责DEBUG，除非我真的写的有问题）</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%A6%82%E8%BF%B0"><span class="toc-text">一、概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AD%A6Spring"><span class="toc-text">1.为什么要学Spring</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AD%A6%E4%BB%80%E4%B9%88"><span class="toc-text">2.学什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%A6%82%E4%BD%95%E5%AD%A6"><span class="toc-text">3.如何学</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Spring%E5%AE%B6%E6%97%8F%E5%92%8CSpring%E5%8F%91%E5%B1%95%E5%8F%B2"><span class="toc-text">4.Spring家族和Spring发展史</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Spring-Framework"><span class="toc-text">二、Spring Framework</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%A1%86%E6%9E%B6%E5%8F%8A%E5%AD%A6%E8%B7%AF%E7%BA%BF"><span class="toc-text">(1).框架及学路线</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#A-%E6%A1%86%E6%9E%B6"><span class="toc-text">A.框架</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#B-%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF"><span class="toc-text">B.学习路线</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%A0%B8%E5%BF%83%E5%AE%B9%E5%99%A8"><span class="toc-text">(2).核心容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-IOC%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9"><span class="toc-text">1.IOC相关内容</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#A-%E6%A6%82%E5%BF%B5"><span class="toc-text">A.概念</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A0%E5%BC%95%E5%85%A5"><span class="toc-text">①引入</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A1Ioc%E3%80%81Ioc%E5%AE%B9%E5%99%A8%E3%80%81DI"><span class="toc-text">②Ioc、Ioc容器、DI</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#B-Ioc%E5%85%A5%E9%97%A8%E6%A1%88%E4%BE%8B"><span class="toc-text">B.Ioc入门案例</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A0%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90"><span class="toc-text">①思路分析</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A1%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4"><span class="toc-text">②实现步骤</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#C-DI%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8"><span class="toc-text">C.DI快速入门</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A0%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90-1"><span class="toc-text">①思路分析</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A1%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4-1"><span class="toc-text">②实现步骤</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#D-bean%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE"><span class="toc-text">D.bean基础配置</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A0bean%E5%88%AB%E5%90%8D"><span class="toc-text">①bean别名</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A1bean%E4%BD%9C%E7%94%A8%E8%8C%83%E5%9B%B4"><span class="toc-text">②bean作用范围</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#E-bean%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="toc-text">E.bean实例化</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A0%E6%96%B9%E5%BC%8F%E4%B8%80%EF%BC%9A%E7%A9%BA%E5%8F%82%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-text">①方式一：空参构造器</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A1%E6%96%B9%E5%BC%8F%E4%BA%8C%EF%BC%9A%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-text">②方式二：静态工厂（了解）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A2%E6%96%B9%E5%BC%8F%E4%B8%89%EF%BC%9A%E5%AE%9E%E4%BE%8B%E5%B7%A5%E5%8E%82%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-text">③方式三：实例工厂（了解）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A3%E6%96%B9%E5%BC%8F%E5%9B%9B%EF%BC%9A%E5%AE%9E%E4%BE%8B%E5%B7%A5%E5%8E%82%E2%80%93%E6%94%B9%E8%BF%9B%EF%BC%88%E7%90%86%E8%A7%A3%E6%8E%8C%E6%8F%A1%EF%BC%89"><span class="toc-text">④方式四：实例工厂–改进（理解掌握）</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#F-bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">F.bean生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A0bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">①bean生命周期</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A1bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%8E%A7%E5%88%B6"><span class="toc-text">②bean生命周期控制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-DI%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9"><span class="toc-text">2.DI相关内容</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#A-%E6%A6%82%E8%BF%B0"><span class="toc-text">A.概述</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#B-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F%E2%80%93setter%E6%B3%A8%E5%85%A5"><span class="toc-text">B.依赖注入方式–setter注入</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A0%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-text">①引用类型</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A1%E7%AE%80%E5%8D%95%E7%B1%BB%E5%9E%8B"><span class="toc-text">②简单类型</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#C-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F%E2%80%93%E6%9E%84%E9%80%A0%E5%99%A8%E6%B3%A8%E5%85%A5"><span class="toc-text">C.依赖注入方式–构造器注入</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A0%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B-1"><span class="toc-text">①引用类型</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A1%E7%AE%80%E5%8D%95%E7%B1%BB%E5%9E%8B-1"><span class="toc-text">②简单类型</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#D-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F%E9%80%89%E6%8B%A9"><span class="toc-text">D.依赖注入方式选择</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#E-%E4%BE%9D%E8%B5%96%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D"><span class="toc-text">E.依赖自动装配</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A0%E6%A6%82%E8%BF%B0"><span class="toc-text">①概述</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A1%E5%AE%9E%E7%8E%B0"><span class="toc-text">②实现</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A2%E8%A1%A5%E5%85%85%E8%AF%B4%E6%98%8E"><span class="toc-text">③补充说明</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#F-%E9%9B%86%E5%90%88%E6%B3%A8%E5%85%A5"><span class="toc-text">F.集合注入</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A0%E5%BC%95%E5%85%A5-1"><span class="toc-text">①引入</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A1%E5%AE%9E%E7%8E%B0-1"><span class="toc-text">②实现</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A2%E8%AF%B4%E6%98%8E"><span class="toc-text">③说明</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-IOC-x2F-DI%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86%E7%AC%AC%E4%B8%89%E6%96%B9bean"><span class="toc-text">3.IOC&#x2F;DI配置管理第三方bean</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#A-%E7%AE%A1%E7%90%86%E6%80%9D%E8%B7%AF"><span class="toc-text">A.管理思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#B-%E4%BE%8B%E5%AD%90"><span class="toc-text">B.例子</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#C-%E5%8A%A0%E8%BD%BDproperties%E6%96%87%E4%BB%B6"><span class="toc-text">C.加载properties文件</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A0%E5%BC%95%E5%85%A5-2"><span class="toc-text">①引入</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A1%E5%AE%9E%E7%8E%B0-2"><span class="toc-text">②实现</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A2%E8%A1%A5%E5%85%85"><span class="toc-text">③补充</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%A0%B8%E5%BF%83%E5%AE%B9%E5%99%A8"><span class="toc-text">4.核心容器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#A-%E8%8E%B7%E5%8F%96%E5%AE%B9%E5%99%A8%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">A.获取容器对象的两种方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#B-%E8%8E%B7%E5%8F%96bean%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">B.获取bean对象的三种方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#C-%E5%AE%B9%E5%99%A8%E7%B1%BB%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-text">C.容器类层次结构</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%A0%B8%E5%BF%83%E5%AE%B9%E5%99%A8%E6%80%BB%E7%BB%93"><span class="toc-text">5.核心容器总结</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#A-%E5%AE%B9%E5%99%A8%E7%9B%B8%E5%85%B3"><span class="toc-text">A.容器相关</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#B-bean%E7%9B%B8%E5%85%B3"><span class="toc-text">B.bean相关</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#C-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3"><span class="toc-text">C.依赖注入相关</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-IOC-x2F-DI%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91"><span class="toc-text">(3).IOC&#x2F;DI注解开发</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%BC%95%E5%85%A5"><span class="toc-text">1.引入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91%E5%AE%9A%E4%B9%89bean"><span class="toc-text">2.注解开发定义bean</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#A-%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87"><span class="toc-text">A.环境准备</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#B-%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91%E5%AE%9A%E4%B9%89bean%E5%AE%9E%E7%8E%B0"><span class="toc-text">B.注解开发定义bean实现</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%BA%AF%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91"><span class="toc-text">3.纯注解开发</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#A-%E5%BC%95%E5%85%A5"><span class="toc-text">A.引入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#B-%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87"><span class="toc-text">B.环境准备</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#C-%E7%BA%AF%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91%E5%AE%9E%E7%8E%B0"><span class="toc-text">C.纯注解开发实现</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91bean%E7%9A%84%E4%BD%9C%E7%94%A8%E8%8C%83%E5%9B%B4%E5%92%8C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">4.注解开发bean的作用范围和生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#A-bean%E7%9A%84%E4%BD%9C%E7%94%A8%E8%8C%83%E5%9B%B4"><span class="toc-text">A.bean的作用范围</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#B-bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">B.bean的生命周期</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#C-%E8%A1%A5%E5%85%85"><span class="toc-text">C.补充</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5"><span class="toc-text">5.注解开发依赖注入</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#A-%E5%BC%95%E5%85%A5-1"><span class="toc-text">A.引入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#B-%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0%E6%8C%89%E7%85%A7%E7%B1%BB%E5%9E%8B%E6%B3%A8%E5%85%A5"><span class="toc-text">B.注解实现按照类型注入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#C-%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0%E6%8C%89%E7%85%A7%E5%90%8D%E7%A7%B0%E6%B3%A8%E5%85%A5"><span class="toc-text">C.注解实现按照名称注入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#D-%E7%AE%80%E5%8D%95%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%B3%A8%E5%85%A5"><span class="toc-text">D.简单数据类型注入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#E-%E6%B3%A8%E8%A7%A3%E8%AF%BB%E5%8F%96properties%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-text">E.注解读取properties配置文件</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A0%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87"><span class="toc-text">①环境准备</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A1%E5%AE%9E%E7%8E%B0-3"><span class="toc-text">②实现</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A2%E8%A1%A5%E5%85%85%E8%AF%B4%E6%98%8E-1"><span class="toc-text">③补充说明</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-IOC-x2F-DI%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91%E7%AE%A1%E7%90%86%E7%AC%AC%E4%B8%89%E6%96%B9bean"><span class="toc-text">6.IOC&#x2F;DI注解开发管理第三方bean</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#A-%E7%AE%A1%E7%90%86%E7%AC%AC%E4%B8%89%E6%96%B9bean"><span class="toc-text">A.管理第三方bean</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A0%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87-1"><span class="toc-text">①环境准备</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A1%E6%93%8D%E4%BD%9C"><span class="toc-text">②操作</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#B-%E4%B8%BA%E7%AC%AC%E4%B8%89%E6%96%B9bean%E5%AE%9E%E7%8E%B0%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5"><span class="toc-text">B.为第三方bean实现依赖注入</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A0%E7%AE%80%E5%8D%95%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">①简单数据类型</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A1%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">②引用数据类型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93"><span class="toc-text">7.注解开发总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Spring%E6%95%B4%E5%90%88"><span class="toc-text">(4).Spring整合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Spring%E6%95%B4%E5%90%88MyBatis"><span class="toc-text">1.Spring整合MyBatis</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#A-%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90"><span class="toc-text">A.思路分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#B-%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87-1"><span class="toc-text">B.环境准备</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#C-%E5%AE%9E%E7%8E%B0"><span class="toc-text">C.实现</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Spring%E6%95%B4%E5%90%88JUnit"><span class="toc-text">2.Spring整合JUnit</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-AOP"><span class="toc-text">(5).AOP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%A6%82%E8%BF%B0"><span class="toc-text">1.概述</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#A-%E5%BC%95%E5%85%A5-2"><span class="toc-text">A.引入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#B-AOP%E7%AE%80%E4%BB%8B"><span class="toc-text">B.AOP简介</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#C-AOP%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D"><span class="toc-text">C.AOP概念介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A0%E5%BC%95%E5%85%A5-3"><span class="toc-text">①引入</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A1AOP%E6%A6%82%E5%BF%B5"><span class="toc-text">②AOP概念</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-AOP%E5%AE%9E%E7%8E%B0"><span class="toc-text">2.AOP实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#A-%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90"><span class="toc-text">A.需求分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#B-%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87-2"><span class="toc-text">B.环境准备</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#C-%E5%AE%9E%E7%8E%B0-1"><span class="toc-text">C.实现</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-AOP%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-text">3.AOP工作流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-AOP%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86"><span class="toc-text">4.AOP配置管理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#A-AOP%E5%88%87%E5%85%A5%E7%82%B9%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">A.AOP切入点表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A0%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F"><span class="toc-text">①语法格式</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A1%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-text">②通配符</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A2%E4%B9%A6%E5%86%99%E6%8A%80%E5%B7%A7"><span class="toc-text">③书写技巧</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#B-AOP%E9%80%9A%E7%9F%A5%E7%B1%BB%E5%9E%8B"><span class="toc-text">B.AOP通知类型</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A0%E7%B1%BB%E5%9E%8B%E4%BB%8B%E7%BB%8D"><span class="toc-text">①类型介绍</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A1%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87"><span class="toc-text">②环境准备</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A2%E9%80%9A%E7%9F%A5%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">③通知类型的使用</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A3%E7%8E%AF%E7%BB%95%E9%80%9A%E7%9F%A5%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">④环绕通知的注意事项</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#C-AOP%E9%80%9A%E7%9F%A5%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="toc-text">C.AOP通知获取数据</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A0%E8%8E%B7%E5%8F%96%E5%88%87%E5%85%A5%E7%82%B9%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9E%E5%8F%82"><span class="toc-text">①获取切入点方法的实参</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A1%E8%8E%B7%E5%8F%96%E5%88%87%E5%85%A5%E7%82%B9%E6%96%B9%E6%B3%95%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-text">②获取切入点方法的返回值</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A2%E8%8E%B7%E5%8F%96%E5%88%87%E5%85%A5%E7%82%B9%E6%96%B9%E6%B3%95%E7%9A%84%E5%BC%82%E5%B8%B8%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-text">③获取切入点方法的异常（了解）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%A1%88%E4%BE%8B"><span class="toc-text">5.案例</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#A-%E9%9C%80%E6%B1%82"><span class="toc-text">A.需求</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#B-%E5%88%86%E6%9E%90"><span class="toc-text">B.分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#C-%E5%AE%9E%E7%8E%B0-2"><span class="toc-text">C.实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#D-%E6%80%BB%E7%BB%93"><span class="toc-text">D.总结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-AOP%E6%80%BB%E7%BB%93"><span class="toc-text">6.AOP总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-AOP%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86"><span class="toc-text">(6)AOP事务管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%A6%82%E8%BF%B0-1"><span class="toc-text">1.概述</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0Spring%E4%BA%8B%E5%8A%A1"><span class="toc-text">①Spring事务</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1Spring%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E4%BA%8B%E5%8A%A1"><span class="toc-text">②Spring怎么实现事务</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AE%9E%E7%8E%B0"><span class="toc-text">2.实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BE%8B%E5%AD%90"><span class="toc-text">3.例子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Spring%E4%BA%8B%E5%8A%A1%E8%A7%92%E8%89%B2"><span class="toc-text">4.Spring事务角色</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0%E5%BC%95%E5%85%A5-4"><span class="toc-text">①引入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1"><span class="toc-text">②</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-Spring%E4%BA%8B%E5%8A%A1%E5%B1%9E%E6%80%A7"><span class="toc-text">5.Spring事务属性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#A-%E4%BA%8B%E5%8A%A1%E9%85%8D%E7%BD%AE"><span class="toc-text">A.事务配置</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#B-%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA"><span class="toc-text">B.事务传播行为</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A0%E5%BC%95%E5%85%A5-5"><span class="toc-text">①引入</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A1%E5%AE%9E%E7%8E%B0-4"><span class="toc-text">②实现</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%A6%82%E4%BD%95%E7%9C%8BSpring%E6%8A%A5%E9%94%99"><span class="toc-text">三、如何看Spring报错</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/24/%E5%BF%AB%E6%8D%B7%E9%94%AE/" title="快捷键">快捷键</a><time datetime="2023-04-24T13:16:22.000Z" title="发表于 2023-04-24 21:16:22">2023-04-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9F%A5%E8%AF%86/" title="计算机知识">计算机知识</a><time datetime="2023-04-24T13:11:01.000Z" title="发表于 2023-04-24 21:11:01">2023-04-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/24/java%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0/" title="Java语法基础概述">Java语法基础概述</a><time datetime="2023-04-24T10:27:36.000Z" title="发表于 2023-04-24 18:27:36">2023-04-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/24/git/" title="git">git</a><time datetime="2023-04-24T08:32:11.000Z" title="发表于 2023-04-24 16:32:11">2023-04-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/24/SSM%E6%95%B4%E5%90%88/" title="SSM整合">SSM整合</a><time datetime="2023-04-24T08:31:50.000Z" title="发表于 2023-04-24 16:31:50">2023-04-24</time></div></div></div></div></div></div></main><footer id="footer" style="background: rgba(255,255,255, .0)"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By OrangeZzc</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><b>We can't change our fate,but we can do our best!</b></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"></div><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>