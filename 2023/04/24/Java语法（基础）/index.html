<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java语法（基础部分） | Orange's Blog</title><meta name="author" content="OrangeZzc"><meta name="copyright" content="OrangeZzc"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="世界上最好的编程语言">
<meta property="og:type" content="article">
<meta property="og:title" content="Java语法（基础部分）">
<meta property="og:url" content="https://orangezzcs.gitee.io/orange-zzcs/2023/04/24/Java%E8%AF%AD%E6%B3%95%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/index.html">
<meta property="og:site_name" content="Orange&#39;s Blog">
<meta property="og:description" content="世界上最好的编程语言">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://orangezzcs.gitee.io/orange-zzcs/imgs/javayufafenmian.jpg">
<meta property="article:published_time" content="2023-04-24T08:30:06.000Z">
<meta property="article:modified_time" content="2023-04-27T08:40:19.198Z">
<meta property="article:author" content="OrangeZzc">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://orangezzcs.gitee.io/orange-zzcs/imgs/javayufafenmian.jpg"><link rel="shortcut icon" href="/orange-zzcs/img/favicon.png"><link rel="canonical" href="https://orangezzcs.gitee.io/orange-zzcs/2023/04/24/Java%E8%AF%AD%E6%B3%95%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/orange-zzcs/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/orange-zzcs/',
  algolia: undefined,
  localSearch: {"path":"/orange-zzcs/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":30},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: OrangeZzc","link":"链接: ","source":"来源: Orange's Blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java语法（基础部分）',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-27 16:40:19'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/orange-zzcs/img/avater.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/orange-zzcs/archives/"><div class="headline">文章</div><div class="length-num">26</div></a><a href="/orange-zzcs/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/orange-zzcs/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/orange-zzcs/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/orange-zzcs/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/orange-zzcs/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/orange-zzcs/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/orange-zzcs/link/"><i class="fa-fw fas fa-link"></i><span> 学无止境</span></a></div><div class="menus_item"><a class="site-page" href="/orange-zzcs/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: transparent"><nav id="nav"><span id="blog-info"><a href="/orange-zzcs/" title="Orange's Blog"><span class="site-name">Orange's Blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/orange-zzcs/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/orange-zzcs/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/orange-zzcs/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/orange-zzcs/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/orange-zzcs/link/"><i class="fa-fw fas fa-link"></i><span> 学无止境</span></a></div><div class="menus_item"><a class="site-page" href="/orange-zzcs/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java语法（基础部分）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-04-24T08:30:06.000Z" title="发表于 2023-04-24 16:30:06">2023-04-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-04-27T08:40:19.198Z" title="更新于 2023-04-27 16:40:19">2023-04-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/orange-zzcs/categories/Java%E8%AF%AD%E6%B3%95/">Java语法</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">27k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>94分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java语法（基础部分）"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="1、关键字、保留字、标识符"><a href="#1、关键字、保留字、标识符" class="headerlink" title="1、关键字、保留字、标识符"></a>1、关键字、保留字、标识符</h2><h3 id="A-保留字"><a href="#A-保留字" class="headerlink" title="A.保留字"></a>A.保留字</h3><p>现在不是关键字，将来可能成为关键字的字符串，有：goto、const、null</p>
<h3 id="B-标识符"><a href="#B-标识符" class="headerlink" title="B.标识符"></a>B.标识符</h3><p>凡是自己可以起名字的地方都叫标识符，如：类名、变量名、方法名、接口名、包名等。标识符的命名规则：</p>
<p>​		①由26个英文字母大小写，0-9，_或$组成。</p>
<p>​		②数字不可以开头。</p>
<p>​		③不可以使用关键字和保留字。</p>
<p>​		④Java中严格区分大小写，如：s1和S1不一样。</p>
<h2 id="2、Java中的命名规范"><a href="#2、Java中的命名规范" class="headerlink" title="2、Java中的命名规范"></a>2、Java中的命名规范</h2><p>包名：所有字母小写。 </p>
<p>类名、接口名：所有单词的首字母大写。</p>
<p>变量名、方法名：第一个单词首字母小写，其余单词的首字母大写。</p>
<p>常量名：所有字母都大写。多单词时每个单词用下划线连接，如：XXX_YYY_ZZZ</p>
<h2 id="3、定义变量"><a href="#3、定义变量" class="headerlink" title="3、定义变量"></a>3、定义变量</h2><p>格式：变量类型 变量名 &#x3D; 变量值</p>
<p>变量的声明和赋值可以不写在一起，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>；</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="type">int</span> i ;</span><br><span class="line">i = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>注意：①使用变量之前要先声明并赋值，不然编译不通过。</p>
<p>​		   ②不可以在同一作用域内定义同名变量。</p>
<p>​		   ③变量的作用域：其定义所在的一对{ }内。变量只有在其作用域内才有效。</p>
<hr>
<p><img src="/orange-zzcs/imgs/image-20230426200639227.png" alt="image-20230426200639227"></p>
<h3 id="①基本数据类型"><a href="#①基本数据类型" class="headerlink" title="①基本数据类型"></a>①基本数据类型</h3><h4 id="A-整型"><a href="#A-整型" class="headerlink" title="A.整型"></a>A.整型</h4><p><img src="/orange-zzcs/imgs/image-20230426200702737.png" alt="image-20230426200702737"></p>
<p>注意：</p>
<p>​		①byte表示的范围是：-128~127，如果赋值时超出了这个范围就会编译不通过。</p>
<p>​		②long类型数据在赋值时要在变量值后面加上“l”或“L”，如：	</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">l1</span> <span class="operator">=</span> <span class="number">123l</span>;</span><br><span class="line"><span class="type">long</span> <span class="variable">l2</span> <span class="operator">=</span> <span class="number">12L</span>;</span><br></pre></td></tr></table></figure>



<h4 id="B-浮点型"><a href="#B-浮点型" class="headerlink" title="B.浮点型"></a>B.浮点型</h4><p>​			①float（占4字节）、double（占8字节）。</p>
<p>​			②float表示数值的范围比long还大。</p>
<p>​			③定义float类型变量时，变量要以”f”或”F”结尾。</p>
<p>​			④定义浮点型变量时，常用double型。</p>
<h4 id="C-字符型"><a href="#C-字符型" class="headerlink" title="C.字符型"></a>C.字符型</h4><p>​			①定义char类型变量，通常使用一对单引号，引号内部只能写一个字符。char占两个字节。</p>
<p>​			②可以赋值转义字符给字符型变量，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="string">&#x27;\n&#x27;</span>;<span class="comment">// \n表示换行</span></span><br><span class="line"><span class="type">char</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="string">&#x27;\t&#x27;</span>;<span class="comment">// \t表示制表符即Tab键</span></span><br><span class="line">System.out.print(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;world&quot;</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果为：</span></span><br><span class="line"><span class="comment">helloworld</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">System.out.print(<span class="string">&quot;hello&quot;</span> + c1);</span><br><span class="line">System.out.println(<span class="string">&quot;world&quot;</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果为：</span></span><br><span class="line"><span class="comment">hello</span></span><br><span class="line"><span class="comment">world</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">System.out.print(<span class="string">&quot;hello&quot;</span> + c2);</span><br><span class="line">System.out.println(<span class="string">&quot;world&quot;</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果为：</span></span><br><span class="line"><span class="comment">hello	world</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h4 id="D-布偶型"><a href="#D-布偶型" class="headerlink" title="D.布偶型"></a>D.布偶型</h4><p>​		①boolean只能取true或false</p>
<hr>
<h3 id="②基本数据类型之间的运算"><a href="#②基本数据类型之间的运算" class="headerlink" title="②基本数据类型之间的运算"></a>②基本数据类型之间的运算</h3><p>前提：这里讨论只是7种基本数据类型变量间的运算。不包括boolean类型的。</p>
<h4 id="A-自动类型转换"><a href="#A-自动类型转换" class="headerlink" title="A.自动类型转换"></a>A.自动类型转换</h4><p>自动转换：小–&gt;大（小、大指数据的表示范围）</p>
<p>byte、short、char两两间的运算或自己与自己的运算，其结果都为int型。</p>
<p><img src="/orange-zzcs/imgs/image-20230426200736380.png" alt="image-20230426200736380"></p>
<h4 id="B-强制类型转换"><a href="#B-强制类型转换" class="headerlink" title="B.强制类型转换"></a>B.强制类型转换</h4><p>​		①需要使用强转符：（）</p>
<p>​		②注意：强制转换可能导致精度损失，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="number">12.9</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> (<span class="type">int</span>)d1;<span class="comment">//输出结果为：12。浮点型转整型时结果取整数</span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">l1</span> <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line"><span class="type">short</span> <span class="variable">s2</span> <span class="operator">=</span> (<span class="type">short</span>)l1;<span class="comment">//输出结果还是123，没有精度损失</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> (<span class="type">byte</span>)i2;<span class="comment">//输出结果为-128，有精度损失</span></span><br></pre></td></tr></table></figure>



<h4 id="C-注意"><a href="#C-注意" class="headerlink" title="C.注意"></a>C.注意</h4><p>​		整型常量，默认类型为int型。浮点型常量，默认类型为double型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">1232213</span>;</span><br><span class="line"><span class="comment">//123213后面没加L或l编译也能通过，因为整型常量默认为int型，int转换成long型属于自动类型转换，所以编译没有报错。</span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="number">12.3</span>;</span><br><span class="line"><span class="comment">//12.3后面没加F或f，编译会报错，因为浮点型常量默认为double型，double转float需要强制转换，所以编译报错。</span></span><br><span class="line"></span><br><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">12</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">b1</span> <span class="operator">=</span> b + <span class="number">1</span>；<span class="comment">//此行会编译报错，因为1属于整型常量，所以为int型，(b + 1)结果为int型数据，int型转byte需要强制转换。</span></span><br></pre></td></tr></table></figure>

<p>总结：long类型和float类型数据记得加（L或l）、（F或f）</p>
<hr>
<h3 id="③引用数据类型"><a href="#③引用数据类型" class="headerlink" title="③引用数据类型"></a>③引用数据类型</h3><h4 id="A-String-字符串"><a href="#A-String-字符串" class="headerlink" title="A. 	String(字符串)"></a>A. 	String(字符串)</h4><p>​	①声明String类型变量时，使用””（双引号）。</p>
<p>​	②赋给字符串的值，可以是单个字符，可以多个字符，也可以没有。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;as&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="type">char</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="string">&#x27;&#x27;</span>;<span class="comment">//编译不通过，因为char类型不能不赋值。</span></span><br></pre></td></tr></table></figure>

<p>​	③String可以和8种基本数据类型变量做运算，且只能做连接运算（即 “+” ），其运算结果为String类型。</p>
<p>例子：</p>
<p><img src="/orange-zzcs/imgs/image-20230426200758162.png" alt="image-20230426200758162"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;*	*&quot;</span>);<span class="comment">//结果为*	*</span></span><br><span class="line">System.out.println(<span class="string">&#x27;*&#x27;</span> + <span class="string">&#x27;\t&#x27;</span> + <span class="string">&#x27;*&#x27;</span>);<span class="comment">//结果为93</span></span><br><span class="line">System.out.println(<span class="string">&#x27;*&#x27;</span> + <span class="string">&quot;\t&quot;</span> + <span class="string">&#x27;*&#x27;</span>);<span class="comment">//结果为*	*</span></span><br><span class="line">System.out.println(<span class="string">&#x27;*&#x27;</span> + <span class="string">&#x27;\t&#x27;</span> + <span class="string">&quot;*&quot;</span>);<span class="comment">//结果为51*</span></span><br><span class="line">System.out.println(<span class="string">&#x27;*&#x27;</span> + (<span class="string">&#x27;\t&#x27;</span> + <span class="string">&quot;*&quot;</span>));<span class="comment">//结果为*	*</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// *的ASCII码为42，&quot;\t&quot;的ASCII码为9</span></span><br><span class="line"><span class="comment">//总结：当+为连接运算时，\t是Tab键；为加号时，\t变成整型</span></span><br></pre></td></tr></table></figure>



<hr>
<h3 id="④进制与进制间的转换（了解）"><a href="#④进制与进制间的转换（了解）" class="headerlink" title="④进制与进制间的转换（了解）"></a>④进制与进制间的转换（了解）</h3><h4 id="A-进制"><a href="#A-进制" class="headerlink" title="A.进制"></a>A.进制</h4><p>对于整数，有四种表示方式：</p>
<p><img src="/orange-zzcs/imgs/image-20230426200813331.png" alt="image-20230426200813331"></p>
<p>上面的0b、0B、0x、0X都是数字零。</p>
<p>例子：</p>
<img src="/imgs/image-20230426200830729.png" alt="image-20230426200830729" style="zoom:80%;" />

<p>输出结果为：</p>
<p><img src="/orange-zzcs/imgs/image-20230426200848470.png" alt="image-20230426200848470"></p>
<h4 id="B-二进制与十进制（了解）"><a href="#B-二进制与十进制（了解）" class="headerlink" title="B.二进制与十进制（了解）"></a>B.二进制与十进制（了解）</h4><p><code>计算机底层都以补码的方式来存储数值！</code></p>
<p>正数的补码、反码、原码一样；负数的反码为：在原码基础上，除符号位（即最高位）外所有位都取反。负数的补码：在反码的基础上加1。</p>
<p>符号位上：0代表正数，1代表负数。</p>
<h4 id="C-其他进制之间的转换"><a href="#C-其他进制之间的转换" class="headerlink" title="C.其他进制之间的转换"></a>C.其他进制之间的转换</h4><ol>
<li><p>二进制转八进制：只需将二进制中从低位开始，每三个合成一个数即可。</p>
<p> <img src="/orange-zzcs/imgs/image-20230426200902100.png" alt="image-20230426200902100"></p>
</li>
<li><p>二进制转十六进制：只需将二进制中从低位开始，每四个合成一个数即可。</p>
<p> <img src="/orange-zzcs/imgs/image-20230426200911336.png" alt="image-20230426200911336"></p>
</li>
<li><p>八进制转二进制：将八进制中的一个数变成三位，然后将这些合起来即可。</p>
<p> <img src="/orange-zzcs/imgs/image-20230426200922680.png" alt="image-20230426200922680"></p>
</li>
<li><p>十六进制转二进制：将十六进制中的一个数变成四位，然后将这些合起来即可。</p>
<p> <img src="/orange-zzcs/imgs/image-20230426200931366.png" alt="image-20230426200931366"></p>
</li>
</ol>
<h4 id="D-总结"><a href="#D-总结" class="headerlink" title="D.总结"></a>D.总结</h4><p>实际开发中，很少用到进制转换知识，我们只需知识其转换的思想即可，如果开发中用到进制转换，我们会调用方法来解决，如·下图。<img src="/orange-zzcs/imgs/image-20230426200942518.png" alt="image-20230426200942518"></p>
<hr>
<h2 id="4、运算符"><a href="#4、运算符" class="headerlink" title="4、运算符"></a>4、运算符</h2><h3 id="A-算术运算符"><a href="#A-算术运算符" class="headerlink" title="A.算术运算符"></a>A.算术运算符</h3><p><img src="/orange-zzcs/imgs/image-20230426200952660.png" alt="image-20230426200952660"></p>
<p>注意：当容量小的数据类型的变量与容量大的数据类型的变量做算术运算时，结果自动提升为大容量的数据类型。</p>
<h4 id="1-除运算（-x2F-）"><a href="#1-除运算（-x2F-）" class="headerlink" title="1.除运算（  &#x2F;  ）"></a>1.除运算（  &#x2F;  ）</h4><p>如果除数和被除数都是整数，而想让结果变成浮点数，可以像下面那样。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">12</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">result</span> <span class="operator">=</span> num1*<span class="number">1.0</span> / num2;<span class="comment">//结果为2.4，注意结果的数据类型为double型，如果用float类型数据去接收结果需要强制转换。</span></span><br></pre></td></tr></table></figure>

<h4 id="2-取余运算（-）"><a href="#2-取余运算（-）" class="headerlink" title="2.取余运算（%）"></a>2.取余运算（%）</h4><p>结果的符号与被模数（即下面例子中的m变量）的符号相同。</p>
<img src="/imgs/image-20230426201004064.png" alt="image-20230426201004064" style="zoom:67%;" />

<p><img src="/orange-zzcs/imgs/image-20230426201016932.png" alt="image-20230426201016932"></p>
<h4 id="3-自增、自减运算"><a href="#3-自增、自减运算" class="headerlink" title="3.自增、自减运算"></a>3.自增、自减运算</h4><p>前（++），如：++a。先自加1，后运算。</p>
<p>后（++），如：a++。先运算，后自加1。</p>
<p>a–及–a同理</p>
<h3 id="B-赋值运算符"><a href="#B-赋值运算符" class="headerlink" title="B.赋值运算符"></a>B.赋值运算符</h3><h4 id="1-连续赋值"><a href="#1-连续赋值" class="headerlink" title="1.连续赋值"></a>1.连续赋值</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i1,i2;</span><br><span class="line">i1 = i2 = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//***************************</span></span><br><span class="line"><span class="type">int</span> <span class="variable">j1</span> <span class="operator">=</span> <span class="number">20</span>,j2 = <span class="number">30</span>;</span><br></pre></td></tr></table></figure>

<h4 id="2-x3D-、-x3D-、-x3D-、-x3D-、-x2F-x3D"><a href="#2-x3D-、-x3D-、-x3D-、-x3D-、-x2F-x3D" class="headerlink" title="2.+&#x3D;、-&#x3D;、*&#x3D;、%&#x3D;、&#x2F;&#x3D;"></a>2.+&#x3D;、-&#x3D;、*&#x3D;、%&#x3D;、&#x2F;&#x3D;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">num1 += <span class="number">2</span>;<span class="comment">//相当于num1 = num1 + 2，结果为12</span></span><br><span class="line"><span class="comment">//-=、*=、%=、/=也类似</span></span><br></pre></td></tr></table></figure>

<p>注意：+&#x3D;、-&#x3D;、*&#x3D;、%&#x3D;、&#x2F;&#x3D;不会改变变量本身的数据类型。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例一：</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>；</span><br><span class="line">i *= <span class="number">0.1</span>;<span class="comment">//执行完此行代码后，变量i的数据类型还是int型，因此i=0</span></span><br><span class="line">System.out.println(i);</span><br><span class="line">i++;</span><br><span class="line">System.out.println(i);<span class="comment">//i=1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//例二：</span></span><br><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">n *= m++;<span class="comment">//等价于：n = n * m++;即n = 3 * 2 </span></span><br><span class="line">System.out.println(m);<span class="comment">//3</span></span><br><span class="line">System.out.println(n);<span class="comment">//6</span></span><br></pre></td></tr></table></figure>



<p>补充：</p>
<p><img src="/orange-zzcs/imgs/image-20230426201030290.png" alt="image-20230426201030290"></p>
<p><img src="/orange-zzcs/imgs/image-20230426201037985.png" alt="image-20230426201037985"></p>
<h3 id="C-比较运算符"><a href="#C-比较运算符" class="headerlink" title="C.比较运算符"></a>C.比较运算符</h3><p><img src="/orange-zzcs/imgs/image-20230426201046831.png" alt="image-20230426201046831"></p>
<p>说明：</p>
<p>​	①比较运算符的结果都是boolean型，也即是true或false</p>
<p>​	② &gt;  、&lt; 、  &gt;&#x3D; 、 &lt;&#x3D; ：只能使用在数值型的数据之间。</p>
<p>​	③ !&#x3D;、&#x3D;&#x3D;：可以使用在数值型数据之间，还可以使用在其他引用类型变量之间。（存在自动类型转换）如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">10.0</span>;</span><br><span class="line">System.out.println(i == j);<span class="comment">//true</span></span><br><span class="line"><span class="type">char</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">System.out.println(i == k);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h3 id="D-逻辑运算符"><a href="#D-逻辑运算符" class="headerlink" title="D.逻辑运算符"></a>D.逻辑运算符</h3><p><img src="/orange-zzcs/imgs/image-20230426201058271.png" alt="image-20230426201058271"></p>
<p>说明：逻辑运算符操作的都是boolean类型的变量。其运算结果也是boolean类型数据。</p>
<h4 id="1-amp-与-amp-amp"><a href="#1-amp-与-amp-amp" class="headerlink" title="1.&amp; 与 &amp;&amp;"></a>1.&amp; 与 &amp;&amp;</h4><p>​		运算规则：两个为真，结果才为真。</p>
<p>​		相同点：</p>
<p>​				①&amp; 与 &amp;&amp; 的运算结果相同。</p>
<p>​				②当符号左边是true时，二者都会执行符号右边的运算。</p>
<p>​		不同点：当符号左边是false时，&amp;继续执行符号右边的运算。&amp;&amp;不再执行符号右边的运算。</p>
<p>​		写代码时推荐使用：&amp;&amp;。</p>
<h4 id="2-与"><a href="#2-与" class="headerlink" title="2.  |  与   ||"></a>2.  |  与   ||</h4><p>​		运算规则：其中一个为真，结果为真。</p>
<p>​		相同点：</p>
<p>​				① |  与 || 的运算结果相同。</p>
<p>​				②当符号左边是false时，二者都会执行符号右边的运算。</p>
<p>​		不同点：当符号左边是true时， |  继续执行符号右边的运算，而 || 不再执行符号右边的运算。</p>
<p>​		写代码时推荐使用：|| 。</p>
<h4 id="3-异或运算（-）"><a href="#3-异或运算（-）" class="headerlink" title="3.异或运算（^）"></a>3.异或运算（^）</h4><p>​		运算规则：相同为false，不相同为true。</p>
<h3 id="E-位运算符（了解）"><a href="#E-位运算符（了解）" class="headerlink" title="E.位运算符（了解）"></a>E.位运算符（了解）</h3><p><img src="/orange-zzcs/imgs/image-20230426201111871.png" alt="image-20230426201111871"></p>
<p>​	①操作对象：整型数据；其运算结果：整型数据。</p>
<p>​	②左移运算符（&lt;&lt;）和右移运算符(&gt;&gt;)</p>
<p>​	&lt;&lt; ：在一定范围内，每向左移1位，相当于 * 2。</p>
<p>​	&gt;&gt; ：在一定范围内，每向右移1位，相当于 &#x2F; 2。</p>
<h3 id="F-三元运算符"><a href="#F-三元运算符" class="headerlink" title="F.三元运算符"></a>F.三元运算符</h3><p>​	①格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//(条件表达式)? 表达式1 : 表达式2;</span></span><br></pre></td></tr></table></figure>

<p>​	②说明：</p>
<p>​       A.条件表达式的运算结果必须是boolean型。</p>
<p>​	   B.三元运算符的运算结果是返回表达式1或表达式2。如：</p>
<p><img src="/orange-zzcs/imgs/image-20230426201122933.png" alt="image-20230426201122933"></p>
<p>​	   C.如果条件表达式为true，执行表达式1；如果表达式为false，执行表达式2。</p>
<p>​	   D.表达式1和表达式2的数据类型可以不一样，但接收三元表达式结果的变量的数据类型要能接收这两个表达式的数据类型。如：</p>
<p><img src="/orange-zzcs/imgs/image-20230426201131464.png" alt="image-20230426201131464"></p>
<p>​	  E.三元运算符可以嵌套使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> (m &gt; n)? <span class="string">&quot;m大&quot;</span> : ((m == n)? <span class="string">&quot;m = n&quot;</span> : <span class="string">&quot;n大&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>​	  F.凡是可以使用三元运算符的地方，都可以改写成 if-else语句。当程序既可以使用三元运算符，又可以使用if-else结构，那么优先选择三元运算符。原因是：简洁、执行效率高。</p>
<p>练习：如何获取三个数中的最大值？</p>
<p><img src="/orange-zzcs/imgs/image-20230426201141917.png" alt="image-20230426201141917"></p>
<hr>
<h2 id="5、流程控制"><a href="#5、流程控制" class="headerlink" title="5、流程控制"></a>5、流程控制</h2><h3 id="A-分支结构"><a href="#A-分支结构" class="headerlink" title="A.分支结构"></a>A.分支结构</h3><h4 id="①if…-else"><a href="#①if…-else" class="headerlink" title="①if….else"></a>①if….else</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 条件判断语句的三种结构</span></span><br><span class="line"><span class="comment">1、</span></span><br><span class="line"><span class="comment">if(条件表达式)&#123;</span></span><br><span class="line"><span class="comment">	代码块；</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">2、</span></span><br><span class="line"><span class="comment">if（条件表达式）&#123;</span></span><br><span class="line"><span class="comment">	代码块1；</span></span><br><span class="line"><span class="comment">&#125;else&#123;</span></span><br><span class="line"><span class="comment">	代码块2；</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">3、</span></span><br><span class="line"><span class="comment">if(条件表达式)&#123;</span></span><br><span class="line"><span class="comment">	代码块1；</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">else if（条件表达式2）&#123;</span></span><br><span class="line"><span class="comment">	代码块2；</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">......</span></span><br><span class="line"><span class="comment">else&#123;  //此行的else结构是可选项，即可有可无。</span></span><br><span class="line"><span class="comment">	代码块n;//如果上面的条件表达式都不为true，则执行代码块n</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><img src="/orange-zzcs/imgs/image-20230426201152697.png" alt="image-20230426201152697"></p>
<h4 id="②switch-case"><a href="#②switch-case" class="headerlink" title="②switch-case"></a>②switch-case</h4><p>​		A.switch-case的结构</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">switch(表达式)&#123;  //表达式：一般为一个变量</span></span><br><span class="line"><span class="comment">	case 常量1:</span></span><br><span class="line"><span class="comment">		语句1; //可以是多个语句</span></span><br><span class="line"><span class="comment">		break;</span></span><br><span class="line"><span class="comment">	case 常量2:</span></span><br><span class="line"><span class="comment">		语句2;</span></span><br><span class="line"><span class="comment">		break;</span></span><br><span class="line"><span class="comment">	.....</span></span><br><span class="line"><span class="comment">    case 常量N:</span></span><br><span class="line"><span class="comment">		语句N;</span></span><br><span class="line"><span class="comment">		break;</span></span><br><span class="line"><span class="comment">	default: //当上面的case都不满足时，执行default。</span></span><br><span class="line"><span class="comment">		语句;</span></span><br><span class="line"><span class="comment">		break;//此行的break可写可不写</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">//default结构为可选项。每个case里的break也是可选项，不过一般都写上。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>​		B.说明</p>
<p>​			①根据switch表达式中的值，依次匹配各个case中的常量。一旦匹配成功，则进入相应case结构中，调用其执行语句。当调用完执行语句以后，则仍然继续向下执行其他case结构中的执行语句（<code>向下执行过程中不再进行case的判断</code>），直到遇到break关键字或switch-case结构末尾结束为止。</p>
<p>​			②switch结构中的表达式，只能是如下的6种数据类型之一：byte、short、char、int、枚举类型（jdk5.0新增）、String类型（jdk7.0新增）。</p>
<p>​			③case之后只能声明常量，不能声明范围。如下面的情况，编译会报错。</p>
<p>​		C.补充</p>
<p>​			①如果switch-case结构中的多个case的执行语句相同，则可以考虑进行合并。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> <span class="number">78</span>;</span><br><span class="line"><span class="keyword">switch</span>(score / <span class="number">10</span>)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;不及格&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;不及格&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;及格&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以合并成：</span></span><br><span class="line"><span class="keyword">switch</span>(score / <span class="number">10</span>)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;不及格&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;及格&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​			②当switch的参数为一个枚举类对象时，case 后面直接写枚举类的对象名即可。</p>
<p><img src="/orange-zzcs/imgs/image-20230426201301084.png" alt="image-20230426201301084"></p>
<p>​		throw可以代替break。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="/orange-zzcs/imgs/image-20230426201310715.png" alt="image-20230426201310715"></p>
<hr>
<h3 id="B-循环结构"><a href="#B-循环结构" class="headerlink" title="B.循环结构"></a>B.循环结构</h3><h4 id="①for"><a href="#①for" class="headerlink" title="①for"></a>①for</h4><p>​		a.for循环的结构</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//①初始化条件  ②循环条件(是boolean类型) ③循环体 ④迭代条件</span></span><br><span class="line"><span class="keyword">for</span>(①;②;④)&#123;</span><br><span class="line">    ③</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//初始化条件中定义的变量只在for循环中有效。</span></span><br><span class="line"><span class="comment">//当初始化条件当中有多个时，请使用“,”将各个部分隔开。如：</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>,k = <span class="number">2</span>;j &lt;= <span class="number">5</span>;j++)&#123;</span><br><span class="line">    k++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果初始化条件放在了for循环的外面，则①的位置就不用写东西了，如：</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(;i &lt; <span class="number">10</span>;i++)&#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这样写，出来了for循环后i还可以继续使用</span></span><br></pre></td></tr></table></figure>



<h4 id="②while"><a href="#②while" class="headerlink" title="②while"></a>②while</h4><p>​		a.while循环的结构</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//①初始化条件  ②循环条件(是boolean类型) ③循环体 ④迭代条件</span></span><br><span class="line"><span class="comment">/*while循环的结构：</span></span><br><span class="line"><span class="comment">①;</span></span><br><span class="line"><span class="comment">while(②)&#123;</span></span><br><span class="line"><span class="comment">    ③;</span></span><br><span class="line"><span class="comment">    ④;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>​		b.声明</p>
<p>​			①写while循环千万小心不要丢了迭代条件。一旦丢了，就可能导致死循环！</p>
<p>​			②for循环和while循环是可以相互转换的！for循环和while循环的区别：初始化条件部分的作用范围不同。（for循环中的初始化条件变量只能在for循环里使用，出来for循环就没有了；而while循环的初始化条件变量出了while循环后还可以使用）</p>
<h4 id="③do…-while"><a href="#③do…-while" class="headerlink" title="③do….while"></a>③do….while</h4><p>​		a.do….while循环的结构</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//①初始化条件  ②循环条件(是boolean类型) ③循环体 ④迭代条件</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">①；</span></span><br><span class="line"><span class="comment">do&#123;</span></span><br><span class="line"><span class="comment">   ③；</span></span><br><span class="line"><span class="comment">   ④；</span></span><br><span class="line"><span class="comment">&#125;while(②);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">执行顺序：① - ③ - ④ - ② - ③ - ④ - .... - ② </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>​		b.说明</p>
<p>​			①do-while循环至少执行一次循环体。</p>
<p>​			②当do-while循环中的循环体执行多次时，其与while循环、for循环的执行结果是一样的。<u>日常开发中常用for循环和while循环。</u></p>
<h3 id="C-练习"><a href="#C-练习" class="headerlink" title="C.练习"></a>C.练习</h3><h4 id="补充说明："><a href="#补充说明：" class="headerlink" title="补充说明："></a>补充说明：</h4><p>​		①当要求输入某个特定值时才可以终止循环时，就需要用到下面的结构：while(true)或for(;;)，再根据实际条件在循环内加上break即可。如：下面的练习一。</p>
<p>​		②结束循环的两种方式：</p>
<p>​			A.不再满足循环条件。</p>
<p>​			B.在循环体中，执行break。</p>
<hr>
<p>​	 练习一：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题目：</span></span><br><span class="line"><span class="comment">从键盘读入个数不确定的整数，并判断读入的正数和负数的个数，输入为0时结束程序。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="variable">positiveNumber</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//记录正数的个数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">negativeNumber</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//记录负数的个数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123; <span class="comment">//while(true)这个结构等价于for(;;)</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">    <span class="keyword">if</span>(number &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        positiveNumber++；</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(number &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        negativeNumber++;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	练习二：求100以内的质数。（质数：只能能被1和自身整除的数，最小的质数为2。）</p>
<img src="/imgs/image-20230426201327670.png" alt="image-20230426201327670" style="zoom:67%;" />

<p>​		为什么要重置isFlag？如果前一个数的isFlag是false，而接下来的一个数就算是质数，那么也不会被输出。</p>
<hr>
<h4 id="嵌套循环："><a href="#嵌套循环：" class="headerlink" title="嵌套循环："></a>嵌套循环：</h4><p>​		当为两层循环时，可以将嵌套循环看成是一个表格，内层循环相当于列，外层循环相当于行。</p>
<hr>
<h3 id="D-break、continue"><a href="#D-break、continue" class="headerlink" title="D.break、continue"></a>D.break、continue</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">            使用范围       循环中使用的作用      相同点</span></span><br><span class="line"><span class="comment">break；     switch-case       </span></span><br><span class="line"><span class="comment">		   循环结构中      结束当前循环      关键字后面不能</span></span><br><span class="line"><span class="comment">                                            紧接着声明执行</span></span><br><span class="line"><span class="comment">continue：  循环结构中      结束当次循环      语句</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>补充：<br>    ①当break，continue用于多重循环结构时，break是默认跳出最近的一层循环；continue是默认结束最近一层循环的当前循环。<br>    ②如果想用break结束指定某一层的for循环，则在那层的for循环前加上个“标签”（标签名可以随便起），然后再break + “标签”即可，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">label:<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= <span class="number">4</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j &lt;= <span class="number">10</span>;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(j % <span class="number">4</span> == <span class="number">0</span>)&#123;</span><br><span class="line">				<span class="keyword">break</span> label;<span class="comment">//结束的是外层的for循环</span></span><br><span class="line">			&#125;</span><br><span class="line">			System.out.print(j);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println();</span><br><span class="line">	  &#125; <span class="comment">//输出结果为：123</span></span><br></pre></td></tr></table></figure>

<p>​	③如果想用continue结束指定某一层的for循环当前循环，则在那层的for循环前加上个“标签”（标签名可以随便起），然后再continue+ “标签”即可，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">label:<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= <span class="number">4</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j &lt;= <span class="number">10</span>;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(j % <span class="number">4</span> == <span class="number">0</span>)&#123;</span><br><span class="line">				<span class="keyword">continue</span> label;<span class="comment">//结束的是外层的for循环</span></span><br><span class="line">			&#125;</span><br><span class="line">			System.out.print(j);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println();</span><br><span class="line">	  &#125; <span class="comment">//输出结果为：123123123123</span></span><br></pre></td></tr></table></figure>

<p>​	④当循环结构里面有个switch-case，而你想当执行到某个case时就结束循环，可以在循环前面加个“标签”，然后在break+“标签”，即可。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">label:<span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">    <span class="keyword">switch</span> (number) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            System.out.print(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">//结束的是switch-case</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            System.out.print(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">//结束的是switch-case</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            System.out.print(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span> label;<span class="comment">//结束的是while循环</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;已退出while循环&quot;</span>);</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>



<p>​	练习：求2-100000以内的所有质数并计算质数的总数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;2-100000的质数有：&quot;</span>);</span><br><span class="line">label:<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>;i &lt;= <span class="number">100000</span>;i++)&#123;</span><br><span class="line">       	<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span>;j &lt;= Math.sqrt(i);j++) &#123;</span><br><span class="line">		  <span class="keyword">if</span> (i % j == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">continue</span> label;</span><br><span class="line">	       &#125;</span><br><span class="line">	  	&#125;</span><br><span class="line">	  	count++;</span><br><span class="line">	   	System.out.println(i);</span><br><span class="line">	  &#125;</span><br><span class="line">	System.out.println(<span class="string">&quot;2-100000的质数个数为&quot;</span> + count);</span><br><span class="line">	&#125;	</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="6、Scanner-获取输入"><a href="#6、Scanner-获取输入" class="headerlink" title="6、Scanner(获取输入)"></a>6、Scanner(获取输入)</h2><h3 id="A-实现步骤"><a href="#A-实现步骤" class="headerlink" title="A.实现步骤"></a>A.实现步骤</h3><p>​		①导包：import java.util.Scanner；&#x2F;&#x2F;需写在程序的开头</p>
<p>​		②Scanner的实例化：Scanner 变量名 &#x3D; new Scanner(System.in);</p>
<p>​		③调用Scanner类的相关方法：</p>
<p>​			A.如果想获取int、byte、short、long、float、double类型的数据，则：变量名.nextXxx()，如：变量名.nextInt等。</p>
<p>​			B.如果想获取字符串，则：变量名.next()。</p>
<p>​			C.Scanner没有提供获取char类型变量的方法，如果想获取char类型变量，可以先获取String类型变量，再利用String类的方法来转换成char类型变量。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> scan.next();</span><br><span class="line"><span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s1.charAt(<span class="number">0</span>);<span class="comment">//0代表：获取s1字符串的第一个字符。如果是1：代表获取s1字符串的第二个字符。</span></span><br></pre></td></tr></table></figure>



<h3 id="B-注意"><a href="#B-注意" class="headerlink" title="B.注意"></a>B.注意</h3><pre><code> 需要根据相应的方法，来输入指定类型的值。如果输入的数据类型与要求的类型不匹配时，会报异常：InputMisMatchExcpetion，导致程序终止。
</code></pre>
<hr>
<h2 id="7、生成随机数"><a href="#7、生成随机数" class="headerlink" title="7、生成随机数"></a>7、生成随机数</h2><p>​	想在[a,b]这个范围内，生成一个随机整数，如何做呢？</p>
<h4 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h4><p>​		(int)(Math.random() * (b - a + 1) + a)</p>
<p>​		注：a,b都为整数</p>
<p>​		补充：Math.random()产生的是[0.0,1.0)的随机数（产生的随机数为double型）</p>
<p>如：在[10,99]生成一个随机数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> (<span class="type">int</span>)(Math.random() * (<span class="number">99</span> - <span class="number">10</span> + <span class="number">1</span>) + <span class="number">10</span>);</span><br></pre></td></tr></table></figure>



<h2 id="8、数组"><a href="#8、数组" class="headerlink" title="8、数组"></a>8、数组</h2><h3 id="①数组的概述"><a href="#①数组的概述" class="headerlink" title="①数组的概述"></a>①数组的概述</h3><p>​	数组实际上是一种特殊的类，其继承于Object类，因此也可以调用Object类中的方法。例子：int arr[]，则其属于一维数组int类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> b[] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">b.equals(obj);</span><br></pre></td></tr></table></figure>



<h4 id="A-数组相关的概念"><a href="#A-数组相关的概念" class="headerlink" title="A.数组相关的概念"></a>A.数组相关的概念</h4><p>​			&gt; 数组名 </p>
<p>​			&gt; 元素</p>
<p>​			&gt; 角标、下标、索引（三者其实是同一个概念）</p>
<p>​			&gt; 数组的长度：即元素的个数</p>
<h4 id="B-数组的特点"><a href="#B-数组的特点" class="headerlink" title="B.数组的特点"></a>B.数组的特点</h4><p><img src="/orange-zzcs/imgs/image-20230426201353925.png" alt="image-20230426201353925"></p>
<h4 id="C-数组的分类"><a href="#C-数组的分类" class="headerlink" title="C.数组的分类"></a>C.数组的分类</h4><p><img src="/orange-zzcs/imgs/image-20230426201401583.png" alt="image-20230426201401583"></p>
<h3 id="②一维数组"><a href="#②一维数组" class="headerlink" title="②一维数组"></a>②一维数组</h3><h4 id="A-一维数组声明和初始化"><a href="#A-一维数组声明和初始化" class="headerlink" title="A.一维数组声明和初始化"></a>A.一维数组声明和初始化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">静态初始化：(数组的初始化和数组元素的赋值操作同时进行)</span></span><br><span class="line"><span class="comment">int[] ids = new int[]&#123;1,2,3,4,5&#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">动态初始化：(数组的初始化和数组元素的赋值操作分开进行)</span></span><br><span class="line"><span class="comment">String[] names = new String[5]; </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">声明和初始化可以分开，如：</span></span><br><span class="line"><span class="comment">int[] number;</span></span><br><span class="line"><span class="comment">number = new int[]&#123;2,3,4,5&#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">String[] address;</span></span><br><span class="line"><span class="comment">address = new String[5];</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注意：数组的正确声明和初始化方式只有以上四种</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>​	总结：数组一旦初始化完成，其长度就确定了。数组长度一旦确定			   了，就不可以修改。		</p>
<h4 id="B-数组元素的使用"><a href="#B-数组元素的使用" class="headerlink" title="B.数组元素的使用"></a>B.数组元素的使用</h4><pre><code> 通过索引（即下标）的方式调用，格式为： 数组名[索引]  ，如：
</code></pre>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String[] names = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">3</span>];</span><br><span class="line">names[<span class="number">0</span>] = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">names[<span class="number">1</span>] = <span class="string">&quot;def&quot;</span>;</span><br><span class="line">names[<span class="number">2</span>] = <span class="string">&quot;ghi&quot;</span>;</span><br><span class="line">System.out.println(names[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>



<h4 id="C-获取数组的长度"><a href="#C-获取数组的长度" class="headerlink" title="C.获取数组的长度"></a>C.获取数组的长度</h4><p>​	  格式为：数组名.length，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] names = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;def&quot;</span>,<span class="string">&quot;ghi&quot;</span>&#125;;</span><br><span class="line">System.out.println(names.length);<span class="comment">//为3</span></span><br></pre></td></tr></table></figure>



<h4 id="D-遍历数组"><a href="#D-遍历数组" class="headerlink" title="D.遍历数组"></a>D.遍历数组</h4><p><img src="/orange-zzcs/imgs/image-20230426201415426.png" alt="image-20230426201415426"></p>
<h4 id="E-数组元素的默认初始化值"><a href="#E-数组元素的默认初始化值" class="headerlink" title="E.数组元素的默认初始化值"></a>E.数组元素的默认初始化值</h4><p>​		数组元素是整型：默认为：0</p>
<p>​		数组元素是浮点型：默认为：0.0</p>
<p>​		数组元素是char型：默认为：ASCII为零的那个字符</p>
<p>​		数组元素是boolean型：默认为：false</p>
<p>​		数组元素是String型：默认为：null</p>
<h4 id="F-数组的内存分析"><a href="#F-数组的内存分析" class="headerlink" title="F.数组的内存分析"></a>F.数组的内存分析</h4><p>​		内存的主要结构有：</p>
<img src="/imgs/image-20230426201435906.png" alt="image-20230426201435906" style="zoom:67%;" />

<p>​		局部变量：在方法中定义的变量。</p>
<p>​		常量池：存放字符串。</p>
<img src="/imgs/image-20230426201456265.png" alt="image-20230426201456265" style="zoom:67%;" />



<h3 id="③二维数组"><a href="#③二维数组" class="headerlink" title="③二维数组"></a>③二维数组</h3><p>​	二维数组：设实际上是一维数组里的元素是一个一维数组。</p>
<p><img src="/orange-zzcs/imgs/image-20230426201517488.png" alt="image-20230426201517488"></p>
<h4 id="A-二维数组声明和初始化"><a href="#A-二维数组声明和初始化" class="headerlink" title="A.二维数组声明和初始化"></a>A.二维数组声明和初始化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">静态初始化：</span></span><br><span class="line"><span class="comment">int[][] arr1 = new int[][]&#123;&#123;1,3,4&#125;,&#123;2,6,7&#125;,&#123;5,8&#125;&#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">动态初始化1：</span></span><br><span class="line"><span class="comment">String[][] arr2 = new String[3][2];//3行2列</span></span><br><span class="line"><span class="comment">动态初始化2：</span></span><br><span class="line"><span class="comment">String[][] arr3 = new String[3][];</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">以上写法是正确的写法。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>​		总结：</p>
<p>​			二维数组就像一张表，第一个“[ ]”，就相当于表中的行，第二个“[ ] ”就相当于表中的列。</p>
<h4 id="B-数组元素的使用-1"><a href="#B-数组元素的使用-1" class="headerlink" title="B.数组元素的使用"></a>B.数组元素的使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] arr1 = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">2</span>,<span class="number">6</span>,<span class="number">7</span>&#125;,&#123;<span class="number">5</span>,<span class="number">8</span>&#125;&#125;;</span><br><span class="line">System.out.println(arr1[<span class="number">0</span>][<span class="number">0</span>]);<span class="comment">//输出结果为：1</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果想输出第n行，第n列的元素，其格式为：数组名[n-1][n-1];</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">String[][] arr3 = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">3</span>][];</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果使用了上面的方式声明和初始化数组，想要输出数组第二行某列的元素，则先要指定该行有多少列：</span></span><br><span class="line"><span class="comment">arr3[1] = new String[4];//第二行有四列</span></span><br><span class="line"><span class="comment">然后才可以输出第二行某列的元素。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">String[][] arr2 = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">3</span>][<span class="number">2</span>];</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果使用了上面的声明和初始化方式，想要输出数组的第n行第n列的元素，其格式为：数组名[n-1][n-1];</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>​	</p>
<h4 id="C-获取数组的长度-1"><a href="#C-获取数组的长度-1" class="headerlink" title="C.获取数组的长度"></a>C.获取数组的长度</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">数组名.length;//结果为此数组的行数</span></span><br><span class="line"><span class="comment">数组名[n].length;//结果为第n-1行的列数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">//联想一下二维数在内存中的存储形式就能理解上面的知识</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h4 id="D-遍历数组-1"><a href="#D-遍历数组-1" class="headerlink" title="D.遍历数组"></a>D.遍历数组</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] arr1 = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">7</span>,<span class="number">8</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; arr1.length;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; arr1[i].length;j++)&#123;</span><br><span class="line">        System.out.print(arr1[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行结果为：</span></span><br><span class="line"><span class="comment">1 2 4 </span></span><br><span class="line"><span class="comment">4 5 </span></span><br><span class="line"><span class="comment">7 8 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h4 id="E-数组元素的默认初始化值-1"><a href="#E-数组元素的默认初始化值-1" class="headerlink" title="E.数组元素的默认初始化值"></a>E.数组元素的默认初始化值</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">规定：二维数组分为外层数组的元素，内层数组的元素</span></span><br><span class="line"><span class="comment">	int[][] arr = new int[3][4];</span></span><br><span class="line"><span class="comment">	外层元素：arr[0]、arr[1]等</span></span><br><span class="line"><span class="comment">	内存元素：arr[0][0]、arr[1][1]等</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">① 数组元素的默认初始化值</span></span><br><span class="line"><span class="comment">针对初始化方式一：比如：int[][] arr = new int[3][4];</span></span><br><span class="line"><span class="comment">	外层元素的初始化值为：地址值</span></span><br><span class="line"><span class="comment">	内存元素的初始化值为：与一维数组初始化情况相同，如果数组类					    型为int型，则为0;为float型，则为						0.0;String型，则为null；Boolean						 型，则为false。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">针对初始化方式二：比如：int[][] arr = new int[3][];</span></span><br><span class="line"><span class="comment">	外层元素的初始化值为：null（因为外层元素都是存放一维数						  组--&gt; 而一维数组是引用类型--&gt; 引用						  类型数据默认初始化值为null --&gt; 所以					  这里为null）</span></span><br><span class="line"><span class="comment">	内存元素的初始化值为：不能调用，否则会报错</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>​	</p>
<h4 id="F-数组的内存分析-1"><a href="#F-数组的内存分析-1" class="headerlink" title="F.数组的内存分析"></a>F.数组的内存分析</h4><p><img src="/orange-zzcs/imgs/image-20230426201559357.png" alt="image-20230426201559357"></p>
<h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p>​	引用数据类型变量的值要么是null，要么是一个地址值。</p>
<h3 id="④数组练习"><a href="#④数组练习" class="headerlink" title="④数组练习"></a>④数组练习</h3><h4 id="练习一"><a href="#练习一" class="headerlink" title="练习一"></a>练习一</h4><p><img src="/orange-zzcs/imgs/image-20230426201609577.png" alt="image-20230426201609577"></p>
<p>​	解释：</p>
<p>​		x是一维数组，y是二维数组。进行赋值时，要么两个变量的类型一样，要么满足自动转换或进行强制转换。</p>
<p>​		a) y是一维数组，x[0]是一个int型数据，两者类型不一样，不能进行赋值。</p>
<p>​		b) x是一维数组，y[0]也是一维数组，所以可以赋值。</p>
<p>​		c) x是一维数组，y【0】【0】是int型数据，两者类型不一样，不能进行赋值。</p>
<p>​		d) x是一维数组，不存在x【0】【0】</p>
<p>​		e) x[0]是int型数据，y【0】【0】也是int型数据，两者类型一样，可以赋值。</p>
<p>​		f) x是一维数组，y是二维数组，两者类型不一样，不可以赋值。</p>
<h3 id="⑤数组中涉及的常见算法"><a href="#⑤数组中涉及的常见算法" class="headerlink" title="⑤数组中涉及的常见算法"></a>⑤数组中涉及的常见算法</h3><h4 id="A-数组元素的赋值（会在面试中以手写的形式考察）"><a href="#A-数组元素的赋值（会在面试中以手写的形式考察）" class="headerlink" title="A.数组元素的赋值（会在面试中以手写的形式考察）"></a>A.数组元素的赋值（会在面试中以手写的形式考察）</h4><p>​	a.杨辉三角</p>
<p><img src="/orange-zzcs/imgs/image-20230426201621541.png" alt="image-20230426201621541"></p>
<p>​	代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//先把数组的框搭建起来</span></span><br><span class="line">    <span class="type">int</span>[][] yanghui = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>][];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; yanghui.length;i++) &#123;</span><br><span class="line">        yanghui[i] = <span class="keyword">new</span> <span class="title class_">int</span>[i+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//为数组里的每个元素赋值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; yanghui.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; yanghui[i].length;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">0</span> || j == (yanghui[i].length-<span class="number">1</span>)) &#123;</span><br><span class="line">                yanghui[i][j] = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                yanghui[i][j] = (yanghui[i-<span class="number">1</span>][j] +                                           yanghui[i-<span class="number">1</span>][j-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历输出数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; yanghui.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; yanghui[i].length;j++) &#123;</span><br><span class="line">            System.out.print(yanghui[i][j] + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<p>​	</p>
<p>​	b.回形数</p>
<h4 id="B-求数值型数组中元素的最大值、最小值、平均数、总和等"><a href="#B-求数值型数组中元素的最大值、最小值、平均数、总和等" class="headerlink" title="B.求数值型数组中元素的最大值、最小值、平均数、总和等"></a>B.求数值型数组中元素的最大值、最小值、平均数、总和等</h4><p>​	题目要求：定义一个int型的一维数组，包含10个元素，分别赋一些随机整数，然后求出所有元素的最大值，最小值，和值，平均值，并输出出来。所有随机数都是两位数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; arr.length;i++) &#123;</span><br><span class="line">        arr[i] = (<span class="type">int</span>)(Math.random() * <span class="number">90</span> + <span class="number">10</span>);</span><br><span class="line">        System.out.print(arr[i] + <span class="string">&quot; &quot;</span>);<span class="comment">//输出该数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">    <span class="comment">//求数组里的最大值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; max) &#123;</span><br><span class="line">            max = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;该数组的最大值为：&quot;</span> + max);</span><br><span class="line">    <span class="comment">//求数组里的最小值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; min) &#123;</span><br><span class="line">            min = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;该数组的最小值为：&quot;</span> + min);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//求数组的总和</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        sum += arr[i]; </span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;该数组的总和为：&quot;</span> + sum);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//求数组的平均数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">avg</span> <span class="operator">=</span> sum / arr.length;</span><br><span class="line">    System.out.println(<span class="string">&quot;该数组的平均数为：&quot;</span> + avg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="C-数组的复制、反转、查找（线性查找、二分法查找（会在面试中考察））"><a href="#C-数组的复制、反转、查找（线性查找、二分法查找（会在面试中考察））" class="headerlink" title="C.数组的复制、反转、查找（线性查找、二分法查找（会在面试中考察））"></a>C.数组的复制、反转、查找（线性查找、二分法查找（会在面试中考察））</h4><p>​	<strong>复制</strong>：</p>
<p>​		将arr1数组复制到arr2数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr1 = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span>[] arr2;</span><br><span class="line">arr2 = arr1;<span class="comment">//这种操作不能称作数组的“复制”。因为arr2指向的是			arr1数组。</span></span><br><span class="line"><span class="comment">//数组的复制：</span></span><br><span class="line">arr2 = <span class="keyword">new</span> <span class="title class_">int</span>[arr1.length];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; arr2.length;i++)&#123;</span><br><span class="line">    arr2[i] = arr1[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	</p>
<p>​	<strong>反转</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr1 = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//中间变量</span></span><br><span class="line">    <span class="comment">//对数组进行反转</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr1.length / <span class="number">2</span>; i++) &#123;</span><br><span class="line">        temp = arr1[i];</span><br><span class="line">        arr1[i] = arr1[arr1.length - <span class="number">1</span> - i];</span><br><span class="line">        arr1[arr1.length - <span class="number">1</span> - i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对反转后的数组进行输出</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr1.length; i++) &#123;</span><br><span class="line">        System.out.print(arr1[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;<span class="comment">//结果为：6 5 4 3 2 1 </span></span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>



<p>​	<strong>查找</strong>：(两种基本的查找方式：线性查找、二分查找(此方法常用))</p>
<p>​		①线性查找：(即：从前往后一个一个进行查找)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">String[] arr = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;aa&quot;</span>,<span class="string">&quot;bb&quot;</span>,<span class="string">&quot;cc&quot;</span>&#125;;</span><br><span class="line"><span class="type">String</span> <span class="variable">dest</span> <span class="operator">=</span> <span class="string">&quot;bb&quot;</span>;<span class="comment">//查找对象</span></span><br><span class="line"><span class="comment">//从前往后遍历数组，看是否找到查找对象</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; arr.length;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(dest.equals(arr[i]))&#123;</span><br><span class="line">        <span class="comment">//dest.equals(字符串A)的作用是判断dest字符串是否与字符串A相等，如果相等返回true，不相等返回false。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;找到了指定的元素，位置为：&quot;</span>+i);</span><br><span class="line">        <span class="keyword">break</span>;<span class="comment">//找到之后就退出for循环		       </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i == arr.length - <span class="number">1</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;找不到指定的元素&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		总结：</p>
<p>​			如果想比较两个字符串是否相等，可以使用字符串变量里的equals方法，如果相等，则返回true，不相等，则返回false。</p>
<hr>
<p>​		②二分法查找：(即：折半查找)</p>
<p>​			前提：<strong>所要查找的数组必须要有序。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">24</span>,<span class="number">56</span>,<span class="number">77</span>&#125;;</span><br><span class="line">    <span class="type">int</span> <span class="variable">dest</span> <span class="operator">=</span> <span class="number">12</span>;<span class="comment">//查找目标</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">head</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//初始的首索引</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> arr.length - <span class="number">1</span>;<span class="comment">//初始的尾索引</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isFlag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//二分查找</span></span><br><span class="line">    <span class="keyword">while</span>(head &lt;= end) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> (head + end) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (dest == arr[middle]) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;找到了指定的元素，位置为：&quot;</span> 									+ middle);</span><br><span class="line">            isFlag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dest &gt; arr[middle]) &#123;</span><br><span class="line">            head = middle + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            end = middle - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isFlag) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;找不到指定的元素&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<p>​			</p>
<h4 id="D-数组元素的排序算法（会在面试中考察）"><a href="#D-数组元素的排序算法（会在面试中考察）" class="headerlink" title="D.数组元素的排序算法（会在面试中考察）"></a>D.数组元素的排序算法（会在面试中考察）</h4><p>​	排序不仅出现在整型、浮点型数据中，还可以出现在字符串、字符、对象(根据对象的某个属性进行排序)中。</p>
<p><img src="/orange-zzcs/imgs/image-20230426201649608.png" alt="image-20230426201649608"></p>
<p>​	说明：红色字体：要求会手写；黄色字体：要求知道其算法思想。其他了解。</p>
<p>​		①冒泡排序（时间复杂度为：o(n^2)）</p>
<p>​			算法思想：如果想得到一个升序数组。从下标为0的元素开始比较，如果左边的数比右边的数大，则交换，经过一轮后得到一个最大值，然后进行进行下一轮比较，以此类推。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">1</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//中间变量</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">比较轮数 i = 元素个数-1</span></span><br><span class="line"><span class="comment">如果 i 的初始值为1，j的初始值为0，则：</span></span><br><span class="line"><span class="comment">每轮的比较次数 j = 元素个数 - 当前轮数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="comment">//冒泡排序(求升序)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; arr.length;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; arr.length - i;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//循环输出数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        System.out.print(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>



<p>​		②快速排序（面试前再看）</p>
<p>​			时间复杂度为：</p>
<p><img src="/orange-zzcs/imgs/image-20230426201705086.png" alt="image-20230426201705086"></p>
<p>​			算法思想：以求升序为例。每次选数组的第一个元素作为基准，比基准小的数放到右边，比基准大的数放左边，此轮结束后，就会形成两个分区，再分别对这两个分区进行以上操作，直到分区中只有一个元素为止。如：</p>
<img src="/imgs/image-20230426201713449.png" alt="image-20230426201713449" style="zoom:67%;" />



<p>​		③堆排序（面试前再看，问思想）</p>
<p>​		④归并排序（面试前再看，问思想）</p>
<h4 id="E-算法学习网址"><a href="#E-算法学习网址" class="headerlink" title="E.算法学习网址"></a>E.算法学习网址</h4><p><a target="_blank" rel="noopener" href="https://visualgo.net/zh/sorting">https://visualgo.net/zh/sorting</a></p>
<hr>
<h3 id="⑥数组工具类的使用"><a href="#⑥数组工具类的使用" class="headerlink" title="⑥数组工具类的使用"></a>⑥数组工具类的使用</h3><p>​	使用下列方法之前要先写：java.util.Arrays;</p>
<p><img src="/orange-zzcs/imgs/image-20230426201743417.png" alt="image-20230426201743417"></p>
<h4 id="A-判断两个数组是否相等"><a href="#A-判断两个数组是否相等" class="headerlink" title="A.判断两个数组是否相等"></a>A.判断两个数组是否相等</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法为：Arrays.equals(数组名1,数组名2);</span></span><br><span class="line"><span class="comment">//例子：</span></span><br><span class="line"><span class="type">int</span> <span class="variable">arr1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="variable">arr2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isEquals</span> <span class="operator">=</span> Arrays.equals(arr1,arr2);</span><br><span class="line"><span class="comment">//如果两个数相等，则返回true，不相等，则返回false。</span></span><br></pre></td></tr></table></figure>



<h4 id="B-输出数组信息"><a href="#B-输出数组信息" class="headerlink" title="B.输出数组信息"></a>B.输出数组信息</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法为：Arrays.toString(数组名);</span></span><br><span class="line"><span class="comment">//例子：</span></span><br><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">1</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>&#125;;</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br><span class="line"><span class="comment">//注意：Arrays.toString(arr)要放在System.out.println()里不然输出不了结果</span></span><br></pre></td></tr></table></figure>

<p>​		输出结果为：</p>
<p><img src="/orange-zzcs/imgs/image-20230426201755466.png" alt="image-20230426201755466"></p>
<h4 id="C-将数组里的值全替换成某个数"><a href="#C-将数组里的值全替换成某个数" class="headerlink" title="C.将数组里的值全替换成某个数"></a>C.将数组里的值全替换成某个数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法为：Arrays.fill(数组名, 替换成的值);</span></span><br><span class="line"><span class="comment">//例子：</span></span><br><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">1</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>&#125;;</span><br><span class="line">System.out.println(<span class="string">&quot;原来的结果为：&quot;</span> + Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line"><span class="comment">//替换操作：</span></span><br><span class="line">Arrays.fill(arr, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;替换后的结果为：&quot;</span>+Arrays.toString(arr));</span><br></pre></td></tr></table></figure>

<p>​		运行结果为：</p>
<p><img src="/orange-zzcs/imgs/image-20230426201805796.png" alt="image-20230426201805796"></p>
<h4 id="D-对数组进行升序排序"><a href="#D-对数组进行升序排序" class="headerlink" title="D.对数组进行升序排序"></a>D.对数组进行升序排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法为：Arrays.sort(数组名);</span></span><br><span class="line"><span class="comment">//例子：</span></span><br><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">1</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>&#125;;</span><br><span class="line">System.out.println(<span class="string">&quot;排序前：&quot;</span> + Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">Arrays.sort(arr);<span class="comment">//其用的是快速排序</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;排序后：&quot;</span> + Arrays.toString(arr));</span><br></pre></td></tr></table></figure>

<p>​		运行结果为：</p>
<p><img src="/orange-zzcs/imgs/image-20230426201832037.png" alt="image-20230426201832037"></p>
<h4 id="E-二分法查找指定的值"><a href="#E-二分法查找指定的值" class="headerlink" title="E.二分法查找指定的值"></a>E.二分法查找指定的值</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法为：Arrays.binarySearch(数组名, 查找值);</span></span><br><span class="line"><span class="comment">//注意：使用该方法前数组一定要是有序的。</span></span><br><span class="line"><span class="comment">//例子：</span></span><br><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Arrays.binarySearch(arr, <span class="number">5</span>);</span><br><span class="line"><span class="comment">//如果找不到该指定值，则返回一个负数；找到该指定值，则返回该值的索引</span></span><br><span class="line">System.out.println(index);<span class="comment">//结果为：4</span></span><br></pre></td></tr></table></figure>



<h3 id="⑦数组使用中的常见异常"><a href="#⑦数组使用中的常见异常" class="headerlink" title="⑦数组使用中的常见异常"></a>⑦数组使用中的常见异常</h3><p>​	一旦程序出现异常，未处理时，程序就终止执行。</p>
<h4 id="A-数组角标越界的异常"><a href="#A-数组角标越界的异常" class="headerlink" title="A.数组角标越界的异常"></a>A.数组角标越界的异常</h4><p>​	报错为：<strong>ArrayIndexOutOfBoundsException</strong></p>
<p>​	只要超出了数组的下标范围，都算越界。如：</p>
<p><img src="/orange-zzcs/imgs/image-20230426201845752.png" alt="image-20230426201845752"></p>
<h4 id="B-空指针异常"><a href="#B-空指针异常" class="headerlink" title="B.空指针异常"></a>B.空指针异常</h4><p>​	报错为：<strong>NullPointerException</strong></p>
<p>​	<strong>什么为空指针异常：</strong>如：A.方法或A.其他东西，A为null时，就会出现空指针异常。</p>
<p>​	情况一：arr没有指向内存中的数组，此时还去调用数组中元素时就会报空指针异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">arr = <span class="literal">null</span>;</span><br><span class="line">System.out.println(arr[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>

<p>​	情况二：arr[]没有指向内存中的数组，此时还去调用数组中元素时就会报空指针异常。</p>
<p><img src="/orange-zzcs/imgs/image-20230426201909957.png" alt="image-20230426201909957"></p>
<p>​	情况三：引用类型变量的值为null时，还去调用该变量对应的方法，就会报空指针异常。</p>
<h3 id="⑧补充"><a href="#⑧补充" class="headerlink" title="⑧补充"></a>⑧补充</h3><p>A.数组还可以这么写</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="type">int</span>[][] b = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>

<p>B.如果某个方法的参数为Objecct[ ] 类型的，那么传递的参数可以是Objecct[ ] 的子类，如：String[ ] 。因为String[ ] 里每个元素为String类型，Object[ ] 里每个元素为Object类型，String 是 Object 的子类，所以String[ ] 就是Objecct[ ] 的子类。</p>
<hr>
<h2 id="9、面向对象"><a href="#9、面向对象" class="headerlink" title="9、面向对象"></a>9、面向对象</h2><h3 id="①面向过程与面向对象的解释"><a href="#①面向过程与面向对象的解释" class="headerlink" title="①面向过程与面向对象的解释"></a>①面向过程与面向对象的解释</h3><p>​      <strong>面向过程</strong>，强调的是功能行为，以函数为最小单位，<strong>考虑怎么做</strong>。	</p>
<p>​	  <strong>面向对象</strong>，将功能封装进对象，强调具备了功能的对象，以类&#x2F;对象为最小单位，<strong>考虑谁来做</strong>。</p>
<h3 id="②类与对象"><a href="#②类与对象" class="headerlink" title="②类与对象"></a>②类与对象</h3><h4 id="A-引言"><a href="#A-引言" class="headerlink" title="A.引言"></a>A.引言</h4><p>​			设计类，其实就是设计类的成员。类的成员主要包括：属性和方法。</p>
<p>​			属性 &#x3D; 成员变量 &#x3D; field &#x3D; 域、字段</p>
<p>​			方法 &#x3D; 成员方法 &#x3D; 函数 &#x3D; method</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">补充：</span></span><br><span class="line"><span class="comment">	成员变量：</span></span><br><span class="line"><span class="comment">	位置:定义在类里方法外</span></span><br><span class="line"><span class="comment">	注意:不用初始化,也会自动被初始化成默认值</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	局部变量：</span></span><br><span class="line"><span class="comment">	位置:定义在方法里或者方法的声明上</span></span><br><span class="line"><span class="comment">	注意:必须手动初始化来分配内存.如:int i = 5;或者int i;i = 5;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h4 id="B-类与对象的使用"><a href="#B-类与对象的使用" class="headerlink" title="B.类与对象的使用"></a>B.类与对象的使用</h4><p>​	<strong>创建对象的格式：</strong></p>
<p>​		类名 对象名 &#x3D; new 类名();</p>
<p>​	<strong>使用对象的方法、属性的格式：</strong></p>
<p>​		对象名.属性;</p>
<p>​		对象名.方法;</p>
<p>​	<strong>补充：</strong></p>
<p>如果创建了一个类的多个对象，则每个对象都独立的拥有一套类的属性和方法。（这里说的属性是非static的）。这意味着：如果我们修改一个对象的属性a，则不影响另外一个对象属性a的值。</p>
<h4 id="C-对象的内存解析"><a href="#C-对象的内存解析" class="headerlink" title="C.对象的内存解析"></a>C.对象的内存解析</h4><p>​	下图是jvm里真实的内存结构：</p>
<p><img src="/orange-zzcs/imgs/image-20230426201933545.png" alt="image-20230426201933545"></p>
<p>​	<strong>方法区</strong>：存放类信息、常量、静态变量（又称静态域）等</p>
<p>​	<strong>虚拟机栈</strong>：即平时我们认识中的栈。其用于存放局部变量。</p>
<p>​	<strong>堆</strong>：存放new结构的东西。</p>
<p>​	<strong>补充：</strong></p>
<p>​		方法中定义的变量都是局部变量，局部变量存放在虚拟机栈中。成员变量存放在堆空间里的对象实体中。例子：</p>
<p><img src="/orange-zzcs/imgs/image-20230426201947916.png" alt="image-20230426201947916"></p>
<h4 id="D-属性与局部变量的对比"><a href="#D-属性与局部变量的对比" class="headerlink" title="D.属性与局部变量的对比"></a>D.属性与局部变量的对比</h4><p>​	<strong>相同点：</strong></p>
<p>​		①格式相同：数据类型 变量名 &#x3D; 变量值</p>
<p>​		②都要先声明，后使用</p>
<p>​		③都有其对应的作用域</p>
<p>​	<strong>不同点：</strong></p>
<p>​		<strong>A. 在类中声明的位置不同</strong></p>
<p>​			①属性（即：成员变量）定义在类里，方法外面。</p>
<p>​			②局部变量：定义在方法内、方法形参、代码块内、构造器形参、构造器内部的变量</p>
<p>​		<strong>B. 权限修饰符不同</strong></p>
<p>​			①属性：可以在声明属性时，指明其权限，在数据类型前添加权限修饰符。</p>
<p>​			常用的权限修饰符有：private、public、缺省（即不添加权限修饰符的情况）、protected等。</p>
<p>​			权限修饰符的作用：说明变量的作用域（到封装的时会详细说明权限修饰符）。</p>
<p>​			</p>
<p>​			②局部变量：不可以使用权限修饰符。</p>
<p>​		<strong>C. 默认初始化值的情况</strong></p>
<p>​			<strong>属性：</strong></p>
<p>​					都有默认初始化值（与一维数组的默认初始化值情况是一样的）。</p>
<p>​					整型（byte、short、int、long）: 0</p>
<p>​					浮点型（float、double）: 0.0</p>
<p>​					字符型（char）: ASCII为零的字符</p>
<p>​					布尔型（boolean）: false</p>
<p>​					引用数据类型（类、数组、接口）：null	</p>
<p>​			<strong>局部变量</strong>：没有默认初始化值。</p>
<p>​					这意味着，我们在调用局部变量之前，一定要显式赋值。</p>
<p>​					特别地：形参在调用时，我们赋值即可。</p>
<p>​		<strong>D. 在内存中存放的位置不同</strong></p>
<p>​			<strong>属性：</strong>存放到堆空间里的对象实体中（注意：这里的属性是非静态的（即非static））</p>
<p>​			<strong>局部变量：</strong>存放在栈空间中。</p>
<h4 id="E-类中方法的声明和使用"><a href="#E-类中方法的声明和使用" class="headerlink" title="E.类中方法的声明和使用"></a>E.类中方法的声明和使用</h4><p>​	<strong>①方法的声明：</strong></p>
<p>​		<strong>格式：</strong>权限修饰符 返回值类型 方法名 (形参列表){</p>
<p>​						方法体</p>
<p>​					}</p>
<p>​		<strong>注意：</strong>方法一定会有上面的几个部分。，部分方法除了有上面几个部分外还会有关键字：static、final、abstract来修饰，而这些关键字的修饰，后面再讲。</p>
<p>​		<strong>说明：</strong></p>
<p>​				<strong>A. 关于权限修饰符</strong></p>
<p>​					Java规定的4种权限修饰符：private、public、缺省、					protected –&gt; 关于权限修饰符的使用，在封装性再细讲。</p>
<p>​				<strong>B. 关于返回值类型</strong></p>
<p>​					<strong>①如果有返回值</strong>，则必须在方法声明时，指定返回值的类						型。同时，方法中，使用return关键字来<strong>返回指定类型</strong>的						变量或常量。注意：if(age &gt; 18){return name;};这种情况会						报错，因为当age &lt;&#x3D; 18时，没有返回值。</p>
<p>​					<strong>②如果没有返回值</strong>，在方法声明时使用void来表示。一般不						使用return，如果使用的话只能是 “ return;”，表示结束此						方法。</p>
<p>​					<strong>补充：</strong></p>
<p>​						我们定义方法该不该有返回值？</p>
<p>​						①看题目要求</p>
<p>​						②凭经验：具体问题具体分析</p>
<p>​				<strong>C. 关于参数列表</strong></p>
<p>​					形参列表中<strong>可以声明0个，1个，或多个形参。</strong></p>
<p>​					<strong>格式：</strong>数据类型1 形参1，数据类型2 形参2，…..</p>
<p>​					<strong>注意：</strong>不能对形参进行赋值</p>
<p>​					<strong>什么时候需要参数列表呢？</strong>当该方法需要外界传递东西时，就要定义形参。</p>
<p>​	<strong>②return关键字的使用：</strong></p>
<p>​		<strong>A.使用范围：</strong>使用在方法体中</p>
<p>​		<strong>B.作用：</strong>①结束方法</p>
<p>​					  ②针对有返回值的方法，返回对应数据。</p>
<p>​		<strong>C.注意：</strong>return后不能声明执行语句。</p>
<p>​	<strong>③补充：</strong></p>
<p>​		A.方法的使用中，可以调用当前类的属性或方法。</p>
<p>​			方法A和B在同一个类里，当静态方法A想调用非静态方法B时，就要在方法A中声明一个对象，然后通过对象调用B方法。其他情况则可以直接调用。</p>
<p>​		B.方法中不可以定义方法。</p>
<p>​		C.对象.方法或方法里调方法都是按就近原则调用。</p>
<h4 id="F-练习"><a href="#F-练习" class="headerlink" title="F.练习"></a>F.练习</h4><p>​	<strong>练习一：</strong></p>
<p><img src="/orange-zzcs/imgs/image-20230426202010356.png" alt="image-20230426202010356"></p>
<p><img src="/orange-zzcs/imgs/image-20230426202020616.png" alt="image-20230426202020616"></p>
<p>​	运行结果为：</p>
<p><img src="/orange-zzcs/imgs/image-20230426202031306.png" alt="image-20230426202031306"></p>
<p>​	<strong>总结：</strong>当执行到s1.study()时，study方法里又使用了name属性，那这个name是谁的呢？是s1调用了study方法，所以这个name是s1的name。</p>
<p>​	<strong>练习二</strong>：</p>
<p>​	<strong>题目：</strong></p>
<p><img src="/orange-zzcs/imgs/image-20230426202114783.png" alt="image-20230426202114783"></p>
<p>​	<strong>代码实现：</strong></p>
<p><img src="/orange-zzcs/imgs/image-20230426202125070.png" alt="image-20230426202125070"></p>
<p><img src="/orange-zzcs/imgs/image-20230426202138012.png" alt="image-20230426202138012"></p>
<p>​	要求1：打印出3年级的学生信息。</p>
<p><img src="/orange-zzcs/imgs/image-20230426202148207.png" alt="image-20230426202148207"></p>
<p>​	要求2：使用冒泡排序按学生成绩排序，并遍历所有学生信息。</p>
<p><img src="/orange-zzcs/imgs/image-20230426202158529.png" alt="image-20230426202158529"></p>
<p>​	<strong>内存解析：</strong></p>
<p><img src="/orange-zzcs/imgs/image-20230426202211679.png" alt="image-20230426202211679"></p>
<p>​	<strong>总结：</strong></p>
<p>​		当要求创建多个对象时，这样做：</p>
<p>​			①创建该类的数组，如上图第10行代码</p>
<p>​			②创建对象，即让数组元素指向对象实体。如上图第11、12行代码</p>
<p>​			③数组元素.属性或数组元素.方法。如：上图第13-15行代码</p>
<p>​	<strong>练习三</strong>：</p>
<p>​		将功能封装到方法中，可用使main方法中的代码更简洁，同时可用提高代码的复用性（即可以在其他任意一个类中使用该类的方法）。</p>
<hr>
<h3 id="③理解”万事万物皆对象“"><a href="#③理解”万事万物皆对象“" class="headerlink" title="③理解”万事万物皆对象“"></a>③理解”万事万物皆对象“</h3><ul>
<li><p>在Java语言范畴中，我们都将功能（即方法）、结构（即属性）等封装到类中，通过类的实例化，来调用具体的功能结构。</p>
</li>
<li><p>涉及到Java 语言与前端HTML、后端的数据库交互时，前后端的结构在Java层面交互时，都体现为类、对象。</p>
</li>
</ul>
<h3 id="④匿名对象的使用"><a href="#④匿名对象的使用" class="headerlink" title="④匿名对象的使用"></a>④匿名对象的使用</h3><p>​	A.理解：我们创建的对象，没有显示的赋给一个变量。即为匿名对象。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">people</span>();<span class="comment">//这就是使用了匿名对象</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">people</span>().eat();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">people</span>().age = <span class="number">10</span>;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">people</span>().age);<span class="comment">//此行代码在堆空间中又新建了一个对象实体，所以不是10而是0。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">people</span>&#123;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">char</span> sex;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;吃饭啦&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	运行结果：</p>
<p><img src="/orange-zzcs/imgs/image-20230426202225962.png" alt="image-20230426202225962"></p>
<p>​	</p>
<p>​	在实际开发中会像下面那样使用匿名对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">PhoneMall</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PhoneMall</span>();</span><br><span class="line">        p1.show(<span class="keyword">new</span> <span class="title class_">Phone</span>());<span class="comment">//使用匿名对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PhoneMall</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(Phone phone)</span> &#123;</span><br><span class="line">        phone.sendEmail();</span><br><span class="line">        phone.playGame();</span><br><span class="line">        <span class="comment">//这时候上面两个方法使用的对象都是同一个对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span>&#123;</span><br><span class="line">    <span class="type">double</span> price;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发送邮件&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">playGame</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;玩游戏&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="⑤方法的重载"><a href="#⑤方法的重载" class="headerlink" title="⑤方法的重载"></a>⑤方法的重载</h3><h4 id="A-定义"><a href="#A-定义" class="headerlink" title="A.定义"></a>A.定义</h4><p>​		在<strong>同一个类</strong>中，允许存在一个以上的<strong>同名方法</strong>，只要它们的<strong>参数个数、参数顺序或者参数类型不同即可</strong>。（不满足定义那就不属于重载）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">顺口溜：</span><br><span class="line">   两同一不同：同一个类、同一个方法名</span><br><span class="line">		   数列表不同：参数个数不同，参数类型不同，参数顺序不同</span><br></pre></td></tr></table></figure>

<p>​		如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="comment">//以才两个方法构成了重载</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">char</span>[] arr)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//以才两个方法构成了重载</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">char</span>[] arr1，<span class="type">int</span>[] arr2)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] arr1，<span class="type">char</span>[] arr2)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="B-判断是否是重载"><a href="#B-判断是否是重载" class="headerlink" title="B.判断是否是重载"></a>B.判断是否是重载</h4><p>​		跟方法的权限修饰符、返回值类型、形参变量名、方法体都没有关系。</p>
<h3 id="⑥可变参数个数的方法"><a href="#⑥可变参数个数的方法" class="headerlink" title="⑥可变参数个数的方法"></a>⑥可变参数个数的方法</h3><h4 id="A-格式"><a href="#A-格式" class="headerlink" title="A.格式"></a>A.格式</h4><p>​		数据类型 … 形参名</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">    <span class="comment">//使用了可变参数个数的方法：</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">(<span class="type">int</span> ... a)</span> &#123;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="B-使用"><a href="#B-使用" class="headerlink" title="B.使用"></a>B.使用</h4><p>​		其实“int … a”就像一个一维数组，int 为数组的类型，a就是数组名。因此可变参数个数的使用方法就像使用数组一样，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line">        p1.tset(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tset</span><span class="params">(<span class="type">int</span> ... a)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; a.length;i++) &#123;</span><br><span class="line">            System.out.println(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		运行结果：</p>
<p><img src="/orange-zzcs/imgs/image-20230426202242455.png" alt="image-20230426202242455"></p>
<h4 id="C-说明"><a href="#C-说明" class="headerlink" title="C.说明"></a>C.说明</h4><p>​		①当调用可变个数形参的方法时，<strong>传入的参数个可以是0个、1个、2个</strong>。。。。</p>
<p>​		②可变个数形参的方法与本类中方法名相同，形参不同的方法之间构成重载。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">    <span class="comment">//使用了可变参数个数的方法：</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">(<span class="type">int</span> ... a)</span> &#123;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		③在jdk5.0之前，想使用可变个数形参的方法得像下面一样做：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="type">Phone</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line">       </span><br><span class="line">       p1.sendEmail(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">    <span class="comment">//jdk5.0之前使用可变参数个数的方法：</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">(<span class="type">int</span>[] a)</span> &#123;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//jdk5.0之后使用可变参数个数的方法：</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">(<span class="type">int</span> ... a)</span> &#123;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		所以jdk5.0之前的可变参数个数方法与jdk5.0之后的可变参数个数方法（也就是A中的格式）之间不构成重载。换句话说，也就是它俩不能同时出现。</p>
<p>​		④可变参数只能放在参数列表的末尾。</p>
<p>​		⑤参数列表中只能有一个可变参数。</p>
<hr>
<h3 id="⑦方法参数的值传递机制"><a href="#⑦方法参数的值传递机制" class="headerlink" title="⑦方法参数的值传递机制"></a>⑦方法参数的值传递机制</h3><h4 id="A-形参与实参"><a href="#A-形参与实参" class="headerlink" title="A.形参与实参"></a>A.形参与实参</h4><p>​		<strong>形参</strong>：方法定义时，声明的小括号内的参数。</p>
<p>​		<strong>实参</strong>：方法调用时，实际传递给形参的数据。</p>
<h4 id="B-值传递机制"><a href="#B-值传递机制" class="headerlink" title="B.值传递机制"></a>B.值传递机制</h4><p>​		如果参数是<strong>基本数据类型</strong>，此时实参赋给形参的是实参真实存储的<strong>数据值</strong>。</p>
<p>​		如果参数是<strong>引用数据类型</strong>，此时实参赋给形参的是实参存储数据的<strong>地址值</strong>。</p>
<h4 id="C-练习-1"><a href="#C-练习-1" class="headerlink" title="C.练习"></a>C.练习</h4><p>​		练习一：见如下网址中的“2.关于方法形参的传递机制：值传递”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://blog.csdn.net/Hhuaahua/article/details/108149332</span><br></pre></td></tr></table></figure>

<p>​		总结：</p>
<p>​				方法A想通过调用方法B来交换方法A中两个变量i、j的值。如果i、j为基本数据类型，那是无法通过方法B进行交换的；如果i、j为引用数据类型变量，那方法B可以通过接收这两个变量的地址，进而交换这两个变量的值。</p>
<p>​		练习二：见如下网址中的“2.关于方法形参的传递机制：值传递”下面的例题</p>
<hr>
<h3 id="⑧递归方法"><a href="#⑧递归方法" class="headerlink" title="⑧递归方法"></a>⑧递归方法</h3><p>​    <strong>定义：</strong>一个方法体内调用它自身。</p>
<p>​	递归就像循环，它会重复执行某行代码，但这种重复执行无须循环控制。<strong>递归一定要向已知方向递归</strong>（即要向递归出口方向递归），否则这种递归就变成无穷递归，类似于死循环。</p>
<p>​    <strong>例子：</strong>求1-n自然数的和</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Hello</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hello</span>();</span><br><span class="line">        System.out.println(test.getSum(<span class="number">100</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//求1-n自然数的和</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> n + getSum(n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果为5050</span></span><br></pre></td></tr></table></figure>



<hr>
<h3 id="⑨构造器-或构造方法"><a href="#⑨构造器-或构造方法" class="headerlink" title="⑨构造器(或构造方法)"></a>⑨构造器(或构造方法)</h3><h4 id="A-构造器的作用"><a href="#A-构造器的作用" class="headerlink" title="A.构造器的作用"></a>A.构造器的作用</h4><p>​		①创建对象</p>
<p>​			Person p &#x3D; new <u>Person()</u>，横线部分就是构造器。</p>
<p>​		②初始化对象的属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">ublic <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">People</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">People</span>(<span class="number">10</span>,<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        <span class="type">People</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">People</span>();</span><br><span class="line">        </span><br><span class="line">        System.out.println(p1.age + <span class="string">&quot; &quot;</span> + p1.name);</span><br><span class="line">        <span class="comment">//结果：10 Tom</span></span><br><span class="line">        System.out.println(p2.age + <span class="string">&quot; &quot;</span> + p2.name);</span><br><span class="line">        <span class="comment">//结果：18 null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>&#123;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器：</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">People</span><span class="params">(<span class="type">int</span> n,String s)</span> &#123;</span><br><span class="line">        age = n;</span><br><span class="line">        name = s;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">People</span><span class="params">()</span> &#123;</span><br><span class="line">        age = <span class="number">18</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="B-说明"><a href="#B-说明" class="headerlink" title="B.说明"></a>B.说明</h4><p>​		①如果没有显示定义类的构造器的话， 则系统默认提供一个空参的构造器，而<strong>构造器的权限与类的权限相同</strong>。</p>
<p>​		②定义<strong>构造器</strong>的<strong>格式：</strong><code>权限修饰符 类名(形参列表) &#123; &#125;</code> ，如：public Person() {}</p>
<p>​		③一个类中可以定义多个构造器，彼此构成重载。</p>
<p>​		④一个类中，至少会有一个构造器。</p>
<h4 id="C-注意-1"><a href="#C-注意-1" class="headerlink" title="C.注意"></a>C.注意</h4><p>​		①一旦显式的定义了类的构造器之后，系统就不再提供默认的空参构造器。</p>
<p>​		②<strong>只要造对象，就一定会用构造器。</strong></p>
<h3 id="⑩属性赋值的先后顺序"><a href="#⑩属性赋值的先后顺序" class="headerlink" title="⑩属性赋值的先后顺序"></a>⑩属性赋值的先后顺序</h3><ul>
<li>赋值的位置：<br>  ① 默认初始化<br>  ② 显式初始化 &#x2F; ⑤ 在代码块中赋值<br>  ③ 构造器中初始化<br>  ④ 通过“对象.属性“或“对象.方法”的方式赋值</li>
<li>赋值的先后顺序：<br>  ① - ② &#x2F; ⑤ - ③ - ④<br>  ②和⑤取决于在声明的先后顺序，值取后面的。</li>
</ul>
<h3 id="11-、JavaBean"><a href="#11-、JavaBean" class="headerlink" title="(11)、JavaBean"></a>(11)、JavaBean</h3><h4 id="A-定义-1"><a href="#A-定义-1" class="headerlink" title="A.定义"></a>A.定义</h4><p>​		JavaBean是一种Java语言写成的可重用组件。</p>
<h4 id="B-组成"><a href="#B-组成" class="headerlink" title="B.组成"></a>B.组成</h4><p>​	满足以下要求的类都叫JavaBean</p>
<ul>
<li>类是公共的</li>
<li>有一个<u>无参</u>的<u>公共</u>的构造器</li>
<li>有属性，且有对应的get、set方法</li>
</ul>
<p>​	</p>
<h3 id="12-、关键字"><a href="#12-、关键字" class="headerlink" title="(12)、关键字"></a>(12)、关键字</h3><h4 id="A-this关键字"><a href="#A-this关键字" class="headerlink" title="A.this关键字"></a>A.this关键字</h4><p>​	①引入：当方法中形参名与属性名同名时，为了区分它俩，我们需要在<strong>属性前加this关键字。</strong></p>
<p>​	<strong>②格式</strong>：<strong>this.属性</strong>或<strong>this.方法</strong></p>
<p>​	<strong>③this关键字可以修饰属性、方法。</strong></p>
<p>​		A.在类的方法中，我们使用this关键字修饰属性或方法时：</p>
<p>​			this关键字可以理解为：当前对象的</p>
<p>​		B.在类的构造器中，我们使用this关键字修饰属性或方法时：</p>
<p>​			this关键字可以理解为：当前创建的对象</p>
<p>​	<strong>④this关键字可以修饰构造器</strong></p>
<p>​		<strong>this关键字调用构造器的意义：</strong></p>
<p>​			当构造器B与构造器A中存在相同的代码时，为了减少冗余，我们可以使用“this(形参列表)”方式来调用构造器A。</p>
<p>​		<code>A.</code>我们在类的构造器中，可以显示的使用“this(形参列表)”方式，来调用本类中指定的<strong>其他</strong>构造器。</p>
<p>​		<code>B.</code>构造器中不能通过“this(形参列表)”方式调用自己。</p>
<p>​		<code>C.</code>构造器A调用了构造器B，那么构造器B就不能调用构造器A，不然会出现死循环。</p>
<img src="/imgs/image-20230426202304328.png" alt="image-20230426202304328" style="zoom:67%;" />

<p>​		<code>D.</code>规定：</p>
<p>​					①“this(形参列表)”必须声明在当前构造器的首行。</p>
<p>​					②构造器内部，<strong>最多只能声明一个“this(形参列表)”</strong>，用来调用其他的构造器。</p>
<p>​	⑤补充：当单独使用“this”时（如：27行代码），其代表：当前对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Boy</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Boy</span>();</span><br><span class="line">        b1.name = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Girl</span> <span class="variable">g1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Girl</span>();</span><br><span class="line">        g1.name = <span class="string">&quot;Jelly&quot;</span>;</span><br><span class="line"></span><br><span class="line">        b1.shout(g1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shout</span><span class="params">(Boy boy)</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;也喜欢&quot;</span> + boy.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Boy</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shout</span><span class="params">(Girl girl)</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;喜欢&quot;</span> + girl.name);</span><br><span class="line">        <span class="comment">//下面的“this”代表当前对象，即：谁调用当前shout方法，那这个对象就是谁</span></span><br><span class="line">        girl.shout(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		运行结果：</p>
<p><img src="/orange-zzcs/imgs/image-20230426202320483.png" alt="image-20230426202320483"></p>
<p>​	⑥练习：当类中的属性为自定义类类型时：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        p1.name = <span class="string">&quot;x&quot;</span>;</span><br><span class="line">        p1.car = <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br><span class="line">        p1.car.setColour(<span class="string">&quot;白色&quot;</span>);</span><br><span class="line">        p1.car.setCarBrand(<span class="string">&quot;BMW&quot;</span>);</span><br><span class="line">        p1.car.setPlateNumber(<span class="string">&quot;xxxxxx&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;恭喜&quot;</span> + p1.name + <span class="string">&quot;先生喜提一辆车牌为&quot;</span> + p1.car.getPlateNumber() + p1.car.getColour() + 			p1.car.getCarBrand());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    Car car;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String colour;<span class="comment">//颜色</span></span><br><span class="line">    <span class="keyword">private</span> String plateNumber;<span class="comment">//车牌</span></span><br><span class="line">    <span class="keyword">private</span> String carBrand;<span class="comment">//车的品牌</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setColour</span><span class="params">(String colour)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.colour = colour;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getColour</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> colour;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPlateNumber</span><span class="params">(String plateNumber)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.plateNumber = plateNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPlateNumber</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> plateNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCarBrand</span><span class="params">(String carBrand)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.carBrand = carBrand;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCarBrand</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> carBrand;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	运行结果为：</p>
<p><img src="/orange-zzcs/imgs/image-20230426202631968.png" alt="image-20230426202631968"></p>
<p>​	该程序的内存图为：</p>
<p><img src="/orange-zzcs/imgs/image-20230427155759240.png" alt="image-20230427155759240"></p>
<hr>
<h4 id="B-package关键字"><a href="#B-package关键字" class="headerlink" title="B.package关键字"></a>B.package关键字</h4><p>​	①引入</p>
<p>​		为了更好的实现项目中类的管理，提供了包的概念。</p>
<p>​	②package的使用</p>
<p>​		A.使用packet 声明类或接口所属的包，声明在源文件的首行。</p>
<p>​		B.每“.”一次，就代表一层文件目录。如：</p>
<p><img src="/orange-zzcs/imgs/image-20230426202652783.png" alt="image-20230426202652783"></p>
<p>​		C.同一个包下，不能命名同名的接口、类。不同的包可以。</p>
<p>​		D.JDK中主要的包介绍：</p>
<p><img src="/orange-zzcs/imgs/image-20230426202705602.png" alt="image-20230426202705602"></p>
<hr>
<h4 id="C-import关键字"><a href="#C-import关键字" class="headerlink" title="C.import关键字"></a>C.import关键字</h4><p>​	①在源文件中使用import显式的导入指定包下的类或接口。</p>
<p>​	②声明在包的声明和类的声明之间。</p>
<p>​	③如果需要导入多个类或接口，那么就并列显式多个import语句即可。</p>
<p>​	④举例：可以使用java.util.*的方式，一次性导入util包下所有的类或接口。</p>
<p>​	⑤如果使用的类或接口是java.lang包下定义的，则可以省略import结构。</p>
<p>​	⑥使用同一包下的类或接口时，就不用导入包下的类或接口；而使用其他包下的类或接口时，就需要导入指定包下的类或接口（是否需要导入，与权限修饰符无关）。</p>
<p>​	⑦如果在源文件中，使用了不同包下的同名的类，则必须至少有一个类需要以全类名的方式显示。如：</p>
<p><img src="/orange-zzcs/imgs/image-20230426202822430.png" alt="image-20230426202822430"></p>
<p>​	⑧使用“xxx.*”方式表明可以调用xxx包下爱的所有结构。但是如果使用的是xxx子包下的结构，则仍需显式导入。</p>
<hr>
<h3 id="13-、面向对象综合练习"><a href="#13-、面向对象综合练习" class="headerlink" title="(13)、面向对象综合练习"></a>(13)、面向对象综合练习</h3><h4 id="综合练习一的总结"><a href="#综合练习一的总结" class="headerlink" title="综合练习一的总结"></a>综合练习一的总结</h4><p>1、当类中的属性为数组时，一定要在使用该数组属性前初始化该数组，可通过对象.属性或构造器的方式声明该数组，如：</p>
<p>2、删除数组元素的操作：</p>
<p><img src="/orange-zzcs/imgs/image-20230426202857819.png" alt="image-20230426202857819"></p>
<h3 id="14-、类的成员之四：代码块-或初始化块"><a href="#14-、类的成员之四：代码块-或初始化块" class="headerlink" title="(14)、类的成员之四：代码块(或初始化块)"></a>(14)、类的成员之四：代码块(或初始化块)</h3><h4 id="A-引入"><a href="#A-引入" class="headerlink" title="A.引入"></a>A.引入</h4><p>​	<strong>格式：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态代码块</span></span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">    <span class="comment">//代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非静态代码块</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	<strong>作用：</strong><code>用来初始化类、对象</code></p>
<p>​	<strong>修饰符：</strong>如果有修饰符的话，只能使用static</p>
<p>​	<strong>分类：</strong>静态代码块、非静态代码块</p>
<h4 id="B-静态代码块"><a href="#B-静态代码块" class="headerlink" title="B.静态代码块"></a>B.静态代码块</h4><p>​	①内部可以有输出语句</p>
<p>​	②随着类的加载而执行，而且只执行一次（补充：使用类的时候就会加载类）</p>
<p>​	③作用：初始化类的信息</p>
<p>​	④如果一个类中定义了多个静态代码块，则按照声明的先后顺序执行</p>
<p>​	⑤静态代码块的执行要优先于非静态代码块的执行</p>
<p>​	⑥静态代码块只能调用静态的属性、静态的方法，不能调用非静态的属性、方法</p>
<h4 id="C-非静态代码块"><a href="#C-非静态代码块" class="headerlink" title="C.非静态代码块"></a>C.非静态代码块</h4><p>​	①内部可以有输出语句</p>
<p>​	②随着对象的创建而执行</p>
<p>​	③每创建一个对象，就执行一次非静态代码块</p>
<p>​	④作用：可以创建对象时，对对象的属性等进行初始化</p>
<p>​	⑤如果一个类中定义了多个非静态代码块，则按照声明的先后顺序执行</p>
<p>​	⑥非静态代码块内可以调用静态的属性、静态的方法、或非静态的属性、或非静态的方法</p>
<h4 id="D-静态代码块、非静态代码块及构造器三者的执行顺序"><a href="#D-静态代码块、非静态代码块及构造器三者的执行顺序" class="headerlink" title="D.静态代码块、非静态代码块及构造器三者的执行顺序"></a>D.静态代码块、非静态代码块及构造器三者的执行顺序</h4><p>​	由父及子，先执行静态代码块，静态代码块执行完后，回到父类，先执行非静态代码块再执行构造器，然后到子类，也是先执行子类的非静态代码块，再执行子类的构造器，直到最后一个子类的非静态代码块和构造器执行完。</p>
<hr>
<h3 id="15-类的成员之五：内部类-了解"><a href="#15-类的成员之五：内部类-了解" class="headerlink" title="(15)类的成员之五：内部类(了解)"></a>(15)类的成员之五：内部类(了解)</h3><h4 id="A-引入-1"><a href="#A-引入-1" class="headerlink" title="A.引入"></a>A.引入</h4><p>​	如类A中需声明一个结构，但这结构用属性来刻画会不完整，因此就得造个类B来描述这个结构，但只有类A调用类B其他类不会去调用，所以就将类B放到类A中变成一个内部类。类A称为外部类。</p>
<p>​	<strong>分类：</strong>成员内部类（静态的、非静态的）、局部内部类（声明在方法内、构造器内、代码块内）</p>
<h4 id="B-成员内部类"><a href="#B-成员内部类" class="headerlink" title="B.成员内部类"></a>B.成员内部类</h4><p>​	①一方面，作为外部类的成员：</p>
<ul>
<li>调用外部类的结构，如：属性、方法、构造器等。</li>
<li>可以被static修饰。被static修饰之后只能调用静态的结构了。</li>
<li>可以被4种不同的权限修饰（public、缺省、protected、private）</li>
</ul>
<p>​	②另一方面，作为一个类：</p>
<ul>
<li>可以在内部定义属性、方法、构造器等结构；</li>
<li>可以声明为abstract类 ，表明该类不能造对象</li>
<li>可以声明为final的，不被继承。不声明为final则，可以被继承</li>
</ul>
<p>​		</p>
<h4 id="C-开发中局部内部类的使用"><a href="#C-开发中局部内部类的使用" class="headerlink" title="C.开发中局部内部类的使用"></a>C.开发中局部内部类的使用</h4><p>​	局部内部类最常见的用法：返回一个实现某个接口的类的对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line">	<span class="comment">//返回一个实现Comparable接口的类的对象</span></span><br><span class="line">	<span class="keyword">public</span> Comparable <span class="title function_">getComparable</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">class</span> <span class="title class_">MyComparable</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&#123;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyComparable</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		</p>
<p>​		注意点：</p>
<p>​		在局部内部类的方法中（如：show方法）如果调用局部内部类所声明的方法（比如：method方法）中的局部变量（比如：num）的话，要求此局部变量声明为final的。jdk 7及之前版本：要求此局部变量显示的声明为final的；jdk 8及之后的版本：可以省略final的声明，但实际上还是存在final。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">//局部变量</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">class</span> <span class="title class_">AA</span>&#123;</span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">				System.out.println(num);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="D-如何实例化成员内部类的对"><a href="#D-如何实例化成员内部类的对" class="headerlink" title="D.如何实例化成员内部类的对"></a>D.如何实例化成员内部类的对</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//创建Dog实例（静态的成员内部类）</span></span><br><span class="line">		InnerClass.<span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InnerClass</span>.Dog();</span><br><span class="line">		dog.method1();</span><br><span class="line">		<span class="comment">//创建Bird实例（非静态的成员内部类）</span></span><br><span class="line">		<span class="type">InnerClass</span> <span class="variable">innerClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InnerClass</span>();</span><br><span class="line">		InnerClass.<span class="type">Bird</span> <span class="variable">bird</span> <span class="operator">=</span> innerClass.<span class="keyword">new</span> <span class="title class_">Bird</span>();</span><br><span class="line">		bird.method();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InnerClass</span>&#123;</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">Bird</span>&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;小鸟唱歌&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Dog</span>&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;汪汪汪&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	</p>
<h4 id="E-如何在成员内部类中区分调用外部类的结构（没重名可以直接调用这些结构。如果重名见下面代码）"><a href="#E-如何在成员内部类中区分调用外部类的结构（没重名可以直接调用这些结构。如果重名见下面代码）" class="headerlink" title="E.如何在成员内部类中区分调用外部类的结构（没重名可以直接调用这些结构。如果重名见下面代码）"></a>E.如何在成员内部类中区分调用外部类的结构（没重名可以直接调用这些结构。如果重名见下面代码）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Outer</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">		Outer.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> outer.<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">		inner.mb(<span class="number">333</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">111</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">222</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mb</span><span class="params">(<span class="type">int</span> s)</span> &#123;</span><br><span class="line">			System.out.println(s); <span class="comment">//方法形参s</span></span><br><span class="line">			System.out.println(<span class="built_in">this</span>.s); <span class="comment">// 内部类的属性s</span></span><br><span class="line">			System.out.println(Outer.<span class="built_in">this</span>.s); <span class="comment">//外部类属性s</span></span><br><span class="line">		 &#125; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="10、面向对象三大特性"><a href="#10、面向对象三大特性" class="headerlink" title="10、面向对象三大特性"></a>10、面向对象三大特性</h2><h3 id="①封装与隐藏"><a href="#①封装与隐藏" class="headerlink" title="①封装与隐藏"></a>①封装与隐藏</h3><h4 id="A-问题的引入"><a href="#A-问题的引入" class="headerlink" title="A.问题的引入"></a>A.问题的引入</h4><p>​		当我们创建一个类的对象以后，我们可以通过“对象.属性”的方式，对对象的属性进行赋值。这里，赋值操作要受到属性的数据类型和存储范围的制约。除此之外，没有其他制约条件。但是，在实际问题中，我们往往需要给属性赋值加入额外的限制条件。这个条件就不能在属性声明时体现，我们只能通过方法进行限制条件的添加（比如：setAge()）。同时，我们需要避免用户再使用“对象.属性”的方式对属性进行赋值。则需要将属性声明为私有的（即：private）。–&gt; 上面对属性的操作就体现了封装性。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">People</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">People</span>();</span><br><span class="line">        p1.setAge(<span class="number">10</span>);</span><br><span class="line">        System.out.println(p1.getAge());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> temp)</span> &#123;</span><br><span class="line">        age = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="B-封装性的体现"><a href="#B-封装性的体现" class="headerlink" title="B.封装性的体现"></a>B.封装性的体现</h4><p>​		我们将类的属性xxx私有化（private），同时，提供公共的（public）方法来获取（getXxx）和设置（setXxx）此属性的值。如：上面第10-18行代码。</p>
<p>​		<strong>注意：</strong>这只是封装性的一种体现，并不等同于封装性。封装性的体现还包括：不对外暴露的私有方法，单例模式等等。</p>
<p>​		<strong>补充：</strong>属性被私有化后，该类内的方法还是可以直接使用该私有属性的。</p>
<h4 id="C-四种权限修饰符"><a href="#C-四种权限修饰符" class="headerlink" title="C.四种权限修饰符"></a>C.四种权限修饰符</h4><p>​		<strong>引入：</strong>封装性的体现，需要权限修饰符来配合。</p>
<p>​		<strong>Java规定的4种权限（从小到大排列）</strong></p>
<p>​			private、缺省、protected、public</p>
<p><img src="/orange-zzcs/imgs/image-20230426203046635.png" alt="image-20230426203046635"></p>
<h4 id="D-四种权限的使用"><a href="#D-四种权限的使用" class="headerlink" title="D.四种权限的使用"></a>D.四种权限的使用</h4><p>​		①4种权限<strong>可以用来修饰类及类的内部结构</strong>：<strong>属性、方法、构造器、内部类</strong>（<strong>注意：</strong>不能修饰代码块）</p>
<p>​		②具体的，4种权限都可以用来修饰类的内部结构：<strong>属性、方法、构造器、内部类</strong></p>
<p>​				<strong>修饰类</strong>的话，<strong>只能</strong>使用：<strong>缺省、public</strong></p>
<p>​		③Java权限修饰符置于类的成员定义前，用来限定对象对该类成员的访问权限。</p>
<h4 id="E-总结封装性"><a href="#E-总结封装性" class="headerlink" title="E.总结封装性"></a>E.总结封装性</h4><p>​		Java提供了4种权限修饰符来修饰类及类的内部结构，体现类及类的内部结构在被调用时的可见性的大小</p>
<p>​		①<strong>属性</strong>及<strong>方法</strong>被各权限修饰符修饰时：</p>
<table>
<thead>
<tr>
<th align="center">权限</th>
<th align="center">类内</th>
<th align="center">同一个包内的类</th>
<th align="center">不同包内的子类</th>
<th align="center">同一个工程的类</th>
</tr>
</thead>
<tbody><tr>
<td align="center">private</td>
<td align="center">直接使用</td>
<td align="center">不可以调用</td>
<td align="center">不可以调用</td>
<td align="center">不可以调用</td>
</tr>
<tr>
<td align="center">缺省</td>
<td align="center">直接使用</td>
<td align="center">可以通过对象调用</td>
<td align="center">不可以调用</td>
<td align="center">不可以调用</td>
</tr>
<tr>
<td align="center">protected</td>
<td align="center">直接使用</td>
<td align="center">可以通过对象调用</td>
<td align="center">可以通过对象调用</td>
<td align="center">不可以调用</td>
</tr>
<tr>
<td align="center">public</td>
<td align="center">直接使用</td>
<td align="center">可以通过对象调用</td>
<td align="center">可以通过对象调用</td>
<td align="center">可以通过对象调用</td>
</tr>
</tbody></table>
<p>​		注意:</p>
<p>​		被protect修饰的属性和方法，此时想调用这些结构的类A与这些结构所在的类B处于不同包下，此时如果类A是类B的子类，则可以调用类B中被protect修饰的属性和方法；否则，不能调用被protect修饰的属性和方法。如果类A与类B在同一个包下，类A是不是类B的子类都可以使用这些结构。</p>
<p>​		②当<strong>类被public修饰</strong>时：代表该类在此项目内可以。</p>
<p>​			当<strong>类被缺省修饰</strong>时：代表该类只能在当前包内使用。</p>
<h4 id="F-补充"><a href="#F-补充" class="headerlink" title="F.补充"></a>F.补充</h4><p>​			同一个包内不可以定义同名类，不同包下可以定义同名类。</p>
<hr>
<h3 id="②继承性"><a href="#②继承性" class="headerlink" title="②继承性"></a>②继承性</h3><h4 id="A-问题的引入-1"><a href="#A-问题的引入-1" class="headerlink" title="A.问题的引入"></a>A.问题的引入</h4><p>​	现在有类A，类A中有一些方</p>
<p>法和属性，准备创建一个类B，类B中有些方法和属性与类A的一样，这时我们就可以使用继承性，让类B继承类A，这样类B就不用再写这些相同的方法和属性了。</p>
<h4 id="B-继承性的好处"><a href="#B-继承性的好处" class="headerlink" title="B.继承性的好处"></a>B.继承性的好处</h4><ul>
<li>减少了代码的冗余，提高了代码的复用性。</li>
<li>便于功能的扩展。(后期需在子类中添加相同的功能时，只需在父类添加即可，不用在每个子类中添加)</li>
<li>为之后多态性的使用提供了前提。</li>
</ul>
<h4 id="C-继承性的格式"><a href="#C-继承性的格式" class="headerlink" title="C.继承性的格式"></a>C.继承性的格式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	其中：A被称为子类、派生类、subclass；B被称为父类、超类、基类、superclass</p>
<h4 id="D-说明"><a href="#D-说明" class="headerlink" title="D.说明"></a>D.说明</h4><p>​	①一旦子类A继承父类B以后，子类A就获取了父类B中声明的所有的属性和方法。特别的，父类中声明为private的属性或方法，子类继承父类后，仍然认为获取了父类中的私有结构。只是因为封装性影响，使得子类不能直接调用父类的结构而已（但可通过父类中的get、set方法来使用）。</p>
<p>​	②子类继承父类之后，还可以声明自己特有的属性或方法，实现功能扩展。</p>
<p>​	③extends的含义：延展、扩展</p>
<p>​	④子类继承了父类的属性后，在堆空间中，子类的对象实体中会有父类的属性（父类的private属性也在里面）。</p>
<p>​	⑤子类继承父类的属性和方法后，子类就拥有了这些属性和方法，但子类能不能用呢？还得看父类中这些属性和方法的权限大小。</p>
<h4 id="E-继承性的规则"><a href="#E-继承性的规则" class="headerlink" title="E.继承性的规则"></a>E.继承性的规则</h4><p>​	①一个类可以被多个子类继承。</p>
<p>​	②Java中类的单继承性：一个类只能有一个父类。</p>
<p>​	③子父类是相对的概念。</p>
<p>​	④子类直接继承的父类，称为：直接父类。间接继承的父类成为：间接父类。</p>
<p>​	⑤子类继承父类以后，就获取了直接父类以及所有间接父类中声明的属性和方法。</p>
<h4 id="F-继承练习"><a href="#F-继承练习" class="headerlink" title="F.继承练习"></a>F.继承练习</h4><p>​	子类继承了父类，那么就可以在子类里使用父类的属性和方法了，但如果使用父类中的私有属性，只能通过get、set方法调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Cylinder</span> <span class="variable">cylinder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cylinder</span>();</span><br><span class="line">        <span class="type">double</span> <span class="variable">findVolume</span> <span class="operator">=</span> cylinder.findVolume();</span><br><span class="line">        System.out.println(<span class="string">&quot;圆柱的面积为：&quot;</span> + findVolume);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findArea</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3.14</span> * a * a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Cylinder：圆柱</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cylinder</span> <span class="keyword">extends</span> <span class="title class_">Circle</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//计算圆柱体积</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findVolume</span><span class="params">()</span>&#123;</span><br><span class="line">        a = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">return</span> findArea() * length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	运行结果为：</p>
<p><img src="/orange-zzcs/imgs/image-20230426203105859.png" alt="image-20230426203105859"></p>
<h4 id="G-重写"><a href="#G-重写" class="headerlink" title="G.重写"></a>G.重写</h4><p>​	重写实际上就是将父类中被重写的方法覆盖掉。</p>
<p>​	<strong>引入：</strong></p>
<p>​		当子类继承父类后，发现需要对父类中的某个方法进行修改，此时我们就可以在子类中使用重写的方式将父类中的同名同参方法<strong>覆盖</strong>掉。</p>
<p>​	<strong>运用：</strong></p>
<p>​		①子类重写父类的方法A后，通过子类调用方法A时，执行的是子类中重写的方法。</p>
<p>​		②在实际开发中，子类重写的方法的声明与父类被重写的方法的声明一样。（即：直接将父类中被重写的方法的声明复制到子类中）</p>
<p>​	<strong>规则：</strong></p>
<p>​		①子类重写的方法的方法名和形参列表与父类被重写的方法的方法名和形参列表相同。</p>
<p>​		②子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符。</p>
<p>​		特别的：子类<strong>不能重写</strong>父类中声明为<strong>private权限的方法。</strong></p>
<p>​	    ③返回值类型：</p>
<p>​			A.父类被重写的方法的返回值类型是void，则子类重写的方法的返回值类型只能是void。</p>
<p>​			B.父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是A类或A类的子类。</p>
<p>​			补充：①.方法的返回值类型可以是基本数据类型，可以是 类 类						型（return写的是该类的实例对象）。	</p>
<p>​					   ②.如果父类中被重写的方法的返回值类型为：Object类 类							型，则子类重写的方法的返回值类型可以是Object类 类							型也可以是Object类 类型的子类，如：String类型等。</p>
<p>​			C.父类被重写的方法的返回值类型是基本数据类型，则子类重写的方法的返回值类型必须是相同的基本数据类型。</p>
<p>​		④子类重写的方法抛出的异常不能大于父类被重写的方法抛出的异常类型，最小的异常是没有异常，因此子类重写的方法中也可以不写“throws+异常类型”。（在异常处理的时候补充）</p>
<p>​	</p>
<p>​	<strong>额外说明：</strong></p>
<p>​		子类与父类中的同名同参数的方法要么都声明为非static的(考虑重写)，要么都声明为static的（不是重写）。</p>
<p>​		被static修饰的方法不能被重写。</p>
<hr>
<h4 id="H-Super关键字"><a href="#H-Super关键字" class="headerlink" title="H.Super关键字"></a>H.Super关键字</h4><p>​	<strong>引言：</strong></p>
<p>​		子类重写了父类的方法，此时父类的方法就被覆盖掉了，如果子类中还想调用父类中被重写的方法，那就得使用Super关键字了。</p>
<p>​	<strong>Super关键字的使用：调用属性和方法</strong></p>
<p>​		A.super理解为：父类的…….</p>
<p>​		B.super可以用来调用：属性、方法、构造器</p>
<p>​		C.super的使用</p>
<p>​			①当子父类出现同名属性时，可以用super表明调用的是父类中的属性（super.属性）。</p>
<p>​			②子类中想调用父类中被重写的方法，可以使用”super.方法”的方式调用。</p>
<p>​	<strong>Super的使用：调用构造器</strong></p>
<p>​		A.我们可以在子类的构造器中显式的使用”super(形参列表)”的方式，调用父类中声明的指定的构造器。</p>
<p>​		B.”super(形参列表)”必须声明在子类构造器的首行！</p>
<p>​		C.我们在类的构造器中，针对于”this(形参列表)”或”super(形参列表)”只能二选一，不能同时出现。（因为他们都得放在首行）</p>
<p>​		D.在子类构造器的首行，没有显式的声明“this（形参列表）”或“super（形参列表）”，则默认调用的是父类中空参的构造器super()。若父类中又没有无参的构造器，则编译出错。</p>
<p>​		E.如果有n个构造器，则最多有n-1个构造器使用this关键字调用其他构造器，至少有一个构造器使用super关键字调用父类的构造器。</p>
<p>​	<strong>补充注意：</strong>	没有<strong>super.super</strong>。类C直接父类为类B，间接父类为类A，类B重写了类A中的toString方法，而类C想调用间接父类中的toString方法，此时不能通过super来调用了，只能在间接父类中再声明一个方法（将重写的toString方法的内容写在这里，然后toString方法调用该方法），然后类C调用直接父类中的该方法即可。</p>
<hr>
<h4 id="I-子类对象实例化的全过程"><a href="#I-子类对象实例化的全过程" class="headerlink" title="I.子类对象实例化的全过程"></a>I.子类对象实例化的全过程</h4><p>​	①从结果上看（继承性）</p>
<p>​		子类继承父类以后，就获取了父类中声明的属性或方法。创建子类的对象，在堆空间中，就会加载所有父类中声明的属性。</p>
<p>​	②从过程上看</p>
<p>​		当我们通过子类的构造器创建子类对象时，我们一定会直接或间接的调用其父类的构造器，进而调用父类的父类构造器……直到调用了java.lang.Object类中的空参构造器为止。<strong>正因为加载过所有的父类的结构，所以才可以看到内存中有父类中的结构</strong>，子类对象才可以考虑进行调用。</p>
<hr>
<h4 id="J-Object类"><a href="#J-Object类" class="headerlink" title="J.Object类"></a>J.Object类</h4><p>​	<strong>引入：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果没有显式的声明一个类的父类的话，则此类继承于Java.lang.Object类。</span><br><span class="line">所有类（除Java.lang.Object类之外）都继承于Java.lang.Object类。这意味着，所有的Java类具有Java.lang.Object类声明的功能。</span><br></pre></td></tr></table></figure>

<p>​								<strong>Object类是所有类的根父类</strong></p>
<p>​	<strong>说明：</strong></p>
<p>​		Objecct类里没有声明属性，声明了一个空参构造器，声明了一些方法。</p>
<p>​	<strong>Object类中常用的方法：</strong></p>
<p>​		<strong>①equals()</strong></p>
<p>​			equals()和&#x3D;&#x3D;的区别：</p>
<p>​			<code>==的使用：</code><br>​				①可以使用在基本数据类型变量和引用数据类型变量中<br>​				②如果比较的是基本数据类型变量，比较两个变量保存的数据是否相等（不一定类型相同）<br>​					如果比较的是引用数据类型变量，比较两个对象的地址值是否相等，即两个引用是否指向同一个对象实体</p>
<p>​			<code>补充：</code>&#x3D;&#x3D;符号使用时。必须保证符号左右两边的变量类型一致。</p>
<p><code>equals()方法的使用：</code><br>①其是一个方法，而非运算符。所以只能适用于引用数据类型<br>②Object类中定义的equals()和&#x3D;&#x3D;的作用相同，比较两个对象的地址值是否相同，即两个引用是否指向同一个对象实体。<br>③像String、Date、File、包装类等都重写了Object类中的equals()方法。重写以后，比较的不是两个引用的地址是否相同，而是比较两个对象的“实体内容”是否相同。<br>④通常情况下，我们自定义的类如果使用equals()的话，也通常是比较两个对象的“实体”内容是否相同（通常比较两个对象的属性值是否相等）。那么，我们就需要对Object类中的equals()进行重写。</p>
<p><code>总结：</code><br>涉及到基本数据类型用“&#x3D;&#x3D;”，引用数据类型用“equals()”</p>
<p>​		如果想重新Object类中的equals()方法，我们通常调用现成的equals()方法。步骤为：Source–&gt;生成hashCode()和equals()–&gt;选择需要比较的属性–&gt;点击OK即可。</p>
<p>​		如果手写（不推荐，因为逻辑上不够严谨），其格式大概为：（主要目的：熟悉一下格式，为后续的集合做准备）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;<span class="comment">//自定义一个类</span></span><br><span class="line">    <span class="type">int</span> orderId;</span><br><span class="line">    String orderName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> <span class="comment">//重写equals方法</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span> == obj)  <span class="comment">//1.比较两者地址是否相同</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> Order) <span class="comment">//2.若地址不同，判断两者是否同一类型</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> (Order)obj; <span class="comment">//3.向下转型，为了调用子类的属性和方法</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//正确的：</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.orderId == order.orderId &amp;&amp; </span><br><span class="line">                <span class="built_in">this</span>.orderName.equals(order.orderName); <span class="comment">//4.比较子类的属性的“内容”而不是地址</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//错误的：</span></span><br><span class="line">            <span class="comment">//return this.orderId == order.orderId &amp;&amp;</span></span><br><span class="line">            <span class="comment">//this.orderName == order.orderName;</span></span><br><span class="line">        &#125;	</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		<strong>equals()练习：</strong></p>
<p>​		练习1：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">		<span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">		System.out.println(s1.equals(s2));<span class="comment">//true</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		练习2：如果类A中的属性有自定义类 类型，那么比较两个类A的对象是否相等是，要这样做：</p>
<p><img src="/orange-zzcs/imgs/image-20230426203241742.png" alt="image-20230426203241742"></p>
<p>​		<strong>②toString()</strong></p>
<p>​			1.<strong>当我们输出一个对象的引用时，实际上就是调用当前对象的toString()方法。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">System.out.println(p1);</span><br><span class="line">System.out.println(p1.toString);</span><br><span class="line"><span class="comment">//第3、4行代码输出的内容是一样的，因此它们实际上是等价的</span></span><br></pre></td></tr></table></figure>

<p>​			2.Object类中toString()方法输出的是该对象的地址值（地址值中包含对象的类型和虚拟地址）</p>
<p>​			3.像 File、String、Date及包装类（Wrapper Class）等来说，重写了toString()方法，使得调用toString()方法时输出不是地址值而是“实体内容”信息（即输出对象的属性）。</p>
<p>​			4.自定义类也可以重写toString()方法，当调用此方法时，返回对象的“实体内容”。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Source--&gt; 生成toString()--&gt; 选择要输出的属性--&gt; 点击OK即可重写toString()方法</span><br><span class="line">注：使用系统提供重写的toString()方法，只能输出其类所拥有的属性（不包括静态变量）</span><br></pre></td></tr></table></figure>



<h4 id="K-继承中的this关键字"><a href="#K-继承中的this关键字" class="headerlink" title="K.继承中的this关键字"></a>K.继承中的this关键字</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getA</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Man</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getA</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Man</span> <span class="variable">m1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Man</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> m1.getA();</span><br><span class="line">        System.out.println(a);</span><br><span class="line">        <span class="comment">//输出2；如果没有第八行，则输出结果为1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	总结：在继承关系中，子类使用”this.属性”或”this.方法”，都会先观察子类中是否有该属性、方法。如果有，则使用这些属性和方法；如果没有，则执行父类中的属性和方法。</p>
<hr>
<h3 id="③多态性-属于运行时行为）"><a href="#③多态性-属于运行时行为）" class="headerlink" title="③多态性(属于运行时行为）"></a>③多态性(属于运行时行为）</h3><h4 id="A-何为多态性"><a href="#A-何为多态性" class="headerlink" title="A.何为多态性"></a>A.何为多态性</h4><p>​	对象的多态性：父类的引用指向子类的对象。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Man</span>();</span><br><span class="line"><span class="comment">//Man为子类，Person为父类</span></span><br></pre></td></tr></table></figure>

<h4 id="B-多态性的使用"><a href="#B-多态性的使用" class="headerlink" title="B.多态性的使用"></a>B.多态性的使用</h4><p>​	虚拟方法调用</p>
<p>​	有了对象的多态性以后，我们在编译期，只能调用父类中声明的方法，但在运行期，我们实际<strong>执行的是子类重写父类的方法。</strong></p>
<p>​	总结：编译看左边；运行，看右边。</p>
<h4 id="C-多态性的使用前提"><a href="#C-多态性的使用前提" class="headerlink" title="C.多态性的使用前提"></a>C.多态性的使用前提</h4><p>​	①有类的继承关系</p>
<p>​	②方法的重写</p>
<h4 id="D-多态性的好处"><a href="#D-多态性的好处" class="headerlink" title="D.多态性的好处"></a>D.多态性的好处</h4><p>​	实现代码的通用性</p>
<h4 id="E-注意"><a href="#E-注意" class="headerlink" title="E.注意"></a>E.注意</h4><p>​	<strong>对象的多态性，只适用于方法，</strong>不适用于属性（编译和运行都看左边）</p>
<h4 id="F-多态的内存解析"><a href="#F-多态的内存解析" class="headerlink" title="F.多态的内存解析"></a>F.多态的内存解析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Man</span>();</span><br></pre></td></tr></table></figure>

<p>​	堆空间中创建了一个对象实体，该对象实体中有父类的属性，也有子类的属性。方法区当中有父类的方法，也有子类的方法。但由于变量声明为父类类型，导致编译时，只能调用父类中声明的属性和方法。子类特有的属性和方法不能调用。</p>
<h4 id="G-instanceof-操作符"><a href="#G-instanceof-操作符" class="headerlink" title="G.instanceof 操作符"></a>G.instanceof 操作符</h4><p>​	<strong>①引入：</strong>如何才能调用子类特有的方法和属性？	</p>
<p>​		<strong>方法：</strong>向下转型，使用强制类型转换符。</p>
<p><img src="/orange-zzcs/imgs/image-20230426203300410.png" alt="image-20230426203300410"></p>
<p>​	</p>
<p>​		<strong>instanceof使用情景：</strong></p>
<p>​		使用强转时，可能出现ClassCastException的异常。为了避免出现这种错误，我们引入instanceof关键字，在强转前进行判断。</p>
<p>​	<strong>②instanceof的格式</strong></p>
<p>​		a intanceof  A ：判断父类的引用a是否是类A的实例，是返回true，否则返回false。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Man</span>();</span><br><span class="line"><span class="keyword">if</span>(p1 <span class="keyword">instanceof</span> Man)&#123;<span class="comment">//返回true</span></span><br><span class="line">    <span class="type">Man</span> <span class="variable">m1</span> <span class="operator">=</span> (Man)p1;<span class="comment">//当为true时，就可以进行强</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">为什么返回true？</span></span><br><span class="line"><span class="comment">因为声明多态时，p1指向的是子类Man的对象，所以返回true</span></span><br><span class="line"><span class="comment">p1 instanceof Woman ，返回false</span></span><br><span class="line"><span class="comment">因为声明多态时，p1指向的是子类Man的对象，不是子类Woman的对象所以返回false</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>​		如果a instanceof A返回true，则a intanceof B也返回true。其中类B是类A的父类。</p>
<p>​	<strong>③补充：</strong></p>
<p>​	A.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Objecct</span> <span class="variable">ob1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Man</span>();</span><br><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> (Person)ob1;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">强转时，不仅可以转为Man,也可以转为Man的父类Person</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>​	Object类、Person类、Man类三者的继承关系：</p>
<img src="/imgs/image-20230426203350374.png" alt="image-20230426203350374" style="zoom:67%;" />

<p>​	B.instanceof的其他含义：</p>
<p>​		a instanceof B，判断a是否是B类 类型，如：c1 instanceof Person，其含义为：判断c1是否是Person类型。</p>
<p>​	C.如何判断a instanceof B是true还是false。</p>
<p>​		已知：对象a属于Person类型。我们拿着Person和B进行对比，如果B也是Person类型或是Person类的父类，则返回true；如果B是Person类的子类，则返回false。</p>
<p>​	D.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="type">Man</span> <span class="variable">m1</span> <span class="operator">=</span> (Man)p1; <span class="comment">//ClassCastException，强转只发生在多态中，第一行代码的声明方式并不属于多态。</span></span><br></pre></td></tr></table></figure>



<hr>
<h2 id="11、包装类的使用"><a href="#11、包装类的使用" class="headerlink" title="11、包装类的使用"></a>11、包装类的使用</h2><h3 id="A-JUnit单元测试"><a href="#A-JUnit单元测试" class="headerlink" title="A.JUnit单元测试"></a>A.JUnit单元测试</h3><h4 id="①什么是单元测试"><a href="#①什么是单元测试" class="headerlink" title="①什么是单元测试"></a>①什么是单元测试</h4><p>​		对某一部分代码进行测试</p>
<h4 id="②单元测试的步骤"><a href="#②单元测试的步骤" class="headerlink" title="②单元测试的步骤"></a>②单元测试的步骤</h4><p>​		<strong>复杂型：</strong></p>
<p>​		A.选中当前工程，右键选择：build path—add libraries—JUnit 4 —下一步 。</p>
<p>​		B.创建Java 类，进行单元测试。此时的Java类要求：①此类是public的；②此类提供公共的无参构造器。</p>
<p>​		C.此类中声明单元测试方法，方法的权限是public，没有返回值，没有形参。</p>
<p>​		D.此单元测试方法上需要声明注解：@Test，并在单元测试类中导入：import org.junit.Test;</p>
<p>​		E.将需要测试的代码写在单元测试方法里。</p>
<p>​		F.写好代码后，左键双击单元测试方法名，右键 run as — JUnit Test 。</p>
<p>​		G.在JUnit视图中看看结果，执行结果没有任何异常：绿条，反之红条（在红条的下方可以看到异常的原因）。</p>
<p>​		<strong>简单型：</strong></p>
<p>​	    A.创建一个public类</p>
<p>​		B.声明一个测试方法。该方法权限为public，没有返回值，没有形参列表。</p>
<p>​		C.在声明的测试方法上面加上@Test，然后将鼠标放在@Test上，导入相关东西。</p>
<p>​		D.左键双击单元测试方法名，右键 run as — JUnit Test 。</p>
<h4 id="③说明"><a href="#③说明" class="headerlink" title="③说明"></a>③说明</h4><p>​		A.可以在该类中声明多个单元测试方法</p>
<p>​		B.也可以声明属性、其他的方法</p>
<p>​		C.单元测试里如果使用到了Scanner从键盘获取用户输入，用户从键盘是输入不了数据的。输入不了的原因不是代码造成的。如果想输入，只能换成main方法。</p>
<hr>
<h3 id="B-包装类"><a href="#B-包装类" class="headerlink" title="B.包装类"></a>B.包装类</h3><h4 id="①引入"><a href="#①引入" class="headerlink" title="①引入"></a>①引入</h4><p>​		基本数据类型的功能比较单薄，不可以通过基本数据类型变量来调用方法，因此为了使基本数据类型变量也可以调用对应的方法，我们就将基本数据类型封装到一个类中，这些类就叫：包装类。</p>
<h4 id="②基本数据类型对应的包装类"><a href="#②基本数据类型对应的包装类" class="headerlink" title="②基本数据类型对应的包装类"></a>②基本数据类型对应的包装类</h4><img src="/imgs/image-20230426203535893.png" alt="image-20230426203535893" style="zoom:67%;" />

<p>​	注意：数值型的包装类都继承了父类：Number</p>
<h4 id="③基本数据类型、包装类、String三者之间的相互转换"><a href="#③基本数据类型、包装类、String三者之间的相互转换" class="headerlink" title="③基本数据类型、包装类、String三者之间的相互转换"></a>③基本数据类型、包装类、String三者之间的相互转换</h4><p>​		A.基本数据类型–&gt; 包装类，调用包装类的构造器即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">10</span>);</span><br><span class="line">System.out.println(integer.toString);<span class="comment">//10</span></span><br><span class="line"><span class="comment">//System.out.println(integer);       与第二行代码等价</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">System.out.println(integer.toString);<span class="comment">//数字：123</span></span><br></pre></td></tr></table></figure>

<p>​		调用包装类的构造器时，也可以选择形参为String类型的构造器，但要注意引号内只能填纯数字（数值型包装类）。布偶类型的包装类如果选了String形参的构造器，其双引号内写true（不区分大小写），则值为true，写其他的内容，则值为false。</p>
<p>​		应用：当调用方法A，但该方的形参为Object类型，我们又需要把基本数据类型传进去方法中，此时就需要将基本数据类型转换为包装类。</p>
<p>​		B.包装类–&gt; 基本数据类型，调用包装类Xxx的xxxValue()方法</p>
<p>​			如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">10</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> integer.intValue();</span><br></pre></td></tr></table></figure>

<p>​			应用：当需要做基本运算时，就要把包装类转换为基本数据类型</p>
<p>​		</p>
<p>​		C.JFK5.0新特性：：自动装箱与自动拆箱</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自动装箱：基本数据类型--&gt; 包装类的对象，如：</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="comment">//以后基本数据类型--&gt; 包装类，这样写就行，不用像上面那样</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//自动拆箱：包装类--&gt; 基本数据类型，如：</span></span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> integer;</span><br><span class="line"><span class="comment">//以后包装类--&gt; 基本数据类型，这样写就行，不用像上面那样</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> a;</span><br></pre></td></tr></table></figure>

<p>​		</p>
<p>​		D.基本数据类型、包装类–&gt; String类型，调用String重载的valueOf(Xxx xxx)方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> String.valueOf(<span class="number">10</span>);<span class="comment">//&quot;10&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> String.valueOf(integer);<span class="comment">//&quot;10&quot;</span></span><br></pre></td></tr></table></figure>



<p>​		E.String类型–&gt; 基本数据类型、包装类，调用包装类的parseXxx(String s)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> Integer.parseInt(s3);<span class="comment">//数字：123</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;12.6&quot;</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">k</span> <span class="operator">=</span> Double.parseDouble(s4);</span><br><span class="line"><span class="comment">//转换时，要注意字符串要满足转换目标类型的要求，如：</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;123a&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> Integer.parseInt(s1);<span class="comment">//报错：NumberFormatException</span></span><br></pre></td></tr></table></figure>

<p>​			</p>
<h4 id="④练习"><a href="#④练习" class="headerlink" title="④练习"></a>④练习</h4><p>​		练习一：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="type">Integer</span> <span class="variable">j</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line">	System.out.println(i == j); <span class="comment">//false，“==”比较两个地址是否相同</span></span><br><span class="line">	</span><br><span class="line">	<span class="type">Integer</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">	<span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">	System.out.println(m == n);<span class="comment">//true,</span></span><br><span class="line">	</span><br><span class="line">	<span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">	<span class="type">Integer</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">	System.out.println(x == y);<span class="comment">//false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">第二、三个运行结果为什么是这样？</span></span><br><span class="line"><span class="comment">这是因为，Integer 内部定义了IntegerCache结构，IntegerCache 中定义了数组Integer[ ]，保存了-128~127 范围的整数。如果我们使用自动装箱的方式，给Integer 赋值的范围在-128 ~ 127范围内时，可以直接使用Integer[ ] 中的元素，不必再去new；如果超出了-128~127，则需要new</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">① 在上述第二段代码中，m 和 n 都在-128 ~ 127范围内，且第一次定义m时用了数组元素，用完后不会销毁，所以在定义n时，仍用的是数组里相同的元素，两者地址值相等，所以结果true 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">② 而在上述第三段代码中，x 和 y 都不在-128 ~ 127范围内，要再new 一个对象，于是分别new 了两个对象，两者地址值不相等，所以结果false 。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>​	</p>
<p>​	练习二：</p>
<p>​		有了自动装箱和自动拆箱后，Object类、包装类、基本数据类型类型之间的关系为：</p>
<p><img src="/orange-zzcs/imgs/image-20230427155908288.png" alt="image-20230427155908288"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">Vector</span> <span class="variable">v</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vector</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//v.elementAt()方法接收的是Object类型的形参</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> v.elementAt(i);<span class="comment">//自动转换</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> (<span class="type">int</span>)object;<span class="comment">//强制转换</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    v.addElement(s1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="12、面向对象中的其他关键字"><a href="#12、面向对象中的其他关键字" class="headerlink" title="12、面向对象中的其他关键字"></a>12、面向对象中的其他关键字</h2><h3 id="A-static"><a href="#A-static" class="headerlink" title="A.static"></a>A.static</h3><h4 id="①引入-1"><a href="#①引入-1" class="headerlink" title="①引入"></a>①引入</h4><p>​				static：静态的</p>
<p>​				static可以修饰<strong>属性、方法、代码块、内部类</strong>，不能修饰外部类</p>
<h4 id="②使用static修饰属性：静态变量（又称类变量）"><a href="#②使用static修饰属性：静态变量（又称类变量）" class="headerlink" title="②使用static修饰属性：静态变量（又称类变量）"></a>②使用static修饰属性：静态变量（又称类变量）</h4><p>​		A.属性按照是否使用 static 修饰，又分为：静态属性（类变量）和非静态属性（实例变量）。</p>
<p>​			<strong>实例变量：</strong><br>​			我们创建了类的多个对象，每个对象都独立的拥有一套类中的非静态变量。当修改其中一个对象的非静态属性时，不会导致其他对象中同样的属性值的修改。</p>
<p>​			<strong>静态变量：</strong><br>​			我们创建了类的多个对象，多个对象共享一个静态变量。当通过某一个对象修改静态变量时，会导致其他对象调用此静态变量时，是修改过了的。</p>
<p>​		<strong>B.static修饰属性的其他说明</strong></p>
<p>​			①静态变量随着类的加载而加载。可以通过“类.静态变量”的方式进行调用。</p>
<p>​			②静态变量的加载要早于对象的创建。因此也可以通过“对象.静态变量”的方式进行调用。</p>
<p>​			③由于类只会加载一次，则静态变量在内存中也只会存在一份，存在方法区的静态域中。</p>
<p>​			④</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">类变量</th>
<th align="center">实例变量</th>
</tr>
</thead>
<tbody><tr>
<td align="center">类</td>
<td align="center">类.类变量</td>
<td align="center">不可调用</td>
</tr>
<tr>
<td align="center">对象</td>
<td align="center">对象.类变量</td>
<td align="center">对象.实例变量</td>
</tr>
</tbody></table>
<p>​		</p>
<p>​		<strong>C.类变量与实例变量内存解析</strong></p>
<p><img src="/orange-zzcs/imgs/image-20230426203626530.png" alt="image-20230426203626530"></p>
<p>​	</p>
<h4 id="③使用static修饰方法：静态方法"><a href="#③使用static修饰方法：静态方法" class="headerlink" title="③使用static修饰方法：静态方法"></a><strong>③使用static修饰方法：静态方法</strong></h4><p>​		<strong>A.</strong></p>
<p>​			随着类的加载而加载但不执行，可以通过“类.静态方法”的方式调用</p>
<p>​		<strong>B.</strong></p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">静态方法</th>
<th align="center">非静态方法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">类</td>
<td align="center">类名.静态方法</td>
<td align="center">不可调用</td>
</tr>
<tr>
<td align="center">对象</td>
<td align="center">对象.静态方法</td>
<td align="center">对象.非静态方法</td>
</tr>
</tbody></table>
<p>​		<strong>C.</strong></p>
<p>​			静态方法中，只能调用静态的方法或属性。如果想调用非静态的属性或方法，只能先创建对象，然后通过对象来调用。</p>
<p>​			非静态方法中，既可以调用非静态的方法或属性，也可以调用静态的方法或属性。</p>
<h4 id="④static注意点"><a href="#④static注意点" class="headerlink" title="④static注意点"></a><strong>④static注意点</strong></h4><p>​		A.在静态方法内，不能使用this 、super 关键字。（此时还没有对象）</p>
<p>​		B.关于静态属性和静态方法的使用，可以从类和对象的生命周期的角度去理解。</p>
<p>​		C.通常类变量都不会放在构造器里。</p>
<h4 id="⑤如何确定是否使用-static"><a href="#⑤如何确定是否使用-static" class="headerlink" title="⑤如何确定是否使用 static"></a><strong>⑤如何确定是否使用 static</strong></h4><p>​		属性：			</p>
<ul>
<li>属性是可以被多个对象共享的，不会随着对象的不同而不同的。</li>
<li>类中的常量也常常声明为static。是常量但不加static修饰的情况：每个人的身份证号，不能改但没个人的身份证号又不一样，因此不能加static。</li>
</ul>
<p>​		方法：</p>
<ul>
<li>操作静态属性的方法，通常设置为 static 的。</li>
<li>工具类中的方法，习惯声明为 static 的。</li>
</ul>
<hr>
<h3 id="B-Static关键字的应用–单例设计模式"><a href="#B-Static关键字的应用–单例设计模式" class="headerlink" title="B.  Static关键字的应用–单例设计模式"></a>B.  Static关键字的应用–单例设计模式</h3><h4 id="①定义"><a href="#①定义" class="headerlink" title="①定义"></a>①定义</h4><p>​		<strong>设计模式：</strong></p>
<p>​			是在大量的实践中总结和理论化之后优选的代码结构、编程风格、以及解决问题的思考方式。即：<strong>解决问题的套路</strong></p>
<p>​		<strong>单列设计模式：</strong></p>
<p>​			就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法。</p>
<p>​		<strong>单例设计模式设计思想</strong></p>
<p>​			如果我们要让类在一个虚拟机中只能产生一个对象，我们首先必须将类的构造器的访问权限设置为private，这样，就不能用new操作符在类的外部产生类的对象了，但在类内部仍可以产生该类的对象。因为在类的外部开始还无法得到类的对象，只能调用该类的某个静态方法以返回类内部创建的对象，静态方法只能访问类中的静态成员变量，所以，指向类内部产生的该类对象的变量也必须定义成静态的。</p>
<h4 id="②实现-饿汉式-amp-懒汉式"><a href="#②实现-饿汉式-amp-懒汉式" class="headerlink" title="②实现(饿汉式&amp;懒汉式)"></a>②实现(饿汉式&amp;懒汉式)</h4><p>​		<strong>饿汉式：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bank</span> &#123;   </span><br><span class="line">    <span class="comment">// 1.私有化构造器</span></span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Bank</span><span class="params">()</span>   &#123;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.内部提供一个当前类的实例  </span></span><br><span class="line">    <span class="comment">//4.此实例也必须静态化</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Bank</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bank</span>(); </span><br><span class="line">    </span><br><span class="line">     <span class="comment">// 3.提供公共的静态的方法，返回当前类的对象</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	 &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>​		<strong>懒汉式：</strong>	</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bank</span>&#123;</span><br><span class="line">    <span class="comment">//1.私有化构造器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Bank</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.声明当前类的对象，没有初始化</span></span><br><span class="line">    <span class="comment">//4.此对象也必须声明为static</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Bank</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.声明public、static的返回当前类对象的方法。效率稍高</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Bank.class)&#123;</span><br><span class="line">            	<span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">                	instance = <span class="keyword">new</span> <span class="title class_">Bank</span>();</span><br><span class="line">           		 &#125;</span><br><span class="line">        	&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    方式一：但效率稍差</span></span><br><span class="line"><span class="comment">    public static synchronized Bank getInstance()&#123;</span></span><br><span class="line"><span class="comment">        if(instance == null)&#123;</span></span><br><span class="line"><span class="comment">            instance = new Bank();</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return instance;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    方式二：但效率稍差</span></span><br><span class="line"><span class="comment">    public static Bank getInstance()&#123;</span></span><br><span class="line"><span class="comment">        synchronized(Bank.class)&#123;</span></span><br><span class="line"><span class="comment">            if(instance == null)&#123;</span></span><br><span class="line"><span class="comment">                instance = new Bank();</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        	return instance;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="③饿汉式与懒汉式比较"><a href="#③饿汉式与懒汉式比较" class="headerlink" title="③饿汉式与懒汉式比较"></a>③饿汉式与懒汉式比较</h4><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">好处</th>
<th align="center">坏处</th>
</tr>
</thead>
<tbody><tr>
<td align="center">饿汉式</td>
<td align="center">线程安全</td>
<td align="center">对象加载时间过长</td>
</tr>
<tr>
<td align="center">懒汉式</td>
<td align="center">延迟对象的创建</td>
<td align="center">无</td>
</tr>
</tbody></table>
<h4 id="④单例模式应用场景-了解"><a href="#④单例模式应用场景-了解" class="headerlink" title="④单例模式应用场景(了解)"></a>④单例模式应用场景(了解)</h4><ul>
<li><strong>网站的计数器</strong> ，一般也是单例模式实现，否则难以同步。</li>
<li><strong>应用程序的日志应用</strong> ，一般都使用单例模式实现，这一般是由于共享的日志文件一直处于打开状态，因为只能有一个实例去操作，否则内容不好追加。</li>
<li><strong>数据库连接池</strong> 的设计一般也是采用单例模式，因为数据库连接是一种数据库资源。</li>
<li>项目中， <strong>读取配置文件的类</strong> ，一般也只有一个对象。没有必要每次使用配置文件数据，都生成一个对象去读取。</li>
<li><strong>Application</strong> 也是单例的典型应用。</li>
<li><strong>Windows的Task Manager (任务管理器)</strong> 就是很典型的单例模式。</li>
<li><strong>Windows的Recycle Bin (回收站)</strong> 也是典型的单例应用。在整个系统运行过程中，回收站一直维护着仅有的一个实例。</li>
</ul>
<hr>
<h3 id="C-mian-方法的语法-了解"><a href="#C-mian-方法的语法-了解" class="headerlink" title="C.mian()方法的语法(了解)"></a>C.mian()方法的语法(了解)</h3><p>​	①作为程序入口</p>
<p>​	②每个类里都可以写main()方法</p>
<p>​	③main()方法也可以看作一个普通的静态方法</p>
<p>​	④当一个源文件里有多个main()方法，当运行时其会让你选择执行哪个main()方法。</p>
<p>​	⑤main()方法可以作为我们与控制台交互的方式。（了解）</p>
<hr>
<h3 id="D-final"><a href="#D-final" class="headerlink" title="D.final"></a>D.final</h3><h4 id="①引入-2"><a href="#①引入-2" class="headerlink" title="①引入"></a>①引入</h4><p>​		final可以用来修饰的结构：类、方法、变量</p>
<h4 id="②final-用来修饰一个类（了解）"><a href="#②final-用来修饰一个类（了解）" class="headerlink" title="②final 用来修饰一个类（了解）"></a>②final 用来修饰一个类（了解）</h4><p>​		表明此类不能被其它类所继承</p>
<h4 id="③final-用来修饰方法（了解）"><a href="#③final-用来修饰方法（了解）" class="headerlink" title="③final 用来修饰方法（了解）"></a>③final 用来修饰方法（了解）</h4><p>​		表明此方法不能被重写</p>
<h4 id="④final-用来修饰变量"><a href="#④final-用来修饰变量" class="headerlink" title="④final 用来修饰变量"></a>④final 用来修饰变量</h4><p>​		final用来修饰变量，此时“变量”就是一个常量，一但赋值就不能被修改。</p>
<p>​		A.final修饰属性：可以考虑赋值的位置有：显式初始化、代码块中初始化、构造器中初始化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FinalTest</span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//显示初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> b;</span><br><span class="line">    &#123;</span><br><span class="line">        b=<span class="number">1</span>;</span><br><span class="line">    &#125;<span class="comment">//代码块中初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> c;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FinalTest</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        c=<span class="number">2</span>;</span><br><span class="line">    &#125;<span class="comment">//构造器中初始化</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">那三种情况都可以给常量赋值，在什么情况选哪种赋值情况比较好？</span></span><br><span class="line"><span class="comment">​ 当多个对象的常量值都一样时，可以显式初始化、代码块初始化。</span></span><br><span class="line"><span class="comment">​ 当需要将某个方法的返回值，赋给一个常量时，可以使用代码块初始化、构造器初始化。</span></span><br><span class="line"><span class="comment">​ 当每个对象的常量值都不一样时，可以使用构造器初始化。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>​		B.final修饰局部变量：</p>
<p>​			尤其是修饰形参时，表明此形参是一个常量。当我们调用此方法时，给常量形参赋一个实参。一旦赋值以后，就只能在方法体内使用此形参，但不能重新赋值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FinalTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="comment">//a = 20;  会报错，一旦赋值就不能修改其值</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> b)</span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//b = 20;  会报错，一旦赋值就不能修改其值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	</p>
<h4 id="⑤static-final"><a href="#⑤static-final" class="headerlink" title="⑤static final"></a>⑤static final</h4><p>​		static final 只能用来修饰属性和方法，但用来修饰方法的情况少见。</p>
<p>​		static final 用来修饰属性：全局常量</p>
<h3 id="E-abstract"><a href="#E-abstract" class="headerlink" title="E.abstract"></a>E.abstract</h3><h4 id="①-引入"><a href="#①-引入" class="headerlink" title="①.引入"></a>①.引入</h4><p>​		当父类被多个子类继承时，就很少再通过造父类的对象来调用父类的方法了，因为子类继承了父类的属性和方法。因此可以用<strong>abstract</strong>关键字来修饰父类，表明父类<strong>不可以创建对象了。</strong></p>
<p>​		abstract：抽象的</p>
<p>​		abstract可以用来修饰的结构：类、方法</p>
<p>​		abstract修饰类：抽象类，abstract修饰方法：抽象方法</p>
<h4 id="②-抽象类"><a href="#②-抽象类" class="headerlink" title="②.抽象类"></a>②.抽象类</h4><p>​		①抽象类不能实例化</p>
<p>​		②抽象类中一定有构造器，便于子类的构造器调用父类的构造器。</p>
<p>​		③开发中，都会提供抽象类的子类，让子类实例化，完成相关的操作。</p>
<h4 id="③-抽象方法"><a href="#③-抽象方法" class="headerlink" title="③.抽象方法"></a>③.抽象方法</h4><p>​		A.抽象方法只有方法的声明，没有方法体。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//只有上面的格式才为抽象方法</span></span><br></pre></td></tr></table></figure>

<p>​		B.抽象方法不能被调用。</p>
<p>​		C.包含抽象方法的类，一定是一个抽象类。反之，抽象类中可以没有抽象方法。</p>
<p>​		D.若继承的父类中有抽象方法，则子类要不重写父类（直接父类、间接父类）中所有的抽象方法，此时子类可以实例化；要不不重写父类中抽象的方法，此时子类要声明为abstract的，并不能造子类的对象。</p>
<h4 id="④-抽象方法的应用"><a href="#④-抽象方法的应用" class="headerlink" title="④.抽象方法的应用"></a>④.抽象方法的应用</h4><p>​		如父类中有一个方法A，而子类会重写该方法A，并且不同的子类重写的内容也不一样，父类中的方法A就无法确定其方法体的内容，因此就可以将方法A声明为抽象方法。</p>
<h4 id="⑤-abstract使用上的注意点"><a href="#⑤-abstract使用上的注意点" class="headerlink" title="⑤.abstract使用上的注意点"></a>⑤.abstract使用上的注意点</h4><p>​		A.abstract只能用来修饰类和方法</p>
<p>​		B.abstract不能用来修饰私有方法、静态方法、final的方法、final的类</p>
<h4 id="⑥-匿名类（看得懂就行）"><a href="#⑥-匿名类（看得懂就行）" class="headerlink" title="⑥.匿名类（看得懂就行）"></a>⑥.匿名类（看得懂就行）</h4><p>​		由于抽象类不能实例化，假设 Person 是一个抽象类，那么 Person p&#x3D; new Person (); 是错误的写法，但是 Person p&#x3D; new Person () { }; { }内重写 Person 的抽象方法，此时是不报错的。这时new Person( ){ } 就说创建了一个匿名子类的对象p。（此时类的种类不清楚，但是是 Person 的子类，没有子类名）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">		method(s1);</span><br><span class="line">		</span><br><span class="line">		<span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>() &#123;</span><br><span class="line"><span class="comment">//匿名子类（new Person()&#123;&#125;）。父类引用指向匿名子类的对象 --&gt;多态</span></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">walk</span><span class="params">()</span> &#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;高一（9）班走路&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		method(p2);<span class="comment">//属于多态，因此执行子类中重写的方法</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Person p)</span> &#123;</span><br><span class="line">		p.walk();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">walk</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">walk</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;学生走路&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/orange-zzcs/imgs/image-20230426203656079.png" alt="image-20230426203656079"></p>
<p>​		实际上，代码3-4和25-29行代码与6-14行代码是等价的。这就体现了匿名子类的意义：不用创建抽象类的子类（25–29行代码）。</p>
<p>​		注意：</p>
<p>​				①使用匿名子类的前提：父类是抽象类</p>
<p>​				②匿名子类如果赋给了一个对象，则可以多次使用该对象，如果没有赋给一个对象，则该匿名子类只能使用一次。</p>
<p>​		补充：（看得懂就行）</p>
<p><img src="/orange-zzcs/imgs/image-20230426204728151.png" alt="image-20230426204728151"></p>
<p>​		也可以将匿名子类直接放到方法实参处，这就是匿名子类的匿名对象</p>
<hr>
<h4 id="⑦-应用–模板方法设计模式（了解）"><a href="#⑦-应用–模板方法设计模式（了解）" class="headerlink" title="⑦.应用–模板方法设计模式（了解）"></a>⑦.应用–模板方法设计模式（了解）</h4><ul>
<li>当功能内部一部分实现是确定的，一部分实现是不确定的。这时可以把不确定的部分暴露出去，让子类去实现。</li>
<li>换句话说，在软件开发中实现一个算法时，整体步骤很固定、通用，这些步骤已经在父类中写好了。但是某些部分易变，易变部分可以抽象出来，供不同子类实现。这就是一种模板模式。</li>
</ul>
<h3 id="G-interface-接口"><a href="#G-interface-接口" class="headerlink" title="G.interface(接口)"></a>G.interface(接口)</h3><h4 id="①引入-3"><a href="#①引入-3" class="headerlink" title="①引入"></a>①引入</h4><p>​	Java里类只能单继承，但想继承多个类，只能引入接口的概念，有了接口，就可以得到多重继承的效果。</p>
<p>​	有时必须从几个类中抽取一些共同的行为特征，而它们之间又没有is-a关系（即继承关系），仅仅是具有相同的行为特征而已。如：手机、键盘等，它们支持USB连接，手机和USB之间不是继承关系，所以因将USB声明为接口。</p>
<h4 id="②接口的格式"><a href="#②接口的格式" class="headerlink" title="②接口的格式"></a>②接口的格式</h4><p>​		接口使用interface来定义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Fly</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">①类与接口之间属于并列关系，一个类可以实现多个接口，实现了某个接口后，类就拥有了接口的功能。实现了接口的类就叫实现类。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">②接口中静态的结构也可以通过接口名调用</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="③-接口定义"><a href="#③-接口定义" class="headerlink" title="③.接口定义"></a>③.接口定义</h4><p>​		如何定义接口，定义接口中的成员</p>
<p>​		①JDK7及以前：<strong>只能定义全局常量和抽象方法</strong></p>
<p>​			全局常量：public static final 的，但书写时，可以省略不写。声明时要赋值，不然报错。</p>
<p>​			抽象方法：public abstract的，书写时也可省略不写</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Fly</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_SPEED</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> <span class="variable">MAX_SPEED</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">    <span class="comment">//public static final可以不写，但实际上还是有的</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>;<span class="comment">//public abstract可以不写，但实际上还是有的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		②JDK8及以后：除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法</p>
<p>​		<strong>静态方法：</strong>接口中定义的静态方法，<strong>只能通过接口名来调用</strong>，其他的调用方式都不行。实现类中继承不了接口中定义的静态方法。</p>
<p>​		<strong>默认方法：</strong>只能<strong>通过实现类的对象来调用</strong>默认方法。默认方法可以在实现类中重写（重写时，default就不用写了），调用时，仍然调用的是重写以后的方法。</p>
<p>​		<strong>其他说明：</strong></p>
<p>​			①类优先原则：如果子类（或实现类）继承的父类和实现的接口中声明了同名同参数的默认方法，那么在子类没有重写此方法的情况下，默认调用的是父类中的同名同参数的方法。—–&gt;类优先原则（只针对方法）</p>
<p>​			②若一个接口中定义了一个默认方法，而另外一个接口中也定义了一个同名同参数的默认方法，在实现类同时实现了这两个接口且没有重写方法时，会出现：<strong>接口冲突</strong>。要想不冲突，只能在实现类中重写此方法。重写之后想调用某个接口的同名同参默认方法，则可以通过“接口名.super.默认方法名”调用</p>
<p>​			③静态方法和默认方法都有方法体</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Fly</span>&#123;</span><br><span class="line">    <span class="comment">//静态方法，public可以省略但实际上还是有的</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>&#123;<span class="comment">//与第3行代码一样</span></span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//默认方法，default要写出来，public可以省略但实际上还是有的</span></span><br><span class="line">	<span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;<span class="comment">//与11行代码一样</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="④接口的使用"><a href="#④接口的使用" class="headerlink" title="④接口的使用"></a>④接口的使用</h4><p>​		A.Java中，<strong>类与接口是并列的两个结构</strong></p>
<p>​		B.接口中不能定义构造器！这意味着接口不可以实例化</p>
<p>​		C.Java开发中，类通过实现（<strong>implements</strong>）的方式使用接口</p>
<p>​			类实现了接口后，就拥有了接口中的所有结构了。</p>
<p>​			①如果实现类（实现接口的类叫实现类）实现了接口中的所有抽象方法，则此实现类就可以造对象</p>
<p>​			②如果实现类没有实现接口中所有的抽象方法，则此实现类仍为一个抽象方法。</p>
<p>​		D.Java中，类可以实现多个接口 –&gt; 弥补了Java单继承性的局限性</p>
<p>​			继承多个接口，接口之间用逗号隔开</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Plane</span> <span class="keyword">implements</span> <span class="title class_">Fly</span>, Attack&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		E.当类中既有继承，又实现了接口，那其格式为：先写继承后写接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Plane</span> <span class="keyword">extends</span> <span class="title class_">TranSport</span> <span class="keyword">implements</span> <span class="title class_">Flyable</span>, Attack&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		F.接口与接口之间为继承关系，而且可以多继承</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">AA</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">BB</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">CC</span> <span class="keyword">extends</span> <span class="title class_">AA</span>, BB&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		补充：类与类之间是继承关系（extends）；类与接口之间是实现关系（implements）；接口与接口之间是继承关系（extends）</p>
<h4 id="⑤其他"><a href="#⑤其他" class="headerlink" title="⑤其他"></a>⑤其他</h4><p>​	A.接口的具体使用，体现多态性</p>
<p>​	例如一个方法的形参是接口类型，由于接口不能实例化，所以只能提供其实现类的对象，即体现了多态性。</p>
<p>​	B.接口，实际上可以看做是一种规范</p>
<p>​		要想让实现类造对象，实现类就必须重写接口中的抽象方法，这就体现了接口的规范性。</p>
<p>​	C.开发中，面向接口编程（体会）</p>
<p>​		我们在应用程序中，调用的结构都是JDBC中定义的接口，不会出现具体某个数据库厂商的API。</p>
<h4 id="⑥匿名实现类"><a href="#⑥匿名实现类" class="headerlink" title="⑥匿名实现类"></a>⑥匿名实现类</h4><p>​	与匿名子类一样</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Fly</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">speed</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Fly</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Fly</span>()&#123;<span class="comment">//匿名实现类的非匿名对象</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">speed</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;飞机加速&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<img src="/imgs/image-20230426204754586.png" alt="image-20230426204754586" style="zoom:67%;" />



<h4 id="⑦应用–代理模式-amp-工厂模式"><a href="#⑦应用–代理模式-amp-工厂模式" class="headerlink" title="⑦应用–代理模式&amp;工厂模式"></a>⑦应用–代理模式&amp;工厂模式</h4><p>​	A.代理模式</p>
<p>​		定义：类B不想操作某个接口里的方法，因此让类A去帮类B操作实现这些方法，这就是代理模式，其中类B称为被代理类，类A称为代理类。</p>
<p>​		分类：静态代理、动态代理</p>
<p>​	B.工厂模式</p>
<p>​		定义：“工厂”用来创建对象的，达到让对象的创建与对象的使用分开的目的</p>
<p>​		分类：简单工厂模式、工厂方法模式、抽象工厂模式</p>
<p>​		简单工厂模式：一般使用静态方法，通过接收的参数的不同返回不同的实例对象。缺点：对于增加新产品，不修改代码的话，是无法扩展的。从而产生工厂方法模式。</p>
<p>​		工厂方法模式：将工厂变成一个接口，再创建一些具体工厂实现类，让实现类去返回实例对象。</p>
<p>​		抽象工厂模式：在对象的创建上比工厂方法模式的创建复杂些。（了解，后面再讲）</p>
<hr>
<h2 id="13、异常处理"><a href="#13、异常处理" class="headerlink" title="13、异常处理"></a>13、异常处理</h2><h3 id="A-定义-2"><a href="#A-定义-2" class="headerlink" title="A.定义"></a>A.定义</h3><p>​	在Java语言中，将程序执行中发生的不正常情况称为“异常”。 (开发过程中的<strong>语法错误和逻辑错误不是异常</strong>)</p>
<h3 id="B-分类"><a href="#B-分类" class="headerlink" title="B.分类"></a>B.分类</h3><p>​	Exception和Error的顶级父类为Throwable</p>
<h4 id="①Error"><a href="#①Error" class="headerlink" title="①Error"></a>①Error</h4><p>​	Java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等严重情况。<strong>一般不编写针对性的代码进行处理。因此需要对报错的代码进行修改</strong></p>
<p>​	比如：StackOverflowError（栈溢出）和OOM(OutOfMemoryError，堆溢出)。</p>
<h4 id="②Exception"><a href="#②Exception" class="headerlink" title="②Exception"></a>②Exception</h4><p>​	Exception: 其它因编程错误或偶然的外在因素导致的一般性问题，<strong>可以使用针对性的代码进行处理</strong>。例如：</p>
<ul>
<li>空指针访问</li>
<li>试图读取不存在的文件</li>
<li>网络连接中断</li>
<li>数组角标越界</li>
</ul>
<p>​	Exception又可以分为运行时异常（unchecked）和编译时异常（checked）</p>
<h4 id="③异常的体系结构图"><a href="#③异常的体系结构图" class="headerlink" title="③异常的体系结构图"></a>③异常的体系结构图</h4><p><img src="/orange-zzcs/imgs/image-20230426204816564.png" alt="image-20230426204816564"></p>
<h4 id="④常见的运行时异常"><a href="#④常见的运行时异常" class="headerlink" title="④常见的运行时异常"></a>④常见的运行时异常</h4><p>​		NullPointerException：空指针异常（如：该对象为Null，但调用了其方法）</p>
<p>​		ArryIndexOutOfBoundsException：数组下标越界异常</p>
<p>​		classCastException：强制转换异常（如：父类强制转换为不正确的子类时）</p>
<p>​		NumberFormatException：(如：出现在包装类转基本数据类型时)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span>  <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Integer.parseInt(str);<span class="comment">//因为abc不是int类型，所以出现NumberFormatException</span></span><br></pre></td></tr></table></figure>

<p>​		InputMismatchException：输入异常（用scanner时，获取的是int型，但输入的是字符型）</p>
<p>​		ArithmeticException：运算异常（如：除数为0）</p>
<hr>
<h3 id="C-异常处理"><a href="#C-异常处理" class="headerlink" title="C.异常处理"></a>C.异常处理</h3><p>​	<strong>Java中有异常处理的机制：抓抛模型</strong></p>
<p>​	<strong>过程一：“抛”：</strong>程序在正常执行的过程中，一旦出现异常，就会在异常代码处生成一个异常类的对象，并对此对象抛出。一旦抛出对象以后，其后的代码就不再执行。</p>
<p>​	<strong>过程二：“抓”：</strong>过程一抛出对象后，需要对对象进行抓取，即：对异常进行处理，处理方式就是①try-catch-finally ②throws</p>
<p>​	</p>
<h3 id="D-异常处理机制一：try-catch-finally"><a href="#D-异常处理机制一：try-catch-finally" class="headerlink" title="D.异常处理机制一：try-catch-finally"></a>D.异常处理机制一：try-catch-finally</h3><p>​	try-catch-finally是处理异常，即把异常解决掉。在方法体内使用。</p>
<h4 id="①格式"><a href="#①格式" class="headerlink" title="①格式"></a>①格式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//可能出现异常的代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">1</span> 变量名<span class="number">1</span>)&#123;<span class="comment">//变量名只在第一个catch的&#123;&#125;里有效</span></span><br><span class="line">    <span class="comment">//异常处理的方式1</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">2</span> 变量名<span class="number">2</span>)&#123;</span><br><span class="line">    <span class="comment">//异常处理的方式2</span></span><br><span class="line">&#125;</span><br><span class="line">.....</span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">//一定会执行的代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可以抓取多种类型的异常，即可以有多个catch</span></span><br></pre></td></tr></table></figure>

<h4 id="②说明一"><a href="#②说明一" class="headerlink" title="②说明一"></a>②说明一</h4><ul>
<li>finally是可选的</li>
<li>使用try将可能出现异常的代码包装起来，在执行过程中，一旦出现异常，就会生成一个对应异常类的对象，且try里剩下的代码也不会继续执行。然后就根据此对象的类型，去catch中进行匹配。</li>
<li>一旦try中的异常对象匹配到某一个catch时，就进入catch中进行异常的处理。一旦处理完成，就跳出当前的try-catch结构（此时没有finally）,继续执行其后的代码。（只会进入一个catch，与case类似）</li>
<li>catch中的异常类型如果满足子父类关系，则要求子类一定声明在父类的上面，否则报错。如果不是子父类关系，则无先后顺序要求。</li>
<li>catch的{ }里常用的异常对象处理方式： ① String getMessage（）获取异常信息，返回字符串 ② printStackTrace（）获取异常类类名和异常信息，以及异常出现在程序中的位置。返回值void。</li>
<li>在try结构中声明的变量，在出了try结构以后，就不能再被调用</li>
<li>try-catch-finally 可以嵌套。</li>
</ul>
<h4 id="③说明二"><a href="#③说明二" class="headerlink" title="③说明二"></a>③说明二</h4><p>​	<strong>try-catch-finally中finally的使用</strong></p>
<p>​	A.finally是可选的</p>
<p>​	B.finally中声明的是一定会被执行的代码。即使catch中又出现异常了，try中有return语句，catch中有return语句，try中没有异常等情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line">		<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> order.method();</span><br><span class="line">		System.out.println(i);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="type">int</span>[] b = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1</span>];</span><br><span class="line">			System.out.println(b[<span class="number">1</span>]);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;<span class="keyword">catch</span> (ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;数组下标越界&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">		&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;一定会执行的代码&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/orange-zzcs/imgs/image-20230426204833352.png" alt="image-20230426204833352"></p>
<p>​	C.像数据库连接、输入输出流、网络编程Socket等资源，JVM是不能自动回收的，需要自己手动进行资源释放。此时的资源释放就需要声明在finally中。</p>
<h4 id="④体会"><a href="#④体会" class="headerlink" title="④体会"></a>④体会</h4><p>​	A.使用try-catch-finally处理编译时异常，使得程序在编译时不再报错，但是运行时仍可能报错。相当于将一个编译时可能出现的异常，延迟到运行时出现。</p>
<p>​	B.开发中，由于<strong>运行时异常</strong>比较常见，所以我们通常<strong>就不</strong>针对运行时异常<strong>编写try-catch-finally</strong>了。针对于<strong>编译时异常</strong>，我们一<strong>定要考虑异常的处理。</strong></p>
<h3 id="E-异常处理机制二：throws-异常类型"><a href="#E-异常处理机制二：throws-异常类型" class="headerlink" title="E.异常处理机制二：throws+异常类型"></a>E.异常处理机制二：throws+异常类型</h3><ul>
<li>throws是把异常往上一级抛，throws也不处理运行时异常，谁调用就把异常抛给谁。</li>
<li>“throws + 异常类型” 写在方法的声明处，指明此方法执行时，可能会抛出异常类型。一旦当方法体执行时，出现异常，仍会在异常代码处生成一个异常类的对象，此对象满足throws后异常类型时，就会被抛出（不满足时程序报错终止）。异常代码后续的代码就不再执行。</li>
<li>出现了异常类型A，那么throws的时候可以写其父类的异常类型。如：出现了RuntimeException，则可以写throws Exception。</li>
</ul>
<h4 id="①体会"><a href="#①体会" class="headerlink" title="①体会"></a>①体会</h4><p>​	try-catch-finally 真正将异常处理掉了，但是throws 的方法只是将异常抛给了方法的调用者，并没有真正将异常处理掉。</p>
<h3 id="F-开发中如何选择异常处理的方式"><a href="#F-开发中如何选择异常处理的方式" class="headerlink" title="F.开发中如何选择异常处理的方式"></a>F.开发中如何选择异常处理的方式</h3><ol>
<li>父类中被重写的方法没有throws方式处理异常，则子类重写的方法也不能使用throws。意味着若子类重写的方法中有异常，必须使用try-catch-finally 方式处理。</li>
<li>执行的方法a 中，先后又调用了另外的几个方法，这几个方法是递进关系执行的。我们建议在这几个方法的声明里使用throws的方式进行处理。而执行的方法a可以考虑使用try-catch-finally 方式将这几个方法包起来。</li>
<li>当该方法A会被其他方法调用，而该方法A又会出现异常时，通常不会在方法A中对异常进行try-catch-finally，而是throws</li>
</ol>
<h3 id="G-补充"><a href="#G-补充" class="headerlink" title="G.补充"></a>G.补充</h3><p>​	出现运行时异常，只能去修改出错的代码了</p>
<h3 id="H-手动抛出异常"><a href="#H-手动抛出异常" class="headerlink" title="H.手动抛出异常"></a>H.手动抛出异常</h3><p>​	声明在方法里</p>
<h4 id="①格式：throw-new-异常类型（）"><a href="#①格式：throw-new-异常类型（）" class="headerlink" title="①格式：throw new 异常类型（）;"></a>①格式：<strong>throw new 异常类型（）;</strong></h4><p>​	抛出异常的类型：Excception、RuntimeException（从这两种异常类型中选）</p>
<ul>
<li>如果抛出的异常类型为：Excception，则必须对异常做出处理，不然报错。Exception可以选择不带参数的，或带参数的（String message，将想要输出的语句写进去，然后在处理该异常时可以调用getMessage方法来将该语句输出）</li>
<li>如果抛出的异常类型为：RuntimeException（运行时异常），则可以不用对异常进行处理。RuntimeException也可以选择带参数为String message的。</li>
</ul>
<h4 id="②应用"><a href="#②应用" class="headerlink" title="②应用"></a>②应用</h4><p>​	A.当方法需要返回某个类型的值或对象，但又需要通过报错来提醒用户时，可以使用throw。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(a &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> a++;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;a不能小于0&quot;</span>);</span><br><span class="line">        <span class="comment">//可以代替return......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	B.根据需要手动抛出异常来提醒用户</p>
<p>​	快速生成try-catch-finaly的方法：选中可能出现异常的代码 –&gt; 右击 –&gt; surround with –&gt; try &#x2F; catch 块</p>
<h3 id="I-用户自定义异常类"><a href="#I-用户自定义异常类" class="headerlink" title="I.用户自定义异常类"></a>I.用户自定义异常类</h3><h4 id="①如何自定义异常类"><a href="#①如何自定义异常类" class="headerlink" title="①如何自定义异常类"></a>①如何自定义异常类</h4><ul>
<li><p>继承于现有的异常结构：RuntimeException、 Exception</p>
</li>
<li><p>提供全局常量：serialVersionUID （随便赋一个值即可，其用于唯一标识该类）</p>
</li>
<li><p>提供重载的构造器，如：（一般会加上如下的构造器）</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">super</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">	<span class="built_in">super</span>(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="②补充"><a href="#②补充" class="headerlink" title="②补充"></a>②补充</h4><ul>
<li>如果继承的是Exception，当抛出该自定义异常类时，需要对此进行异常处理，否则报错。</li>
<li>如果继承的是RuntimeException，当抛出该自定义异常类时，可以不对此进行异常处理</li>
</ul>
<h2 id="14、项目三中收获的知识"><a href="#14、项目三中收获的知识" class="headerlink" title="14、项目三中收获的知识"></a>14、项目三中收获的知识</h2><ol>
<li><p>枚举</p>
<p> 一个类只能有有限个对象，且这些对象都是确定的。</p>
</li>
<li><p>构造器：一般提供一个带参的构造器和一个空参的构造器</p>
</li>
<li><p>如果方法有返回值，且方法里有switch-case，而又需要在switch-case里“return 值”，此时可以将switch-case里的break删掉（不然报错）<img src="/orange-zzcs/imgs/image-20230426204859359.png" alt="image-20230426204859359"></p>
</li>
<li><p><img src="/orange-zzcs/imgs/image-20230426204914439.png" alt="image-20230426204914439"></p>
<p> “BUSY.equals()”这样写可以减少空指针异常的情况，因为BUSY是确实的。</p>
<p> equalsIgnoreCase该方法可以忽略大小写来比较是否相等</p>
</li>
<li><pre><code class="java"> int i = 0,j = 1;
</code></pre>
</li>
<li><p>MVC，M：放一些基础的类；V：放与用户交互的页面操作；C：放一些逻辑处理</p>
</li>
<li><p><img src="/orange-zzcs/imgs/image-20230426204946788.png" alt="image-20230426204946788"></p>
<p> 有时候，调用别的方法其返回的数组值为NULL，为了避免空指针异常，所以加个判断</p>
</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://orangezzc.github.io/">OrangeZzc</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://orangezzcs.gitee.io/orange-zzcs/2023/04/24/Java%E8%AF%AD%E6%B3%95%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/">https://orangezzcs.gitee.io/orange-zzcs/2023/04/24/Java%E8%AF%AD%E6%B3%95%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://orangezzcs.gitee.io/orange-zzcs" target="_blank">Orange's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/orange-zzcs/tags/Java/">Java</a></div><div class="post_share"><div class="social-share" data-image="/orange-zzcs/./imgs/javayufafenmian.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/orange-zzcs/2023/04/24/Maven%EF%BC%88%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86%EF%BC%89/" title="Maven(基础部分)"><img class="cover" src="/orange-zzcs/./imgs/mavenfenmian.jpg" onerror="onerror=null;src='/orange-zzcs/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Maven(基础部分)</div></div></a></div><div class="next-post pull-right"><a href="/orange-zzcs/2023/04/24/IDEA%E7%9A%84%E4%BD%BF%E7%94%A8/" title="IDEA"><img class="cover" src="/orange-zzcs/./imgs/ideadefenmian.jpg" onerror="onerror=null;src='/orange-zzcs/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">IDEA</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/orange-zzcs/2023/04/26/Java%E8%AF%AD%E6%B3%95%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/" title="Java语法（高级）"><img class="cover" src="/orange-zzcs/./imgs/javayufafenmian.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-26</div><div class="title">Java语法（高级）</div></div></a></div><div><a href="/orange-zzcs/2023/04/24/java%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0/" title="Java语法基础概述"><img class="cover" src="/orange-zzcs/./imgs/javayufafenmian.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-24</div><div class="title">Java语法基础概述</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/orange-zzcs/img/avater.jpeg" onerror="this.onerror=null;this.src='/orange-zzcs/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">OrangeZzc</div><div class="author-info__description">欢迎来到我的博客!</div></div><div class="card-info-data site-data is-center"><a href="/orange-zzcs/archives/"><div class="headline">文章</div><div class="length-num">26</div></a><a href="/orange-zzcs/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/orange-zzcs/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/OrangeZzc" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:3486484066@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #24292e;"></i></a><a class="social-icon" href="http://wpa.qq.com/msgrd?v=3&amp;uin=3486484066&amp;site=qq&amp;menu=yes" target="_blank" title="QQ"><i class="fab fa-qq"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">如果在阅读过程中遇到了问题，可以随时联系我，看到了会在第一时间给出回复（不负责DEBUG，除非我真的写的有问题）</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E5%85%B3%E9%94%AE%E5%AD%97%E3%80%81%E4%BF%9D%E7%95%99%E5%AD%97%E3%80%81%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="toc-text">1、关键字、保留字、标识符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#A-%E4%BF%9D%E7%95%99%E5%AD%97"><span class="toc-text">A.保留字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="toc-text">B.标识符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81Java%E4%B8%AD%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83"><span class="toc-text">2、Java中的命名规范</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F"><span class="toc-text">3、定义变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A0%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">①基本数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#A-%E6%95%B4%E5%9E%8B"><span class="toc-text">A.整型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-%E6%B5%AE%E7%82%B9%E5%9E%8B"><span class="toc-text">B.浮点型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E5%AD%97%E7%AC%A6%E5%9E%8B"><span class="toc-text">C.字符型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#D-%E5%B8%83%E5%81%B6%E5%9E%8B"><span class="toc-text">D.布偶型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A1%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BF%90%E7%AE%97"><span class="toc-text">②基本数据类型之间的运算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#A-%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">A.自动类型转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">B.强制类型转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E6%B3%A8%E6%84%8F"><span class="toc-text">C.注意</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A2%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">③引用数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#A-String-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">A. 	String(字符串)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A3%E8%BF%9B%E5%88%B6%E4%B8%8E%E8%BF%9B%E5%88%B6%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-text">④进制与进制间的转换（了解）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#A-%E8%BF%9B%E5%88%B6"><span class="toc-text">A.进制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%8E%E5%8D%81%E8%BF%9B%E5%88%B6%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-text">B.二进制与十进制（了解）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E5%85%B6%E4%BB%96%E8%BF%9B%E5%88%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-text">C.其他进制之间的转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#D-%E6%80%BB%E7%BB%93"><span class="toc-text">D.总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">4、运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#A-%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">A.算术运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%99%A4%E8%BF%90%E7%AE%97%EF%BC%88-x2F-%EF%BC%89"><span class="toc-text">1.除运算（  &#x2F;  ）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%8F%96%E4%BD%99%E8%BF%90%E7%AE%97%EF%BC%88-%EF%BC%89"><span class="toc-text">2.取余运算（%）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%87%AA%E5%A2%9E%E3%80%81%E8%87%AA%E5%87%8F%E8%BF%90%E7%AE%97"><span class="toc-text">3.自增、自减运算</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">B.赋值运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%BF%9E%E7%BB%AD%E8%B5%8B%E5%80%BC"><span class="toc-text">1.连续赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-x3D-%E3%80%81-x3D-%E3%80%81-x3D-%E3%80%81-x3D-%E3%80%81-x2F-x3D"><span class="toc-text">2.+&#x3D;、-&#x3D;、*&#x3D;、%&#x3D;、&#x2F;&#x3D;</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">C.比较运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#D-%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">D.逻辑运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-amp-%E4%B8%8E-amp-amp"><span class="toc-text">1.&amp; 与 &amp;&amp;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%B8%8E"><span class="toc-text">2.  |  与   ||</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97%EF%BC%88-%EF%BC%89"><span class="toc-text">3.异或运算（^）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#E-%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-text">E.位运算符（了解）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#F-%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">F.三元运算符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-text">5、流程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#A-%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84"><span class="toc-text">A.分支结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0if%E2%80%A6-else"><span class="toc-text">①if….else</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1switch-case"><span class="toc-text">②switch-case</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84"><span class="toc-text">B.循环结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0for"><span class="toc-text">①for</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1while"><span class="toc-text">②while</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2do%E2%80%A6-while"><span class="toc-text">③do….while</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E7%BB%83%E4%B9%A0"><span class="toc-text">C.练习</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A5%E5%85%85%E8%AF%B4%E6%98%8E%EF%BC%9A"><span class="toc-text">补充说明：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF%EF%BC%9A"><span class="toc-text">嵌套循环：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#D-break%E3%80%81continue"><span class="toc-text">D.break、continue</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81Scanner-%E8%8E%B7%E5%8F%96%E8%BE%93%E5%85%A5"><span class="toc-text">6、Scanner(获取输入)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#A-%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4"><span class="toc-text">A.实现步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-%E6%B3%A8%E6%84%8F"><span class="toc-text">B.注意</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%95%B0"><span class="toc-text">7、生成随机数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%AC%E5%BC%8F"><span class="toc-text">公式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81%E6%95%B0%E7%BB%84"><span class="toc-text">8、数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A0%E6%95%B0%E7%BB%84%E7%9A%84%E6%A6%82%E8%BF%B0"><span class="toc-text">①数组的概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#A-%E6%95%B0%E7%BB%84%E7%9B%B8%E5%85%B3%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">A.数组相关的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-%E6%95%B0%E7%BB%84%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-text">B.数组的特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">C.数组的分类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A1%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-text">②一维数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#A-%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E5%A3%B0%E6%98%8E%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">A.一维数组声明和初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">B.数组元素的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E8%8E%B7%E5%8F%96%E6%95%B0%E7%BB%84%E7%9A%84%E9%95%BF%E5%BA%A6"><span class="toc-text">C.获取数组的长度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#D-%E9%81%8D%E5%8E%86%E6%95%B0%E7%BB%84"><span class="toc-text">D.遍历数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#E-%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9A%84%E9%BB%98%E8%AE%A4%E5%88%9D%E5%A7%8B%E5%8C%96%E5%80%BC"><span class="toc-text">E.数组元素的默认初始化值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#F-%E6%95%B0%E7%BB%84%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90"><span class="toc-text">F.数组的内存分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A2%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-text">③二维数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#A-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E5%A3%B0%E6%98%8E%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">A.二维数组声明和初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9A%84%E4%BD%BF%E7%94%A8-1"><span class="toc-text">B.数组元素的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E8%8E%B7%E5%8F%96%E6%95%B0%E7%BB%84%E7%9A%84%E9%95%BF%E5%BA%A6-1"><span class="toc-text">C.获取数组的长度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#D-%E9%81%8D%E5%8E%86%E6%95%B0%E7%BB%84-1"><span class="toc-text">D.遍历数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#E-%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9A%84%E9%BB%98%E8%AE%A4%E5%88%9D%E5%A7%8B%E5%8C%96%E5%80%BC-1"><span class="toc-text">E.数组元素的默认初始化值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#F-%E6%95%B0%E7%BB%84%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90-1"><span class="toc-text">F.数组的内存分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A5%E5%85%85"><span class="toc-text">补充</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A3%E6%95%B0%E7%BB%84%E7%BB%83%E4%B9%A0"><span class="toc-text">④数组练习</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0%E4%B8%80"><span class="toc-text">练习一</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A4%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B6%89%E5%8F%8A%E7%9A%84%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95"><span class="toc-text">⑤数组中涉及的常见算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#A-%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9A%84%E8%B5%8B%E5%80%BC%EF%BC%88%E4%BC%9A%E5%9C%A8%E9%9D%A2%E8%AF%95%E4%B8%AD%E4%BB%A5%E6%89%8B%E5%86%99%E7%9A%84%E5%BD%A2%E5%BC%8F%E8%80%83%E5%AF%9F%EF%BC%89"><span class="toc-text">A.数组元素的赋值（会在面试中以手写的形式考察）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-%E6%B1%82%E6%95%B0%E5%80%BC%E5%9E%8B%E6%95%B0%E7%BB%84%E4%B8%AD%E5%85%83%E7%B4%A0%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%E3%80%81%E6%9C%80%E5%B0%8F%E5%80%BC%E3%80%81%E5%B9%B3%E5%9D%87%E6%95%B0%E3%80%81%E6%80%BB%E5%92%8C%E7%AD%89"><span class="toc-text">B.求数值型数组中元素的最大值、最小值、平均数、总和等</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E6%95%B0%E7%BB%84%E7%9A%84%E5%A4%8D%E5%88%B6%E3%80%81%E5%8F%8D%E8%BD%AC%E3%80%81%E6%9F%A5%E6%89%BE%EF%BC%88%E7%BA%BF%E6%80%A7%E6%9F%A5%E6%89%BE%E3%80%81%E4%BA%8C%E5%88%86%E6%B3%95%E6%9F%A5%E6%89%BE%EF%BC%88%E4%BC%9A%E5%9C%A8%E9%9D%A2%E8%AF%95%E4%B8%AD%E8%80%83%E5%AF%9F%EF%BC%89%EF%BC%89"><span class="toc-text">C.数组的复制、反转、查找（线性查找、二分法查找（会在面试中考察））</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#D-%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E4%BC%9A%E5%9C%A8%E9%9D%A2%E8%AF%95%E4%B8%AD%E8%80%83%E5%AF%9F%EF%BC%89"><span class="toc-text">D.数组元素的排序算法（会在面试中考察）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#E-%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%BD%91%E5%9D%80"><span class="toc-text">E.算法学习网址</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A5%E6%95%B0%E7%BB%84%E5%B7%A5%E5%85%B7%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">⑥数组工具类的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#A-%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E6%98%AF%E5%90%A6%E7%9B%B8%E7%AD%89"><span class="toc-text">A.判断两个数组是否相等</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-%E8%BE%93%E5%87%BA%E6%95%B0%E7%BB%84%E4%BF%A1%E6%81%AF"><span class="toc-text">B.输出数组信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E5%B0%86%E6%95%B0%E7%BB%84%E9%87%8C%E7%9A%84%E5%80%BC%E5%85%A8%E6%9B%BF%E6%8D%A2%E6%88%90%E6%9F%90%E4%B8%AA%E6%95%B0"><span class="toc-text">C.将数组里的值全替换成某个数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#D-%E5%AF%B9%E6%95%B0%E7%BB%84%E8%BF%9B%E8%A1%8C%E5%8D%87%E5%BA%8F%E6%8E%92%E5%BA%8F"><span class="toc-text">D.对数组进行升序排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#E-%E4%BA%8C%E5%88%86%E6%B3%95%E6%9F%A5%E6%89%BE%E6%8C%87%E5%AE%9A%E7%9A%84%E5%80%BC"><span class="toc-text">E.二分法查找指定的值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A6%E6%95%B0%E7%BB%84%E4%BD%BF%E7%94%A8%E4%B8%AD%E7%9A%84%E5%B8%B8%E8%A7%81%E5%BC%82%E5%B8%B8"><span class="toc-text">⑦数组使用中的常见异常</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#A-%E6%95%B0%E7%BB%84%E8%A7%92%E6%A0%87%E8%B6%8A%E7%95%8C%E7%9A%84%E5%BC%82%E5%B8%B8"><span class="toc-text">A.数组角标越界的异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-%E7%A9%BA%E6%8C%87%E9%92%88%E5%BC%82%E5%B8%B8"><span class="toc-text">B.空指针异常</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A7%E8%A1%A5%E5%85%85"><span class="toc-text">⑧补充</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-text">9、面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A0%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%A7%A3%E9%87%8A"><span class="toc-text">①面向过程与面向对象的解释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A1%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1"><span class="toc-text">②类与对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#A-%E5%BC%95%E8%A8%80"><span class="toc-text">A.引言</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">B.类与对象的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E8%A7%A3%E6%9E%90"><span class="toc-text">C.对象的内存解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#D-%E5%B1%9E%E6%80%A7%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-text">D.属性与局部变量的对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#E-%E7%B1%BB%E4%B8%AD%E6%96%B9%E6%B3%95%E7%9A%84%E5%A3%B0%E6%98%8E%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="toc-text">E.类中方法的声明和使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#F-%E7%BB%83%E4%B9%A0"><span class="toc-text">F.练习</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A2%E7%90%86%E8%A7%A3%E2%80%9D%E4%B8%87%E4%BA%8B%E4%B8%87%E7%89%A9%E7%9A%86%E5%AF%B9%E8%B1%A1%E2%80%9C"><span class="toc-text">③理解”万事万物皆对象“</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A3%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">④匿名对象的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A4%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="toc-text">⑤方法的重载</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#A-%E5%AE%9A%E4%B9%89"><span class="toc-text">A.定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%98%AF%E9%87%8D%E8%BD%BD"><span class="toc-text">B.判断是否是重载</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A5%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E4%B8%AA%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">⑥可变参数个数的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#A-%E6%A0%BC%E5%BC%8F"><span class="toc-text">A.格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-%E4%BD%BF%E7%94%A8"><span class="toc-text">B.使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E8%AF%B4%E6%98%8E"><span class="toc-text">C.说明</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A6%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E7%9A%84%E5%80%BC%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6"><span class="toc-text">⑦方法参数的值传递机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#A-%E5%BD%A2%E5%8F%82%E4%B8%8E%E5%AE%9E%E5%8F%82"><span class="toc-text">A.形参与实参</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-%E5%80%BC%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6"><span class="toc-text">B.值传递机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E7%BB%83%E4%B9%A0-1"><span class="toc-text">C.练习</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A7%E9%80%92%E5%BD%92%E6%96%B9%E6%B3%95"><span class="toc-text">⑧递归方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A8%E6%9E%84%E9%80%A0%E5%99%A8-%E6%88%96%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-text">⑨构造器(或构造方法)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#A-%E6%9E%84%E9%80%A0%E5%99%A8%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">A.构造器的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-%E8%AF%B4%E6%98%8E"><span class="toc-text">B.说明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E6%B3%A8%E6%84%8F-1"><span class="toc-text">C.注意</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A9%E5%B1%9E%E6%80%A7%E8%B5%8B%E5%80%BC%E7%9A%84%E5%85%88%E5%90%8E%E9%A1%BA%E5%BA%8F"><span class="toc-text">⑩属性赋值的先后顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E3%80%81JavaBean"><span class="toc-text">(11)、JavaBean</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#A-%E5%AE%9A%E4%B9%89-1"><span class="toc-text">A.定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-%E7%BB%84%E6%88%90"><span class="toc-text">B.组成</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E3%80%81%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">(12)、关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#A-this%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">A.this关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-package%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">B.package关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-import%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">C.import关键字</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0"><span class="toc-text">(13)、面向对象综合练习</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%BC%E5%90%88%E7%BB%83%E4%B9%A0%E4%B8%80%E7%9A%84%E6%80%BB%E7%BB%93"><span class="toc-text">综合练习一的总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E3%80%81%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E4%B9%8B%E5%9B%9B%EF%BC%9A%E4%BB%A3%E7%A0%81%E5%9D%97-%E6%88%96%E5%88%9D%E5%A7%8B%E5%8C%96%E5%9D%97"><span class="toc-text">(14)、类的成员之四：代码块(或初始化块)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#A-%E5%BC%95%E5%85%A5"><span class="toc-text">A.引入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-text">B.静态代码块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E9%9D%9E%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-text">C.非静态代码块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#D-%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%E3%80%81%E9%9D%9E%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%E5%8F%8A%E6%9E%84%E9%80%A0%E5%99%A8%E4%B8%89%E8%80%85%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-text">D.静态代码块、非静态代码块及构造器三者的执行顺序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E4%B9%8B%E4%BA%94%EF%BC%9A%E5%86%85%E9%83%A8%E7%B1%BB-%E4%BA%86%E8%A7%A3"><span class="toc-text">(15)类的成员之五：内部类(了解)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#A-%E5%BC%95%E5%85%A5-1"><span class="toc-text">A.引入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">B.成员内部类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E5%BC%80%E5%8F%91%E4%B8%AD%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">C.开发中局部内部类的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#D-%E5%A6%82%E4%BD%95%E5%AE%9E%E4%BE%8B%E5%8C%96%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E5%AF%B9"><span class="toc-text">D.如何实例化成员内部类的对</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#E-%E5%A6%82%E4%BD%95%E5%9C%A8%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB%E4%B8%AD%E5%8C%BA%E5%88%86%E8%B0%83%E7%94%A8%E5%A4%96%E9%83%A8%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84%EF%BC%88%E6%B2%A1%E9%87%8D%E5%90%8D%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E8%B0%83%E7%94%A8%E8%BF%99%E4%BA%9B%E7%BB%93%E6%9E%84%E3%80%82%E5%A6%82%E6%9E%9C%E9%87%8D%E5%90%8D%E8%A7%81%E4%B8%8B%E9%9D%A2%E4%BB%A3%E7%A0%81%EF%BC%89"><span class="toc-text">E.如何在成员内部类中区分调用外部类的结构（没重名可以直接调用这些结构。如果重名见下面代码）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="toc-text">10、面向对象三大特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A0%E5%B0%81%E8%A3%85%E4%B8%8E%E9%9A%90%E8%97%8F"><span class="toc-text">①封装与隐藏</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#A-%E9%97%AE%E9%A2%98%E7%9A%84%E5%BC%95%E5%85%A5"><span class="toc-text">A.问题的引入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-%E5%B0%81%E8%A3%85%E6%80%A7%E7%9A%84%E4%BD%93%E7%8E%B0"><span class="toc-text">B.封装性的体现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E5%9B%9B%E7%A7%8D%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-text">C.四种权限修饰符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#D-%E5%9B%9B%E7%A7%8D%E6%9D%83%E9%99%90%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">D.四种权限的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#E-%E6%80%BB%E7%BB%93%E5%B0%81%E8%A3%85%E6%80%A7"><span class="toc-text">E.总结封装性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#F-%E8%A1%A5%E5%85%85"><span class="toc-text">F.补充</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A1%E7%BB%A7%E6%89%BF%E6%80%A7"><span class="toc-text">②继承性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#A-%E9%97%AE%E9%A2%98%E7%9A%84%E5%BC%95%E5%85%A5-1"><span class="toc-text">A.问题的引入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-%E7%BB%A7%E6%89%BF%E6%80%A7%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-text">B.继承性的好处</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E7%BB%A7%E6%89%BF%E6%80%A7%E7%9A%84%E6%A0%BC%E5%BC%8F"><span class="toc-text">C.继承性的格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#D-%E8%AF%B4%E6%98%8E"><span class="toc-text">D.说明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#E-%E7%BB%A7%E6%89%BF%E6%80%A7%E7%9A%84%E8%A7%84%E5%88%99"><span class="toc-text">E.继承性的规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#F-%E7%BB%A7%E6%89%BF%E7%BB%83%E4%B9%A0"><span class="toc-text">F.继承练习</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#G-%E9%87%8D%E5%86%99"><span class="toc-text">G.重写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#H-Super%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">H.Super关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#I-%E5%AD%90%E7%B1%BB%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B"><span class="toc-text">I.子类对象实例化的全过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#J-Object%E7%B1%BB"><span class="toc-text">J.Object类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#K-%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84this%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">K.继承中的this关键字</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A2%E5%A4%9A%E6%80%81%E6%80%A7-%E5%B1%9E%E4%BA%8E%E8%BF%90%E8%A1%8C%E6%97%B6%E8%A1%8C%E4%B8%BA%EF%BC%89"><span class="toc-text">③多态性(属于运行时行为）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#A-%E4%BD%95%E4%B8%BA%E5%A4%9A%E6%80%81%E6%80%A7"><span class="toc-text">A.何为多态性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-%E5%A4%9A%E6%80%81%E6%80%A7%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">B.多态性的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-%E5%A4%9A%E6%80%81%E6%80%A7%E7%9A%84%E4%BD%BF%E7%94%A8%E5%89%8D%E6%8F%90"><span class="toc-text">C.多态性的使用前提</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#D-%E5%A4%9A%E6%80%81%E6%80%A7%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-text">D.多态性的好处</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#E-%E6%B3%A8%E6%84%8F"><span class="toc-text">E.注意</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#F-%E5%A4%9A%E6%80%81%E7%9A%84%E5%86%85%E5%AD%98%E8%A7%A3%E6%9E%90"><span class="toc-text">F.多态的内存解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#G-instanceof-%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-text">G.instanceof 操作符</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11%E3%80%81%E5%8C%85%E8%A3%85%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">11、包装类的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#A-JUnit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-text">A.JUnit单元测试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-text">①什么是单元测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="toc-text">②单元测试的步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2%E8%AF%B4%E6%98%8E"><span class="toc-text">③说明</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-text">B.包装类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E5%BC%95%E5%85%A5"><span class="toc-text">①引入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%AF%B9%E5%BA%94%E7%9A%84%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-text">②基本数据类型对应的包装类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E5%8C%85%E8%A3%85%E7%B1%BB%E3%80%81String%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2"><span class="toc-text">③基本数据类型、包装类、String三者之间的相互转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A3%E7%BB%83%E4%B9%A0"><span class="toc-text">④练习</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%AD%E7%9A%84%E5%85%B6%E4%BB%96%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">12、面向对象中的其他关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#A-static"><span class="toc-text">A.static</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E5%BC%95%E5%85%A5-1"><span class="toc-text">①引入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E4%BD%BF%E7%94%A8static%E4%BF%AE%E9%A5%B0%E5%B1%9E%E6%80%A7%EF%BC%9A%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%EF%BC%88%E5%8F%88%E7%A7%B0%E7%B1%BB%E5%8F%98%E9%87%8F%EF%BC%89"><span class="toc-text">②使用static修饰属性：静态变量（又称类变量）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2%E4%BD%BF%E7%94%A8static%E4%BF%AE%E9%A5%B0%E6%96%B9%E6%B3%95%EF%BC%9A%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-text">③使用static修饰方法：静态方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A3static%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="toc-text">④static注意点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A4%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E6%98%AF%E5%90%A6%E4%BD%BF%E7%94%A8-static"><span class="toc-text">⑤如何确定是否使用 static</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-Static%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%BA%94%E7%94%A8%E2%80%93%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-text">B.  Static关键字的应用–单例设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E5%AE%9A%E4%B9%89"><span class="toc-text">①定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E5%AE%9E%E7%8E%B0-%E9%A5%BF%E6%B1%89%E5%BC%8F-amp-%E6%87%92%E6%B1%89%E5%BC%8F"><span class="toc-text">②实现(饿汉式&amp;懒汉式)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2%E9%A5%BF%E6%B1%89%E5%BC%8F%E4%B8%8E%E6%87%92%E6%B1%89%E5%BC%8F%E6%AF%94%E8%BE%83"><span class="toc-text">③饿汉式与懒汉式比较</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A3%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-%E4%BA%86%E8%A7%A3"><span class="toc-text">④单例模式应用场景(了解)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-mian-%E6%96%B9%E6%B3%95%E7%9A%84%E8%AF%AD%E6%B3%95-%E4%BA%86%E8%A7%A3"><span class="toc-text">C.mian()方法的语法(了解)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#D-final"><span class="toc-text">D.final</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E5%BC%95%E5%85%A5-2"><span class="toc-text">①引入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1final-%E7%94%A8%E6%9D%A5%E4%BF%AE%E9%A5%B0%E4%B8%80%E4%B8%AA%E7%B1%BB%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-text">②final 用来修饰一个类（了解）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2final-%E7%94%A8%E6%9D%A5%E4%BF%AE%E9%A5%B0%E6%96%B9%E6%B3%95%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-text">③final 用来修饰方法（了解）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A3final-%E7%94%A8%E6%9D%A5%E4%BF%AE%E9%A5%B0%E5%8F%98%E9%87%8F"><span class="toc-text">④final 用来修饰变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A4static-final"><span class="toc-text">⑤static final</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#E-abstract"><span class="toc-text">E.abstract</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0-%E5%BC%95%E5%85%A5"><span class="toc-text">①.引入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1-%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-text">②.抽象类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2-%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="toc-text">③.抽象方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A3-%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">④.抽象方法的应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A4-abstract%E4%BD%BF%E7%94%A8%E4%B8%8A%E7%9A%84%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="toc-text">⑤.abstract使用上的注意点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A5-%E5%8C%BF%E5%90%8D%E7%B1%BB%EF%BC%88%E7%9C%8B%E5%BE%97%E6%87%82%E5%B0%B1%E8%A1%8C%EF%BC%89"><span class="toc-text">⑥.匿名类（看得懂就行）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A6-%E5%BA%94%E7%94%A8%E2%80%93%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-text">⑦.应用–模板方法设计模式（了解）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#G-interface-%E6%8E%A5%E5%8F%A3"><span class="toc-text">G.interface(接口)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E5%BC%95%E5%85%A5-3"><span class="toc-text">①引入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%A0%BC%E5%BC%8F"><span class="toc-text">②接口的格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2-%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89"><span class="toc-text">③.接口定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A3%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">④接口的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A4%E5%85%B6%E4%BB%96"><span class="toc-text">⑤其他</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A5%E5%8C%BF%E5%90%8D%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-text">⑥匿名实现类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A6%E5%BA%94%E7%94%A8%E2%80%93%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F-amp-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-text">⑦应用–代理模式&amp;工厂模式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13%E3%80%81%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-text">13、异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#A-%E5%AE%9A%E4%B9%89-2"><span class="toc-text">A.定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-%E5%88%86%E7%B1%BB"><span class="toc-text">B.分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0Error"><span class="toc-text">①Error</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1Exception"><span class="toc-text">②Exception</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2%E5%BC%82%E5%B8%B8%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%9B%BE"><span class="toc-text">③异常的体系结构图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A3%E5%B8%B8%E8%A7%81%E7%9A%84%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8"><span class="toc-text">④常见的运行时异常</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-text">C.异常处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#D-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%E4%B8%80%EF%BC%9Atry-catch-finally"><span class="toc-text">D.异常处理机制一：try-catch-finally</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E6%A0%BC%E5%BC%8F"><span class="toc-text">①格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E8%AF%B4%E6%98%8E%E4%B8%80"><span class="toc-text">②说明一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2%E8%AF%B4%E6%98%8E%E4%BA%8C"><span class="toc-text">③说明二</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A3%E4%BD%93%E4%BC%9A"><span class="toc-text">④体会</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#E-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%E4%BA%8C%EF%BC%9Athrows-%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%9E%8B"><span class="toc-text">E.异常处理机制二：throws+异常类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E4%BD%93%E4%BC%9A"><span class="toc-text">①体会</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#F-%E5%BC%80%E5%8F%91%E4%B8%AD%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-text">F.开发中如何选择异常处理的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#G-%E8%A1%A5%E5%85%85"><span class="toc-text">G.补充</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#H-%E6%89%8B%E5%8A%A8%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8"><span class="toc-text">H.手动抛出异常</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E6%A0%BC%E5%BC%8F%EF%BC%9Athrow-new-%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%9E%8B%EF%BC%88%EF%BC%89"><span class="toc-text">①格式：throw new 异常类型（）;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E5%BA%94%E7%94%A8"><span class="toc-text">②应用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I-%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E7%B1%BB"><span class="toc-text">I.用户自定义异常类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E7%B1%BB"><span class="toc-text">①如何自定义异常类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E8%A1%A5%E5%85%85"><span class="toc-text">②补充</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14%E3%80%81%E9%A1%B9%E7%9B%AE%E4%B8%89%E4%B8%AD%E6%94%B6%E8%8E%B7%E7%9A%84%E7%9F%A5%E8%AF%86"><span class="toc-text">14、项目三中收获的知识</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/orange-zzcs/2023/04/26/Java%E8%AF%AD%E6%B3%95%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/" title="Java语法（高级）"><img src="/orange-zzcs/./imgs/javayufafenmian.jpg" onerror="this.onerror=null;this.src='/orange-zzcs/img/404.jpg'" alt="Java语法（高级）"/></a><div class="content"><a class="title" href="/orange-zzcs/2023/04/26/Java%E8%AF%AD%E6%B3%95%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/" title="Java语法（高级）">Java语法（高级）</a><time datetime="2023-04-26T10:51:27.000Z" title="发表于 2023-04-26 18:51:27">2023-04-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/orange-zzcs/2023/04/24/%E5%BF%AB%E6%8D%B7%E9%94%AE/" title="快捷键"><img src="/orange-zzcs/./imgs/kuaijiejianfenmian.jpg" onerror="this.onerror=null;this.src='/orange-zzcs/img/404.jpg'" alt="快捷键"/></a><div class="content"><a class="title" href="/orange-zzcs/2023/04/24/%E5%BF%AB%E6%8D%B7%E9%94%AE/" title="快捷键">快捷键</a><time datetime="2023-04-24T13:16:22.000Z" title="发表于 2023-04-24 21:16:22">2023-04-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/orange-zzcs/2023/04/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9F%A5%E8%AF%86/" title="计算机知识"><img src="/orange-zzcs/./imgs/jishuanjizhishifenmian.jpg" onerror="this.onerror=null;this.src='/orange-zzcs/img/404.jpg'" alt="计算机知识"/></a><div class="content"><a class="title" href="/orange-zzcs/2023/04/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9F%A5%E8%AF%86/" title="计算机知识">计算机知识</a><time datetime="2023-04-24T13:11:01.000Z" title="发表于 2023-04-24 21:11:01">2023-04-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/orange-zzcs/2023/04/24/java%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0/" title="Java语法基础概述"><img src="/orange-zzcs/./imgs/javayufafenmian.jpg" onerror="this.onerror=null;this.src='/orange-zzcs/img/404.jpg'" alt="Java语法基础概述"/></a><div class="content"><a class="title" href="/orange-zzcs/2023/04/24/java%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0/" title="Java语法基础概述">Java语法基础概述</a><time datetime="2023-04-24T10:27:36.000Z" title="发表于 2023-04-24 18:27:36">2023-04-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/orange-zzcs/2023/04/24/git/" title="Git"><img src="/orange-zzcs/./imgs/gitfenmian.jpg" onerror="this.onerror=null;this.src='/orange-zzcs/img/404.jpg'" alt="Git"/></a><div class="content"><a class="title" href="/orange-zzcs/2023/04/24/git/" title="Git">Git</a><time datetime="2023-04-24T08:32:11.000Z" title="发表于 2023-04-24 16:32:11">2023-04-24</time></div></div></div></div></div></div></main><footer id="footer" style="background: rgba(255,255,255, .0)"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By OrangeZzc</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><b>We can't change our fate,but we can do our best!</b></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/orange-zzcs/js/utils.js"></script><script src="/orange-zzcs/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"></div><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/orange-zzcs/js/search/local-search.js"></script></div></div></body></html>