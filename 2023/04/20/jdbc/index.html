<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>JDBC | Orange's Blog</title><meta name="author" content="OrangeZzc"><meta name="copyright" content="OrangeZzc"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="JDBC是操作关系型数据库的一套API">
<meta property="og:type" content="article">
<meta property="og:title" content="JDBC">
<meta property="og:url" content="https://orangezzc.github.io/2023/04/20/jdbc/index.html">
<meta property="og:site_name" content="Orange&#39;s Blog">
<meta property="og:description" content="JDBC是操作关系型数据库的一套API">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://orangezzc.github.io/imgs/jdbc.jpeg">
<meta property="article:published_time" content="2023-04-20T07:05:16.000Z">
<meta property="article:modified_time" content="2023-04-24T10:18:06.554Z">
<meta property="article:author" content="OrangeZzc">
<meta property="article:tag" content="JDBC">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://orangezzc.github.io/imgs/jdbc.jpeg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://orangezzc.github.io/2023/04/20/jdbc/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":30},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: OrangeZzc","link":"链接: ","source":"来源: Orange's Blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JDBC',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-24 18:18:06'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avater.jpeg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">25</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 学无止境</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: transparent"><nav id="nav"><span id="blog-info"><a href="/" title="Orange's Blog"><span class="site-name">Orange's Blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 学无止境</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">JDBC</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-04-20T07:05:16.000Z" title="发表于 2023-04-20 15:05:16">2023-04-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-04-24T10:18:06.554Z" title="更新于 2023-04-24 18:18:06">2023-04-24</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/java%E5%9F%BA%E7%A1%80/">java基础</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">21.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>74分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="JDBC"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="一、JDBC简介"><a href="#一、JDBC简介" class="headerlink" title="一、JDBC简介"></a>一、JDBC简介</h3><h4 id="①JDBC概念"><a href="#①JDBC概念" class="headerlink" title="①JDBC概念"></a>①JDBC概念</h4><ul>
<li>JDBC就是使用Java语言操作关系型数据库的一套API。</li>
</ul>
<h4 id="②JDBC本质"><a href="#②JDBC本质" class="headerlink" title="②JDBC本质"></a>②JDBC本质</h4><ul>
<li>SUN公司定义的一套操作所有关系型数据库的规则，即接口。</li>
<li>各个数据库厂商去实现这套接口，提供数据库驱动jar包。</li>
<li>我们可以使用这套(JDBC)编程，真正执行的代码是驱动jar包中的实现类。</li>
</ul>
<h4 id="③JDBC好处"><a href="#③JDBC好处" class="headerlink" title="③JDBC好处"></a>③JDBC好处</h4><ul>
<li>各数据库厂商使用相同的接口，Java代码不需要针对不同数据库分别开发。</li>
<li>可随时替换底层数据库，访问数据库的Java代码基本不变。</li>
</ul>
<h4 id="④补充"><a href="#④补充" class="headerlink" title="④补充"></a>④补充</h4><p>​	当我们需要使用不同的数据库时，我们只需要导入不同的数据库驱动jar包即可。</p>
<img src="/imgs/image-20230423202509764.png" alt="image-20230423202509764" style="zoom: 67%;" />



<hr>
<h3 id="二、JDBC快速入门"><a href="#二、JDBC快速入门" class="headerlink" title="二、JDBC快速入门"></a>二、JDBC快速入门</h3><p>​	通过JDBC来连接数据库。</p>
<h4 id="①实现步骤"><a href="#①实现步骤" class="headerlink" title="①实现步骤"></a>①实现步骤</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0.导入驱动jar包</span></span><br><span class="line">mysql-connector-java-<span class="number">5.1</span><span class="number">.34</span>.jar</span><br><span class="line"><span class="comment">//1.注册驱动</span></span><br><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);<span class="comment">//&quot;com.mysql.jdbc.Driver&quot;是固定的</span></span><br><span class="line"><span class="comment">//2.获取连接</span></span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url,username,password);</span><br><span class="line"><span class="comment">//3.定义SQL语句</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update...&quot;</span>;</span><br><span class="line"><span class="comment">//4.获取执行SQL对象</span></span><br><span class="line"><span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> conn.createStatement();</span><br><span class="line"><span class="comment">//5.执行SQL</span></span><br><span class="line">stmt.execuleUpdate(sql);<span class="comment">//返回受影响的行数，</span></span><br><span class="line"><span class="comment">//6.处理返回结果</span></span><br><span class="line"><span class="comment">//7.释放资源 </span></span><br><span class="line">stmt.close();</span><br><span class="line">conn.close();</span><br><span class="line"><span class="comment">//如果使用到了如下类的对象，就把这些对象的资源释放掉</span></span><br><span class="line"><span class="comment">//Connection、Statement、PreparedStatement、ResultSet</span></span><br></pre></td></tr></table></figure>



<h4 id="②实现步骤的说明"><a href="#②实现步骤的说明" class="headerlink" title="②实现步骤的说明"></a>②实现步骤的说明</h4><ul>
<li>注册驱动：说明接下来使用的是哪个驱动。即说明接下来使用的是哪个数据库提供的JDBC接口实现类。</li>
<li>getConnection(url,username,password)：<ul>
<li>url：jdbc:mysql:&#x2F;&#x2F;数据库管理系统所在主机的地址(或域名)：3306&#x2F;连接的是数据库管理系统下的哪个数据库。例子：jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;db1。</li>
<li>username、password：登录数据库管理系统时的用户名和密码。</li>
</ul>
</li>
<li>执行SQL：将SQL语句发送给数据库，让数据库处理这些SQL语句。</li>
</ul>
<h4 id="③JDBC-API详解"><a href="#③JDBC-API详解" class="headerlink" title="③JDBC  API详解"></a>③JDBC  API详解</h4><h5 id="A-DriverManager"><a href="#A-DriverManager" class="headerlink" title="A.DriverManager"></a>A.DriverManager</h5><h6 id="①概述"><a href="#①概述" class="headerlink" title="①概述"></a>①概述</h6><p>​	DriverManager属于工具类，该类的两个主要功能是：注册驱动、获取数据库连接。</p>
<h6 id="②注册驱动"><a href="#②注册驱动" class="headerlink" title="②注册驱动"></a>②注册驱动</h6><ul>
<li><p>实现原理：</p>
<p>  ​		按照JDBC中的实现步骤，我们用Class.forName(“com.mysql.jdbc.Driver”)来注册驱动。该代码底层实现原理是：</p>
<p>  ​		Driver是一个类，该类中有一个静态代码块，静态代码块中调用了DriverManager类中的静态方法registerDriver()，该方法就是用来注册驱动的。</p>
<p>  ​		所以当通过反射来加载Driver类时，同时也执行了Driver类中的静态代码块，也就调用了registerDriver()来注册驱动了。</p>
</li>
<li><p>提示：</p>
<p>  ​	如果使用的是MySQL 5之后的驱动jar包，那么就可以省略注册驱动的步骤。</p>
</li>
</ul>
<h6 id="③获取连接"><a href="#③获取连接" class="headerlink" title="③获取连接"></a>③获取连接</h6><p>​	调用DriverManager类中的静态方法getConnection(String url,String user,String password)，该方法返回的是一个Connection类的对象。</p>
<p>​	<strong>细节</strong>：</p>
<ul>
<li><p>如果连接的是本机MySQL服务器(即地址为127.0.0.1)，并且MySQL服务默认端口是3306，则url可以简写为：jdbc:mysql:&#x2F;&#x2F;&#x2F;数据库名称</p>
</li>
<li><p>当我们执行该语句后，运行结果中会显示一个警告：建议以安全的方式连接数据库(SSL)，但这种连接方式会使性能降低，一般不使用。为了不出现这个警告，我们可以在url的最后面加上：?useSSL&#x3D; fasle即可。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://127.0.0.1:3306/db1?useSSL=false&quot;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="B-Connection"><a href="#B-Connection" class="headerlink" title="B.Connection"></a>B.Connection</h5><h6 id="①作用"><a href="#①作用" class="headerlink" title="①作用"></a>①作用</h6><p>​	获取执行SQL的对象、管理事务。</p>
<h6 id="②获取执行SQL对象"><a href="#②获取执行SQL对象" class="headerlink" title="②获取执行SQL对象"></a>②获取执行SQL对象</h6><ol>
<li>普通执行SQL对象</li>
</ol>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Statement <span class="title function_">createStatement</span><span class="params">()</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>预编译SQL的执行SQL对象：防止SQL注入</li>
</ol>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PreparedStatement <span class="title function_">prepareStatement</span><span class="params">(sql)</span></span><br><span class="line"><span class="comment">//关闭资源时，记得把PreparedStatement对象也关闭掉</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>执行存储过程的对象（少用，了解即可）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CallableStatement prepareCall(sql)</span><br></pre></td></tr></table></figure>



<h6 id="③事务管理"><a href="#③事务管理" class="headerlink" title="③事务管理"></a>③事务管理</h6><ul>
<li><p>概述：</p>
<p>  <img src="/imgs/image-20220921154856156.png" alt="image-20220921154856156"></p>
<p>  Conncetion中也有三个方法来管理事务，它们分别对应着MySQL中的事务管理的三个步骤。</p>
<p>  <img src="/imgs/image-20220921155103081.png" alt="image-20220921155103081"></p>
</li>
<li><p>使用：</p>
<p>  开启事务的代码写在执行SQL之前，提交事务的代码写在“处理事务返回的结果”的后面，然后将开启事务到提交事务之间的代码用try包起来，在catch里写回滚事务的代码。</p>
</li>
</ul>
<h5 id="C-Statement"><a href="#C-Statement" class="headerlink" title="C.Statement"></a>C.Statement</h5><h6 id="①作用-1"><a href="#①作用-1" class="headerlink" title="①作用"></a>①作用</h6><p>​		执行SQL语句</p>
<h6 id="②相关方法"><a href="#②相关方法" class="headerlink" title="②相关方法"></a>②相关方法</h6><ol>
<li><p>int executeUpdate(sql)</p>
<p> 该方法执行的是DML、DDL语句<br> 返回值：<br>  ①DML语句受影响的行数，我们可以根据返回的行数来判断，该SQL是否执行成功<br> ②DDL语句执行后，执行成功也可能返回0，如：创建数据库或创建表执行成功了，受影响行数也为0</p>
</li>
<li><p>ResultSet executeQuery(sql)</p>
<p> 该方法执行的是DQL语句<br> 返回值：ResultSet结果集对象</p>
</li>
</ol>
<p><code>注意</code>：关闭资源时，记得把ResultSet对象资源也得关闭。</p>
<h5 id="D-ResultSet"><a href="#D-ResultSet" class="headerlink" title="D.ResultSet"></a>D.ResultSet</h5><h6 id="①概述-1"><a href="#①概述-1" class="headerlink" title="①概述"></a>①概述</h6><p>​	ResultSet中存储了通过executeQuery(sql)查询得到的结果。(说明：这里的sql特指DQL语句)</p>
<p>​	由于DQL语句查询得到的结果为：一个数据 或 一行数据 或 一张表</p>
<p>​	所以实际上，ResultSet中存储的是一个数据 或 一行数据 或 一张表。</p>
<h6 id="②获取查询结果"><a href="#②获取查询结果" class="headerlink" title="②获取查询结果"></a>②获取查询结果</h6><ul>
<li>boolean next()<ul>
<li>作用：①将光标从当前位置向下移动一行。(光标的初始位置为：表头) ②判断当前行是否为有效行。</li>
<li>返回值：<ul>
<li>true：有效行，代表当前行有数据。</li>
<li>false：无效行，代表当前行没有数据。</li>
</ul>
</li>
</ul>
</li>
<li>xxx getXxx(参数)<ul>
<li>作用：获取数据</li>
<li>Xxx：数据类型；如：int getInt(参数)</li>
<li>参数：二选一<ul>
<li>①int：列的编号，从1开始。</li>
<li>②String：列的名称</li>
</ul>
</li>
</ul>
</li>
</ul>
<h6 id="③练习"><a href="#③练习" class="headerlink" title="③练习"></a>③练习</h6><p>​	查询account账户表数据，封装为Account对象中，并存储到ArrayList集合中。</p>
<h5 id="E-PreparedStatement"><a href="#E-PreparedStatement" class="headerlink" title="E.PreparedStatement"></a>E.PreparedStatement</h5><h6 id="①概述-2"><a href="#①概述-2" class="headerlink" title="①概述"></a>①概述</h6><p>​	PreparedStatement是一个接口，其继承Statement类。</p>
<p>​	其作用：执行SQL语句，并且能够预防SQL注入。</p>
<h6 id="②SQL注入"><a href="#②SQL注入" class="headerlink" title="②SQL注入"></a>②SQL注入</h6><p>​	SQL注入是通过操作输入来修改事先定义好的SQL语句，用以达到执行代码对服务器进行攻击的方法。</p>
<p>​	如：在登录输入密码时，写入一段SQL代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#如现登录的用户名为张三，其密码为123</span><br><span class="line">SELECT * FROM user_login WHERE name = &#x27;张三&#x27; AND password = &#x27;123&#x27;;-- 如果查询到数据，就代表该用户存在且密码正确，登录成功</span><br><span class="line"></span><br><span class="line">#如果我在输入密码时写了作用的SQL语句：&#x27; or &#x27;1&#x27; = &#x27;1&#x27;</span><br><span class="line">SELECT * FROM user_login WHERE name = &#x27;张三&#x27; AND password = &#x27;&#x27; or &#x27;1&#x27; = &#x27;1&#x27;;</span><br><span class="line">-- 此时用户输入的密码就改变了原来查询语句的面貌，导致WHERE后面的条件永远成立，select就能查询到数据，代表着登录成功了。这就是SQL注入。</span><br></pre></td></tr></table></figure>

<p>​	</p>
<h6 id="③解决SQL注入"><a href="#③解决SQL注入" class="headerlink" title="③解决SQL注入"></a>③解决SQL注入</h6><p>​	<strong>实现步骤</strong>：</p>
<ol>
<li><p>获取PreparedStatement对象，用Connection类的对象去调用prepareStatement(sql)方法</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> con.prepareStatement(sql);</span><br></pre></td></tr></table></figure>

<p> 注意：sql语句中的参数值，使用 “ ? ” 占位符代替，如：</p>
<p> sql可以为增删改查操作。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from user where username = ? and password = ?&quot;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置参数。通过PreparedStatement类的对象去调用setXxx(参数1,参数2)去给 “ ? ”赋值。</p>
<p> 说明：</p>
<ul>
<li>Xxx：数据类型；如：setInt(参数1，参数2)</li>
<li>参数：<ul>
<li>参数1：? 的位置。第一个?的位置为1。</li>
<li>参数2：? 的值。</li>
</ul>
</li>
</ul>
</li>
<li><p>执行SQL。通过PreparedStatement类的对象调用execuleUpdate()或executeQuery()来执行SQL语句。注意：不用再向这两个方法传递SQL语句。</p>
</li>
</ol>
<h6 id="④解决SQL注入的原理"><a href="#④解决SQL注入的原理" class="headerlink" title="④解决SQL注入的原理"></a>④解决SQL注入的原理</h6><p>​	当我们通过setXxx方法来设置占位符 “?” 的值时，会对设置的值进行校验，如果其中涉及到了一些SQL关键字或单引号等会对其进行转移操作，即将这些变成字符串。这样就不会产生SQL注入了。</p>
<h6 id="⑤PreparedStatement原理"><a href="#⑤PreparedStatement原理" class="headerlink" title="⑤PreparedStatement原理"></a>⑤PreparedStatement原理</h6><ul>
<li><strong>PreparedStatement的好处</strong><ol>
<li>预编译SQL，性能提高。</li>
<li>防止SQL注入：将敏感字符进行转义。</li>
<li>PreparedStatement<strong>预编译功能默认是关闭的</strong>，<strong>需要我们手动开启</strong>，在获取数据库连接时，在url后面加上“<strong>useServerPrepStmts &#x3D; true</strong>”，<strong>并且在这段代码前加上 &amp; 和前面的内容连起来</strong>。</li>
</ol>
</li>
<li><strong>PreparedStatement原理</strong><ol>
<li>在获取PreparedStatement对象时，将SQL语句发送给MySQL服务器进行检查，编译(这些步骤很耗时)。</li>
<li>执行SQL时就不用再进行检查和预编译了，速度更快。</li>
<li>如果SQL语句的模板一样，则只需要进行一次检查和预编译。</li>
</ol>
</li>
<li><strong>PreparedStatement比以普通的方式执行SQL快在哪里？</strong><ol>
<li>普通的方式进行SQL：其在执行SQL时才将SQL语句发送给数据库进行检查和编译，最后才真正执行。比预编译耗时。</li>
<li>普通的方式进行SQL：需要对每一条SQL语句进行检查和编译，预编译的话，只要模板相同就只执行一次检查和编译，节省了时间。</li>
</ol>
</li>
</ul>
<hr>
<h4 id="④数据库连接池"><a href="#④数据库连接池" class="headerlink" title="④数据库连接池"></a>④数据库连接池</h4><h5 id="A-概述"><a href="#A-概述" class="headerlink" title="A.概述"></a>A.概述</h5><ol>
<li>数据库连接池：是个容器，负责分配、管理数据库连接。</li>
<li>它允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个。—&gt; 资源复用、提高响应效率</li>
<li>释放空间时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏。—&gt; 避免数据库连接遗漏</li>
</ol>
<p>​	<strong>好处</strong>：</p>
<ul>
<li>资源复用</li>
<li>提高响应效率</li>
<li>避免数据库连接遗漏</li>
</ul>
<p>​	</p>
<h5 id="B-数据库连接池实现"><a href="#B-数据库连接池实现" class="headerlink" title="B.数据库连接池实现"></a>B.数据库连接池实现</h5><h6 id="①概述-3"><a href="#①概述-3" class="headerlink" title="①概述"></a>①概述</h6><ol>
<li><p>官方(SUN公司)提供了数据库连接池的标准接口DataSource，该接口由第三方组织实现。</p>
<ul>
<li><p>该接口的功能是：获取数据库连接，该接口中有一个方法：</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection getConnection()</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>常见的数据库连接池：DBCP、C3P0、Druid</p>
<ul>
<li>Druid：是阿里巴巴开源的数据库连接池项目。其功能强大，性能优秀。</li>
</ul>
</li>
</ol>
<h6 id="②Druid使用步骤"><a href="#②Druid使用步骤" class="headerlink" title="②Druid使用步骤"></a>②Druid使用步骤</h6><ol>
<li><p>导入jar包：druid-1.1.12.jar</p>
</li>
<li><p>定义配置文件，文件的后缀为properties。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">driverClassName = com.mysql.jdbc.Driver<span class="comment">//注册数据库驱动，使用哪个数据库就注册哪个数据库驱动</span></span><br><span class="line">url = jdbc:mysql:<span class="comment">//数据库管理系统所在主机的地址(或域名)：3306/连接的是数据库管理系统下的哪个数据库。例子：jdbc:mysql://127.0.0.1:3306/db1。</span></span><br><span class="line">username = 登录数据库的用户</span><br><span class="line">password = 密码</span><br><span class="line">initialSize = <span class="number">5</span> <span class="comment">//初始化连接数量</span></span><br><span class="line">maxActive = <span class="number">10</span> <span class="comment">//最大连接数</span></span><br><span class="line">maxWait = <span class="number">3000</span> <span class="comment">//最大等待时间，单位为毫秒</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//还有其它参数可以设置</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>加载配置文件</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Properties</span> <span class="variable">prop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();<span class="comment">//创建配置文件对象</span></span><br><span class="line">prop.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;配置文件的路径&quot;</span>));<span class="comment">//加载配置文件</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>获取数据库连接池对象</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DataSource</span> <span class="variable">ds</span> <span class="operator">=</span> DruidDataSourcrFactory.createDataSourcr(prop);<span class="comment">//该方法会抛异常</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>获取数据库连接</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> ds.getConnection();</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取连接之后，就定义SQL，获取执行SQL的对象，执行SQL，释放资源。</p>
</li>
</ol>
<p>​	</p>
<h6 id="③元视图操作的方法（即遍历Map）"><a href="#③元视图操作的方法（即遍历Map）" class="headerlink" title="③元视图操作的方法（即遍历Map）"></a>③元视图操作的方法（即遍历Map）</h6><ul>
<li>Set <strong>keySet</strong>()：返回所有key构成的Set集合</li>
<li>Collection <strong>values</strong>()：返回所有value构成的Collection集合</li>
<li>Set <strong>entrySet</strong>()：返回所有key-value对构成的Set集合</li>
</ul>
<p>map没有iterator方法，遍历时可以用以上方法得到set或者Collection，再用他们的iterator方法，即可实现遍历。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">HashMap</span> <span class="variable">map1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map1.put(<span class="string">&quot;aa&quot;</span>,<span class="number">2</span>);</span><br><span class="line">        map1.put(<span class="string">&quot;cc&quot;</span>,<span class="number">3</span>);</span><br><span class="line">        map1.put(<span class="string">&quot;bb&quot;</span>,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历map1当中的key</span></span><br><span class="line">        <span class="type">Set</span> <span class="variable">keySet</span>  <span class="operator">=</span> map1.keySet();</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> keySet.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历map1当中的value</span></span><br><span class="line">        <span class="type">Collection</span> <span class="variable">collection</span> <span class="operator">=</span> map1.values();</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator1</span> <span class="operator">=</span> collection.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator1.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator1.next());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历map1当中的key-value对，方式一：</span></span><br><span class="line">        <span class="type">Set</span> <span class="variable">entrySet</span> <span class="operator">=</span> map1.entrySet();</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator2</span> <span class="operator">=</span> entrySet.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator2.hasNext())&#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> iterator2.next();</span><br><span class="line">            <span class="comment">//取出来的数据都是Entry类型</span></span><br><span class="line">            Map.Entry entry= (Map.Entry)o;</span><br><span class="line">            System.out.println(entry.getKey() + <span class="string">&quot;--&quot;</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">//遍历map1当中的key-value对，方式二：</span></span><br><span class="line">    	<span class="type">Set</span> <span class="variable">keySet1</span> <span class="operator">=</span> map1.keySet();</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator3</span> <span class="operator">=</span> keySet1.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator3.hasNext())&#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">key</span> <span class="operator">=</span> iterator3.next();</span><br><span class="line">            <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> map1.get(key);</span><br><span class="line"></span><br><span class="line">            System.out.println(key + <span class="string">&quot;==&quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/imgs/image-20220829170603182.png" alt="image-20220829170603182"></p>
<p>遍历的应用：将Map中的一条条数据取出来放到数据库中</p>
<h6 id="④常用方法总结"><a href="#④常用方法总结" class="headerlink" title="④常用方法总结"></a>④常用方法总结</h6><p><img src="/imgs/image-20220829171040578.png" alt="image-20220829171040578"></p>
<h5 id="M-Collections工具类"><a href="#M-Collections工具类" class="headerlink" title="M.Collections工具类"></a>M.Collections工具类</h5><p>Collections：操作Collection、Map的工具类</p>
<h6 id="①反转"><a href="#①反转" class="headerlink" title="①反转"></a>①反转</h6><p>**reverse(List)**：反转List中元素的顺序，该方法没有返回值</p>
<h6 id="②排序"><a href="#②排序" class="headerlink" title="②排序"></a>②排序</h6><ol>
<li>shuffle(List)：对List集合元素进行随机排序，该方法没有返回值</li>
<li>sort(List)：调用List元素里的comparTO方法对指定的List集合元素进行自然排序（即按升序排序）。</li>
<li>sort(List,Comparator)：根据指定的Comparator产生的顺序对List集合元素进行排序</li>
<li>swap(List,int,int)：将指定 list 集合中的 i 处元素和 j 处元素进行交换</li>
</ol>
<h6 id="③求最值"><a href="#③求最值" class="headerlink" title="③求最值"></a>③求最值</h6><ol>
<li>Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素。自然排序：调用的是集合中元素所在类的compareTo方法。</li>
<li>Object max(Collection，Comparator)：根据 Comparator 指定的顺序，返回给定集合中的最大元素</li>
<li>Object min(Collection)：根据元素的自然顺序，返回给定集合中的最小元素。自然排序：调用的是集合中元素所在类的compareTo方法。</li>
<li>Object min(Collection，Comparator)</li>
</ol>
<h6 id="④计算某元素出现的次数"><a href="#④计算某元素出现的次数" class="headerlink" title="④计算某元素出现的次数"></a>④计算某元素出现的次数</h6><p>**int frequency(Collection，Object)**：返回指定集合中指定元素的出现次数</p>
<h6 id="⑤复制"><a href="#⑤复制" class="headerlink" title="⑤复制"></a>⑤复制</h6><p>**void copy(List dest,List src)**：将src中的内容复制到dest中 </p>
<p><img src="/imgs/image-20220829204754982.png" alt="image-20220829204754982"></p>
<h6 id="⑥替换"><a href="#⑥替换" class="headerlink" title="⑥替换"></a>⑥替换</h6><p>**boolean replaceAll(List list，Object oldVal，Object newVal)**：使用新值替换List 对象的所有旧值</p>
<h6 id="⑦将线程不安全的集合变成线程安全集合"><a href="#⑦将线程不安全的集合变成线程安全集合" class="headerlink" title="⑦将线程不安全的集合变成线程安全集合"></a>⑦将线程不安全的集合变成线程安全集合</h6><p>Collections类中提供了多个synchronizedXxx( )方法，该方法可使将指定集合包装成线程安全的集合，从而可以解决多线程并发访问集合时的线程安全问题，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();<span class="comment">//list存在线程不安全问题</span></span><br><span class="line"><span class="comment">//返回的list1即为线程安全的List</span></span><br><span class="line"><span class="type">List</span> <span class="variable">list1</span> <span class="operator">=</span> Collections.synchronizedList(list);</span><br></pre></td></tr></table></figure>

<p>当多个线程共同操作list1时，就不再发生线程安全问题。</p>
<hr>
<h4 id="6、泛型"><a href="#6、泛型" class="headerlink" title="6、泛型"></a>6、泛型</h4><h5 id="A-引入"><a href="#A-引入" class="headerlink" title="A.引入"></a>A.引入</h5><p>​		我们可以往集合中存放任何的数据类型，这其实是集合的一个缺点，就比如：用集合去存储学生的成绩，在添加数据的时候对数据的类型并没有要求，所以可以添加除int以外的类型数据，这并不是我们希望的，因此我们就引入了泛型。其作用是：表明该集合只能存放泛型中声明的数据类型，不能存放其他数据类型。</p>
<p>​		泛型是jdk5.0的新特性。</p>
<h5 id="B-在集合中使用泛型"><a href="#B-在集合中使用泛型" class="headerlink" title="B.在集合中使用泛型"></a>B.在集合中使用泛型</h5><ol>
<li><p>集合接口或集合类在jdk5.0时都修改为带泛型的结构。 —&gt;前提。如果没有在定义接口或类时声明为带泛型的结构，那么接口内或类内就不能使用泛型。</p>
</li>
<li><p>在实例化集合类时，可以指明具体的泛型类型（只能写类 类型，不能写基本数据类型，要想用基本数据类型—&gt;包装类）</p>
</li>
<li><p>指明完以后，在集合类或接口中凡是定义类或接口时，内部结构（如：方法、构造器、属性等）使用到类的泛型的位置，都指定为实例化的泛型类型。如：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">&quot;hhhhh&quot;</span>);<span class="comment">//此时add方法中的参数变为(String s1),不再是(Object obj)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果实例化时，没有指明泛型的类型（即没使用泛型时）。默认类型为 Java.lang.Object 类型。</p>
</li>
</ol>
<h6 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h6><ol>
<li><p>如果集合中使用泛型声明为Integer，则使用add方法时，仍可以这么写：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list1.add(<span class="number">12</span>);<span class="comment">//仍可以写12</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>集合、比较器（Comparable、Comparator）都可以使用泛型</p>
</li>
<li><p>添加了泛型之后，集合的遍历操作与原来的操作一样，直接调用对应的方法，然后“alt + enter”自动补充即可。生成的代码会有点不同（21行代码）</p>
</li>
</ol>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    list.add(<span class="string">&quot;hhhhh&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;123&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//**********************************</span></span><br><span class="line">    HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;Tom&quot;</span>,<span class="number">12</span>);</span><br><span class="line">    map.put(<span class="string">&quot;Jerry&quot;</span>,<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entrySet = map.entrySet();</span><br><span class="line">    Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iterator1 = entrySet.iterator();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (iterator1.hasNext())&#123;</span><br><span class="line">        Map.Entry&lt;String, Integer&gt; entry = iterator1.next();</span><br><span class="line">        <span class="comment">//现在不用将next方法得到的对象强转为Entry类型</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">        System.out.println(key + <span class="string">&quot;---&quot;</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  <img src="/imgs/image-20220830170745289.png" alt="image-20220830170745289"></p>
<h5 id="C-自定义泛型结构–泛型类"><a href="#C-自定义泛型结构–泛型类" class="headerlink" title="C.自定义泛型结构–泛型类"></a>C.自定义泛型结构–泛型类</h5><p>​	自定义泛型结构有：泛型类、泛型接口、泛型方法</p>
<h6 id="①实现方式"><a href="#①实现方式" class="headerlink" title="①实现方式"></a>①实现方式</h6><p>​	在类名后面加上”<T>“即可，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&lt;T&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	如果定义了泛型类，实例化没有指明类的泛型，则认为此泛型类型为Object类型。要求：如果定义了类是带泛型的，建议在实例化时要指明类的类型。  </p>
<h6 id="②继承关系中的泛型"><a href="#②继承关系中的泛型" class="headerlink" title="②继承关系中的泛型"></a>②继承关系中的泛型</h6><p>​	如果父类为泛型类，则子类有两种情况：</p>
<p>​		情况1：子类明确父类中泛型的类型，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&lt;T&gt;&#123;</span><br><span class="line">    String name;</span><br><span class="line">    T order;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将父类中的泛型明确为String，此时属性order的类型为String</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Man</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&lt;String&gt;&#123;<span class="comment">//Man就不属于泛型类，那么Man再实例化的时候就不能写泛型，只能像普通的类那样实例化</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​	情况2：子类也无法确定父类中的泛型具体是哪种类 类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&lt;T&gt;&#123;</span><br><span class="line">    String name;</span><br><span class="line">    T order;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Man</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Person</span>&lt;T&gt;&#123;<span class="comment">//Man属于泛型类</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Man&lt;String&gt; m = <span class="keyword">new</span> <span class="title class_">Man</span>&lt;&gt;();<span class="comment">//此时order为String类型</span></span><br></pre></td></tr></table></figure>

<p>​	</p>
<h6 id="③细节说明"><a href="#③细节说明" class="headerlink" title="③细节说明"></a>③细节说明</h6><ol>
<li><p>泛型类可能有多个参数，此时应将多个参数一起放在尖括号内。比如：&lt;E1,E2,E3&gt;。实例化时应都要指明其具体的泛型类型。</p>
</li>
<li><p>泛型类的构造器如下：public GenericClass(){}。而下面是错误的：public GenericClass&lt; E&gt;(){}</p>
</li>
<li><p>泛型不同的引用不能相互赋值。</p>
<p> <img src="/imgs/image-20220831102630840.png" alt="image-20220831102630840"></p>
<p> 因为赋值之后，list1指向的是list2堆空间中的对象，当调用list1的add方法时添加的是String类型数据，而list2里只能存Integer类型数据，这就发生了冲突，所以不能赋值。</p>
</li>
<li><p>在普通的静态方法中不能使用类的泛型。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(T order)</span>&#123;<span class="comment">//报错</span></span><br><span class="line">	System.out.println(order);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 因为泛型类型是在创建对象的时候再确定的，而静态方法是在类的加载的时候就加载的，这时候就需要用到这里的泛型数据，而泛型类型没确定，就不行。</p>
</li>
<li><p>异常体系结构下的类，不能是泛型类。</p>
</li>
<li><p>try-catch，catch后面的小括号里不能使用泛型。</p>
</li>
<li><p>如果用泛型造个数组，得这样写：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误:</span></span><br><span class="line">T[] arr1 = <span class="keyword">new</span> <span class="title class_">T</span>[<span class="number">10</span>];</span><br><span class="line"><span class="comment">//正确</span></span><br><span class="line">T[] arr = (T[]) <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">10</span>];<span class="comment">//只能往该数组里存放T或T的子类数据</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>继承关系中的泛型详解</p>
<p> <img src="/imgs/image-20220831105827121.png" alt="image-20220831105827121"></p>
<p> <img src="/imgs/image-20220831110112288.png" alt="image-20220831110112288"></p>
<p> <strong>A、B是子类自己的泛型</strong></p>
</li>
</ol>
<h6 id="④应用"><a href="#④应用" class="headerlink" title="④应用"></a>④应用</h6><ol>
<li>当类中的某个属性的类型不确定时，就可以使用泛型类，如：</li>
</ol>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&lt;T&gt;&#123;</span><br><span class="line">	String name;</span><br><span class="line">    T personT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>对数据库中的表进行操作的类中可以声明为泛型类，因为该类可能操作不同的表，每个表又不同，所以就用泛型，让子类去继承该类时再明确泛型类型（即明确操作的是哪种表）。</p>
</li>
<li></li>
</ol>
<hr>
<h5 id="D-自定义泛型结构–泛型接口"><a href="#D-自定义泛型结构–泛型接口" class="headerlink" title="D.自定义泛型结构–泛型接口"></a>D.自定义泛型结构–泛型接口</h5><h6 id="①实现方式-1"><a href="#①实现方式-1" class="headerlink" title="①实现方式"></a>①实现方式</h6><p>​	在接口名后面加上“<T>“即可，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Dog</span>&lt;T&gt;&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="E-自定义泛型结构–泛型方法"><a href="#E-自定义泛型结构–泛型方法" class="headerlink" title="E.自定义泛型结构–泛型方法"></a>E.自定义泛型结构–泛型方法</h5><h6 id="①定义"><a href="#①定义" class="headerlink" title="①定义"></a>①定义</h6><p>​	泛型方法：在方法中出现了泛型的结构，泛型参数与类的泛型参数没有任何关系。换句话说，泛型方法属于的类是不是泛型类都没有关系。</p>
<h6 id="②格式"><a href="#②格式" class="headerlink" title="②格式"></a>②格式</h6><p>​	在返回值类型前加上“<T>”即可。</p>
<h6 id="③使用"><a href="#③使用" class="headerlink" title="③使用"></a>③使用</h6><p>​	调用泛型方法时，往该泛型方法中传递的参数的类型决定了该泛型方法泛型的类型。</p>
<h6 id="④注意"><a href="#④注意" class="headerlink" title="④注意"></a>④注意</h6><p>​	泛型方法，可以声明为静态的。原因：泛型参数是在调用方法时确实的，并非在实例化时确定。</p>
<h5 id="F-泛型在继承方面的体现"><a href="#F-泛型在继承方面的体现" class="headerlink" title="F.泛型在继承方面的体现"></a>F.泛型在继承方面的体现</h5><p>①</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//虽然类A是类B的父类，但是G&lt;A&gt; 和 G&lt;B&gt;二者不具备字父类关系，二者是并列关系。G可以是任意的数据类型，如：集合</span></span><br><span class="line">ArrayList&lt;Person&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">ArrayList&lt;Man&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Man&gt;();</span><br><span class="line">list = list1;<span class="comment">//不具备子父类关系，不能相互赋值</span></span><br></pre></td></tr></table></figure>

<p>②</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类A是类B的父类父接口，A&lt;G&gt; 是 B&lt;G&gt;的父类或父接口，泛型的类型要一样</span></span><br><span class="line">HashSet&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">LinkedHashSet&lt;String&gt; set1 = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">set = set1;<span class="comment">//存在子父类关系，可以赋值</span></span><br></pre></td></tr></table></figure>



<h5 id="E-通配符的使用"><a href="#E-通配符的使用" class="headerlink" title="E.通配符的使用"></a>E.通配符的使用</h5><h6 id="①定义-1"><a href="#①定义-1" class="headerlink" title="①定义"></a>①定义</h6><p>​	通配符：?</p>
<p>类A是类B的父类，G<A> 和 G<B> 是并列关系，二者共同的父类是：G&lt;?&gt;</p>
<h6 id="②应用例子"><a href="#②应用例子" class="headerlink" title="②应用例子"></a>②应用例子</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span>&#123;</span><br><span class="line">    ArrayList&lt;Person&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    ArrayList&lt;Man&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">12</span>));</span><br><span class="line">    printList(list);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历集合</span></span><br><span class="line"><span class="comment">//把ArrayList&lt;?&gt;替换为List&lt;?&gt;也行</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printList</span><span class="params">(ArrayList&lt;?&gt; list)</span>&#123;</span><br><span class="line">    Iterator&lt;?&gt; iterator = list.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="③使用-1"><a href="#③使用-1" class="headerlink" title="③使用"></a>③使用</h6><p>A.对于List&lt;?&gt;就不能向其内部添加数据，除了添加null之外。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;?&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list2.add(<span class="string">&quot;sf&quot;</span>);<span class="comment">//报错</span></span><br></pre></td></tr></table></figure>

<p>B.允许读取List&lt;?&gt;的对象list2中的元素，读取的数据类型为Object类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Person&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">12</span>));</span><br><span class="line">List&lt;?&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list2 = list;</span><br><span class="line">System.out.println(list2.get(<span class="number">0</span>));<span class="comment">//Person&#123;name=&#x27;Tom&#x27;, age=12&#125;</span></span><br></pre></td></tr></table></figure>



<h6 id="④有限制条件的通配符"><a href="#④有限制条件的通配符" class="headerlink" title="④有限制条件的通配符"></a>④有限制条件的通配符</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有限制条件的通配符：</span></span><br><span class="line">? <span class="keyword">extends</span> <span class="title class_">A</span></span><br><span class="line">? <span class="built_in">super</span> A</span><br></pre></td></tr></table></figure>

<p>G&lt;? extends A&gt; 可以作为G<A>和G<B>的父类，其中B是A的子类。extends相当于 “&lt;&#x3D;”，G为带泛型的任意一种数据类型，如：集合</p>
<p>G&lt;? superA&gt; 可以作为G<A>和G<B>的父类，，其中B是A的父类。super相当于 “&gt;&#x3D;”，G为带泛型的任意一种数据类型，如：集合</p>
<p><strong>A</strong>.对于G&lt;? extends A&gt;声明的对象，我们是可以获取该对象里的数据的，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Person&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">12</span>));</span><br><span class="line">List&lt;? <span class="keyword">extends</span> <span class="title class_">Person</span>&gt; list2 = <span class="literal">null</span>;</span><br><span class="line">list2 = list;</span><br><span class="line">System.out.println(list2.get(<span class="number">0</span>));<span class="comment">//Person&#123;name=&#x27;Tom&#x27;, age=12&#125;</span></span><br></pre></td></tr></table></figure>

<p>对于G&lt;? superA&gt; 声明的对象也一样可以获取该对象里的数据。</p>
<p><strong>B</strong>.</p>
<p>对于**G&lt;? extends A&gt;**声明的对象，我们不能对其进行添加数据操作，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Person&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">12</span>));</span><br><span class="line">List&lt;? <span class="keyword">extends</span> <span class="title class_">Person</span>&gt; list2 = <span class="literal">null</span>;</span><br><span class="line">list2 = list;</span><br><span class="line"><span class="comment">//报错</span></span><br><span class="line">list2.add();<span class="comment">//无论括号里放什么数据都会报错</span></span><br></pre></td></tr></table></figure>

<p>对于<strong>G&lt;? super A&gt;</strong> 声明的对象，我们可以对其进行添加数据的操作，但只能添加类A或类A的子类的数据，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Person&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;? <span class="built_in">super</span> Person&gt; list3 = <span class="literal">null</span>;</span><br><span class="line">list3 = list;</span><br><span class="line">list3.add(<span class="keyword">new</span> <span class="title class_">Man</span>());</span><br></pre></td></tr></table></figure>



<h6 id="⑤其他"><a href="#⑤其他" class="headerlink" title="⑤其他"></a>⑤其他</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &lt;T extend Person&gt;&#123;</span><br><span class="line">    T order;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里的T只能取Person类或Person类的子类</span></span><br><span class="line"><span class="comment">//如果Person是一个接口，那T只能是该接口的实现类</span></span><br></pre></td></tr></table></figure>



<hr>
<h4 id="7、IO流"><a href="#7、IO流" class="headerlink" title="7、IO流"></a>7、IO流</h4><h5 id="A-File类的使用"><a href="#A-File类的使用" class="headerlink" title="A.File类的使用"></a>A.File类的使用</h5><h6 id="①概述-4"><a href="#①概述-4" class="headerlink" title="①概述"></a>①概述</h6><ul>
<li>File类的一个对象，代表一个文件或一个文件目录（俗称：文件夹）</li>
<li>File类声明在java.io包下</li>
</ul>
<p>​	</p>
<h6 id="②预备知识"><a href="#②预备知识" class="headerlink" title="②预备知识"></a>②预备知识</h6><p>​	<strong>路径</strong>：</p>
<ul>
<li><p>相对路径：相较于某个路径下，指明的路径，如：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>绝对路径：包含盘符在内的文件或文件目录的路径</p>
</li>
</ul>
<p>说明：</p>
<ol>
<li><p><strong>IDEA</strong>中：如果大家开发使用JUnit中的单元测试方法测试，相对路径即为当前Module下。如果大家使用main()测试，相对路径即为当前的Project下。</p>
</li>
<li><p><strong>Eclipse</strong>中：不管使用单元测试方法还是使用mian()测试，相对路径都是当前的Project下。</p>
</li>
<li><p>如何准确的写出文件路径？</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.获取当前代码所在路径</span></span><br><span class="line">System.out.println(System.getProperty(<span class="string">&quot;user.dir&quot;</span>));</span><br><span class="line"><span class="comment">//2.打开显示的路径，在此路径下找到要找的文件</span></span><br><span class="line"><span class="comment">//3.复制找到文件的路径，但不包括1中显示的路径。</span></span><br><span class="line"><span class="comment">//4.完成</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>​	<strong>路径分隔符和系统的关系</strong></p>
<ul>
<li>windows和DOS系统默认使用“ \ ” 来表示</li>
<li>UNIX和URL使用“ &#x2F; ” 来表示</li>
<li>补充：Java中路径分隔符用两个 “ \ ” 表示，目的是区分Java中的转译符” \ “</li>
</ul>
<h6 id="③如何实例化"><a href="#③如何实例化" class="headerlink" title="③如何实例化"></a>③如何实例化</h6><p>​	有以下几种构造器：</p>
<p>​	A.<strong>File(String filePath)</strong></p>
<p>​		filePath：可以是相对路径，也可以是绝对路径</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(hello.txt);</span><br><span class="line"><span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(D:\\hello.txt);</span><br><span class="line"><span class="comment">//此时造了两个File对象，还没涉及到对文件进行操作，所以填入的文件不存在也没事。</span></span><br></pre></td></tr></table></figure>

<p>​	B.<strong>File(String parentPath,String childPath)</strong></p>
<p>​		parentPath：该文件或文件夹的上一级目录</p>
<p>​		childPath：该文件夹名或文件名</p>
<p>​	C.<strong>File(File parentFile,String childPath)</strong></p>
<p>​		parentFile：该文件或文件夹的上一级目录</p>
<p>​		childPath：该文件夹名或文件名</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\java\\exer&quot;</span>);</span><br><span class="line"><span class="type">File</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(f1,<span class="string">&quot;file.txt&quot;</span>);</span><br><span class="line"><span class="comment">//该file.txt文件的绝对路径为：D:\java\exer\file.txt</span></span><br></pre></td></tr></table></figure>



<h5 id="B-File类的常用方法"><a href="#B-File类的常用方法" class="headerlink" title="B.File类的常用方法"></a>B.File类的常用方法</h5><p>​	以下方法是内存层面的调用，还没涉及到硬盘层面的调用。</p>
<h6 id="①获取相应信息"><a href="#①获取相应信息" class="headerlink" title="①获取相应信息"></a>①获取相应信息</h6><ul>
<li><p>**public String getAbsolutePath()**：获取绝对路径</p>
</li>
<li><p><strong>public String getPath()</strong> ：获取路径，显示的是你声明对象时指明的路径</p>
</li>
<li><p><strong>public String getName()</strong> ：获取名称</p>
</li>
<li><p>**public String getParent()**：获取上层文件目录路径。若无，返回null</p>
</li>
<li><p><strong>public long length()</strong> ：获取文件长度（即：字节数）。不能获取目录的长度。 只有真实存在的文件才能获取到长度，不然返回默认值：0。</p>
</li>
<li><p><strong>public long lastModified()</strong> ：获取最后一次的修改时间，毫秒值。只有真实存在的文件或文件目录才返回相应的值，否则返回默认值：0。</p>
<p>  下面两个方法适用于文件目录：（<strong>且指定的目录要真实存在，不然报错</strong>）</p>
</li>
<li><p><strong>public String[] list()</strong> ：获取指定目录下的所有文件或者文件目录的名称数组</p>
</li>
<li><p><strong>public File[] listFiles()</strong> ：获取指定目录下的所有文件或者文件目录的File数组（绝对路径）</p>
</li>
</ul>
<h6 id="②重命名功能"><a href="#②重命名功能" class="headerlink" title="②重命名功能"></a>②重命名功能</h6><p>​	**public boolean renameTo(File dest)**：把文件重命名为指定的文件路径</p>
<p>​	比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"><span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\java\\hi.txt&quot;</span>);</span><br><span class="line">file1.renameTo(file2);</span><br><span class="line"><span class="comment">//要想保证返回true，需要file1在硬盘中是存在的，且file2不能在硬盘中存在</span></span><br></pre></td></tr></table></figure>

<p>​	<strong>说明</strong>：</p>
<ol>
<li>file1、file2中的路径是相对路径、还是绝对路径，都没有关系。</li>
<li>运行的效果是：根据file2的路径在硬盘中创建相应的文件，然后把hello.txt里的内容复制到file2的那个文件里，最后hello.txt文件被删除。</li>
</ol>
<h6 id="③判断功能"><a href="#③判断功能" class="headerlink" title="③判断功能"></a>③判断功能</h6><ul>
<li>**public boolean isDirectory()**：判断是否是文件目录</li>
<li><strong>public boolean isFile()</strong> ：判断是否是文件</li>
<li><strong>public boolean exists()</strong> ：判断硬盘上是否存在该文件或文件目录</li>
<li><strong>public boolean canRead()</strong> ：判断是否可读</li>
<li><strong>public boolean canWrite()</strong> ：判断是否可写</li>
<li><strong>public boolean isHidden()</strong> ：判断是否隐藏</li>
</ul>
<p>如果在硬盘中没有该文件或文件目录，这些方法都会返回默认值：false</p>
<h6 id="④在硬盘中创建对应的文件或文件目录"><a href="#④在硬盘中创建对应的文件或文件目录" class="headerlink" title="④在硬盘中创建对应的文件或文件目录"></a>④在硬盘中创建对应的文件或文件目录</h6><ul>
<li><strong>public boolean createNewFile()</strong> ：创建文件。若文件存在，则不创建，返回false。该方法本身会报异常，我们需要对其进行throws或try-catch-finally</li>
<li><strong>public boolean mkdir()</strong> ：创建文件目录。如果此文件目录存在，就不创建了。如果此文件目录的上层目录不存在，也不创建。 </li>
<li><strong>public boolean mkdirs()</strong> ：创建文件目录。如果上层文件目录不存在，一并创建。</li>
</ul>
<h6 id="⑤删除硬盘中的文件或文件目录"><a href="#⑤删除硬盘中的文件或文件目录" class="headerlink" title="⑤删除硬盘中的文件或文件目录"></a>⑤删除硬盘中的文件或文件目录</h6><ul>
<li>**public boolean delete()**：删除文件或者文件夹</li>
</ul>
<p>注意：Java中的删除不走回收站。 要删除一个文件目录，请注意该文件目录内不能包含文件或者文件目录。</p>
<h6 id="⑥总结"><a href="#⑥总结" class="headerlink" title="⑥总结"></a>⑥总结</h6><ol>
<li>File类中涉及到关于文件或文件目录的创建、删除、重命名、获取修改时间、获取文件大小等方法，并未涉及到写入或读取文件内容的操作。如果需要读取或写入文件内容，必须使用IO流来完成。</li>
<li>后续File类的对象常作为参数传递到流的构造器中，指明要读取或写入的文件。</li>
</ol>
<h5 id="C-IO流原理"><a href="#C-IO流原理" class="headerlink" title="C.IO流原理"></a>C.IO流原理</h5><h6 id="①概述-5"><a href="#①概述-5" class="headerlink" title="①概述"></a>①概述</h6><ul>
<li><p>I&#x2F;O即：Input&#x2F;Output。数据从一个地方传送到另一个地方，就形成数据流，但我们通常不叫数据流，而是叫I&#x2F;O流。</p>
</li>
<li><p>输入：读取外部数据（磁盘、光盘等存储设备的数据）到程序（内存）中。</p>
<p>  输出：将程序（内存）数据输出到磁盘、光盘等存储设备中。</p>
</li>
</ul>
<h6 id="②流的分类"><a href="#②流的分类" class="headerlink" title="②流的分类"></a>②流的分类</h6><ul>
<li><p>按操作数据单位不同分为：字节流(8 bit)，字符流(16 bit)。</p>
<ul>
<li>字节流：一个字节一个字节地存储数据，存的是二进制数据。适用于：非文本文件，如：照片、视频等。</li>
<li>字符流：读取的是一个一个字符（char），存的也是一个一个char(字符)，适用于从文本文件中读取数据。</li>
</ul>
</li>
<li><p>按数据流的流向不同分为：输入流，输出流。</p>
</li>
<li><p>按流的角色的不同分为：节点流，处理流。</p>
<ul>
<li>节点流：直接作用在文件上的流叫节点流，即：可以直接处理File对象的流。</li>
<li>处理流：作用在已有流基础上的流叫处理流</li>
</ul>
<p>  <img src="/imgs/image-20220902142927450.png" alt="image-20220902142927450"></p>
</li>
</ul>
<h6 id="③四个抽象基类"><a href="#③四个抽象基类" class="headerlink" title="③四个抽象基类"></a>③四个抽象基类</h6><p>​	Java的IO流共涉及40多个类，这些类都是从如下4个抽象基类派生的。（基类：基础类的意思）。</p>
<p>​	InputStream、OutputStream属于操作字节流的类，Reader、Writer属于操作字符流的类。</p>
<p><img src="/imgs/image-20220902144531195.png" alt="image-20220902144531195"></p>
<p>​	</p>
<h6 id="④IO流体系结构"><a href="#④IO流体系结构" class="headerlink" title="④IO流体系结构"></a>④IO流体系结构</h6><p><img src="/imgs/image-20220902153228642.png" alt="image-20220902153228642"></p>
<p>​	注：第二行中的流属于节点流，第二行及以后的流属于处理流。蓝色标注的流属于重点学习和掌握的。</p>
<p>​	简化版：</p>
<p><img src="/imgs/image-20220902154142103.png" alt="image-20220902154142103"></p>
<p>​	补充：除了RandomAccessFile不是由四个基类派生而来的，其他的流都是由四个派生基类继承来的。</p>
<h5 id="E-节点流的使用"><a href="#E-节点流的使用" class="headerlink" title="E.节点流的使用"></a>E.节点流的使用</h5><h6 id="①如何从硬盘读入数据"><a href="#①如何从硬盘读入数据" class="headerlink" title="①如何从硬盘读入数据"></a>①如何从硬盘读入数据</h6><p>​	<strong>实现步骤：</strong></p>
<p>​	(读数据和写数据的操作步骤都是下面的4步，由于使用的流不一样，步骤2会不同；是读还是写，导致步骤3不一样，其他地方都一样)</p>
<ol>
<li><p>造File类的对象，指明要操作的文件。文件一定要存在。</p>
</li>
<li><p>根据需要选择具体的流，然后造流的对象，File类的对象作为参数传到流的构造器中。</p>
</li>
<li><p>数据的读入，用流的对象取调用read方法。read()：返回读入的一个字符，如果到达文件末尾，返回-1。</p>
</li>
<li><p>流的关闭操作。流的对象调用close()方法</p>
<p> <strong>注意：</strong></p>
</li>
</ol>
<ul>
<li>造流的对象和调用read方法时，都会抛异常，因此需要用try-catach-finally来处理。用try将这些代码包起来。快捷键：选中需要抱起来的代码   –&gt; alt+shift+z –&gt; try-catch-finally</li>
<li>调用close()方法时，也会抛异常。首先将关闭流的操作放在finally里（因为流声明完，不再使用时，不关闭会出现内存泄漏，使用<strong>必须关闭</strong>），然后再将close操作用try-catch-finally包起来，最后在close这行代码的上面加上判断语句（判断当前流的对象是否为null）。</li>
<li>读入的文件一定要存在，否则就会报FileNotFoundException</li>
</ul>
<p>​	<strong>如何形象理解上面的三个实现步骤：</strong></p>
<p>​	比如我们需要从一个水池里取水，怎么取呢？首先我们得知道水池的位置（即造File对象的步骤），然后我们就要造水管了(即：造流的对象)，但水管具体要安装在哪，我们就需要把File类的对象传到流的构造器中告诉它水管安装在哪，然后就开闸放水（即调用read方法）。</p>
<h6 id="②读入：read方法"><a href="#②读入：read方法" class="headerlink" title="②读入：read方法"></a>②读入：read方法</h6><ol>
<li>**read()**：每次读取一个char或一个byte数据，如果到达文件末尾，返回-1。</li>
<li><strong>read(char[] a)</strong> \ <strong>read(byte[] a)<strong>：将文件当中的内容读到数组a当中，每次读的长度为数组的长度，下一次读取时将原有的内容覆盖掉，而不是将数组中原有的内容先清除掉再添加。该方法返回的是，放入数组中字符\字节的个数，当返回-1时，代表读取完毕。</strong>数组a的长度一般为1024</strong>。如：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(file);</span><br><span class="line"><span class="type">char</span>[] a = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> length;</span><br><span class="line"><span class="keyword">while</span>((length = fr.read(a)) != -<span class="number">1</span>)&#123;<span class="comment">//read会抛异常，需要try-catch-finally，这里省略。</span></span><br><span class="line">    <span class="comment">//方式一：</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; length;i++)&#123;</span><br><span class="line">        System.out.print(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//方式二：</span></span><br><span class="line">    <span class="comment">//String str = new String(a,0,length);//从数组a的0索引处开始取length个数据</span></span><br><span class="line">    <span class="comment">//System.out.print(str);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="③从内存写入数据到硬盘"><a href="#③从内存写入数据到硬盘" class="headerlink" title="③从内存写入数据到硬盘"></a>③从内存写入数据到硬盘</h6><p>​	<strong>实现步骤</strong>：</p>
<ol>
<li>造File类的对象，指明要写入到的文件</li>
<li>根据需要选择具体的流，然后造流的对象，File类的对象作为参数传到流的构造器中。</li>
<li>数据的写入，用流的对象调用write()方法。</li>
<li>流的关闭操作。流的对象调用close()方法</li>
</ol>
<p>​	<strong>说明</strong>：</p>
<ul>
<li>输出操作，对应的File可以不存在。并不会报异常。File的上级目录一定要存在，不然报错。</li>
<li>File对应的硬盘中的文件如果不存在，在输出的过程中，会自动创建此文件。</li>
<li>File对应的硬盘中的文件如果存在：<ul>
<li>如果流使用的构造器是：FileWriter(file,false) &#x2F; FileWriter(file)：对原有文件的覆盖。 &#x2F;&#x2F;第2个参数是指是否能追加内容</li>
<li>如果流使用的构造器是：FileWriter(file,true)：不会对原有文件覆盖，而是在原有文件基础上追加内容。</li>
</ul>
</li>
</ul>
<h6 id="④写出：write方法"><a href="#④写出：write方法" class="headerlink" title="④写出：write方法"></a>④写出：write方法</h6><p>​	**write(String s)**：将字符串s写入到硬盘中</p>
<p>​	**write(char[] a,int index,length)**：从数组a中索引为index的位置开始取长度为：length的数据写入到硬盘中。</p>
<h6 id="⑤注意"><a href="#⑤注意" class="headerlink" title="⑤注意"></a>⑤注意</h6><ol>
<li>对于文本文件（.txt，.java，.c，.cpp），使用字符流（ Reader、Writer）处理。字符流不能处理字节数据。</li>
<li>）对于非文本文件（.jpg，.mp3，.mp4，.avi，.doc，.ppt，……）使用字节流（InputStream、OutputStream）处理。用字节流去实现文本文件的复制是没问题的，但在复制过程中对内容进行输出就可能出现乱码。</li>
</ol>
<h6 id="⑥补充"><a href="#⑥补充" class="headerlink" title="⑥补充"></a>⑥补充</h6><p>​	节点流的构造器除了有放File类对象的构造器，还有放String的构造器。</p>
<p>​	放String的构造器，以FileReader为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"><span class="comment">//传的是该文件的相对路径或绝对路径。</span></span><br><span class="line"><span class="comment">//这种声明方式实际上也是造了一个File类的对象，然后将此对象放到FileReader构造器中。</span></span><br></pre></td></tr></table></figure>



<h5 id="F-缓冲流"><a href="#F-缓冲流" class="headerlink" title="F. 缓冲流"></a>F. 缓冲流</h5><h6 id="①概述-6"><a href="#①概述-6" class="headerlink" title="①概述"></a>①概述</h6><p>​	缓冲流属于处理流的一种。处理流：对现有流进行包装的流，其作用在现有流上。</p>
<p>​	缓冲流：提高流的读写效率，开发中常用缓冲流。</p>
<p><img src="/imgs/image-20220903130413372.png" alt="image-20220903130413372"></p>
<h6 id="②缓冲流的使用"><a href="#②缓冲流的使用" class="headerlink" title="②缓冲流的使用"></a>②缓冲流的使用</h6><p>​	<strong>用缓冲流实现读写操作，实现步骤</strong>：</p>
<ol>
<li>造File类对象，指明要读入 (或写入)的文件</li>
<li>造相应的节点流的对象，把File类的对象作为参数传递到节点流的构造器中</li>
<li>根据节点流的类型选择对应的缓冲流并造其对象，把上面节点流的对象作为参数传递到缓冲流的构造器中。</li>
<li>用缓冲流的对象调用read()方法（或write()方法）。</li>
<li>流的关闭。要求：先关外层的流，再关内层的流。同一层的流，先关哪个都行。<ul>
<li>说明：关闭外层流的同时，内层流也会自动的进行关闭。关于内层流的关闭，我们可以省略。</li>
</ul>
</li>
</ol>
<p>​	注意：</p>
<ul>
<li>造流的对象、调用read()、调用write()都会抛异常，所以要用try-catch-finally来处理。将步骤1-4用try包起来。流的关闭操作放在finally里。</li>
</ul>
<p>​	<strong>以上实现步骤的形象理解</strong>：</p>
<p>​	我们需要从一个池子中快速地把水抽出来。首先，我们得知道水池的位置（即造File类的对象，指明池子的位置），然后由于缓冲流是作用在现有流的基础上，所以得造节点流的对象（就相当于造了根水管），接着把File类的对象传到节点流的构造器中（即指明水管安装的位置），再接着造缓冲流的对象（相当于弄了台增压水泵），把节点流的对象作为参数传递到缓冲流的构造器中（相当于告诉增压水泵安装到哪根水管）。这些步骤执行完后，用缓冲流的对象调用read()方法（或write()方法）。</p>
<h6 id="③readLine"><a href="#③readLine" class="headerlink" title="③readLine()"></a>③readLine()</h6><p>​	<strong>BufferedReader</strong>中提供了一个**readLine()**方法，该方法每次从文件中读取一行数据，并以String的形式返回。当读到文件末尾时，返回null。</p>
<p>​	注意：</p>
<ul>
<li>该方法提高流的对象调用</li>
<li>该方法返回的内容不包含换行符。如果想换行，可以用流的对象调用newLine()，实现换行操作。</li>
</ul>
<h6 id="④为什么缓冲流能提高速度"><a href="#④为什么缓冲流能提高速度" class="headerlink" title="④为什么缓冲流能提高速度"></a>④为什么缓冲流能提高速度</h6><p>​	缓冲流内部提供了一个大小为8192个字节（8kb）的缓冲区，每次从文件中读取的数据都会先放在缓冲区中，当存放的容量达到8192时，就会调用flush()方法将缓冲区中的内容写出到另一个文件并清空缓冲区。这样就减少了与文件的交互次数，从而提高了读写效率。</p>
<h5 id="G-转换流"><a href="#G-转换流" class="headerlink" title="G.转换流"></a>G.转换流</h5><h6 id="①概述-7"><a href="#①概述-7" class="headerlink" title="①概述"></a>①概述</h6><ul>
<li><p>转换流是处理流中的一种。</p>
</li>
<li><p>转换流：提供了在字节流和字符流之间的转换。</p>
</li>
<li><p>Java中提供了两个转换流：</p>
<ul>
<li>InputStreamReader：将一个字节的输入流转换为字符的输入流</li>
<li>OutputStreamWriter：将一个字符的输出流转换为字节的输出流</li>
<li>上面两个流属于字符流</li>
<li>这两个流<strong>只能操作文本文件。</strong></li>
</ul>
</li>
<li><p>解码：字节、字节数组 —&gt; 字符数组、字符串</p>
<p>  编码：字符数组、字符串 —&gt; 字节、字节数组</p>
</li>
</ul>
<h6 id="②InputStreamReader"><a href="#②InputStreamReader" class="headerlink" title="②InputStreamReader"></a>②InputStreamReader</h6><p>​	InputStreamReader的使用，实现了字节的输入流到字符的输入流的转换</p>
<p>​	</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;dbcp.txt&quot;</span>);</span><br><span class="line"><span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(fis);<span class="comment">//使用系统默认的字符集</span></span><br><span class="line"><span class="comment">//InputStreamReader isr = new InputStreamReader(fis,&quot;UTF-8&quot;);//参数2指明了字符集，集体使用哪个字符集，取决于文件dbcp.txt保存时使用的字符集</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>[] cbuf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"><span class="keyword">while</span>((len = isr.read(cbuf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(cbuf,<span class="number">0</span>,len);</span><br><span class="line">    System.out.print(str);</span><br><span class="line">&#125;</span><br><span class="line">isr.close();</span><br><span class="line"><span class="comment">//注意：此代码还没有用try-catch-finally进行异常处理</span></span><br></pre></td></tr></table></figure>



<h6 id="②OutputStreamWriter"><a href="#②OutputStreamWriter" class="headerlink" title="②OutputStreamWriter"></a>②OutputStreamWriter</h6><p><img src="/imgs/image-20220903214413204.png" alt="image-20220903214413204"></p>
<p>上述过程的代码实现：</p>
<p><img src="/imgs/image-20220903214048047.png" alt="image-20220903214048047"></p>
<p>​	注意：上面代码并没有用try-catch-finally处理异常，自己写的时候要补上。</p>
<h5 id="H-字符集"><a href="#H-字符集" class="headerlink" title="H.字符集"></a>H.字符集</h5><h6 id="①编码表"><a href="#①编码表" class="headerlink" title="①编码表"></a>①编码表</h6><p>​	计算机只能识别二进制数据，早期由来是电信号。为了方便应用计算机，让它可以识别各个国家的文字。就将各个国家的文字用数字来表示，并一一对应，形成一张表。这就是编码表。</p>
<h6 id="②常见编码表"><a href="#②常见编码表" class="headerlink" title="②常见编码表"></a>②常见编码表</h6><ul>
<li>ASCII：美国标准信息交换码。 用一个字节的7位可以表示。</li>
<li>ISO8859-1：拉丁码表。欧洲码表用一个字节的8位表示。</li>
<li>GB2312：中国的中文编码表。最多两个字节编码所有字符。兼容了ASCII，因为ASCII用一个字节就可以表示，不用用两个字节表示，这样可以节省空间。<ul>
<li>那怎么识别是一个字节表示一个字符还是两个字节表示一个字符呢？看字节中最左边的那位，如果是1，则表示它还有一个字节，即两个字节表示一个字符；如果是0，则一个字节表示一个字符。GBK也采用这种方式识别。</li>
</ul>
</li>
<li>GBK：中国的中文编码表升级，融合了更多的中文文字符号。最多两个字节编码。兼容了ASCII。</li>
<li>Unicode：国际标准码，融合了目前人类使用的所有字符。为每个字符分配唯一的字符码。所有的文字都用两个字节来表示。</li>
<li>UTF-8：变长的编码方式，可用1-4个字节来表示一个字符。（中文用3个字节存储。）UTF-8是Unicode的一种具体实现。</li>
</ul>
<h6 id="③启示"><a href="#③启示" class="headerlink" title="③启示"></a>③启示</h6><p>​	客户端、浏览器  &lt;—&gt; 后台 &lt;—-&gt; 数据库</p>
<p>​	为了保证不乱码，这三个部分都要统一字符集。 </p>
<h5 id="I-标准输入、输出流-了解"><a href="#I-标准输入、输出流-了解" class="headerlink" title="I.标准输入、输出流(了解)"></a>I.标准输入、输出流(了解)</h5><ul>
<li>标准输入、输出流是处理流中的一种。</li>
<li>in、out是System里的两个属性。</li>
<li>System.in和System.out分别代表了系统标准的输入和输出。</li>
<li>System.in：默认从键盘输入，字节流；System.out：默认从控制台（显示器）输出。</li>
<li>通过System类的setIn(InputStream is)，setOut(PrintStream ps)方法重新指定输入和输出的流。PrintStream是OutputStream的子类。</li>
</ul>
<h5 id="J-打印流-了解"><a href="#J-打印流-了解" class="headerlink" title="J.打印流(了解)"></a>J.打印流(了解)</h5><ul>
<li>打印流是处理流中的一种。</li>
<li>实现将基本数据类型的数据格式转化为字符串输出。</li>
<li>打印流：PrintStream（字节输出流）和PrintWriter（字符输出流）。</li>
<li>它们提供了一系列重载的print()和println()方法，用于多种数据类型的输出。为什么我们能通过print()就能接收不同类型的数据并输出，是因为调用了PrintStream中重载的print \ println方法。</li>
<li>System.out返回的是PrintStream的实例</li>
</ul>
<h6 id="①把控制台中输出的内容保存到文件"><a href="#①把控制台中输出的内容保存到文件" class="headerlink" title="①把控制台中输出的内容保存到文件"></a>①把控制台中输出的内容保存到文件</h6><p>​	步骤：</p>
<ol>
<li>创建FileOutputStream的对象，构造器中放File类的对象或直接放文件的路径。（指明要写入的文件）</li>
<li>因为打印流属于处理流，创建PrintStream类的对象时，将FileOutputStream的对象放进去构造器中。</li>
<li>用 if 判断打印流的对象是否为null，不为null，则System.setOut(打印流对象);</li>
<li>接下来写你想写的内容。</li>
<li>流的关闭操作。</li>
</ol>
<p>注意：要用try-catch-finally将1-4包起来</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">PrintStream</span> <span class="variable">pw</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;h.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//指明写入到的文件</span></span><br><span class="line">        pw = <span class="keyword">new</span> <span class="title class_">PrintStream</span>(fr,<span class="literal">true</span>);</span><br><span class="line">  <span class="comment">//创建打印输出流，设置为自动刷新模式（写入换行或&#x27;\n&#x27;时都会刷新输出缓冲区）</span></span><br><span class="line">        <span class="keyword">if</span> (pw != <span class="literal">null</span>)&#123;</span><br><span class="line">            System.setOut(pw);</span><br><span class="line">            <span class="comment">//把标准输出流（控制台输出）改成输出到指定文件</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="number">123</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pw != <span class="literal">null</span>)</span><br><span class="line">            pw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="K-数据流-了解"><a href="#K-数据流-了解" class="headerlink" title="K.数据流(了解)"></a>K.数据流(了解)</h5><h6 id="①概述-8"><a href="#①概述-8" class="headerlink" title="①概述"></a>①概述</h6><ul>
<li>数据流属于处理流的一种。</li>
<li>数据流：DataInputStream 和 DataOutputStream</li>
<li>分别“套接”在 InputStream 和 OutputStream 子类的流上。</li>
<li>数据流的作用：读取或写出基本数据类型的变量或字符串</li>
</ul>
<h6 id="②数据流中的方法"><a href="#②数据流中的方法" class="headerlink" title="②数据流中的方法"></a>②数据流中的方法</h6><p><img src="/imgs/image-20220904144442549.png" alt="image-20220904144442549"></p>
<h6 id="③数据流的使用"><a href="#③数据流的使用" class="headerlink" title="③数据流的使用"></a>③数据流的使用</h6><p>​	练习：将内存中的字符串、基本数据类型的变量写出到文件中。</p>
<p>​	注意：下面代码中并没用try-catch-finally对异常进行处理，写的时候要补上。</p>
<p>​				打开写出的数据文件，里面乱码是正常的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//1.创建数据流的对象，DataOutputStream的构造器需要传一个OutputStream子类的对象</span></span><br><span class="line">    <span class="type">DataOutputStream</span> <span class="variable">dis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;data.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.写入操作</span></span><br><span class="line">    dis.writeUTF(<span class="string">&quot;Tom&quot;</span>);<span class="comment">//writeUTF(String s):写入字符串</span></span><br><span class="line">    dis.flush();<span class="comment">//调用flush()将内存中的数据写入到文件中</span></span><br><span class="line">    dis.writeInt(<span class="number">12</span>);</span><br><span class="line">    dis.flush();</span><br><span class="line">    dis.writeBoolean(<span class="literal">true</span>);</span><br><span class="line">    dis.flush();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//流的关闭</span></span><br><span class="line">    dis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	</p>
<p>​	练习：将文件中存储的基本数据类型变量和字符串读取到内存中，然后再保存在变量中。</p>
<p>​	注意：面代码中并没用try-catch-finally对异常进行处理，写的时候要补上。</p>
<p>​				读数据的时候要与写数据时的顺序一样，不然报异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//1.造数据流的对象，其构造器中需要出入InputStream子类的对象</span></span><br><span class="line">    <span class="type">DataInputStream</span> <span class="variable">dis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;data.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.写数据的操作</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> dis.readUTF();</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> dis.readInt();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">c</span> <span class="operator">=</span> dis.readBoolean();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;name:&quot;</span> + s + <span class="string">&quot;ID:&quot;</span> + i + <span class="string">&quot;是否男&quot;</span> + c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.流的关闭</span></span><br><span class="line">    dis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="L-对象流"><a href="#L-对象流" class="headerlink" title="L.对象流"></a>L.对象流</h5><h6 id="①概述-9"><a href="#①概述-9" class="headerlink" title="①概述"></a>①概述</h6><p>​	<strong>对象流</strong>：用于存储和读取<strong>基本数据类型</strong>数据或<strong>对象</strong>的处理流。它的强大之处是可以把Java中的对象写入到数据源（如：文件）中，也能把对象从数据源中还原回来。</p>
<p>​	<strong>序列化</strong>：将内存中的Java对象保存到磁盘中或通过网络传输出去。使用ObjectOutputStream实现</p>
<p>​	<strong>逆序列化</strong>：将磁盘文件中的对象还原为内存中的一个Java对象。使用ObjectInputStream实现</p>
<p>​	<strong>对象流</strong>：<strong>ObjectInputStream</strong>、<strong>ObjectOutputStream</strong>，属于处理流的一种</p>
<p>​	<strong>对象能序列化、逆序列化的前提是其所在类必须是可序列化的。</strong></p>
<p>​	</p>
<h6 id="②对象序列化机制"><a href="#②对象序列化机制" class="headerlink" title="②对象序列化机制"></a>②对象序列化机制</h6><p>​	允许把内存中的Java对象转换成平台无关的二进制流，从而允许把这种二进制流持久地保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点（序列化）。当其它程序获取了这种二进制流，就可以恢复成原来的Java对象（逆序列化）。</p>
<p>​	实际上对象序列化机制就是描述了一下序列化和逆序列化。</p>
<h6 id="③对象流的使用"><a href="#③对象流的使用" class="headerlink" title="③对象流的使用"></a>③对象流的使用</h6><p>​	A.ObjectOutputStream的使用</p>
<p>​	实现步骤：</p>
<ol>
<li><p>造ObjectOutputStream对象。</p>
<p> 但该构造器需要传OutputStream的子类，因此造FileOutputStream的对象放进去。将要写入的文件放到FileOutputStream构造器中。</p>
</li>
<li><p>调用writeObject(要写入的对象)，将对象写入文件中</p>
</li>
<li><p>流的关闭</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.造ObjectOutputStream对象</span></span><br><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;object.dat&quot;</span>));</span><br><span class="line"><span class="comment">//2.写入数据</span></span><br><span class="line">oos.writeObject(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;123&quot;</span>));</span><br><span class="line">oos.flush();</span><br><span class="line"><span class="comment">//关闭流</span></span><br><span class="line">oos.close();</span><br></pre></td></tr></table></figure>

<p>注意：上面代码存在异常，需要try-catch-finally进行异常处理</p>
<p>​	B.ObjectInputStream的使用</p>
<p>​	实现步骤：</p>
<ol>
<li><p>造ObjectInputStream对象。</p>
<p> 但该构造器需要传InputStream的子类，因此造FileInputStream的对象放进去。将要读入的文件放到FileInputStream构造器中。</p>
</li>
<li><p>调用readObject()，从文件中读取对象</p>
</li>
<li><p>流的关闭</p>
</li>
</ol>
<p>​	注意：上面代码存在异常，需要try-catch-finally进行异常处理</p>
<h6 id="④自定义类可序列化"><a href="#④自定义类可序列化" class="headerlink" title="④自定义类可序列化"></a>④自定义类可序列化</h6><p>​	要想自定义类能够保存在磁盘或从磁盘读出到内存，该对象所在类必须是可序列化的。具体实现步骤为：</p>
<ol>
<li><p>需要实现接口：Serializable</p>
</li>
<li><p>当前类提供一个全局常量：serialVersionUID，该常量为Long型，值可以为随意的一个值。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1234567L</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>除当前类需要实现Serializable接口外，还必须保证其内部所有属性也是可序列化的。（基本数据类型、String：本身就已经是可序列化）</p>
</li>
<li><p>补充：ObjectOutputStream和ObjectInputStream不能序列化static和transient修饰的成员变量。即：被这两个关键字修饰的属性其值是不能被保存到文件中的，当我们用ObjectInputStream去读这些属性时，读出来的是默认值。</p>
</li>
</ol>
<p>​	为什么需要serialVersionUID？用于表识该对象属于哪个类。如果没有显示使用serialVersionUID，系统会根据类中的细节自动生成一个serialVersionUID，序列化的时候就把当时的serialVersionUID也存到磁盘中了；逆序列化的时候就拿着这个serialVersionUID去比对，如果修改了当前类的内容，类的serialVersionUID就会发生改变，此时对象中的serialVersionUID与类的serialVersionUID就对不上了，就会导致对象还原不回去。因此我们需要显示指明serialVersionUID。</p>
<hr>
<h5 id="M-随机存取文件流（了解）"><a href="#M-随机存取文件流（了解）" class="headerlink" title="M.随机存取文件流（了解）"></a>M.随机存取文件流（了解）</h5><h6 id="①概述-10"><a href="#①概述-10" class="headerlink" title="①概述"></a>①概述</h6><ul>
<li>RandomAccessFile直接继承于Java.lang.Object类，它没有继承那四个抽象基类。</li>
<li>RandomAccessFile实现了DataInput、DataOutput这两个接口，因此它既可以作为一个输入流，又可以作为一个输出流。</li>
</ul>
<h6 id="②RandomAccessFile的使用"><a href="#②RandomAccessFile的使用" class="headerlink" title="②RandomAccessFile的使用"></a>②RandomAccessFile的使用</h6><p>​	<strong>构造器</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">RandomAccessFile</span><span class="params">(File file,String mode)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">RandomAccessFile</span><span class="params">(String name,String mode)</span></span><br><span class="line"><span class="comment">//name:指明要写入或读入的文件，可以写文件的相对路径或文件的绝对路径（其本质上还是造了一个File类的对象）</span></span><br><span class="line"><span class="comment">//mode:指定RandomAccessFile的访问模式：见下图，普通的写操作选rw就行</span></span><br></pre></td></tr></table></figure>

<p><img src="/imgs/image-20220905141403405.png" alt="image-20220905141403405"></p>
<p>​	使用例子：（注：下面代码没有用try-catch-finally对异常进行处理，写的时候要补上）<img src="/imgs/image-20220905142709003.png" alt="image-20220905142709003"></p>
<p>​	虽然此类既可以是输入流，也可以是输出流。对于读写操作，我们还是得造两个对象来分别处理读操作、写操作。</p>
<h6 id="③说明"><a href="#③说明" class="headerlink" title="③说明"></a>③说明</h6><ul>
<li>进行写出操作时，如果该文件不存在，就会造一个新的文件。<ul>
<li>如果文件存在，则会对原有文件内容进行覆盖。（默认情况下，从头覆盖）</li>
</ul>
</li>
<li>write()：该方法实现的效果为对文件内容的覆盖（在文件原本存在的情况下）</li>
</ul>
<h6 id="④方法"><a href="#④方法" class="headerlink" title="④方法"></a>④方法</h6><ol>
<li><p>seek(long pos)：该方法的作用是将指针调到文件中角标为pos的位置，角标从0开始。<img src="/imgs/image-20220905150208025.png" alt="image-20220905150208025"></p>
<p> 从角标为3的位置开始对文件内容进行覆盖。</p>
<p> 如果想在文件末尾进行添加数据，则将pos设置为当前文件的大小（调用File类中的length方法即可），再使用write方法。</p>
</li>
</ol>
<h6 id="⑤应用"><a href="#⑤应用" class="headerlink" title="⑤应用"></a>⑤应用</h6><p>​	该类可应用于文件的断点续传操作。</p>
<h5 id="N-NIO-2中Path、Paths、Files类的使用（了解）"><a href="#N-NIO-2中Path、Paths、Files类的使用（了解）" class="headerlink" title="N.NIO.2中Path、Paths、Files类的使用（了解）"></a>N.NIO.2中Path、Paths、Files类的使用（了解）</h5><h6 id="①理解"><a href="#①理解" class="headerlink" title="①理解"></a>①理解</h6><ul>
<li>Java NIO (New IO，Non-Blocking IO)是从Java 1.4版本开始引入的一套新的IO API，可以替代标准的Java IO API。NIO与原来的IO有同样的作用和目的，但是使用的方式完全不同，NIO支持面向缓冲区的(IO是面向流的)、基于通道的IO操作。NIO将以更加高效的方式进行文件的读写操作。</li>
<li>随着 JDK 7 的发布，Java对NIO进行了极大的扩展，增强了对文件处理和文件系统特性的支持，以至于我们称他们为 NIO.2。</li>
</ul>
<h6 id="②Path"><a href="#②Path" class="headerlink" title="②Path"></a>②Path</h6><p>​	<strong>引入</strong>：</p>
<p>​	早期的Java只提供了一个File类来访问文件系统，但File类的功能比较有限，所提供的方法性能也不高。而且，大多数方法在出错时仅返回失败，并不会提供异常信息。NIO. 2为了弥补这种不足，引入了Path接口。<strong>实际上，Path可以看成是File类的升级版本，实际引用的资源也可以不存在。</strong></p>
<p><img src="/imgs/image-20220905160945668.png" alt="image-20220905160945668"></p>
<p>​	Path中的常用方法：</p>
<p><img src="/imgs/image-20220905161408689.png" alt="image-20220905161408689"></p>
<h6 id="③Paths"><a href="#③Paths" class="headerlink" title="③Paths"></a>③Paths</h6><p>​	Paths是一个类，用于创建Path对象的。</p>
<p>​	Paths类提供的静态get()方法用来获取Path对象</p>
<p><img src="/imgs/image-20220905161318974.png" alt="image-20220905161318974"></p>
<h6 id="④Files"><a href="#④Files" class="headerlink" title="④Files"></a>④Files</h6><p>​	用于操作文件或文件目录的工具类	</p>
<p>​	常用方法：</p>
<p><img src="/imgs/image-20220905161649470.png" alt="image-20220905161649470"><img src="/imgs/image-20220905161705595.png" alt="image-20220905161705595"></p>
<h5 id="O-ByteArrayOutputStream"><a href="#O-ByteArrayOutputStream" class="headerlink" title="O.ByteArrayOutputStream"></a>O.ByteArrayOutputStream</h5><h6 id="①概述-11"><a href="#①概述-11" class="headerlink" title="①概述"></a>①概述</h6><p>​	该流可用于存储字节流数据，并将字符流数据保存到 byte[ ] 数组中。如：</p>
<h6 id="②toString"><a href="#②toString" class="headerlink" title="②toString()"></a>②toString()</h6><p>​	该方法可以将ByteArrayOutputStream底层中的 byte[ ] 转换为字符串</p>
<h6 id="③getBytes"><a href="#③getBytes" class="headerlink" title="③getBytes()"></a>③getBytes()</h6><p>​	该方法属于String类中的方法，可以将字符串转换为一个byte数组</p>
<h6 id="④例子"><a href="#④例子" class="headerlink" title="④例子"></a>④例子</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//h.txt文件中存放了abc,现在想将此文件中的英文字母全转为大写再输出到文件uph.txt中</span></span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;h.txt&quot;</span>);</span><br><span class="line"><span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line"><span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造器不需要形参</span></span><br><span class="line"><span class="keyword">while</span>((len = fis.read(buffer)) != <span class="literal">null</span>)&#123;</span><br><span class="line">    baos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">toUpperCase</span> <span class="operator">=</span> baos.toString().toUpperCase();</span><br><span class="line"></span><br><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;uph.txt&quot;</span>);</span><br><span class="line"><span class="comment">//因为fos属于字节流，只能向里面添加字节流数据，因此需要将字符串转换为byte数组再写入到文件中</span></span><br><span class="line">fos.write(toUpperCase.getBytes());</span><br></pre></td></tr></table></figure>



<h4 id="8、网络编程"><a href="#8、网络编程" class="headerlink" title="8、网络编程"></a>8、网络编程</h4><h5 id="①网络编程概述"><a href="#①网络编程概述" class="headerlink" title="①网络编程概述"></a>①网络编程概述</h5><h6 id="A-网络编程的目的"><a href="#A-网络编程的目的" class="headerlink" title="A.网络编程的目的"></a>A.网络编程的目的</h6><ul>
<li>直接或间接地通过网络协议与其它计算机实现数据交换，进行通讯。</li>
</ul>
<h6 id="B-网络编程中有两个主要的问题"><a href="#B-网络编程中有两个主要的问题" class="headerlink" title="B.网络编程中有两个主要的问题"></a>B.网络编程中有两个主要的问题</h6><ol>
<li><p>如何准确地定位网络上一台或多台主机；定位主机上的特定的应用。</p>
<ul>
<li>IP：区分主机。</li>
<li>端口号：区分一个主机上不同的应用程序。</li>
</ul>
</li>
<li><p>找到主机后如何可靠高效地进行数据传输。</p>
<p> 一定的规则（即网络通信协议，有两套参考模型）：</p>
<ul>
<li>OSI参考模型：模型过于理想化，未能在因特网上广泛推广。</li>
<li>TCP&#x2F;IP参考模型：事实上的国际标准。</li>
</ul>
<p> <img src="/imgs/image-20220905205609057.png" alt="image-20220905205609057"></p>
<p> 层与层之间是可以进行数据传输的，如：</p>
</li>
</ol>
<p><img src="/imgs/image-20220905205705818.png" alt="image-20220905205705818"></p>
<p>​	</p>
<h6 id="C-通信要素1–IP和端口号"><a href="#C-通信要素1–IP和端口号" class="headerlink" title="C.通信要素1–IP和端口号"></a>C.通信要素1–IP和端口号</h6><p>​	<strong>IP</strong>：</p>
<ul>
<li><p>Java中用InetAddress类来表示IP，一个具体的InetAddress对象就是一个具体的IP地址。</p>
</li>
<li><p>IP分类：IPV4 和 IPV6；公网地址(万维网使用)和私有地址(局域网使用)</p>
</li>
<li><p>域名：如：<a target="_blank" rel="noopener" href="http://www.baidu.com、www.vip.com等,本质上对应着一个ip地址./">www.baidu.com、www.vip.com等，本质上对应着一个IP地址。</a></p>
<ul>
<li>当我们在网站中输入一个域名时，先会去找主机host下是否有这个域名存在，没有则发送给域名解析服务器（DNS），让其解析域名并向主机返回该域名对应的IP地址，主机就拿着这个IP地址去访问相应的网站了。</li>
</ul>
</li>
<li><p>本机IP地址：127.0.0.1 ；对应的域名为：Localhost</p>
</li>
<li><p>实例化 InetAddress 两个方法：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.getByName（String host）</span></span><br><span class="line"><span class="type">InetAddress</span> <span class="variable">inet</span> <span class="operator">=</span> InetAddress.getByName(String host);<span class="comment">//返回的是对应域名或IP的对象。注意：该方法会抛异常，我们需要try-catch-finally</span></span><br><span class="line"><span class="comment">//host可以是具体的一个IP地址或域名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.getLocalHost（）</span></span><br><span class="line"><span class="type">InetAddress</span> <span class="variable">inet1</span> <span class="operator">=</span> InetAddress.getLocalHost();<span class="comment">//获取本机的IP地址</span></span><br></pre></td></tr></table></figure>

<p>  两个常用方法：获取域名getHostName()，获取IP地址getHostAddress()</p>
</li>
</ul>
<p>​	<strong>端口号</strong>：</p>
<ul>
<li>端口号用来标识正在计算机上运行的进程（程序）；不同的进程有不同的端口号。被规定为一个 16 位的整数 0~65535。</li>
<li>端口号分类（了解）<ul>
<li>公认端口：0~1023。被预先定义的服务通信占用（如：HTTP占用端口80，FTP占用端口21，Telnet占用端口23）</li>
<li>注册端口：1024~49151。分配给用户进程或应用程序。（如：Tomcat占用端口8080，MySQL占用端口3306，Oracle占用端口1521等）。</li>
<li>动态&#x2F;私有端口：49152~65535。</li>
</ul>
</li>
<li>端口号与IP地址的组合得出一个网络套接字：Socket。</li>
</ul>
<h6 id="D-通信要素2–网络协议"><a href="#D-通信要素2–网络协议" class="headerlink" title="D.通信要素2–网络协议"></a>D.通信要素2–网络协议</h6><p>​	<strong>引入</strong>：我们知道了IP和端口号后，就可以进行数据传输了，但怎么传涉及到了网络协议。</p>
<p>​	<strong>TCP</strong></p>
<ul>
<li><p>使用TCP协议前，须先建立TCP连接，形成传输数据通道。</p>
</li>
<li><p>传输前，采用“三次握手”方式，点对点通信，是可靠的。</p>
</li>
<li><p>TCP协议进行通信的两个应用进程：客户端、服务端。</p>
</li>
<li><p>在连接中可进行大数据量的传输。</p>
</li>
<li><p>传输完毕，需释放已建立的连接，效率低（相较于UDP）。</p>
</li>
<li><p><strong>三次握手</strong></p>
<p>  <img src="/imgs/20201108194729168.png" alt="在这里插入图片描述"></p>
<p>  形象理解：<br>  A：你在吗，我是A<br>  B：我在呢，我是B<br>  A：你在就行跟你说个事，我是A</p>
<ul>
<li>“<strong>四次挥手</strong>”</li>
</ul>
</li>
</ul>
<p><img src="/imgs/20201108201307379.png" alt="在这里插入图片描述"></p>
<p>​	“四次挥手”即终止TCP连接。</p>
<p>​		形象理解：像结婚要双方同意才可以。A向B请求断开连接，B反馈。B再向A请求断开连接，A再反馈。两方都断开才是真正的断开。</p>
<p>​	<strong>UDP</strong>：</p>
<ul>
<li>将数据、源、目的封装成数据包，<strong>不需要建立连接</strong>。</li>
<li>每个数据报的大小限制在64K内 。数据比较大时，需要分多个包发送。</li>
<li>发送不管对方是否准备好，接收方收到也不确认，故是<strong>不可靠</strong>的。</li>
<li>发送数据结束时无需释放资源，开销小，速度快。</li>
</ul>
<h5 id="②TCP网络编程"><a href="#②TCP网络编程" class="headerlink" title="②TCP网络编程"></a>②TCP网络编程</h5><h6 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h6><ul>
<li>创建Socket对象，指明服务器端的IP和端口号。</li>
<li>用Socket对象调用getOutputStream()方法，获取一个输出流。用于给客户端发送信息。</li>
<li>拿着输出流调用write()进行数据输出操作。</li>
<li>Socket、流的关闭。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">client</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//1.创建Socket对象，指明服务器端的IP与端口号</span></span><br><span class="line">	<span class="type">InetAddress</span> <span class="variable">inet</span> <span class="operator">=</span>InetAddress.getByName(<span class="string">&quot;127.0.0.1);//服务端的IP地址</span></span><br><span class="line"><span class="string">	Socket socket=new Socket(inet,8899);//端口号8899</span></span><br><span class="line"><span class="string">	</span></span><br><span class="line"><span class="string">//2.获取一个输出流，用于输出数据</span></span><br><span class="line"><span class="string">	OutputStream os=socket.getOutputStream();</span></span><br><span class="line"><span class="string">	</span></span><br><span class="line"><span class="string">//3.写出数据</span></span><br><span class="line"><span class="string">	os.write(&quot;</span>你好，我是客户端<span class="string">&quot;);</span></span><br><span class="line"><span class="string">	</span></span><br><span class="line"><span class="string">//4.资源关闭</span></span><br><span class="line"><span class="string">	os.close();</span></span><br><span class="line"><span class="string">	socket.close();</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>​	注意：上面代码存在异常，需要用try-catch-finally对其进行异常处理</p>
<h6 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h6><ul>
<li>创建服务器端的ServerSocket，指明服务器的端口号。</li>
<li>用上面创建的对象去调用accept()，接收来自客户端的socket。</li>
<li>用获取到的socket对象去调用getInputStream()，获取输入流。</li>
<li>用流的对象去调用read()方法，进行相应的读操作。</li>
<li>关闭ServerSocket、socket、流</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务端</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">server</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//1.创建Socket对象，指明自己的端口号</span></span><br><span class="line">	ServerSocket s=<span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8899</span>);</span><br><span class="line"><span class="comment">//2.调用accept()表示接收来自于客户端的socket</span></span><br><span class="line">	Socket socket=s.acept();</span><br><span class="line"><span class="comment">//3.获取输入流</span></span><br><span class="line">	InputStream is=socket.getInputStream();</span><br><span class="line">	</span><br><span class="line"><span class="comment">//不建议这样写，一个中文3个字节，5太小，两个中文时，第二个字被分开存会出现乱码</span></span><br><span class="line">	<span class="comment">/*byte[] buffer=new byte[5];</span></span><br><span class="line"><span class="comment">	int len;</span></span><br><span class="line"><span class="comment">	while((len=is.read(buffer))!=-1)</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		String str=new String(buffer,0,len);</span></span><br><span class="line"><span class="comment">		System.out.print(str);</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"><span class="comment">//建议如下写：</span></span><br><span class="line"><span class="comment">//4.读取输入流中的数据</span></span><br><span class="line">	ByteArrayOutputStream baos=<span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();<span class="comment">//这时写入的内容在ByteArrayOutputStream的数组里，不会每5个就还原，而是等所有的输完后整体转换，所以不会出现乱码。</span></span><br><span class="line">	<span class="type">byte</span>[] buffer=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span>];</span><br><span class="line">	<span class="type">int</span> len;</span><br><span class="line">	<span class="keyword">while</span>((len=is.read(buffer))!=-<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		baos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.print(baos.toString());</span><br><span class="line">	</span><br><span class="line"><span class="comment">//5.资源关闭</span></span><br><span class="line">	baos.close();</span><br><span class="line">	is.close();</span><br><span class="line">	socket.close();</span><br><span class="line">	ss.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	上面代码会抛异常，我们需要用try把除关闭操作外的代码包起来，将关闭操作的代码放到finally里。</p>
<h5 id="③UDP网络编程（了解）"><a href="#③UDP网络编程（了解）" class="headerlink" title="③UDP网络编程（了解）"></a>③UDP网络编程（了解）</h5><p>（1）类 DatagramSocket 和 DatagramPacket 实现了基于 UDP 协议网络程序。</p>
<p>（2）UDP数据报通过数据报套接字 DatagramSocket 发送和接收，系统不保证UDP数据报一定能够安全送到目的地，也不能确定什么时候可以抵达。</p>
<p>（3）DatagramPacket 对象封装了UDP数据报，在数据报中包含了发送端的IP地址和端口号以及接收端的IP地址和端口号。</p>
<p>（4）UDP协议中每个数据报都给出了完整的地址信息，因此无须建立发送方和接收方的连接。如同发快递包裹一样。</p>
<h5 id="④URL编程"><a href="#④URL编程" class="headerlink" title="④URL编程"></a>④URL编程</h5><h6 id="A-URL"><a href="#A-URL" class="headerlink" title="A.URL"></a>A.URL</h6><p>​	<strong>URL</strong>：统一资源定位符，它表示 Internet 上某一资源的地址。</p>
<p>​	<strong>URL的基本结构由5部分组成</strong>：</p>
<pre><code> &lt;传输协议&gt;://&lt;主机名&gt;:&lt;端口号&gt;/&lt;文件名&gt;#片段名?参数列表   
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/examples/beauty.jpg?usernam=Tom</span><br><span class="line">协议   主机名    端口号 资源地址            参数列表 </span><br><span class="line">主机名：相当于IP </span><br></pre></td></tr></table></figure>

<p>​	</p>
<h6 id="B-实例化URL对象"><a href="#B-实例化URL对象" class="headerlink" title="B.实例化URL对象"></a>B.实例化URL对象</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://localhost:8080/examples/beauty.jpg?usernam=Tom&quot;</span>);</span><br></pre></td></tr></table></figure>

<h6 id="C-常用方法"><a href="#C-常用方法" class="headerlink" title="C.常用方法"></a>C.常用方法</h6><p><img src="/imgs/image-20220906181630928.png" alt="image-20220906181630928"></p>
<h6 id="D-用于"><a href="#D-用于" class="headerlink" title="D.用于"></a>D.用于</h6><p>编程实现对网络资源的获取并进行保存</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://localhost:8080/examples/beauty.jpg?usernam=Tom&quot;</span>);</span><br><span class="line">        <span class="comment">//下面两行代码获取与服务器的连接</span></span><br><span class="line">        <span class="type">HttpURLConnection</span> <span class="variable">connection</span> <span class="operator">=</span> (HttpURLConnection) url.openConnection();</span><br><span class="line">        connection.connect();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取到连接后就可以将网站中的资源读取进来了</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">stream</span> <span class="operator">=</span> connection.getInputStream();</span><br><span class="line">        <span class="comment">//下面就是对流的读取操作（略）</span></span><br><span class="line">        <span class="comment">//关闭流</span></span><br><span class="line">	<span class="comment">//关闭与服务器的连接</span></span><br><span class="line">        connection.disconnection();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	上面代码要用try-catch-finally进行处理</p>
<h4 id="9、反射"><a href="#9、反射" class="headerlink" title="9、反射"></a>9、反射</h4><p>本节重点：红色字部分+笔记⑤体会反射的动态性+笔记⑦调用运行时类的指定结构+笔记⑥中的重点关注</p>
<img src="C:\Users\橙子\AppData\Roaming\Typora\typora-user-images\image-20220908170508164.png" alt="image-20220908170508164" style="zoom: 50%;" />

<h5 id="①引入"><a href="#①引入" class="headerlink" title="①引入"></a>①引入</h5><p>​	后端运行起来后，当前端发送一个登录操作的URL给后端时，后端就会根据登录来造登录的对象，再通过对象调用相应方法实现登录操作；前端发送注册操作的URL给后端，后端就造注册的对象，再调用相应方法实现注册。我们运行时才知道造哪个类的对象，这就需要用到反射了。</p>
<h5 id="②反射概述"><a href="#②反射概述" class="headerlink" title="②反射概述"></a>②反射概述</h5><h6 id="A-Java是准动态语言"><a href="#A-Java是准动态语言" class="headerlink" title="A.Java是准动态语言"></a>A.Java是准动态语言</h6><p>​	反射具有动态的特性，从而让Java有了一定的动态性，所以Java属于准动态语言。</p>
<h6 id="B-反射提供的功能"><a href="#B-反射提供的功能" class="headerlink" title="B.反射提供的功能"></a>B.反射提供的功能</h6><ul>
<li>在运行时判断任意一个对象所属的类</li>
<li>在运行时构造任意一个类的对象</li>
<li>在运行时判断任意一个类所具有的成员变量和方法</li>
<li>在运行时获取泛型信息</li>
<li>在运行时调用任意一个对象的成员变量和方法</li>
<li>在运行时处理注解</li>
<li>生成动态代理</li>
</ul>
<h6 id="C-相关主要API"><a href="#C-相关主要API" class="headerlink" title="C.相关主要API"></a>C.相关主要API</h6><ul>
<li>java.lang.Class:代表一个类</li>
<li>java.lang.reflect.Method:代表类的方法</li>
<li>java.lang.reflect.Field:代表类的成员变量</li>
<li>java.lang.reflect.Constructor:代表类的构造器</li>
</ul>
<p>注：如果用到了最后三个API，需要导包</p>
<h5 id="③关于java-lang-Class类的理解"><a href="#③关于java-lang-Class类的理解" class="headerlink" title="③关于java.lang.Class类的理解"></a>③关于java.lang.Class类的理解</h5><p>​	任何的反射操作都要先造Class类的对象，所以Class类被称为反射源。</p>
<h6 id="A-类的加载过程"><a href="#A-类的加载过程" class="headerlink" title="A.类的加载过程"></a>A.类的加载过程</h6><p>​	程序经过javac.exe命令后，会生成一个或多个字节码文件（.class结尾，一个类对应一个字节码文件）。<br>​	接着使用java.exe命令对某个字节码文件进行解释运行。相当于将某个字节码文件加载到内存中。此过程就称为<strong>类的加载</strong>。加载到内存中的类，称为<strong>运行时类</strong>，此运行时类，就作为<strong>class的一个实例</strong>。</p>
<p>​	换句话说，<strong>Class的实例就对应着一个运行时类</strong>。</p>
<h6 id="B-获取Class的实例的方式（前三种方式需要掌握）"><a href="#B-获取Class的实例的方式（前三种方式需要掌握）" class="headerlink" title="B.获取Class的实例的方式（前三种方式需要掌握）"></a>B.获取Class的实例的方式（前三种方式需要掌握）</h6><p>​	Class是一个泛型类，在声明时可以指明其泛型类型，指明后就可以在后续操作中不用强转。</p>
<ol>
<li><p>方式一：调用运行时类的属性：.class</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz1</span> <span class="operator">=</span> Person.class;</span><br></pre></td></tr></table></figure>
</li>
<li><p>方式二：通过运行时类的对象，调用getClass()</p>
</li>
</ol>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz2</span> <span class="operator">=</span> p1.getClass();</span><br><span class="line"><span class="comment">//getClass()：获取该对象是由哪个类造的</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>方式三：调用Class的静态方法：forName(String classPath)</li>
</ol>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz3</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.atguigu.java.Person&quot;</span>);</span><br><span class="line"><span class="comment">//该方法会抛异常</span></span><br><span class="line"><span class="comment">//这种创建方式体现了反射的动态性</span></span><br></pre></td></tr></table></figure>

<p>  classPath：被称为全类名，即：写出该类是属于哪个包下的类</p>
<p>  这种方式在开发中<strong>使用频率最高</strong>。</p>
<ol start="4">
<li><p>方式四(了解)：使用类的加载器：ClassLoader</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader classLoaser = </span><br><span class="line">当前写代码的类的类名.class.getClassLoader();</span><br><span class="line">Class clazz4 = classLoader.loadClass(&quot;要加载的类的全类名&quot;);</span><br></pre></td></tr></table></figure></li>
</ol>
<h6 id="C-注意"><a href="#C-注意" class="headerlink" title="C.注意"></a>C.注意</h6><p>​	以上四个Class类的对象都是指向同一个运行时类（Person）。</p>
<h6 id="D-补充（了解）"><a href="#D-补充（了解）" class="headerlink" title="D.补充（了解）"></a>D.补充（了解）</h6><p>​	<img src="/imgs/image-20220908121533209.png" alt="image-20220908121533209"></p>
<p>​	例子：</p>
<p><img src="/imgs/image-20220908121637256.png" alt="image-20220908121637256"></p>
<h6 id="E-类的加载器"><a href="#E-类的加载器" class="headerlink" title="E.类的加载器"></a>E.类的加载器</h6><p>​	类的加载器的作用：将class文件字节码内容加载到内存中，然后在堆中生成一个Class类的实例。</p>
<p>​	<strong>类的加载器的分类</strong>：（了解）</p>
<ul>
<li><p>(Bootstap Classloader)<strong>引导类加载器</strong>：是JVM自带的类加载器，负责Java平台核心库，用来装载核心类库中的类。该加载器无法直接获取。</p>
</li>
<li><p>(Extension Classloader)<strong>扩展类加载器</strong>：负责jre&#x2F;lib&#x2F;ext目录下的jar包或 –D java.ext.dirs 指定目录下的jar包装入工作库。jar包：将class文件打包</p>
</li>
<li><p>(System Classloader)<strong>系统类加载器</strong>：负责加载自定义类</p>
<h5 id="④创建运行时类的对象"><a href="#④创建运行时类的对象" class="headerlink" title="④创建运行时类的对象"></a>④创建运行时类的对象</h5><p>  用<strong>Class</strong>类的对象去调用<strong>newIstance()<strong>方法（</strong>该方法会抛异常</strong>），该方法内部调用了运行时类的空参构造器。要想此方法正常的创建运行时类的对象，要求：</p>
<ul>
<li>运行时类必须提供空参的构造器</li>
<li>空参的构造器的权限修饰符要大于private。通常，设置为public。</li>
</ul>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;<span class="comment">//clazz指向了方法区中的Person类，因此造对象的时候也只能造Person类的对象，不能造其他类的对象。</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> (Person)o;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果在创建Class类的对象时指明泛型类型，就可以省略第3行代码</span></span><br><span class="line">Class&lt;Person&gt; clazz1 = Person.class;</span><br><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> clazz1.newInstance();<span class="comment">//直接返回Person类的对象。</span></span><br></pre></td></tr></table></figure>

<p>  ​	如果想调用带参数的构造器也是可以的，表不过通常都是调用空参的构造器。</p>
<h5 id="⑤体会反射的动态性"><a href="#⑤体会反射的动态性" class="headerlink" title="⑤体会反射的动态性"></a>⑤体会反射的动态性</h5>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> num=<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">3</span>);</span><br><span class="line">	String classPath=<span class="string">&quot;&quot;</span>;</span><br><span class="line">	<span class="keyword">switch</span>(num)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">			classPath=<span class="string">&quot;java.util.Date&quot;</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">			classPath=<span class="string">&quot;java.lang.Object&quot;</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">			classPath=<span class="string">&quot;com.attang.java.Person&quot;</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Object obj=getInstance(classPath);</span><br><span class="line">	System.out.println(obj);</span><br><span class="line"></span><br><span class="line">	Public Object <span class="title function_">getInstance</span><span class="params">(String classPath)</span></span><br><span class="line">	&#123;</span><br><span class="line">		Class clazz=Class.forName(classPath);</span><br><span class="line">		<span class="keyword">return</span> class.newInstance();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  ​	<strong>只有在运行时才能确定造的是哪个对象。</strong></p>
<h5 id="⑥获取运行时类的完整结构（了解）"><a href="#⑥获取运行时类的完整结构（了解）" class="headerlink" title="⑥获取运行时类的完整结构（了解）"></a>⑥获取运行时类的完整结构（了解）</h5><h6 id="A-获取属性结构"><a href="#A-获取属性结构" class="headerlink" title="A.获取属性结构"></a>A.获取属性结构</h6><p>  ​	通过Class类的对象去调用。</p>
<p>  ​	getFields()：获取当前运行时类及其父类中声明为public访问权限的属性。</p>
<p>  ​	getDeclaredFields()：获取当前运行时类中声明的所有属性。（不包括父类中声明的属性）</p>
<p>  ​	拿到一个属性后，我们还可以获取当前属性的数据类型、权限修饰符、属性名等信息。</p>
<h6 id="B-获取方法结构"><a href="#B-获取方法结构" class="headerlink" title="B.获取方法结构"></a>B.获取方法结构</h6><p>  ​	通过Class类的对象去调用。</p>
<p>  ​	getMethods()：获取当前运行时类及其所有父类中声明为public权限的方法</p>
<p>  ​	getDeclaredMethods()：获取当前运行时类中声明的所有方法。（不包含父类中声明的方法）</p>
<p>  ​	获取到具体的一个方法之后，我们可以接着获取该方法的权限修饰符、返回值类型、方法名、形参列表、注解、抛出异常类型。</p>
<h6 id="C-获取构造器结构"><a href="#C-获取构造器结构" class="headerlink" title="C.获取构造器结构"></a>C.获取构造器结构</h6><p>  ​	通过Class类的对象去调用。</p>
<p>  ​	getConstructors()：获取当前运行时类中声明为public的构造器。（不包括父类中的构造器）</p>
<p>  ​	getDeclaredConstructors()：获取当前运行时类中声明的所有构造器。（不包括父类中的构造器）</p>
<h6 id="D-获取运行时类的父类"><a href="#D-获取运行时类的父类" class="headerlink" title="D.获取运行时类的父类"></a>D.获取运行时类的父类</h6><p>  ​	通过Class类的对象去调用。</p>
<p>  ​	getSuperclass()：获取当前运行类的父类</p>
<p>  ​	getGenericSuperclass()：获取当前运行类的父类（带泛型的父类）</p>
<h6 id="E-获取当前运行时类的父类的泛型"><a href="#E-获取当前运行时类的父类的泛型" class="headerlink" title="E.获取当前运行时类的父类的泛型"></a>E.获取当前运行时类的父类的泛型</h6>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line"><span class="type">Type</span> <span class="variable">genericSuperclass</span> <span class="operator">=</span> clazz.getGenericSuperclass();</span><br><span class="line"><span class="type">ParameterizedType</span> <span class="variable">paramType</span> <span class="operator">=</span> (ParameterizedType)genericSuperclass;</span><br><span class="line">Type[] actualTypeArguments = paramType.getActualTypeArguments();</span><br><span class="line">System.out.print(actualTypeArguments[<span class="number">0</span>].getTypeName());</span><br></pre></td></tr></table></figure>

<h6 id="F-获取当前运行时类实现的接口"><a href="#F-获取当前运行时类实现的接口" class="headerlink" title="F.获取当前运行时类实现的接口"></a>F.获取当前运行时类实现的接口</h6><p>  ​	通过Class类的对象去调用。</p>
<p>  ​	getInterfaces()：获取当前运行时类实现的接口（不包括父类的接口，要想获取父类实现的接口，就先得获取父类，再接着调用getInterfaces()）</p>
<h6 id="G-获取当前运行时类所在的包"><a href="#G-获取当前运行时类所在的包" class="headerlink" title="G.获取当前运行时类所在的包"></a>G.获取当前运行时类所在的包</h6><p>  ​	通过Class类的对象去调用。</p>
<p>  ​	getPackage()：获取当前运行时类所在的包</p>
<h6 id="H-获取运行时类声明的注解"><a href="#H-获取运行时类声明的注解" class="headerlink" title="H.获取运行时类声明的注解"></a>H.获取运行时类声明的注解</h6><p>  ​	通过Class类的对象去调用。</p>
<p>  ​	getAnnotations()：读取当前运行时类的注解</p>
<h6 id="需要重点了解的是"><a href="#需要重点了解的是" class="headerlink" title="需要重点了解的是"></a>需要重点了解的是</h6><p>  ​	E、F、H</p>
<hr>
<h5 id="⑦调用运行时类的指定结构"><a href="#⑦调用运行时类的指定结构" class="headerlink" title="⑦调用运行时类的指定结构"></a>⑦调用运行时类的指定结构</h5><p>  ​	这里我们重点关注：属性、方法、构造器</p>
<h6 id="A-如何操作运行时类中指定的属性"><a href="#A-如何操作运行时类中指定的属性" class="headerlink" title="A.如何操作运行时类中指定的属性"></a>A.如何操作运行时类中指定的属性</h6><p>  ​	实现步骤：</p>
<ol>
<li>造Class类的对象</li>
<li>创建运行时类的对象</li>
<li>用Class类的对象去调用getDeclaredField(String fieldName)，获取运行时类中指定变量名的属性（注意：<strong>获取不了父类中的属性</strong>）</li>
<li>用获取到的属性调用setAccessible(true)方法，保证当前属性是可访问的（如果不调用该方法，就不能对声明为private的属性进行赋值或获取操作）</li>
<li>用获取到的属性调用set(Object obj,Object value)实现赋值操作，调用get(Object   obj)实现获取属性值操作。其中：obj为要对哪个对象进行操作，value：属性值要设置多少</li>
</ol>
<p>  补充：<strong>如果获取的是静态的属性</strong>，则将步骤2去掉，步骤5中的obj写null或“当前运行时类.class”</p>
<p>  ​	代码实现：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="comment">//1.声明Class类的对象</span></span><br><span class="line">    Class&lt;Person&gt; clazz = (Class&lt;Person&gt;) Class.forName(<span class="string">&quot;com.zzc.javatest.Person&quot;</span>);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//2.创建运行时类的对象</span></span><br><span class="line">    <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.获取运行时类中指定变量名的属性</span></span><br><span class="line">    <span class="type">Field</span> <span class="variable">des</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.对获取到的属性进行赋值或获取操作</span></span><br><span class="line">    des.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    des.set(person,<span class="number">1001</span>);</span><br><span class="line">    System.out.println(des.get(person));</span><br><span class="line">    </span><br><span class="line"> <span class="comment">//第三行代码为什么需要强转？因为该forName方法本身返回的是Class&lt;?&gt;类型数据，而clazz是Class&lt;Person&gt;类型，所有就需要强转。Class&lt;?&gt;是Class&lt;Person&gt;的父类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="B-如何操作运行时类中指定的方法"><a href="#B-如何操作运行时类中指定的方法" class="headerlink" title="B.如何操作运行时类中指定的方法"></a>B.如何操作运行时类中指定的方法</h6><p>  ​	<strong>调用非静态的方法</strong>：</p>
<p>  ​	实现步骤：</p>
<ol>
<li>造Class的实例</li>
<li>造运行时类的对象</li>
<li>用Class类的对象去调用getDeclareMethod(String methodName,方法的形参列表)，参数1：指明获取的方法的名称，参数2：指明获取的方法的形参列表，没有就不用写，有则这样写：“数据类型.class”</li>
<li>用获取到的方法调用setAccessible(true)，保证当前方法是可访问的</li>
<li>调用方法的invoke()：参数1：方法的调用者，参数2：实参，invoke()的返回值即为对应类中调用的方法的返回值。如果没有返回值，则返回的是null。</li>
</ol>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="comment">//1.</span></span><br><span class="line">    Class&lt;Person&gt; clazz = (Class&lt;Person&gt;) Class.forName(<span class="string">&quot;com.zzc.javatest.Person&quot;</span>);</span><br><span class="line">    <span class="comment">//2.</span></span><br><span class="line">    <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line">    <span class="comment">//3.</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">show</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;show&quot;</span>);</span><br><span class="line">    <span class="comment">//4.</span></span><br><span class="line">    show.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">//5.</span></span><br><span class="line">    show.invoke(person);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  ​	<strong>调用静态的方法</strong>：</p>
<p>  ​	<strong>实现步骤</strong>：</p>
<ol>
<li>造Class的实例</li>
<li>用Class类的对象去调用getDeclareMethod(String methodName,方法的形参列表)，参数1：指明获取的方法的名称，参数2：指明获取的方法的形参列表，没有就不用写</li>
<li>用获取到的方法调用setAccessible(true)，保证当前方法是可访问的</li>
<li>调用方法的invoke()：参数1：null或“当前运行时类.class”，参数2：实参，invoke()的返回值即为对应类中调用的方法的返回值。如果没有返回值，则返回的是null。</li>
</ol>
<h6 id="C-如何调用运行时类中指定的构造器"><a href="#C-如何调用运行时类中指定的构造器" class="headerlink" title="C.如何调用运行时类中指定的构造器"></a>C.如何调用运行时类中指定的构造器</h6><p>  ​	<strong>实现步骤</strong>：</p>
<ol>
<li>造Class的实例</li>
<li>用Class的对象去调用getDeclaredConstructor()：参数：指明构造器的参数列表，写参数的时候要这样写：“数据类型.class”。该方法会抛异常。</li>
<li>用获取到的构造器去调用setAccessible(true)，保证此构造器是可访问的</li>
<li>调用此构造器创建运行时类的对象，使用newInstance(实参)</li>
</ol>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="comment">//1.</span></span><br><span class="line">    Class&lt;Person&gt; clazz = (Class&lt;Person&gt;) Class.forName(<span class="string">&quot;com.zzc.javatest.Person&quot;</span>);</span><br><span class="line">    <span class="comment">//2.</span></span><br><span class="line">    Constructor&lt;Person&gt; constructor = clazz.getDeclaredConstructor(String.class, <span class="type">int</span>.class);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.</span></span><br><span class="line">    constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">//4.</span></span><br><span class="line">    <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> constructor.newInstance(<span class="string">&quot;Tom&quot;</span>, <span class="number">12</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="⑧反射应用–动态代理"><a href="#⑧反射应用–动态代理" class="headerlink" title="⑧反射应用–动态代理"></a>⑧反射应用–动态代理</h5><h6 id="①概述-12"><a href="#①概述-12" class="headerlink" title="①概述"></a>①概述</h6><p>  ​	<strong>代理模式</strong>：通过代理类的对象来间接调用被代理类中的方法。</p>
<p>  ​	<strong>代理模式的具体实现</strong>：代理类和被代理类都实现同一个（堆）接口，然后通过代理类的对象来调用方法，如：show()方法，当调用该方法时，实际上调用的是被代理类里的show()方法。从而实现间接操作被代理中的方法。</p>
<p>  ​	<strong>动态代理</strong>：接口、被代理类要先造好，而代理类是动态创建。</p>
<h6 id="②静态代理实现"><a href="#②静态代理实现" class="headerlink" title="②静态代理实现"></a>②静态代理实现</h6><p>  ​	见：笔记12、面向对象中的其他关键字 —&gt; interface –&gt; ⑦</p>
<h6 id="③动态代理实现"><a href="#③动态代理实现" class="headerlink" title="③动态代理实现"></a>③动态代理实现</h6><p>  ​	基础阶段先了解，到框架部分再深入</p>
<hr>
<h4 id="10、Java8的一些新特性"><a href="#10、Java8的一些新特性" class="headerlink" title="10、Java8的一些新特性"></a>10、Java8的一些新特性</h4><h5 id="①概述-13"><a href="#①概述-13" class="headerlink" title="①概述"></a>①概述</h5><p>  ​	java8：</p>
<ul>
<li>速度更快</li>
<li>代码更少(增加了新的语法：Lambda 表达式)</li>
<li>强大的 Stream API</li>
<li>便于并行</li>
<li>最大化减少空指针异常：Optional</li>
<li>Nashorn引擎，允许在JVM上运行JS应用</li>
</ul>
<h5 id="②Lambda表达式"><a href="#②Lambda表达式" class="headerlink" title="②Lambda表达式"></a>②Lambda表达式</h5><h6 id="A-Lambda表达式的举例"><a href="#A-Lambda表达式的举例" class="headerlink" title="A.Lambda表达式的举例"></a>A.Lambda表达式的举例</h6>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(o1,o2) -&gt; Integer.compare(o1,o2);</span><br></pre></td></tr></table></figure>

<h6 id="B-格式"><a href="#B-格式" class="headerlink" title="B.格式"></a>B.格式</h6><p>  ​		-&gt; ：Lambda操作符 或 箭头操作符</p>
<p>  ​		操作符左边：Lambda形参列表（其实就是接口中的抽象方法的形参列表）</p>
<p>  ​		操作符右边：Lambda体（其实就是重写的抽象方法的方法体）</p>
<h6 id="C-Lambda表达式的使用"><a href="#C-Lambda表达式的使用" class="headerlink" title="C.Lambda表达式的使用"></a>C.Lambda表达式的使用</h6><p>  ​		Lambda表达式的本质：函数式接口的匿名实现类的对象。</p>
<p>  ​		总结：</p>
<ol>
<li>操作符左边：Lambda形参列表的参数类型可以省略（类型推断）；如果Lambda形参列表只有一个参数，其一对（）也可以省略。	</li>
<li>操作符右边：Lambda体应该使用一对{ }包裹：如果Lambda体只有一条执行语句（可能是return语句），可以省略这一对{}和return关键字（如果省略{ }，则return必须一起省略）。</li>
</ol>
<h6 id="D-注意"><a href="#D-注意" class="headerlink" title="D.注意"></a>D.注意</h6><p>  ​	Lambda表达式使用前提是：只能使用在接口，且该接口只能是函数式接口（即该接口里只有一个抽象方法）</p>
<h6 id="E-应用场景"><a href="#E-应用场景" class="headerlink" title="E.应用场景"></a>E.应用场景</h6><p>  ​	当函数式接口要创建一个匿名实现类的对象时，我们就可以使用Lambda表达式了。</p>
<hr>
<h5 id="③函数式接口"><a href="#③函数式接口" class="headerlink" title="③函数式接口"></a>③函数式接口</h5><h6 id="A-定义"><a href="#A-定义" class="headerlink" title="A.定义"></a>A.定义</h6><p>  ​	接口中只有一个抽象方法的接口，称为函数式接口。</p>
<p>  ​	我们可以在一个接口上使用 @FunctionalInterface 注解，这样做可以检查它是否是一个函数式接口。</p>
<h6 id="B-Java内置四大核心函数式接口"><a href="#B-Java内置四大核心函数式接口" class="headerlink" title="B.Java内置四大核心函数式接口"></a>B.Java内置四大核心函数式接口</h6><p>  <img src="/imgs/image-20220910134838862.png" alt="image-20220910134838862"></p>
<p>  <img src="/imgs/image-20220910142024000.png" alt="image-20220910142024000"></p>
<p>  ​	以后当见到上面的函数式接口时，我们都可以使用Lambda表达式来造函数式接口的实现类对象。</p>
<h6 id="C-如何使用给定的函数式接口"><a href="#C-如何使用给定的函数式接口" class="headerlink" title="C.如何使用给定的函数式接口"></a>C.如何使用给定的函数式接口</h6><p>  ​	如果我们开发中需要定义一个函数式接口，首先看看在已有的jdk提供的函数式接口是否提供了能满足需求的函数式接口。如果有，则直接调用即可，不需要自己再定义了。</p>
<hr>
<h5 id="④方法引用"><a href="#④方法引用" class="headerlink" title="④方法引用"></a>④方法引用</h5><h6 id="A-使用情景"><a href="#A-使用情景" class="headerlink" title="A.使用情景"></a>A.使用情景</h6><p>  ​	当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用。即：当Lambda体中只有一条语句，且这条语句是：通过对象或类调用了某个方法，像这种情况，我们就可以考虑使用方法引用了，具体能不能使用得看方法引用的使用规则。</p>
<p>  ​	方法引用，本质上就是Lambda表达式，而Lambda表达式作为函数式接口的实例。所以方法引用，也就是函数式接口的实例。</p>
<h6 id="B-格式-1"><a href="#B-格式-1" class="headerlink" title="B.格式"></a>B.格式</h6><p>  ​	格式：类（或对象） :: 方法名</p>
<p>  ​	具体可以分成如下三种情况：</p>
<ol>
<li><p>对象 :: 非静态方法</p>
</li>
<li><p>类 :: 静态方法</p>
</li>
<li><p>类 :: 非静态方法</p>
<p> 以上的方法只写方法名，不用写形参</p>
</li>
</ol>
<h6 id="C-方法引用使用规则"><a href="#C-方法引用使用规则" class="headerlink" title="C.方法引用使用规则"></a>C.方法引用使用规则</h6><ul>
<li>当Lambda体中调用的方法的形参列表和返回值类型与接口中的抽象方法的形参列表和返回值类型相同时，我们就可以使用格式中情况1或情况2来写方法引用，具体选哪个？<ul>
<li>当Lambda体中调用的方法为静态方法，则使用格式中的情况2来写方法引用。</li>
<li>当Lambda体中调用的方法为非静态方法，则使用格式中的情况1来写方法引用。</li>
</ul>
</li>
<li>当Lambda体中调用的方法属于非静态时，选择情况1还是选择情况3呢？<ul>
<li>当抽象方法中的形参为两个（t1,t2），而Lambda体中调用的方法的形参只有一个（t2）而t1作为方法引用的方法的调用者时，我们选择格式中的情况3。</li>
<li>当抽象方法中的形参为一个（t1），而Lambda体中调用的方法的形参为0个，而t1作为方法引用的方法的调用者时，我们选择格式中的情况3。</li>
</ul>
</li>
</ul>
<h6 id="D-具体举例"><a href="#D-具体举例" class="headerlink" title="D.具体举例"></a>D.具体举例</h6><p>  ​	①对象 :: 非静态方法</p>
<p>  ​		例一：</p>
<p>  ​	<img src="/imgs/2021011516393733.png" alt="在这里插入图片描述"></p>
<p>  ​		例二：</p>
<p>  <img src="/imgs/20210115165554334.png" alt="在这里插入图片描述"></p>
<p>  ​	②类::静态方法名</p>
<p>  ​		例一：</p>
<p>  <img src="/imgs/20210115170257876.png" alt="在这里插入图片描述"></p>
<p>  ​		例二：</p>
<p>  <img src="/imgs/20210115170516947.png" alt="在这里插入图片描述"></p>
<p>  ​	③类::实例方法名</p>
<p>  ​	第一个参数作为方法的调用者。</p>
<p>  ​		例一：</p>
<p>  <img src="/imgs/20210115171750232.png" alt="在这里插入图片描述"></p>
<p>  ​		例二：</p>
<p>  <img src="/imgs/20210115171858864.png" alt="在这里插入图片描述"></p>
<p>  ​	最后一句写错了，是pre2</p>
<p>  ​		例三：</p>
<p>  <img src="/imgs/20210115172037108.png" alt="在这里插入图片描述"></p>
<hr>
<h5 id="⑤构造器引用"><a href="#⑤构造器引用" class="headerlink" title="⑤构造器引用"></a>⑤构造器引用</h5><h6 id="A-概述-1"><a href="#A-概述-1" class="headerlink" title="A.概述"></a>A.概述</h6><p>  ​	如果Lambda体中只有一条语句且该语句属于创建对象的语句，那么就可以考虑使用构造器引用，具体能不能使用得看看是否符合构造器引用规则。</p>
<h6 id="B-格式-2"><a href="#B-格式-2" class="headerlink" title="B.格式"></a>B.格式</h6><p>  ​	类名 :: new</p>
<h6 id="C-构造器引用规则"><a href="#C-构造器引用规则" class="headerlink" title="C.构造器引用规则"></a>C.构造器引用规则</h6><p>  ​	函数式接口的抽象方法的形参列表和构造器的形参列表一致。抽象方法的返回值类型即为构造器所属的类的类型。</p>
<h6 id="D-例子"><a href="#D-例子" class="headerlink" title="D.例子"></a>D.例子</h6><p>  ​	例一：</p>
<p>  <img src="/imgs/20210115172827686.png" alt="在这里插入图片描述"></p>
<p>  ​	例二：</p>
<p>  <img src="/imgs/20210115172800444.png" alt="在这里插入图片描述"></p>
<p>  ​	例三：</p>
<p>  <img src="/imgs/20210115172940482.png" alt="在这里插入图片描述"></p>
<hr>
<h5 id="⑥数组引用（？）"><a href="#⑥数组引用（？）" class="headerlink" title="⑥数组引用（？）"></a>⑥数组引用（？）</h5><p>  ​	当Lambda体中只有一条语句且该语句属于创建数组的语句，像这种情况，我们就可以使用数组引用。</p>
<h6 id="A-格式"><a href="#A-格式" class="headerlink" title="A.格式"></a>A.格式</h6><p>  ​	数组类型[ ] :: new</p>
<h6 id="B-使用"><a href="#B-使用" class="headerlink" title="B.使用"></a>B.使用</h6><p>  ​	大家可以把数组看做是一个特殊的类，则写法与构造器引用一致。</p>
<p>  <img src="/imgs/20210115173412647.png" alt="在这里插入图片描述"></p>
<hr>
<h4 id="11、Java8新特性—Stream-API"><a href="#11、Java8新特性—Stream-API" class="headerlink" title="11、Java8新特性—Stream API"></a>11、Java8新特性—Stream API</h4><h5 id="A-概述-2"><a href="#A-概述-2" class="headerlink" title="A.概述"></a>A.概述</h5><ol>
<li><p>Stream是用来对集合中的数据进行计算操作的API，与CPU打交道</p>
<p> 集合关注的是数据的存储，与内存打交道</p>
</li>
<li><p>为什么需要Stream API？</p>
<p> 通常像MySQL这些数据库属于强关系数据库，对数据的过滤操作（如：查询大于3的数据）都是在数据库中完成的，而像Radis、MongDB这些弱关系数据库，则需要在Java层面实现数据的过滤操作。</p>
</li>
<li><p><strong>注意</strong></p>
<ul>
<li>Stream 自己不会存储元素。</li>
<li>Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。</li>
<li>Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。</li>
</ul>
</li>
<li><p><strong>Stream执行流程</strong></p>
<p> ①Stream的实例化</p>
<p> ②一系列的中间操作（过滤、映射….）</p>
<p> ③终止操作</p>
</li>
<li><p><strong>说明</strong></p>
<ul>
<li>中间操作：一个中间操作链，对数据源的数据进行处理</li>
<li>终止操作(终端操作) ：一旦执行终止操作，就执行中间操作链，并产生结果。之后，<strong>Stram对象就不能再被使用。如果还想执行操作，得重新造Stream对象</strong>。</li>
</ul>
</li>
</ol>
<h5 id="B-Stream实例化"><a href="#B-Stream实例化" class="headerlink" title="B.Stream实例化"></a>B.Stream实例化</h5><h6 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h6><p>  ​		<strong>通过集合创建</strong></p>
<p>  ​		<strong>A</strong>.调用集合Collection中默认方法stream()来实例化</p>
<p>  ​			①先造Collection的实现类的对象</p>
<p>  ​			②通过上面造的对象调用stream()方法，该方法返回一个顺序流（读取到的数据顺序与集合中存储数据的顺序一样）</p>
<p>  ​		<strong>B</strong>.调用集合Collection中默认方法parallelStream()来实例化</p>
<p>  ​			①先造Collection的实现类的对象</p>
<p>  ​			②通过上面造的对象调用stream()方法，该方法返回一个并行流。（相当于用多个线程同时对集合中的数据进行读取）</p>
<h6 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h6><p>  ​		<strong>通过数组</strong></p>
<p>  ​		调用<strong>Arrays</strong>里的静态方法**stream()**，把数组放到方法的形参中，返回一个stream对象</p>
<h6 id="方式三"><a href="#方式三" class="headerlink" title="方式三"></a>方式三</h6><p>  ​		通过Stream的of()方法，通过显示值创建一个流，它可以接收任意数量任意类型的参数。</p>
<p>  ​		public static&lt; T &gt; Stream&lt; T &gt; of(T… values) : 返回一个流</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream = Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<p>  ​		该方法适用于：<strong>现造现用</strong>的情况</p>
<h6 id="方法四（了解）"><a href="#方法四（了解）" class="headerlink" title="方法四（了解）"></a>方法四（了解）</h6><p>  ​		创建无限流</p>
<p>  ​		可以使用静态方法 Stream.iterate() 和 Stream.generate(), 创建无限流。</p>
<hr>
<h5 id="C-中间操作–筛选与切片"><a href="#C-中间操作–筛选与切片" class="headerlink" title="C.中间操作–筛选与切片"></a>C.中间操作–筛选与切片</h5><h6 id="①filter-Predicate-p"><a href="#①filter-Predicate-p" class="headerlink" title="①filter(Predicate p)"></a>①filter(Predicate p)</h6><p>  ​			该方法的作用：从集合中排除某些元素，返回一个新的Stream对象</p>
<p>  ​			实现：</p>
<p>  ​			①用Stream的对象去调用filter()方法</p>
<p>  ​			②在该方法的形参里放Predicate接口的匿名实现类的对象（可以选择用Lambda表达式表示）</p>
<p>  ​			③在Predicate 接口的抽象方法test里写具体的过滤操作</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list1.add(<span class="number">1</span>);</span><br><span class="line">    list1.add(<span class="number">2</span>);</span><br><span class="line">    list1.add(<span class="number">3</span>);</span><br><span class="line">    list1.add(<span class="number">4</span>);</span><br><span class="line">	<span class="comment">//1.Stream的实例化</span></span><br><span class="line">    Stream&lt;Integer&gt; stream = list1.stream();</span><br><span class="line">	<span class="comment">//2.调用filter</span></span><br><span class="line">    stream.filter(<span class="keyword">new</span> <span class="title class_">Predicate</span>&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(Integer integer)</span> &#123;</span><br><span class="line">            <span class="comment">//3.写过滤条件</span></span><br><span class="line">            <span class="keyword">return</span> integer &gt; <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).forEach(System.out::println);</span><br><span class="line">    <span class="comment">//上面的写法可以改成用Lambda表达式写</span></span><br><span class="line"> <span class="comment">//stream.filter(integer -&gt; integer &gt; 2).forEach(System.out::println);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//运行结果为：3 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="②limit-n"><a href="#②limit-n" class="headerlink" title="②limit(n)"></a>②limit(n)</h6><p>  ​		截断流，使其元素不超过给定数量。即：从容器的开始端读取n个数据。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stream.limit(<span class="number">3</span>).forEach(System.out::println);<span class="comment">//1，2，3</span></span><br></pre></td></tr></table></figure>

<h6 id="③skip-n"><a href="#③skip-n" class="headerlink" title="③skip(n)"></a>③skip(n)</h6><p>  ​		跳过元素，返回一个扔掉了前n个元素的流。若流中元素不足n个，则返回一个空流。与limit(n)互补。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stream.skip(<span class="number">3</span>).forEach(System.out::println);<span class="comment">//4</span></span><br></pre></td></tr></table></figure>

<h6 id="④distinct"><a href="#④distinct" class="headerlink" title="④distinct()"></a>④distinct()</h6><p>  ​		筛选，通过流所生成元素的hasCode() 和 equals() 去除重复元素</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list1.add(<span class="number">1</span>);</span><br><span class="line">list1.add(<span class="number">2</span>);</span><br><span class="line">list1.add(<span class="number">3</span>);</span><br><span class="line">list1.add(<span class="number">4</span>);</span><br><span class="line">list1.add(<span class="number">4</span>);</span><br><span class="line">Stream&lt;Integer&gt; stream = list1.stream();</span><br><span class="line">stream.distinct().forEach(System.out::println);<span class="comment">//1，2，3，4</span></span><br></pre></td></tr></table></figure>

<h5 id="D-中间操作–映射"><a href="#D-中间操作–映射" class="headerlink" title="D.中间操作–映射"></a>D.中间操作–映射</h5><h6 id="①map-Function-f"><a href="#①map-Function-f" class="headerlink" title="①map(Function f)"></a>①map(Function f)</h6><p>  ​	map(Function f)：依次遍历Stream里的每一个元素，然后按照映射规则对元素进行操作。</p>
<p>  ​	实现：</p>
<p>  ​		①Stream对象调用map方法，往map方法的形参中传入实现Function接口的实现类的对象。</p>
<p>  ​		②在Function接口的抽象方法中写映射的规则</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"> list1.add(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line"> list1.add(<span class="string">&quot;bb&quot;</span>);</span><br><span class="line"> list1.add(<span class="string">&quot;cc&quot;</span>);</span><br><span class="line"> Stream&lt;String&gt; stream = list1.stream();</span><br><span class="line"> stream.map(<span class="keyword">new</span> <span class="title class_">Function</span>&lt;String, Object&gt;() &#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> Object <span class="title function_">apply</span><span class="params">(String string)</span> &#123;</span><br><span class="line">         <span class="comment">//映射规则</span></span><br><span class="line">         <span class="keyword">return</span> string.toUpperCase();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;).forEach(System.out::println);</span><br><span class="line"><span class="comment">//将6-12行代码用Lambda表达式表示</span></span><br><span class="line"><span class="comment">//stream.map(str -&gt; str.toUpperCase()).forEach(System.out::println);</span></span><br><span class="line"><span class="comment">//运行结果：AA,BB,CC</span></span><br></pre></td></tr></table></figure>

<h6 id="②flatMap-Function-f-不会"><a href="#②flatMap-Function-f-不会" class="headerlink" title="②flatMap(Function f)     不会"></a>②flatMap(Function f)     不会</h6><p>  ​		将流中的每个值都换成另一个流，然后把所有流连接成一个流</p>
<h5 id="E-中间操作–排序"><a href="#E-中间操作–排序" class="headerlink" title="E.中间操作–排序"></a>E.中间操作–排序</h5><p>  ​	对集合或数组中的元素进行排序操作</p>
<h6 id="①sorted-自然排序"><a href="#①sorted-自然排序" class="headerlink" title="①sorted()  自然排序"></a>①sorted()  自然排序</h6><p>  ​	使用要求：集合中的元素或数组中的元素所在类要实现Comparable接口。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    ArrayList&lt;Person&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">12</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jerry&quot;</span>,<span class="number">22</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jack&quot;</span>,<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    list.stream().sorted().forEach(System.out::println);</span><br><span class="line">    <span class="comment">//sorted方法实际上调用的是Person类里的compareTo方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="②sorted-Comparator-com-定制排序"><a href="#②sorted-Comparator-com-定制排序" class="headerlink" title="②sorted(Comparator com)  定制排序"></a>②sorted(Comparator com)  定制排序</h6><p>  ​	参数里放实现了Comparator接口的实现类的对象</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    ArrayList&lt;Person&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">12</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jerry&quot;</span>,<span class="number">22</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jack&quot;</span>,<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">	<span class="comment">//定制排序</span></span><br><span class="line">    list.stream().sorted(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Person&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Person o1, Person o2)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> o1.getName().compareTo(o2.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//如果使用Lambda表达式则这样写：</span></span><br><span class="line"><span class="comment">//list.stream().sorted(((o1, o2) -&gt; o1.getName().compareTo(o2.getName()))).forEach(System.out::println);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="F-终结操作–匹配与查找"><a href="#F-终结操作–匹配与查找" class="headerlink" title="F.终结操作–匹配与查找"></a>F.终结操作–匹配与查找</h5><h6 id="①allMatch-Predicate-p"><a href="#①allMatch-Predicate-p" class="headerlink" title="①allMatch(Predicate p)"></a>①allMatch(Predicate p)</h6><ul>
<li>判断集合中或数组中的元素是否都满足Predicate接口中抽象方法里的操作，只有都返回true，allMatch才返回true。</li>
<li>匹配规则写在Predicate接口中的抽象方法里。</li>
</ul>
<h6 id="②anyMatch-Predicate-p"><a href="#②anyMatch-Predicate-p" class="headerlink" title="②anyMatch(Predicate p)"></a>②anyMatch(Predicate p)</h6><ul>
<li>判断集合或数组中的元素是否满足Predicate接口中的抽象方法里的匹配规则，只要有一个元素满足，则返回true。</li>
<li>匹配规则写在Predicate接口中的抽象方法里。</li>
</ul>
<h6 id="③noneMatch-Predicate-p"><a href="#③noneMatch-Predicate-p" class="headerlink" title="③noneMatch(Predicate p)"></a>③noneMatch(Predicate p)</h6><ul>
<li>检查数组或集合中是否没有匹配的元素，返回布偶值。</li>
<li>匹配规则写在Predicate接口中的抽象方法里。</li>
</ul>
<h6 id="④findFirst"><a href="#④findFirst" class="headerlink" title="④findFirst()"></a>④findFirst()</h6><ul>
<li>返回当前Stream里的第一个元素。</li>
</ul>
<h6 id="⑤findAny"><a href="#⑤findAny" class="headerlink" title="⑤findAny()"></a>⑤findAny()</h6><ul>
<li>返回当前流中的任意一个元素。</li>
</ul>
<h6 id="⑥count"><a href="#⑥count" class="headerlink" title="⑥count()"></a>⑥count()</h6><ul>
<li>返回流中元素的个数。</li>
</ul>
<h6 id="⑦max-Comparator-c"><a href="#⑦max-Comparator-c" class="headerlink" title="⑦max(Comparator c)"></a>⑦max(Comparator c)</h6><ul>
<li>返回流中最大值，将比较的规则写在Comparator接口里的抽象方法中。</li>
<li>Comparator属于函数式接口，可以使用Lambda表达式。</li>
</ul>
<h6 id="⑧min-Comparator-c"><a href="#⑧min-Comparator-c" class="headerlink" title="⑧min(Comparator c)"></a>⑧min(Comparator c)</h6><ul>
<li>返回流中最小值，将比较的规则写在Comparator接口里的抽象方法中。</li>
<li>Comparator属于函数式接口，可以使用Lambda表达式。</li>
</ul>
<h6 id="⑨forEach-Consumer-c"><a href="#⑨forEach-Consumer-c" class="headerlink" title="⑨forEach(Consumer c)"></a>⑨forEach(Consumer c)</h6><ul>
<li><p>内部迭代，通常这样写：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">forEach(System.out::print);<span class="comment">//对流中的元素进行遍历输出</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="G-终结操作–规约"><a href="#G-终结操作–规约" class="headerlink" title="G.终结操作–规约"></a>G.终结操作–规约</h5><p>  ​	规约：即求和操作</p>
<h6 id="①reduce-T-identity-BinaryOperator"><a href="#①reduce-T-identity-BinaryOperator" class="headerlink" title="①reduce(T identity,BinaryOperator)"></a>①reduce(T identity,BinaryOperator)</h6><p>  ​	将流中的元素反复累加起来，得到一个值。相当于求和操作。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算1-10的自然数的和</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>);</span><br><span class="line">    <span class="comment">//reduce里的第一个参数为：累加的初始值</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">reduce</span> <span class="operator">=</span> list.stream().reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line">    <span class="comment">//Integer::sum含义：调用Integer里的sum方法</span></span><br><span class="line">    System.out.println(reduce);<span class="comment">//55</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="②reduce-BinaryOperator"><a href="#②reduce-BinaryOperator" class="headerlink" title="②reduce(BinaryOperator)"></a>②reduce(BinaryOperator)</h6><p>  ​	将流中元素反复累加起来，得到一个值，返回Optional<T>。与上面的一样，只是少了一个参数identity来指定累加的初始值。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算1-10的自然数的和</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">Integer</span> <span class="variable">reduce</span> <span class="operator">=</span> list.stream().reduce(Integer::sum);</span><br><span class="line">    <span class="comment">//Integer::sum含义：调用Integer里的sum方法</span></span><br><span class="line">    System.out.println(reduce);<span class="comment">//55</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="H-终结操作–收集"><a href="#H-终结操作–收集" class="headerlink" title="H.终结操作–收集"></a>H.终结操作–收集</h5><h6 id="①collect-Collector-c"><a href="#①collect-Collector-c" class="headerlink" title="①collect(Collector c)"></a>①collect(Collector c)</h6><p>  ​	<strong>方法作用</strong>：将Stream里的数据存储到集合（List、Map、set）中，并返回对应集合的对象。</p>
<p>  ​	Collector是接口，我们使用Collectors中的静态方法来返回一个Collector实现类的对象。</p>
<p>  ​	如果想将Stream里的数据放到：</p>
<ul>
<li>放到List中，将“Collectors.toList()”放到形参中即可</li>
<li>放到Set中，将“Collectors.toSet()”放到形参中即可</li>
<li>放到Map中2，将“Collectors.toMap()”放到形参中即可</li>
</ul>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>);</span><br><span class="line">    List&lt;Integer&gt; list1 = list.stream().filter(i -&gt; i &gt; <span class="number">5</span>).collect(Collectors.toList());</span><br><span class="line">    System.out.println(list1);<span class="comment">//[6, 7, 8, 9, 10]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="12、Java8新特性—Optional类"><a href="#12、Java8新特性—Optional类" class="headerlink" title="12、Java8新特性—Optional类"></a>12、Java8新特性—Optional类</h4><h5 id="①概述-14"><a href="#①概述-14" class="headerlink" title="①概述"></a>①概述</h5><p>  ​	为了避免出现空指针异常的情况，我们引入了Optional类。 </p>
<p>  ​	Optional&lt; T t &gt; 类(java.util.Optional) 是一个容器类，它可以将 t 的地址值赋给Optional的属性value，代表这个值存在。或者仅仅保存null，表示这个值不存在。原来用 null 表示一个值不存在，现在 Optional 可以更好的表达这个概念。并且可以避免空指针异常。</p>
<h5 id="②Optional类的方法"><a href="#②Optional类的方法" class="headerlink" title="②Optional类的方法"></a>②Optional类的方法</h5><h6 id="A-创建Optional类对象的方法"><a href="#A-创建Optional类对象的方法" class="headerlink" title="A.创建Optional类对象的方法"></a>A.创建Optional类对象的方法</h6><p>  ​	→ Optional.of(T t) : 封装数据 t 生成Optional对象，并将数据 t 的地址值赋给Optional内部的value。要求 t 非空，否则报错  </p>
<p>  ​	→ Optional.empty() : 创建了一个Optional对象，但其内部的value &#x3D; null。</p>
<p>  ​	→ **Optional.ofNullable(T t)**：封装数据 t 并将数据 t 的地址值赋给Optional内部的value，生成Optional对象。不要求 t 非空。 </p>
<h6 id="B-常用方法"><a href="#B-常用方法" class="headerlink" title="B.常用方法"></a>B.常用方法</h6><ol>
<li><p><strong>T orElse(T t1)</strong>      —-&gt; 该方法与ofNullable(T t)搭配使用</p>
<ul>
<li>该方法通过Optional类的对象去调用，Optional内部封装的value值或 t1</li>
<li>如果的当前的Optional对象内部封装的 value 是非空的，则返回此value值 。<ul>
<li>如果内部的 value 是空的，则返回orElse()方法中的参数 t1 。</li>
</ul>
</li>
</ul>
</li>
<li><p>T get()    ——&gt; 该方法与of(T t)搭配使用</p>
<ul>
<li>该方法通过Optional类的对象去调用。</li>
<li>如果Optional封装的数据value为空，则get()报错。否则，value不为空时，返回value。</li>
</ul>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    Optional&lt;String&gt; optionalS = Optional.ofNullable(s);</span><br><span class="line">    System.out.println(optionalS.get());<span class="comment">//hello</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p>boolean isPresent()</p>
<ul>
<li>该方法通过Optional类的对象去调用。</li>
<li>判断当前的Optional对象内部封装的 value 是否有值，有值返回true。</li>
</ul>
</li>
</ol>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://orangezzc.github.io/">OrangeZzc</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://orangezzc.github.io/2023/04/20/jdbc/">https://orangezzc.github.io/2023/04/20/jdbc/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://OrangeZzc.github.io" target="_blank">Orange's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JDBC/">JDBC</a></div><div class="post_share"><div class="social-share" data-image="/./imgs/jdbc.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2023/04/20/%E6%95%B0%E6%8D%AE%E5%BA%93/" title="数据库"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">数据库</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avater.jpeg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">OrangeZzc</div><div class="author-info__description">欢迎来到我的博客!</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">25</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/OrangeZzc" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:3486484066@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #24292e;"></i></a><a class="social-icon" href="http://wpa.qq.com/msgrd?v=3&amp;uin=3486484066&amp;site=qq&amp;menu=yes" target="_blank" title="QQ"><i class="fab fa-qq"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">如果在阅读过程中遇到了问题，可以随时联系我，看到了会在第一时间给出回复（不负责DEBUG，除非我真的写的有问题）</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81JDBC%E7%AE%80%E4%BB%8B"><span class="toc-text">一、JDBC简介</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0JDBC%E6%A6%82%E5%BF%B5"><span class="toc-text">①JDBC概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1JDBC%E6%9C%AC%E8%B4%A8"><span class="toc-text">②JDBC本质</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2JDBC%E5%A5%BD%E5%A4%84"><span class="toc-text">③JDBC好处</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A3%E8%A1%A5%E5%85%85"><span class="toc-text">④补充</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81JDBC%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8"><span class="toc-text">二、JDBC快速入门</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4"><span class="toc-text">①实现步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4%E7%9A%84%E8%AF%B4%E6%98%8E"><span class="toc-text">②实现步骤的说明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2JDBC-API%E8%AF%A6%E8%A7%A3"><span class="toc-text">③JDBC  API详解</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#A-DriverManager"><span class="toc-text">A.DriverManager</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A0%E6%A6%82%E8%BF%B0"><span class="toc-text">①概述</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A1%E6%B3%A8%E5%86%8C%E9%A9%B1%E5%8A%A8"><span class="toc-text">②注册驱动</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A2%E8%8E%B7%E5%8F%96%E8%BF%9E%E6%8E%A5"><span class="toc-text">③获取连接</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#B-Connection"><span class="toc-text">B.Connection</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A0%E4%BD%9C%E7%94%A8"><span class="toc-text">①作用</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A1%E8%8E%B7%E5%8F%96%E6%89%A7%E8%A1%8CSQL%E5%AF%B9%E8%B1%A1"><span class="toc-text">②获取执行SQL对象</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A2%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86"><span class="toc-text">③事务管理</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#C-Statement"><span class="toc-text">C.Statement</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A0%E4%BD%9C%E7%94%A8-1"><span class="toc-text">①作用</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A1%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95"><span class="toc-text">②相关方法</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#D-ResultSet"><span class="toc-text">D.ResultSet</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A0%E6%A6%82%E8%BF%B0-1"><span class="toc-text">①概述</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A1%E8%8E%B7%E5%8F%96%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C"><span class="toc-text">②获取查询结果</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A2%E7%BB%83%E4%B9%A0"><span class="toc-text">③练习</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#E-PreparedStatement"><span class="toc-text">E.PreparedStatement</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A0%E6%A6%82%E8%BF%B0-2"><span class="toc-text">①概述</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A1SQL%E6%B3%A8%E5%85%A5"><span class="toc-text">②SQL注入</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A2%E8%A7%A3%E5%86%B3SQL%E6%B3%A8%E5%85%A5"><span class="toc-text">③解决SQL注入</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A3%E8%A7%A3%E5%86%B3SQL%E6%B3%A8%E5%85%A5%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-text">④解决SQL注入的原理</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A4PreparedStatement%E5%8E%9F%E7%90%86"><span class="toc-text">⑤PreparedStatement原理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A3%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0"><span class="toc-text">④数据库连接池</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#A-%E6%A6%82%E8%BF%B0"><span class="toc-text">A.概述</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#B-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%AE%9E%E7%8E%B0"><span class="toc-text">B.数据库连接池实现</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A0%E6%A6%82%E8%BF%B0-3"><span class="toc-text">①概述</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A1Druid%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4"><span class="toc-text">②Druid使用步骤</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A2%E5%85%83%E8%A7%86%E5%9B%BE%E6%93%8D%E4%BD%9C%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%88%E5%8D%B3%E9%81%8D%E5%8E%86Map%EF%BC%89"><span class="toc-text">③元视图操作的方法（即遍历Map）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A3%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93"><span class="toc-text">④常用方法总结</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#M-Collections%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-text">M.Collections工具类</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A0%E5%8F%8D%E8%BD%AC"><span class="toc-text">①反转</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A1%E6%8E%92%E5%BA%8F"><span class="toc-text">②排序</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A2%E6%B1%82%E6%9C%80%E5%80%BC"><span class="toc-text">③求最值</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A3%E8%AE%A1%E7%AE%97%E6%9F%90%E5%85%83%E7%B4%A0%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0"><span class="toc-text">④计算某元素出现的次数</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A4%E5%A4%8D%E5%88%B6"><span class="toc-text">⑤复制</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A5%E6%9B%BF%E6%8D%A2"><span class="toc-text">⑥替换</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A6%E5%B0%86%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E9%9B%86%E5%90%88%E5%8F%98%E6%88%90%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%9B%86%E5%90%88"><span class="toc-text">⑦将线程不安全的集合变成线程安全集合</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E3%80%81%E6%B3%9B%E5%9E%8B"><span class="toc-text">6、泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#A-%E5%BC%95%E5%85%A5"><span class="toc-text">A.引入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#B-%E5%9C%A8%E9%9B%86%E5%90%88%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B"><span class="toc-text">B.在集合中使用泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%AF%B4%E6%98%8E"><span class="toc-text">说明</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#C-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B%E7%BB%93%E6%9E%84%E2%80%93%E6%B3%9B%E5%9E%8B%E7%B1%BB"><span class="toc-text">C.自定义泛型结构–泛型类</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A0%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-text">①实现方式</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A1%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E4%B8%AD%E7%9A%84%E6%B3%9B%E5%9E%8B"><span class="toc-text">②继承关系中的泛型</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A2%E7%BB%86%E8%8A%82%E8%AF%B4%E6%98%8E"><span class="toc-text">③细节说明</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A3%E5%BA%94%E7%94%A8"><span class="toc-text">④应用</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#D-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B%E7%BB%93%E6%9E%84%E2%80%93%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3"><span class="toc-text">D.自定义泛型结构–泛型接口</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A0%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F-1"><span class="toc-text">①实现方式</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#E-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B%E7%BB%93%E6%9E%84%E2%80%93%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-text">E.自定义泛型结构–泛型方法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A0%E5%AE%9A%E4%B9%89"><span class="toc-text">①定义</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A1%E6%A0%BC%E5%BC%8F"><span class="toc-text">②格式</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A2%E4%BD%BF%E7%94%A8"><span class="toc-text">③使用</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A3%E6%B3%A8%E6%84%8F"><span class="toc-text">④注意</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#F-%E6%B3%9B%E5%9E%8B%E5%9C%A8%E7%BB%A7%E6%89%BF%E6%96%B9%E9%9D%A2%E7%9A%84%E4%BD%93%E7%8E%B0"><span class="toc-text">F.泛型在继承方面的体现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#E-%E9%80%9A%E9%85%8D%E7%AC%A6%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">E.通配符的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A0%E5%AE%9A%E4%B9%89-1"><span class="toc-text">①定义</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A1%E5%BA%94%E7%94%A8%E4%BE%8B%E5%AD%90"><span class="toc-text">②应用例子</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A2%E4%BD%BF%E7%94%A8-1"><span class="toc-text">③使用</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A3%E6%9C%89%E9%99%90%E5%88%B6%E6%9D%A1%E4%BB%B6%E7%9A%84%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-text">④有限制条件的通配符</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A4%E5%85%B6%E4%BB%96"><span class="toc-text">⑤其他</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7%E3%80%81IO%E6%B5%81"><span class="toc-text">7、IO流</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#A-File%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">A.File类的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A0%E6%A6%82%E8%BF%B0-4"><span class="toc-text">①概述</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A1%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86"><span class="toc-text">②预备知识</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A2%E5%A6%82%E4%BD%95%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="toc-text">③如何实例化</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#B-File%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">B.File类的常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A0%E8%8E%B7%E5%8F%96%E7%9B%B8%E5%BA%94%E4%BF%A1%E6%81%AF"><span class="toc-text">①获取相应信息</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A1%E9%87%8D%E5%91%BD%E5%90%8D%E5%8A%9F%E8%83%BD"><span class="toc-text">②重命名功能</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A2%E5%88%A4%E6%96%AD%E5%8A%9F%E8%83%BD"><span class="toc-text">③判断功能</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A3%E5%9C%A8%E7%A1%AC%E7%9B%98%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%AF%B9%E5%BA%94%E7%9A%84%E6%96%87%E4%BB%B6%E6%88%96%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95"><span class="toc-text">④在硬盘中创建对应的文件或文件目录</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A4%E5%88%A0%E9%99%A4%E7%A1%AC%E7%9B%98%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E6%88%96%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95"><span class="toc-text">⑤删除硬盘中的文件或文件目录</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A5%E6%80%BB%E7%BB%93"><span class="toc-text">⑥总结</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#C-IO%E6%B5%81%E5%8E%9F%E7%90%86"><span class="toc-text">C.IO流原理</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A0%E6%A6%82%E8%BF%B0-5"><span class="toc-text">①概述</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A1%E6%B5%81%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">②流的分类</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A2%E5%9B%9B%E4%B8%AA%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BB"><span class="toc-text">③四个抽象基类</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A3IO%E6%B5%81%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-text">④IO流体系结构</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#E-%E8%8A%82%E7%82%B9%E6%B5%81%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">E.节点流的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A0%E5%A6%82%E4%BD%95%E4%BB%8E%E7%A1%AC%E7%9B%98%E8%AF%BB%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="toc-text">①如何从硬盘读入数据</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A1%E8%AF%BB%E5%85%A5%EF%BC%9Aread%E6%96%B9%E6%B3%95"><span class="toc-text">②读入：read方法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A2%E4%BB%8E%E5%86%85%E5%AD%98%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE%E5%88%B0%E7%A1%AC%E7%9B%98"><span class="toc-text">③从内存写入数据到硬盘</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A3%E5%86%99%E5%87%BA%EF%BC%9Awrite%E6%96%B9%E6%B3%95"><span class="toc-text">④写出：write方法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A4%E6%B3%A8%E6%84%8F"><span class="toc-text">⑤注意</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A5%E8%A1%A5%E5%85%85"><span class="toc-text">⑥补充</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#F-%E7%BC%93%E5%86%B2%E6%B5%81"><span class="toc-text">F. 缓冲流</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A0%E6%A6%82%E8%BF%B0-6"><span class="toc-text">①概述</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A1%E7%BC%93%E5%86%B2%E6%B5%81%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">②缓冲流的使用</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A2readLine"><span class="toc-text">③readLine()</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A3%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BC%93%E5%86%B2%E6%B5%81%E8%83%BD%E6%8F%90%E9%AB%98%E9%80%9F%E5%BA%A6"><span class="toc-text">④为什么缓冲流能提高速度</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#G-%E8%BD%AC%E6%8D%A2%E6%B5%81"><span class="toc-text">G.转换流</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A0%E6%A6%82%E8%BF%B0-7"><span class="toc-text">①概述</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A1InputStreamReader"><span class="toc-text">②InputStreamReader</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A1OutputStreamWriter"><span class="toc-text">②OutputStreamWriter</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#H-%E5%AD%97%E7%AC%A6%E9%9B%86"><span class="toc-text">H.字符集</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A0%E7%BC%96%E7%A0%81%E8%A1%A8"><span class="toc-text">①编码表</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A1%E5%B8%B8%E8%A7%81%E7%BC%96%E7%A0%81%E8%A1%A8"><span class="toc-text">②常见编码表</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A2%E5%90%AF%E7%A4%BA"><span class="toc-text">③启示</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#I-%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E3%80%81%E8%BE%93%E5%87%BA%E6%B5%81-%E4%BA%86%E8%A7%A3"><span class="toc-text">I.标准输入、输出流(了解)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#J-%E6%89%93%E5%8D%B0%E6%B5%81-%E4%BA%86%E8%A7%A3"><span class="toc-text">J.打印流(了解)</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A0%E6%8A%8A%E6%8E%A7%E5%88%B6%E5%8F%B0%E4%B8%AD%E8%BE%93%E5%87%BA%E7%9A%84%E5%86%85%E5%AE%B9%E4%BF%9D%E5%AD%98%E5%88%B0%E6%96%87%E4%BB%B6"><span class="toc-text">①把控制台中输出的内容保存到文件</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#K-%E6%95%B0%E6%8D%AE%E6%B5%81-%E4%BA%86%E8%A7%A3"><span class="toc-text">K.数据流(了解)</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A0%E6%A6%82%E8%BF%B0-8"><span class="toc-text">①概述</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A1%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">②数据流中的方法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A2%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">③数据流的使用</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#L-%E5%AF%B9%E8%B1%A1%E6%B5%81"><span class="toc-text">L.对象流</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A0%E6%A6%82%E8%BF%B0-9"><span class="toc-text">①概述</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A1%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96%E6%9C%BA%E5%88%B6"><span class="toc-text">②对象序列化机制</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A2%E5%AF%B9%E8%B1%A1%E6%B5%81%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">③对象流的使用</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A3%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8F%AF%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-text">④自定义类可序列化</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#M-%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%8F%96%E6%96%87%E4%BB%B6%E6%B5%81%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-text">M.随机存取文件流（了解）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A0%E6%A6%82%E8%BF%B0-10"><span class="toc-text">①概述</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A1RandomAccessFile%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">②RandomAccessFile的使用</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A2%E8%AF%B4%E6%98%8E"><span class="toc-text">③说明</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A3%E6%96%B9%E6%B3%95"><span class="toc-text">④方法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A4%E5%BA%94%E7%94%A8"><span class="toc-text">⑤应用</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#N-NIO-2%E4%B8%ADPath%E3%80%81Paths%E3%80%81Files%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-text">N.NIO.2中Path、Paths、Files类的使用（了解）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A0%E7%90%86%E8%A7%A3"><span class="toc-text">①理解</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A1Path"><span class="toc-text">②Path</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A2Paths"><span class="toc-text">③Paths</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A3Files"><span class="toc-text">④Files</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#O-ByteArrayOutputStream"><span class="toc-text">O.ByteArrayOutputStream</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A0%E6%A6%82%E8%BF%B0-11"><span class="toc-text">①概述</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A1toString"><span class="toc-text">②toString()</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A2getBytes"><span class="toc-text">③getBytes()</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A3%E4%BE%8B%E5%AD%90"><span class="toc-text">④例子</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8%E3%80%81%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-text">8、网络编程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%A6%82%E8%BF%B0"><span class="toc-text">①网络编程概述</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#A-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9A%84%E7%9B%AE%E7%9A%84"><span class="toc-text">A.网络编程的目的</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#B-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%AD%E6%9C%89%E4%B8%A4%E4%B8%AA%E4%B8%BB%E8%A6%81%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">B.网络编程中有两个主要的问题</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#C-%E9%80%9A%E4%BF%A1%E8%A6%81%E7%B4%A01%E2%80%93IP%E5%92%8C%E7%AB%AF%E5%8F%A3%E5%8F%B7"><span class="toc-text">C.通信要素1–IP和端口号</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#D-%E9%80%9A%E4%BF%A1%E8%A6%81%E7%B4%A02%E2%80%93%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE"><span class="toc-text">D.通信要素2–网络协议</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1TCP%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-text">②TCP网络编程</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-text">客户端</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF"><span class="toc-text">服务器端</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A2UDP%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-text">③UDP网络编程（了解）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A3URL%E7%BC%96%E7%A8%8B"><span class="toc-text">④URL编程</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#A-URL"><span class="toc-text">A.URL</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#B-%E5%AE%9E%E4%BE%8B%E5%8C%96URL%E5%AF%B9%E8%B1%A1"><span class="toc-text">B.实例化URL对象</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#C-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">C.常用方法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#D-%E7%94%A8%E4%BA%8E"><span class="toc-text">D.用于</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9%E3%80%81%E5%8F%8D%E5%B0%84"><span class="toc-text">9、反射</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0%E5%BC%95%E5%85%A5"><span class="toc-text">①引入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1%E5%8F%8D%E5%B0%84%E6%A6%82%E8%BF%B0"><span class="toc-text">②反射概述</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#A-Java%E6%98%AF%E5%87%86%E5%8A%A8%E6%80%81%E8%AF%AD%E8%A8%80"><span class="toc-text">A.Java是准动态语言</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#B-%E5%8F%8D%E5%B0%84%E6%8F%90%E4%BE%9B%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-text">B.反射提供的功能</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#C-%E7%9B%B8%E5%85%B3%E4%B8%BB%E8%A6%81API"><span class="toc-text">C.相关主要API</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A2%E5%85%B3%E4%BA%8Ejava-lang-Class%E7%B1%BB%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">③关于java.lang.Class类的理解</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#A-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="toc-text">A.类的加载过程</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#B-%E8%8E%B7%E5%8F%96Class%E7%9A%84%E5%AE%9E%E4%BE%8B%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%88%E5%89%8D%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%E9%9C%80%E8%A6%81%E6%8E%8C%E6%8F%A1%EF%BC%89"><span class="toc-text">B.获取Class的实例的方式（前三种方式需要掌握）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#C-%E6%B3%A8%E6%84%8F"><span class="toc-text">C.注意</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#D-%E8%A1%A5%E5%85%85%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-text">D.补充（了解）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#E-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-text">E.类的加载器</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A3%E5%88%9B%E5%BB%BA%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-text">④创建运行时类的对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A4%E4%BD%93%E4%BC%9A%E5%8F%8D%E5%B0%84%E7%9A%84%E5%8A%A8%E6%80%81%E6%80%A7"><span class="toc-text">⑤体会反射的动态性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A5%E8%8E%B7%E5%8F%96%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E5%AE%8C%E6%95%B4%E7%BB%93%E6%9E%84%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-text">⑥获取运行时类的完整结构（了解）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#A-%E8%8E%B7%E5%8F%96%E5%B1%9E%E6%80%A7%E7%BB%93%E6%9E%84"><span class="toc-text">A.获取属性结构</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#B-%E8%8E%B7%E5%8F%96%E6%96%B9%E6%B3%95%E7%BB%93%E6%9E%84"><span class="toc-text">B.获取方法结构</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#C-%E8%8E%B7%E5%8F%96%E6%9E%84%E9%80%A0%E5%99%A8%E7%BB%93%E6%9E%84"><span class="toc-text">C.获取构造器结构</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#D-%E8%8E%B7%E5%8F%96%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E7%88%B6%E7%B1%BB"><span class="toc-text">D.获取运行时类的父类</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#E-%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E7%88%B6%E7%B1%BB%E7%9A%84%E6%B3%9B%E5%9E%8B"><span class="toc-text">E.获取当前运行时类的父类的泛型</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#F-%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="toc-text">F.获取当前运行时类实现的接口</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#G-%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E6%89%80%E5%9C%A8%E7%9A%84%E5%8C%85"><span class="toc-text">G.获取当前运行时类所在的包</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#H-%E8%8E%B7%E5%8F%96%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E5%A3%B0%E6%98%8E%E7%9A%84%E6%B3%A8%E8%A7%A3"><span class="toc-text">H.获取运行时类声明的注解</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%9C%80%E8%A6%81%E9%87%8D%E7%82%B9%E4%BA%86%E8%A7%A3%E7%9A%84%E6%98%AF"><span class="toc-text">需要重点了解的是</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A6%E8%B0%83%E7%94%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E6%8C%87%E5%AE%9A%E7%BB%93%E6%9E%84"><span class="toc-text">⑦调用运行时类的指定结构</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#A-%E5%A6%82%E4%BD%95%E6%93%8D%E4%BD%9C%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E4%B8%AD%E6%8C%87%E5%AE%9A%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-text">A.如何操作运行时类中指定的属性</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#B-%E5%A6%82%E4%BD%95%E6%93%8D%E4%BD%9C%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E4%B8%AD%E6%8C%87%E5%AE%9A%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">B.如何操作运行时类中指定的方法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#C-%E5%A6%82%E4%BD%95%E8%B0%83%E7%94%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E4%B8%AD%E6%8C%87%E5%AE%9A%E7%9A%84%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-text">C.如何调用运行时类中指定的构造器</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A7%E5%8F%8D%E5%B0%84%E5%BA%94%E7%94%A8%E2%80%93%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-text">⑧反射应用–动态代理</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A0%E6%A6%82%E8%BF%B0-12"><span class="toc-text">①概述</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A1%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0"><span class="toc-text">②静态代理实现</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A2%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0"><span class="toc-text">③动态代理实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10%E3%80%81Java8%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-text">10、Java8的一些新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0%E6%A6%82%E8%BF%B0-13"><span class="toc-text">①概述</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">②Lambda表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#A-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E4%B8%BE%E4%BE%8B"><span class="toc-text">A.Lambda表达式的举例</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#B-%E6%A0%BC%E5%BC%8F"><span class="toc-text">B.格式</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#C-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">C.Lambda表达式的使用</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#D-%E6%B3%A8%E6%84%8F"><span class="toc-text">D.注意</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#E-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">E.应用场景</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A2%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-text">③函数式接口</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#A-%E5%AE%9A%E4%B9%89"><span class="toc-text">A.定义</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#B-Java%E5%86%85%E7%BD%AE%E5%9B%9B%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-text">B.Java内置四大核心函数式接口</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#C-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E7%BB%99%E5%AE%9A%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-text">C.如何使用给定的函数式接口</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A3%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8"><span class="toc-text">④方法引用</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#A-%E4%BD%BF%E7%94%A8%E6%83%85%E6%99%AF"><span class="toc-text">A.使用情景</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#B-%E6%A0%BC%E5%BC%8F-1"><span class="toc-text">B.格式</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#C-%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E4%BD%BF%E7%94%A8%E8%A7%84%E5%88%99"><span class="toc-text">C.方法引用使用规则</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#D-%E5%85%B7%E4%BD%93%E4%B8%BE%E4%BE%8B"><span class="toc-text">D.具体举例</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A4%E6%9E%84%E9%80%A0%E5%99%A8%E5%BC%95%E7%94%A8"><span class="toc-text">⑤构造器引用</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#A-%E6%A6%82%E8%BF%B0-1"><span class="toc-text">A.概述</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#B-%E6%A0%BC%E5%BC%8F-2"><span class="toc-text">B.格式</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#C-%E6%9E%84%E9%80%A0%E5%99%A8%E5%BC%95%E7%94%A8%E8%A7%84%E5%88%99"><span class="toc-text">C.构造器引用规则</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#D-%E4%BE%8B%E5%AD%90"><span class="toc-text">D.例子</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A5%E6%95%B0%E7%BB%84%E5%BC%95%E7%94%A8%EF%BC%88%EF%BC%9F%EF%BC%89"><span class="toc-text">⑥数组引用（？）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#A-%E6%A0%BC%E5%BC%8F"><span class="toc-text">A.格式</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#B-%E4%BD%BF%E7%94%A8"><span class="toc-text">B.使用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11%E3%80%81Java8%E6%96%B0%E7%89%B9%E6%80%A7%E2%80%94Stream-API"><span class="toc-text">11、Java8新特性—Stream API</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#A-%E6%A6%82%E8%BF%B0-2"><span class="toc-text">A.概述</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#B-Stream%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="toc-text">B.Stream实例化</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%B8%80"><span class="toc-text">方式一</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%BA%8C"><span class="toc-text">方式二</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%B8%89"><span class="toc-text">方式三</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%9B%9B%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-text">方法四（了解）</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#C-%E4%B8%AD%E9%97%B4%E6%93%8D%E4%BD%9C%E2%80%93%E7%AD%9B%E9%80%89%E4%B8%8E%E5%88%87%E7%89%87"><span class="toc-text">C.中间操作–筛选与切片</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A0filter-Predicate-p"><span class="toc-text">①filter(Predicate p)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A1limit-n"><span class="toc-text">②limit(n)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A2skip-n"><span class="toc-text">③skip(n)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A3distinct"><span class="toc-text">④distinct()</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#D-%E4%B8%AD%E9%97%B4%E6%93%8D%E4%BD%9C%E2%80%93%E6%98%A0%E5%B0%84"><span class="toc-text">D.中间操作–映射</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A0map-Function-f"><span class="toc-text">①map(Function f)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A1flatMap-Function-f-%E4%B8%8D%E4%BC%9A"><span class="toc-text">②flatMap(Function f)     不会</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#E-%E4%B8%AD%E9%97%B4%E6%93%8D%E4%BD%9C%E2%80%93%E6%8E%92%E5%BA%8F"><span class="toc-text">E.中间操作–排序</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A0sorted-%E8%87%AA%E7%84%B6%E6%8E%92%E5%BA%8F"><span class="toc-text">①sorted()  自然排序</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A1sorted-Comparator-com-%E5%AE%9A%E5%88%B6%E6%8E%92%E5%BA%8F"><span class="toc-text">②sorted(Comparator com)  定制排序</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#F-%E7%BB%88%E7%BB%93%E6%93%8D%E4%BD%9C%E2%80%93%E5%8C%B9%E9%85%8D%E4%B8%8E%E6%9F%A5%E6%89%BE"><span class="toc-text">F.终结操作–匹配与查找</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A0allMatch-Predicate-p"><span class="toc-text">①allMatch(Predicate p)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A1anyMatch-Predicate-p"><span class="toc-text">②anyMatch(Predicate p)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A2noneMatch-Predicate-p"><span class="toc-text">③noneMatch(Predicate p)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A3findFirst"><span class="toc-text">④findFirst()</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A4findAny"><span class="toc-text">⑤findAny()</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A5count"><span class="toc-text">⑥count()</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A6max-Comparator-c"><span class="toc-text">⑦max(Comparator c)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A7min-Comparator-c"><span class="toc-text">⑧min(Comparator c)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A8forEach-Consumer-c"><span class="toc-text">⑨forEach(Consumer c)</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#G-%E7%BB%88%E7%BB%93%E6%93%8D%E4%BD%9C%E2%80%93%E8%A7%84%E7%BA%A6"><span class="toc-text">G.终结操作–规约</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A0reduce-T-identity-BinaryOperator"><span class="toc-text">①reduce(T identity,BinaryOperator)</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A1reduce-BinaryOperator"><span class="toc-text">②reduce(BinaryOperator)</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#H-%E7%BB%88%E7%BB%93%E6%93%8D%E4%BD%9C%E2%80%93%E6%94%B6%E9%9B%86"><span class="toc-text">H.终结操作–收集</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A0collect-Collector-c"><span class="toc-text">①collect(Collector c)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12%E3%80%81Java8%E6%96%B0%E7%89%B9%E6%80%A7%E2%80%94Optional%E7%B1%BB"><span class="toc-text">12、Java8新特性—Optional类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0%E6%A6%82%E8%BF%B0-14"><span class="toc-text">①概述</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1Optional%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">②Optional类的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#A-%E5%88%9B%E5%BB%BAOptional%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">A.创建Optional类对象的方法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#B-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">B.常用方法</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/24/java%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0/" title="Java语法基础概述">Java语法基础概述</a><time datetime="2023-04-24T10:27:36.000Z" title="发表于 2023-04-24 18:27:36">2023-04-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/24/git/" title="git">git</a><time datetime="2023-04-24T08:32:11.000Z" title="发表于 2023-04-24 16:32:11">2023-04-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/24/SSM%E6%95%B4%E5%90%88/" title="SSM整合">SSM整合</a><time datetime="2023-04-24T08:31:50.000Z" title="发表于 2023-04-24 16:31:50">2023-04-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/24/SpringMvc/" title="SpringMvc">SpringMvc</a><time datetime="2023-04-24T08:31:31.000Z" title="发表于 2023-04-24 16:31:31">2023-04-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/04/24/Spring/" title="Spring">Spring</a><time datetime="2023-04-24T08:31:24.000Z" title="发表于 2023-04-24 16:31:24">2023-04-24</time></div></div></div></div></div></div></main><footer id="footer" style="background: rgba(255,255,255, .0)"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By OrangeZzc</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><b>We can't change our fate,but we can do our best!</b></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"></div><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>