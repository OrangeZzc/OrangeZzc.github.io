<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>项目补充知识</title>
      <link href="/2023/04/24/%E5%81%9A%E9%A1%B9%E7%9B%AE%E6%97%B6%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86/"/>
      <url>/2023/04/24/%E5%81%9A%E9%A1%B9%E7%9B%AE%E6%97%B6%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<ol><li><p>Vue对象里可以写</p> <img src="/imgs/image-20230424155505954.png" alt="image-20230424155505954" style="zoom:67%;" /> </li><li><p>下面引入的代码写在html的body标签的开头即可</p><p> <img src="/imgs/image-20221202220013403-1682322858044.png" alt="image-20221202220013403"></p><p> 上面的路径别写错，不然会识别不了部分代码。<code>要写资源相对于该页面的位置。</code>  </p></li><li><p>如何获取表单里一行数据中的某个值：</p><p> <img src="/imgs/image-20221204225611772-1682322858045.png" alt="image-20221204225611772"></p></li><li><p>要想使用Vue对象里的模型或方法，必须先有Vue对象。除了axios请求中的then里的this是指window对象，在Vue对象里的其它位置使用this，this都是指Vue对象。</p></li><li><p>当点击前端页面中的新增按钮、修改按钮时，弹出的是对话框，不是消息提醒之类的弹框。</p></li><li><p>写添加数据的SQL语句时，要注意别写错关键字</p><p> <img src="/imgs/image-20221205144746602-1682322858046.png" alt="image-20221205144746602"></p></li><li><p>当编写的SQL关键字不是粗体字的话，就可能是识别不了此关键字，需进行相应的设置。</p><p> <img src="/imgs/image-20221206205326825-1682322858046.png" alt="image-20221206205326825"></p></li><li><p>如果发现运行tomcat时出现以下情况，就很有可能在调用对应SQL语句的方法时出错了。找到对应的位置修改即可。</p><p> <img src="/imgs/image-20221206205514876-1682322858046.png" alt="image-20221206205514876"></p></li><li><p><img src="/imgs/image-20221206211120219-1682322858046.png" alt="image-20221206211120219"></p><p><img src="/imgs/image-20221206210923726-1682322858047.png" alt="image-20221206210923726"></p><p>这种情况下就不能直接写username。</p></li><li><p>在浏览器中如何查看表单post提交的数据</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://blog.csdn.net/hkhl_235/article/details/103444085</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 项目开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目补充知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零搭建Web项目</title>
      <link href="/2023/04/24/%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BAweb%E9%A1%B9%E7%9B%AE/"/>
      <url>/2023/04/24/%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BAweb%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<p>实现步骤：</p><ol><li><p>建一个 maven web 项目（见Web服务器-Tomcat –&gt; IDEA中创建maven web项目–实现），然后在pom.xml文件中导入依赖：mybatis、mysql、jsp、servlet、jstl、Tomcat、Fastjson。</p></li><li><p>在webapp下建一个文件命名为：js，用于存放js文件。</p><ol><li>将axios-0.18.0.js文件放到该文件下。（Axios框架需要用到此文件）</li><li>将vue.js文件放到该文件下。</li></ol><p> 注：上面两个文件在电脑D：&#x2F;web开发所需资料。Element ui文件也在。</p></li><li><p>将Element ui文件复制到webapp下。</p></li><li><p>创建三层架构的包结构。创建三层架构的包结构。在Java文件下建com.zzc.web、com.zzc.service、com.zzc.mapper，另外还建com.zzc.pojo（放Javabean），com.zzc.utils（放自定义的工具类）。</p><ol><li>在com.zzc.web包下再建一个文件servlet。<ul><li>在servlet文件下先建一个baseServlet，其内容详见servlet代码优化。以后写的servlet类都继承于baseServle。</li></ul></li><li>在com.zzc.service包下建一个impl文件。<ul><li>先定义一个service相关的接口，如：brandService接口，然后在这里面写对brand表操作的相关方法。</li><li>在impl文件里实现brandService接口，类命名为：brandServiceImpl。</li></ul></li></ol></li><li><p>在数据库中创建需要的表，如：tb_brand表。</p></li><li><p>在com.zzc.pojo包下建数据库表对应的实体类。</p></li><li><p>Mybatis基础环境搭建：</p><ol><li>Mybatis-config.xml</li><li>BrandMapper.xml</li><li>BrandMapper接口</li></ol></li><li><p>在编写前端页面之前都要引入如下三个东西：</p><ol><li><p>引入axios的js文件</p><p> <img src="/imgs/image-20221202171825016-1682322503285.png" alt="image-20221202171825016"></p></li><li><p>引入Element的css、js文件</p><p> <img src="/imgs/image-20221202202141339-1682322503286.png" alt="image-20221202202141339"></p></li><li><p>引入Vue.js文件</p><p> <img src="/imgs/image-20221202172033846-1682322503286.png" alt="image-20221202172033846"></p></li><li><p>在编写页面时参考Element官网，再根据自己需要修改。</p> <figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://element.eleme.cn/#/zh-CN/component/table</span><br></pre></td></tr></table></figure></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web核心（下）</title>
      <link href="/2023/04/24/web%E6%A0%B8%E5%BF%83%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
      <url>/2023/04/24/web%E6%A0%B8%E5%BF%83%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="13-AJAX"><a href="#13-AJAX" class="headerlink" title="13.AJAX"></a>13.AJAX</h2><h3 id="A-概述"><a href="#A-概述" class="headerlink" title="A.概述"></a>A.概述</h3><p><img src="/imgs/image-20230424150618783.png" alt="image-20230424150618783"></p><p><img src="/imgs/image-20230424150627689.png" alt="image-20230424150627689"></p><p><img src="/imgs/image-20230424150637989.png" alt="image-20230424150637989"></p><hr><h3 id="B-AJAX快速入门"><a href="#B-AJAX快速入门" class="headerlink" title="B.AJAX快速入门"></a>B.AJAX快速入门</h3><p>​这下面的开发步骤了解即可，因为这种开发步骤比较繁琐，将来会用Axiox异步框架来代替这种旧的开发方式。</p><p><img src="/imgs/image-20230424150748050.png" alt="image-20230424150748050"></p><p>​具体实现：</p><p>​新建一个HTML页面，使用&lt; script &gt;标签，在里面写Ajax代码。</p><p><img src="/imgs/image-20230424150818807.png" alt="image-20230424150818807"></p><p><img src="/imgs/image-20230424150827232.png" alt="image-20230424150827232"></p><p>说明：</p><ol><li><p>全路径：<a href="http://localhost:8080/%E8%AF%A5%E9%A1%B9%E7%9B%AE%E7%9A%84%E8%AE%BF%E9%97%AE%E8%B7%AF%E5%BE%84/%E8%A2%AB%E8%AE%BF%E9%97%AE%E8%B5%84%E6%BA%90%E7%9A%84%E8%B7%AF%E5%BE%84">http://localhost:8080/该项目的访问路径/被访问资源的路径</a></p></li><li><p>发送请求中的open方法里还有第三个参数，用于设置该请求是异步请求还是同步请求，true就是异步请求，false就是同步请求。该参数默认是：true，所以也可以不写。</p></li><li><p>获取响应中的涉及到的知识见：</p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.w3school.com.cn/js/js_ajax_http_response.asp</span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="C-案例"><a href="#C-案例" class="headerlink" title="C.案例"></a>C.案例</h3><p><img src="/imgs/image-20230424151018672.png" alt="image-20230424151018672"></p><p>​实现步骤：</p><ol><li><p>先编写SelectUserServlet</p><p> <img src="/imgs/image-20221125180554640-1682320230969.png" alt="image-20221125180554640"></p></li><li><p>在注册页面register.html编写Ajax。</p><p> <img src="/imgs/image-20221125181936629-1682320230972.png" alt="image-20221125181936629"></p><p> <img src="/imgs/image-20221125182729372-1682320230973.png" alt="image-20221125182729372"></p></li></ol><p>补充：表单中用户名输入框处的HTML代码：</p><p><img src="/imgs/image-20221125182628316-1682320230973.png" alt="image-20221125182628316"></p><hr><h3 id="D-Axios异步框架"><a href="#D-Axios异步框架" class="headerlink" title="D.Axios异步框架"></a>D.Axios异步框架</h3><h4 id="①概述"><a href="#①概述" class="headerlink" title="①概述"></a>①概述</h4><ul><li>Axios：对原生的AJAX进行封装，简化书写。</li><li>官网：<a href="http://www.axios-http.cn/">http://www.axios-http.cn</a></li></ul><h4 id="②Axios快速入门"><a href="#②Axios快速入门" class="headerlink" title="②Axios快速入门"></a>②Axios快速入门</h4><p>​在IDEA中webapp目录下建一个js目录，用于存放JS文件。</p><p>​在引入axios的js文件前，先将电脑D盘中的”web开发需要资料“中的axios-0.18.0.js文件拉到刚才建的JS文件中。</p><p>​创建HTML文件，在里面写如下代码：</p><p><img src="/imgs/image-20221125210635180-1682320310941.png" alt="image-20221125210635180"></p><p>​说明：</p><ol><li>then前面的部分属于发送请求，then后面部分属于获取响应。</li><li>then后面的部分被称为回调函数，当收到响应后会自动执行回调函数的代码。</li><li>resp.data：data中存储的就是响应数据。</li><li>url：写全路径：<a href="http://localhost:8080/%E8%AF%A5%E9%A1%B9%E7%9B%AE%E7%9A%84%E8%AE%BF%E9%97%AE%E8%B7%AF%E5%BE%84/%E8%A2%AB%E8%AE%BF%E9%97%AE%E8%B5%84%E6%BA%90%E7%9A%84%E8%B7%AF%E5%BE%84%E3%80%82">http://localhost:8080/该项目的访问路径/被访问资源的路径。</a></li><li>Axios中post请求和get请求的不同：就是参数存放的位置不一样。</li><li>date：date中放的数据都是JSON数据，将来这些数据都会放到HTTP协议的请求体中发送给服务器。</li></ol><h4 id="③Axios请求方式别名"><a href="#③Axios请求方式别名" class="headerlink" title="③Axios请求方式别名"></a>③Axios请求方式别名</h4><p>​为进一步简化书写，Axios对所有支持的请求方法进行了封装，封装为对应的方法。</p><p><img src="/imgs/image-20221125211934363-1682320310941.png" alt="image-20221125211934363"></p><p>​</p><p>​例子：</p><p><img src="/imgs/image-20221125211949144-1682320310942.png" alt="image-20221125211949144"></p><hr><h2 id="14-JSON"><a href="#14-JSON" class="headerlink" title="14.JSON"></a>14.JSON</h2><h3 id="A-概述-1"><a href="#A-概述-1" class="headerlink" title="A.概述"></a>A.概述</h3><p>​JSON现常作为浏览器和服务器之间数据载体，在网络中进行数据传输。最终会将JSON中的数据变成字符串存储到HTTP中。</p><h3 id="B-JSON语法"><a href="#B-JSON语法" class="headerlink" title="B.JSON语法"></a>B.JSON语法</h3><p><img src="/imgs/image-20221126174831803-1682320388475.png" alt="image-20221126174831803"></p><p>​注意：以上代码都写在HTML中的&lt; script &gt;标签中</p><hr><h3 id="C-JSON数据和Java对象转换"><a href="#C-JSON数据和Java对象转换" class="headerlink" title="C.JSON数据和Java对象转换"></a>C.JSON数据和Java对象转换</h3><h4 id="①概述-1"><a href="#①概述-1" class="headerlink" title="①概述"></a>①概述</h4><p>​JSON作为数据载体将来会通过异步（AJAX）方式在网络中传输数据，服务器收到JSON数据后需要将其转换为Java对象，而发送数据给浏览器时，需要将Java对象转换为JSON字符串。</p><p>​总结：</p><ul><li>请求数据：JSON字符串转为Java对象</li><li>响应数据：Java对象转为JSON字符串</li></ul><h4 id="②使用"><a href="#②使用" class="headerlink" title="②使用"></a>②使用</h4><p><img src="/imgs/image-20221126202948982-1682320388473.png" alt="image-20221126202948982"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.62<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="D-案例"><a href="#D-案例" class="headerlink" title="D.案例"></a>D.案例</h3><p>​使用Axios和JSON来完成之前做的查询品牌数据和添加品牌数据的案例。</p><ul><li><p><strong>查询所有品牌数据</strong></p><p>  <img src="/imgs/image-20221126211754656-1682320388474.png" alt="image-20221126211754656"></p><p>  补充：<strong>List集合转换为JSON后变成了字符串数组。</strong></p><p>  实现：</p><p>  brand.html：</p><p>  <img src="/imgs/image-20221126221126050-1682320388475.png" alt="image-20221126221126050"></p><p>  <img src="/imgs/image-20221126221555239-1682320388475.png" alt="image-20221126221555239"></p><p>  SelectAllServlet：</p><p>  <img src="/imgs/image-20221126213520686-1682320388475.png" alt="image-20221126213520686"></p><p>  至此，展示所有品牌数据的功能就完成了。</p></li><li><p><strong>添加品牌数据</strong></p><p>  需求：点击 “新增” 按钮，弹出添加数据的表单，点击提交数据后，返回提交结果信息，最后展示现在所有品牌的信息。</p><p>  <img src="/imgs/image-20221127161835465-1682320388475.png" alt="image-20221127161835465"></p><p>  实现：</p><p>  addBrand.html：（前端的代码了解一下就可以，因为后面会学一些框架来简化开发步骤）</p><p>  <img src="/imgs/image-20221127163316571-1682320388475.png" alt="image-20221127163316571"></p><p>  <img src="/imgs/image-20221127172321160-1682320388475.png" alt="image-20221127172321160"></p><p>  <img src="/imgs/image-20221127172647446-1682320388475.png" alt="image-20221127172647446"></p><p>  <img src="/imgs/image-20221127173421868-1682320388476.png" alt="image-20221127173421868"></p><p>  <img src="/imgs/image-20221127174851659-1682320388476.png" alt="image-20221127174851659"></p><p>  AddServlet：</p><p>  <img src="/imgs/image-20221127171103397-1682320388476.png" alt="image-20221127171103397"></p></li></ul><p>补充：</p><p>​为什么不能使用request.getParameter？因为getParameter方法底层是根据and和 ‘ &#x3D; ‘ 来切割数据、获取数据的，而JSON数据存储到HTTP请求行中后其数据的格式是“键名：值”的形式，所以getParameter方法就无法获取到JSON数据。要想获取到JSON数据只能，先从请求体中读取数据（上图中26、27行代码）再将获取到的JSON数据转为Java对象。</p>]]></content>
      
      
      <categories>
          
          <category> Java Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web核心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web核心（中）</title>
      <link href="/2023/04/24/web%E6%A0%B8%E5%BF%83%EF%BC%88%E4%B8%AD%EF%BC%89/"/>
      <url>/2023/04/24/web%E6%A0%B8%E5%BF%83%EF%BC%88%E4%B8%AD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="⑨案例"><a href="#⑨案例" class="headerlink" title="⑨案例"></a>⑨案例</h2><p><img src="/imgs/image-20230424151759217.png" alt="image-20230424151759217"></p><h3 id="A-环境准备"><a href="#A-环境准备" class="headerlink" title="A.环境准备"></a>A.环境准备</h3><ol><li>建一个 maven web 项目（见Web服务器-Tomcat –&gt; IDEA中创建maven web项目），然后在pom.xml文件中导入依赖：mybatis、mysql、jsp、servlet、jstl、Tomcat。</li><li>创建三层架构的包结构。在Java文件下建com.zzc.web、com.zzc.service、com.zzc.mapper，另外还建com.zzc.pojo（放Javabean），com.zzc.utils（放自定义的工具类）。</li><li>在数据库中创建tb_brand表。</li><li>在com.zzc.pojo包下建实体类Brand。</li><li>Mbatis基础环境：<ol><li>Mybatis-config.xml</li><li>BrandMapper.xml</li><li>BrandMapper接口</li></ol></li></ol><h3 id="B-查询所有"><a href="#B-查询所有" class="headerlink" title="B.查询所有"></a>B.查询所有</h3><p><img src="/../imgs/image-20221119160426733-1682310001087.png" alt="image-20221119160426733"></p><p>​</p><ol><li><p>DAO层：在BrandMapper接口里定义selectAll方法。</p></li><li><p>在com.zzc.service包下建个BrandService类，专门用来放一些从数据库的Brand表中获取数据的方法。</p></li><li><p>在webapp下建一个index.html页面。注意：如果将来在浏览器访问时不输入任何的访问资源，浏览器就会默认访问命名为index的html页面。</p></li><li><p>在com.zzc.web下建一个命名为SelectAllServlet的Servlet。</p><ol><li>调用BrandService类中的selectAll方法。</li><li>将数据存入request对象。</li><li>转发到brand.jsp。</li></ol></li><li><p>在webapp目录下建一个命名为brand的jsp页面。</p><ol><li><p>引入JSTL标签库</p> <figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%<span class="meta">@taglib</span> prefix=<span class="string">&quot;c&quot;</span> uri=<span class="string">&quot;http://java.sun.com/jsp/jstl/core&quot;</span> %&gt;</span><br></pre></td></tr></table></figure></li><li><p>使用JSTL标签中的foreach标签遍历数据。</p></li></ol></li><li><p>完成。</p></li></ol><hr><h3 id="C-添加数据"><a href="#C-添加数据" class="headerlink" title="C.添加数据"></a>C.添加数据</h3><p><img src="/../imgs/image-20221119200120310-1682310001087.png" alt="image-20221119200120310"></p><p>​</p><ol><li><p>在BrandMapper接口中提交add方法。</p><p> <img src="/../imgs/image-20221119200302253-1682310001087.png" alt="image-20221119200302253"></p></li><li><p>在BrandService类中声明add方法，add方法里先获取数据连接，再调用BrandMapper接口中的add方法，然后<strong>提交事务</strong>，关闭资源。</p><p> <img src="/../imgs/image-20221119200752666-1682310001087.png" alt="image-20221119200752666"></p></li><li><p>为 “新增” 按钮添加单击事件，用到JavaScript，JavaScript要写在script标签里。</p><p> <img src="/../imgs/image-20221119201531297-1682310001087.png" alt="image-20221119201531297"></p><p> <img src="/../imgs/image-20221119202106701-1682310001087.png" alt="image-20221119202106701"></p></li><li><p>用jsp来编写添加数据页面。</p><p> <img src="/../imgs/image-20221119202524160-1682310001088.png" alt="image-20221119202524160"></p></li><li><p>在com.zzc.web下新建一个Servlet，命名为：AddServlet。</p><ol><li>设置字符输入流的编码集为HTML页面的编码集。不然获取到的中文数据就会乱码。（请求参数中文乱码–POST解决方案）</li><li>在servlet里获取请求数据，将数据封装到brand对象里。</li><li>调用BrandService类中的add方法。（此时数据已经存到数据库了）</li><li>使用请求转发，跳转到SelectServlet。展现添加完成后的所有数据。</li></ol></li></ol><p>​补充：如果出现了404，则访问路径写错了。</p><p>​</p><hr><h3 id="D-修改数据"><a href="#D-修改数据" class="headerlink" title="D.修改数据"></a>D.修改数据</h3><p>​修改数据之前，先回显之前的数据，然后再在这些数据上修改，最后提交修改。</p><p><img src="/../imgs/image-20221119212740338-1682310001088.png" alt="image-20221119212740338"></p><h4 id="①回显数据"><a href="#①回显数据" class="headerlink" title="①回显数据"></a>①回显数据</h4><p><img src="/../imgs/image-20221119212910939-1682310001088.png" alt="image-20221119212910939"></p><p>​</p><ol><li><p>在BrandMapper接口中声明selectById方法。</p></li><li><p>在BrandService类中声明slectById方法。</p><ol><li>获取数据库连接。</li><li>调用BrandMapper接口中的selectById方法，返回brand对象。</li><li>关闭资源。</li></ol></li><li><p>编写 “ 修改 ”  的超链接地址。</p><p> <img src="/../imgs/image-20221119214220754-1682310001088.png" alt="image-20221119214220754"></p><p> 如果不再后面加上 “ ?id&#x3D;${brand.id} ”，到时候使用request对象是获取不到该数据的id值的，所以得加上。 </p></li><li><p>在com.zzc.web下建一个Servler命名为SelectByIdServlet。</p><ol><li>使用request对象来获取id值。</li><li>调用BrandService类中的selectById方法。</li><li>将获取到的brand对象存储到request对象中。</li><li>请求转发。转发到update.jsp。</li></ol></li><li><p>编写update.jsp。</p></li></ol><p>  想将数据回显到表单中。</p><p>  <img src="/../imgs/image-20221120103622795-1682310001088.png" alt="image-20221120103622795"></p><p>  <img src="/../imgs/image-20221120104414569-1682310001088.png" alt="image-20221120104414569"></p><ol start="6"><li>数据回显完成。</li></ol><h4 id="②修改数据"><a href="#②修改数据" class="headerlink" title="②修改数据"></a>②修改数据</h4><p><img src="/../imgs/image-20221120105137616-1682310001088.png" alt="image-20221120105137616"></p><p>​</p><ol><li><p>在BrandMapper接口中声明update方法。</p></li><li><p>在BrandService类中声明update方法。</p></li><li><p>修改update.jsp。</p><p> 因为修改数据的SQL语句中需要用到 id ，但这个 id 不希望用户看到，所以我们得：</p><p> <img src="/../imgs/image-20221120111737938-1682310001088.png" alt="image-20221120111737938"></p></li><li></li></ol><hr><h3 id="E-删除数据"><a href="#E-删除数据" class="headerlink" title="E.删除数据"></a>E.删除数据</h3><ol><li>BrandMapper接口中声明DeleteById方法。</li><li>BrandService类中声明DeleteById方法。<ol><li>获取数据库连接。</li><li>调用BrandMapper接口中的DeleteById方法。记得提交事务和关闭sqlsession资源。</li></ol></li><li>修改 “ 删除 ” 的超链接地址为要访问的Servlet地址，再拼上 “?id&#x3D;${brand.id}”。</li><li>编写DeleteByIdServlet。<ol><li>获取请求数据中的id值。</li><li>调用BrandService类中的DeleteById方法。</li><li>请求转发，跳转到查询所有数据的Servlet，将现在的数据都展现出来。</li></ol></li><li>完成。</li></ol><hr><h3 id="F-补充知识"><a href="#F-补充知识" class="headerlink" title="F.补充知识"></a>F.补充知识</h3><ol><li>将来所有的Servler都放在com.zzc.web包下，而JSP、HTML都放在webapp下。</li><li>在表单提交数据时，其提交的内容就是你表单里的内容，表单里没有的内容，提交的数据里也没有。如：表单里没有 id 这个数据，那么提交的数据中也没有 id 这个数据。</li></ol><hr><h2 id="⑩会话跟踪技术"><a href="#⑩会话跟踪技术" class="headerlink" title="⑩会话跟踪技术"></a>⑩会话跟踪技术</h2><h3 id="A-概述"><a href="#A-概述" class="headerlink" title="A.概述"></a>A.概述</h3><p><img src="/../imgs/image-20221120124846464-1682310001088.png" alt="image-20221120124846464"></p><ul><li><p>上图中一共有三个会话</p></li><li><p>Cookie和Session的区别：存放数据的地方不一样</p><ol><li>Cookie：数据存放在客户端。</li><li>Session：数据存放在服务器端。</li></ol></li><li><p>总结：会话跟踪技术就是来解决一次会话中多次请求间共享数据的问题。</p></li></ul><hr><h3 id="B-Cookie"><a href="#B-Cookie" class="headerlink" title="B.Cookie"></a>B.Cookie</h3><h4 id="①概述"><a href="#①概述" class="headerlink" title="①概述"></a>①概述</h4><ul><li><p>Cookie：客户端会话技术，将数据保存到客户端，以后每次请求都携带Cookie数据访问。</p></li><li><p>Cookie的流程：</p>  <img src="/imgs/image-20230424151926317.png" alt="image-20230424151926317" style="zoom:80%;" /><p>  ​当中间的浏览器访问服务器中的A serlvet时，A servlet会创建一个Cookie对象，然后将Cookie对象随着响应发给浏览器。浏览器收到Cookie对象之后就将Cookie里的数据保存到浏览器内存中。以后的每次请求都会携带所有的Cookie一起访问服务器资源，此时服务器资源就可以获取Cookie中的数据了。</p></li><li><p>作为后端程序员，我们只需要知道如何发送Cookie和获取Cookie即可。</p></li></ul><h4 id="②基本使用"><a href="#②基本使用" class="headerlink" title="②基本使用"></a>②基本使用</h4><p>​<img src="/imgs/image-20230424151940370.png" alt="image-20230424151940370" style="zoom: 67%;" /></p><p>​</p><p>​获取Cookie的例子：</p><img src="/imgs/image-20230424151956442.png" alt="image-20230424151956442" style="zoom:67%;" /><hr><h4 id="③原理"><a href="#③原理" class="headerlink" title="③原理"></a>③原理</h4><p>​服务器与客户端之间都是基于Http协议进行数据传输的，所以Cookie的实现也是基于Http协议的。</p><ol><li>当在服务器发送Cookie时，Cookie中的数据就会存到响应头中（响应头存的都是键值对），其中键名为：Set-cookie，值为Cookie中的数据值。然后就随着Http响应数据发送到客户端了。</li><li>当客户端发送请求给服务器时，会携带所有的Cookie数据访问，这些数据是存放在请求头中（请求头中也是以键值对存储数据）的。键名为：cookie，值为：所有Cookie数据，每个数据之间用分号隔开。</li></ol><hr><h4 id="④使用细节–Cookie存活时间"><a href="#④使用细节–Cookie存活时间" class="headerlink" title="④使用细节–Cookie存活时间"></a>④使用细节–Cookie存活时间</h4><p>​<img src="/../imgs/image-20221121182911003-1682310001088.png" alt="image-20221121182911003"></p><p>​</p><hr><h4 id="⑤使用细节–Cookie存储中文"><a href="#⑤使用细节–Cookie存储中文" class="headerlink" title="⑤使用细节–Cookie存储中文"></a>⑤使用细节–Cookie存储中文</h4><ul><li><p>Cookie不能直接存储中文，不然会报错。</p></li><li><p>如需要存储，则需要进行转码：使用URL编码的方式转码。</p></li><li><p>实现：</p><ul><li><p>使用URLEncoder.encode对数据进行URL编码</p>  <img src="/imgs/image-20230424152023008.png" alt="image-20230424152023008" style="zoom:67%;" /></li><li><p>使用URLDecoder.decode对获取到的数据进行URL解码</p>  <img src="/imgs/image-20230424152031193.png" alt="image-20230424152031193" style="zoom:67%;" /></li></ul></li></ul><p>​</p><hr><h3 id="C-Session"><a href="#C-Session" class="headerlink" title="C.Session"></a>C.Session</h3><h4 id="①引入"><a href="#①引入" class="headerlink" title="①引入"></a>①引入</h4><p>​会话跟踪技术中的Cookie是将数据保存到浏览器内存中的，然后每次请求都会携带着这些Cookie去访问资源，着些资源在网络上传输很容易被获取到，所以我们就引入了会话跟踪技术中的第二个技术：Session。Session是将数据保存到服务端的。</p><h4 id="②概述"><a href="#②概述" class="headerlink" title="②概述"></a>②概述</h4><p>​JavaEE提供HttpSession接口，来实现一次会话的多次请求间数据共享功能。</p><h4 id="③基本使用"><a href="#③基本使用" class="headerlink" title="③基本使用"></a>③基本使用</h4><p>​<img src="/../imgs/image-20221121205808627-1682310001088.png" alt="image-20221121205808627"></p><p>​注意：每次调用Session对象里的方法时，都得先获取Session对象。每次获取到的Session对象都是内存当中的同一个Session对象。</p><hr><h4 id="④原理"><a href="#④原理" class="headerlink" title="④原理"></a>④原理</h4><p>​Session是基于Cookie实现的。</p><p><img src="/../imgs/image-20221122105547870-1682310001088.png" alt="image-20221122105547870"></p><p>​Session里有一个唯一标识：id，用于标识此Session对象。当第一次创建Session对象时，由于浏览器中并没有session的id值，因此会在服务器的内存中创建一个session对象，此时其id值就确定了，然后这个id值会随着这次请求的响应，一起发送给客户端浏览器，而客户端与服务器之间数据传输靠的是Http协议，所以 id 会放在请求头中的键名为set-cookie里。浏览器收到这个 id 后会保存在浏览器内存中，随后的每一次请求都会携带着这个 id 一起访问服务器。当第二次获取session对象时，就从请求头中键名为cookie中获取到了此session的 id 值，然后根据此 id 值来找内存中是否有对应的session对象，如果没有则创建一个新的seesion对象；如果有，则直接获取该session对象。</p><p>​总结：</p><p>​获取session时，先去看浏览器中是否有保存session对象的id。</p><p>​①如果有，那就根据此id值，在服务器的内存中找对应的session对象，如果找不到就创建一个session对象。</p><p>​②如果没有，则直接在服务器的内存中创建一个session对象，然后响应时将session对象的id一起发送到浏览器中，然后浏览器保存在浏览器的内存中。</p><hr><h4 id="⑤使用细节–Session钝化、活化（了解）"><a href="#⑤使用细节–Session钝化、活化（了解）" class="headerlink" title="⑤使用细节–Session钝化、活化（了解）"></a>⑤使用细节–Session钝化、活化（了解）</h4><p>​服务器正常重启后，Session中的数据是否还在？</p><ul><li>钝化：在服务器正常关闭后，Tomcat会自动将Session数据写入硬盘的文件中。</li><li>活化：再次启动服务器后，从文件中加载数据到Session中。</li></ul><p>​什么才算服务器正常关闭？就是通过命令行去关闭服务器。</p><p>​①先在命令行启动该项目</p><img src="/imgs/image-20230424152041417.png" alt="image-20230424152041417" style="zoom:67%;" /><p>​②然后在命令行输入 ctrl + c –&gt; yes –&gt; 正常关闭。</p><img src="/imgs/image-20230424152050178.png" alt="image-20230424152050178" style="zoom:67%;" /><p>​</p><p>​                           <img src="/imgs/image-20230424152059397.png" alt="image-20230424152059397"></p><p>​如果点击上图的按钮进行重启，那么这个 “重启” 属于不正常重启。</p><hr><h4 id="⑥使用细节–Session销毁"><a href="#⑥使用细节–Session销毁" class="headerlink" title="⑥使用细节–Session销毁"></a>⑥使用细节–Session销毁</h4><ul><li><p>默认情况下，无操作，30分钟自动销毁。</p><ul><li><p>当然我们可以在web.xml文件中配置其自动销毁的时间。</p><p>  <img src="/../imgs/image-20221122135131562-1682310001088.png" alt="image-20221122135131562"></p></li></ul></li><li><p>调用Session对象的invalidate()方法。</p><ul><li>应用：将来用户登录的数据都会放在Session对象中，那么退出登录的时候就需要用到Session对象的invalidate()方法了。</li></ul></li></ul><hr><h4 id="⑦补充"><a href="#⑦补充" class="headerlink" title="⑦补充"></a>⑦补充</h4><p>​<img src="/imgs/image-20230424152107298.png" alt="image-20230424152107298" style="zoom:67%;" /></p><p>​当浏览器发送请求1给A Servlet时，在A Servlet获取Session对象，然后关闭浏览器，重新开一个浏览器访问B Servlet，在B Servlet里获取Session对象，此时A Servlet中获取到的Session对象 与 B Servlet中获取到的Session对象不是同一个内存对象。</p><p>​这是因为关闭浏览器后，浏览器内存中存储的session对象的 id 就没了，当B servlet再次获取session对象时，发现浏览器中并没有存储session对象的 id 值，因此就直接在服务器内存中新建了一个Session对象，因此就不是同一个对象了。</p><hr><h3 id="D-Cookie-amp-Session的比较"><a href="#D-Cookie-amp-Session的比较" class="headerlink" title="D.Cookie &amp; Session的比较"></a>D.Cookie &amp; Session的比较</h3><p>​<img src="/imgs/image-20230424152116094.png" alt="image-20230424152116094" style="zoom:67%;" /></p><p>​总结：</p><ol><li><p>Cookie一般用于用户未登录时进行身份验证的，而Session用来存储用户登录之后的数据的。</p></li><li><p>如果想让数据在关闭浏览器之后，下次打开浏览器时还存在，那么就只能使用Cookie。</p><p> 因为在浏览器关闭之后，保存到客户端的Session id 就会被销毁，下次打开浏览器再获取Session对象就不是同一个了。</p></li></ol><hr><h3 id="E-登录注册案例"><a href="#E-登录注册案例" class="headerlink" title="E.登录注册案例"></a>E.登录注册案例</h3><p><img src="/../imgs/image-20221122161512961-1682310001088.png" alt="image-20221122161512961"></p><h4 id="①用户登录"><a href="#①用户登录" class="headerlink" title="①用户登录"></a>①用户登录</h4><p><img src="/../imgs/image-20221122162023281-1682310001088.png" alt="image-20221122162023281"></p><p>​实现步骤：</p><ol><li><p>先写Dao层，再写Service层。</p></li><li><p>写登录页面 login.jsp。</p><p> 因为将来登录失败之后，需要动态获取数据来显示错误的提示信息，如果使用HTML就实现不了这个功能，所以得使用JSP。</p></li><li><p>编写LoginServlet。</p><ol><li><p>如果登录成功，则需要跳转到查询所有数据的Servlet去。可以使用请求转发或请求重定向来实现转发。这里使用请求重定向，因为想用一下Session对象。</p><ol><li>转发之前，先获取Session对象，调用设置参数的方法，将user对象存储到Session对象里。</li><li>在查询所有数据的JSP里，使用EL表达式获取user对象中的username。</li></ol></li><li><p>如果登录失败，则重新跳回到login.jsp。我们可以使用请求转发来实现跳转，跳转前先将提示信息 “用户名或密码错误”存储到request对象中。</p><ol><li><p>login.jsp页面中添加</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;提示信息对应的request对象中的键名&#125;</span><br></pre></td></tr></table></figure><p> 当request对象中没有该键名时，这行代码在页面中就什么也不会显示，当用户输入错误，就可以获取到其值，然后将 “用户名或密码错误”显示到页面。</p></li></ol></li></ol></li><li><p>完成。</p></li></ol><hr><h4 id="②记住用户"><a href="#②记住用户" class="headerlink" title="②记住用户"></a>②记住用户</h4><p>​<img src="/imgs/image-20230424152127444.png" alt="image-20230424152127444" style="zoom:67%;" /></p><p>​</p><p>​实现步骤：</p><ol><li><p>在页面login.jsp中的复选框里添加一个value属性 “value&#x3D;1”，当此复选框被勾选时value就会随着请求一起发送到服务器，我们就可以通过request对象来获取此value值，然后判断是否等于1，等于则说明复选框被勾选。</p></li><li><p>修改login.jsp，当登录成功并且复选框被选中，就将用户名和密码存储到Cookie对象中，设置存活数据，发送Cookie。</p><p> <img src="/../imgs/image-20221123105055644-1682310001088.png" alt="image-20221123105055644"></p></li><li><p>在login.jsp页面获取Cookie数据后，设置到用户名和密码框中。</p><p> 如何在JSP页面中获取Cookie数据呢？</p><p> 使用**${cookie.key.value}** &#x2F;&#x2F;其中key指存储在Cookie中的键名称，例子：${cookie.username.value} </p><p> <img src="/../imgs/image-20221123111359565-1682310001088.png" alt="image-20221123111359565"></p></li><li><p>完成</p></li></ol><hr><h4 id="③用户注册"><a href="#③用户注册" class="headerlink" title="③用户注册"></a>③用户注册</h4><p>​<img src="/../imgs/image-20221123114556845-1682310001088.png" alt="image-20221123114556845"></p><p>​</p><p>​实现步骤：</p><ol><li><p>在UserMapper接口中编写两个方法。</p></li><li><p>在UserService类中写注册方法。</p> <img src="/imgs/image-20230424152137911.png" alt="image-20230424152137911" style="zoom:67%;" /></li><li><p>编写注册页面register.jsp。因为将来要动态显示信息，所以得用JSP。</p></li><li><p>编写RegisterServlet。</p><p> <img src="/../imgs/image-20221123120456027-1682310001088.png" alt="image-20221123120456027"></p><p> <img src="/../imgs/image-20221123120431574-1682310001088.png" alt="image-20221123120431574"></p></li><li><p>在login.jsp和register.jsp对应的位置获取数据即可。</p></li><li><p>完成。</p></li></ol><hr><h4 id="④验证码–展示验证码"><a href="#④验证码–展示验证码" class="headerlink" title="④验证码–展示验证码"></a>④验证码–展示验证码</h4><p>​验证码其实就是由Java生成的一张图片。</p><p>​功能要求：</p><p>​展示验证码图片，并可以点击切换。</p><p>​实现步骤：</p><ol><li><p>修改验证码图片的访问路径。</p><p> <img src="/../imgs/image-20221123161817117-1682310001088.png" alt="image-20221123161817117"></p></li><li><p>编写checkCodeServlet，专门用来生成验证码和验证码图片。</p><p> <img src="/../imgs/image-20221123160616951-1682310001088.png" alt="image-20221123160616951"></p></li><li><p>为 “看不清” 按钮添加单击事件，实现换验证码图片的功能。</p><p> <img src="/../imgs/image-20221123162255170-1682310001088.png" alt="image-20221123162255170"></p><p> 如果不加 “new Date().getMillliseconds()” ，就会导致点击一次 “看不清”后再点击就换不了图片，原因是scr的那个路径被缓存了，所以得让这个src路径变化且唯一，因此在后面加上当前的时间即可。</p></li></ol><hr><h4 id="⑤验证码–校验验证码"><a href="#⑤验证码–校验验证码" class="headerlink" title="⑤验证码–校验验证码"></a>⑤验证码–校验验证码</h4><p>​验证码图片访问和提交注册表单是两次请求，所以要将程序生成的验证码存入Session中。</p><img src="/imgs/image-20230424152148060.png" alt="image-20230424152148060" style="zoom:67%;" /><p>​实现步骤：</p><ol><li><p>在CheckCodeServlet中将验证码存入session。</p><p> <img src="/../imgs/image-20221123164008334-1682310001089.png" alt="image-20221123164008334"></p></li><li><p>在regiserServlet里获取用户输入的验证码数据，获取程序生成的验证码。</p><p> <img src="/../imgs/image-20221123164406790-1682310001089.png" alt="image-20221123164406790"></p></li><li><p>比对验证码信息。比对操作要写在注册操作的前面，不然注册了再进行比对就没有意义了。</p><p> <img src="/../imgs/image-20221123165517995-1682310001089.png" alt="image-20221123165517995"></p></li><li><p>在register.jsp页面中补充一段代码，用于验证码输入错误时出现提示信息。</p> <figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h6&gt;$&#123;register_msg&#125;&lt;/h6&gt;</span><br></pre></td></tr></table></figure></li><li><p>完成。</p></li></ol><hr><h2 id="11、Filter"><a href="#11、Filter" class="headerlink" title="11、Filter"></a>11、Filter</h2><h3 id="A-概述-1"><a href="#A-概述-1" class="headerlink" title="A.概述"></a>A.概述</h3><p>​<img src="/imgs/image-20230424152155797.png" alt="image-20230424152155797" style="zoom:67%;" /></p><p>​资源中一些通用的操作可以放到Filter过滤器中，这样可以节省代码量。</p><h3 id="B-Filter快速入门"><a href="#B-Filter快速入门" class="headerlink" title="B.Filter快速入门"></a>B.Filter快速入门</h3><p><img src="/../imgs/image-20221123182453927-1682310001089.png" alt="image-20221123182453927"></p><p>​</p><hr><h3 id="C-Filter执行流程"><a href="#C-Filter执行流程" class="headerlink" title="C.Filter执行流程"></a>C.Filter执行流程</h3><p>​<img src="/imgs/image-20230424152204323.png" alt="image-20230424152204323" style="zoom:67%;" /></p><p>​</p><ul><li><p>Filter执行流程：<img src="/imgs/image-20230424152244187.png" alt="image-20230424152244187"></p></li><li><p>一般，放行前，对request对象中的数据进行处理；放行后，对response数据进行处理。</p><p>  因为放行前request对象中就已经有数据了（服务器会自动地将请求数据放到request对象中），而response对象中还没有数据，所以放行前对equest对象中的数据进行处理。放行后，就会去访问服务器的资源，然后回到Filter中执行放行后的代码，因此放行后会对response数据进行处理。</p></li></ul><hr><h3 id="D-Filter使用细节"><a href="#D-Filter使用细节" class="headerlink" title="D.Filter使用细节"></a>D.Filter使用细节</h3><h4 id="①Filter-拦截路径配置"><a href="#①Filter-拦截路径配置" class="headerlink" title="①Filter 拦截路径配置"></a>①Filter 拦截路径配置</h4><p>​<img src="/imgs/image-20230424152252945.png" alt="image-20230424152252945" style="zoom:67%;" /></p><h4 id="②过滤器链"><a href="#②过滤器链" class="headerlink" title="②过滤器链"></a>②过滤器链</h4><p>​<img src="/imgs/image-20230424152301823.png" alt="image-20230424152301823" style="zoom:67%;" /></p><ul><li><p>按照上图，Filter的执行流程是：Filter1 –&gt; 放行前逻辑 –&gt; 放行 –&gt; Filter2的放行前逻辑 –&gt; 放行 –&gt; web资源 –&gt; Filter2中的放行后逻辑 –&gt; Filter1中的放行后逻辑。</p></li><li><p>如果有多个过滤器，那先执行哪个过滤器呢？</p><p>  注解配置的Filter，过滤器的执行顺序是按照 过滤器类名的升序排序的，即对类名中的每个字母按照字母顺序进行比较，小的就先执行。</p><p>  如：过滤器1的类名为：filterDemo，过滤器2的类名为：filterDemo2，过滤器3的类名为：AFilter。</p><p>  ​其执行顺序是：</p><p>  ​AFilter –&gt; filterDemo –&gt; filterDemo2</p><p>  ​因为A排在F的前面，因此比较小先执行；filterDemo 和 filterDemo2前面都一样，而filterDemo的 “o” 后面没有东西，所以比较小。</p></li></ul><hr><h3 id="E-案例"><a href="#E-案例" class="headerlink" title="E.案例"></a>E.案例</h3><p>​引入：</p><p>​我们希望服务器中任何资源被访问前都先登录然后再访问。如果每个资源中都写判断是否登录的代码，那就会有很多重复的代码，所以就不妨把判断是否登录的代码放在过滤器中，这样就可以节省代码量。</p><p>​<img src="/../imgs/image-20221124215854668-1682310001089.png" alt="image-20221124215854668"></p><p>​</p><p>​实现：</p><p><img src="/../imgs/image-20221124220505631-1682310001089.png" alt="image-20221124220505631"></p><p><img src="/../imgs/image-20221124220522055-1682310001089.png" alt="image-20221124220522055"></p><p><img src="/../imgs/image-20221124220542999-1682310001089.png" alt="image-20221124220542999"></p><hr><h2 id="12、Listener"><a href="#12、Listener" class="headerlink" title="12、Listener"></a>12、Listener</h2><h3 id="A-概述-2"><a href="#A-概述-2" class="headerlink" title="A.概述"></a>A.概述</h3><p><img src="/../imgs/image-20221125154415677-1682310001089.png" alt="image-20221125154415677"></p><p>​在这个8个监听器中最重要的就是ServletContextListener监听器，其代表着整个web项目。（当web应用发布成功时，就会自动创建ServletContextListener对象，调用其里面的contextInitialized方法；当web项目被卸载时，就会调用其里面的contextDestroyed方法进行销毁）</p><h3 id="B-ServletContextListener使用"><a href="#B-ServletContextListener使用" class="headerlink" title="B.ServletContextListener使用"></a>B.ServletContextListener使用</h3><ol><li>写一个类，该类继承ServletContextListener接口，复写接口中所有的方法。</li><li>在该类上面写上@WebListener注解。</li></ol><p>补充：</p><ol><li>一般在contextInitialized()方法里进行资源的加载操作，在contextDestroyed()里释放资源。</li><li>现在先不用管其里面需要加载哪些资源，到时候讲到Spring时，Spring里面就是用ServletContextListener监听器中的contextInitialized()方法来加载Spring所需要的资源的。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web核心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ElementUI</title>
      <link href="/2023/04/24/ElementUI/"/>
      <url>/2023/04/24/ElementUI/</url>
      
        <content type="html"><![CDATA[<h2 id="①概述"><a href="#①概述" class="headerlink" title="①概述"></a>①概述</h2><ul><li><p>Element：是饿了么公司前端开发团队提供的一套基于 Vue 的网站组件库，用于快速构建网页。</p></li><li><p>组件：组成网页的部件，例如 超链接、按钮、图片、表等等~。</p></li><li><p>Element官网：</p>  <figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://element.eleme.cn/#/zh-CN/component/carousel</span><br></pre></td></tr></table></figure></li></ul><h2 id="②Element快速入门"><a href="#②Element快速入门" class="headerlink" title="②Element快速入门"></a>②Element快速入门</h2><ol><li><p>将Element ui文件复制到webapp下（Element ui文件在电脑 D:\web开发所需资料）</p></li><li><p>创建一个HTML。引入Element的css、js文件和 Vue.js。注意：文件路径从webapp下开始写</p><p> <img src="/imgs/image-20230312180602805-1682321984281.png" alt="image-20230312180602805"></p></li><li><p>创建div标签，设置其id值为app。以后从官网复制过来的代码都放在div标签包裹的范围里。如果涉及到CSS代码，则将CSS代码（style标签里包裹的代码就是CSS代码）放到HTML页面中的head标签里。</p></li><li><p>创建Vue核心对象</p><p> <img src="/imgs/image-20221128210855663-1682321984283.png" alt="image-20221128210855663"></p></li><li><p>官网复制Element组件代码</p></li></ol><p>​说明：不用看懂从官网复制的代码，你也看不懂，因为这是用Element定义的，不是HTML标签。实在不知道其意思，就试试将一部分代码删掉，再还原，此时就清楚其意思了。 </p><hr><h2 id="③Element布局"><a href="#③Element布局" class="headerlink" title="③Element布局"></a>③Element布局</h2><p>Element中有两种布局的方式：</p><ol><li><p>Layout布局：按行进行布局，一行里有24个格子。</p><p> <img src="/imgs/image-20221128214114256-1682321984283.png" alt="image-20221128214114256"></p><p> 如果想让这一行里只有两个格子，则让每个格子占12个格子的宽度。如：</p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-row</span>&gt;</span>   <span class="comment">&lt;!-- row代表行 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">el-col</span> <span class="attr">:span</span>=<span class="string">&quot;12&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;grid-content bg-purple&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">el-col</span>&gt;</span>   <span class="comment">&lt;!-- col代列 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">el-col</span> <span class="attr">:span</span>=<span class="string">&quot;12&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;grid-content bg-purple-light&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">el-col</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-row</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- 这里一共有一行，两个格子 --&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>Container布局容器：带侧边导航栏的布局方式。</p><p> <img src="/imgs/image-20221128213747606-1682321984283.png" alt="image-20221128213747606"></p></li></ol><hr><h2 id="④Element组件"><a href="#④Element组件" class="headerlink" title="④Element组件"></a>④Element组件</h2><p>​具体使用见Element官网。将官网中的代码复制过来，然后根据实际情况修改即可。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://element.eleme.cn/#/zh-CN/component/card</span><br></pre></td></tr></table></figure><hr><h2 id="⑤案例"><a href="#⑤案例" class="headerlink" title="⑤案例"></a>⑤案例</h2><h3 id="A-查询所有"><a href="#A-查询所有" class="headerlink" title="A.查询所有"></a>A.查询所有</h3><p><img src="/imgs/image-20221129170413333-1682321984283.png" alt="image-20221129170413333"></p><p>​</p><p>​实现：</p><ol><li><p>编写BrandMapper</p><ol><li><p>如果brand对象中的属性名和brand表中的字段名不一致，那就要像下面那样做映射。</p><p> <img src="/imgs/image-20221129170908576-1682321984284.png" alt="image-20221129170908576"></p></li><li><p>编写SQL语句</p><p> <img src="/imgs/image-20221129171111240-1682321984283.png" alt="image-20221129171111240"></p></li></ol></li><li><p>在Java下的service包下建对应service的接口，其实现类就放在impl文件下即可。（impl文件是放service文件下的）</p><p> 这样做的目的是降低web层和service层代码的耦合性（即关联程度）。</p><p> <img src="/imgs/image-20221129172310701-1682321984284.png" alt="image-20221129172310701"></p> <img src="/imgs/image-20230424154158092.png" alt="image-20230424154158092" style="zoom:67%;" /> </li><li><p>编写SelectAllServlet</p><p> <img src="/imgs/image-20221129173234909-1682321984284.png" alt="image-20221129173234909"></p></li><li><p>后台代码写完，对其进行测试看是否有出错。打开浏览器访问SelectAllServlet，如果页面中返回了JSON中的数据，则代表后台代码编写没有问题。</p></li><li><p>编写brand.html页面</p><ol><li><p>数据展示部分的代码可以抄Element官网中的表格，然后根据实际情况修改即可。</p></li><li><p>实现模型的双向绑定</p><p> <img src="/imgs/image-20221129174403466-1682321984286.png" alt="image-20221129174403466"></p><p> <img src="/imgs/image-20221129174331722-1682321984286.png" alt="image-20221129174331722"></p></li></ol></li><li><p>完成</p></li></ol><hr><h3 id="B-新增品牌"><a href="#B-新增品牌" class="headerlink" title="B.新增品牌"></a>B.新增品牌</h3><p><img src="/imgs/image-20221129183620359-1682321984286.png" alt="image-20221129183620359"></p><p>实现：</p><ol><li><p>编写BrandMapper</p><p> <img src="/imgs/image-20221129184045280-1682321984286.png" alt="image-20221129184045280"></p></li><li><p>在brandService接口中写上add方法，然后在刚才的brandService实现类中重写add方法</p><ol><li><p>brandService接口：</p><p> <img src="/imgs/image-20221129184449915-1682321984286.png" alt="image-20221129184449915"></p></li><li><p>brandService实现类：</p><p> <img src="/imgs/image-20221129184709296-1682321984287.png" alt="image-20221129184709296"></p></li></ol></li><li><p>编写AddServlet</p><p> <img src="/imgs/image-20221129185319861-1682321984287.png" alt="image-20221129185319861"></p></li><li><p>编写brand.html</p><p> <img src="/imgs/image-20221129210925084-1682321984287.png" alt="image-20221129210925084"></p><p> <img src="/imgs/image-20221129210742216-1682321984287.png" alt="image-20221129210742216"></p><p> <img src="/imgs/image-20221129205408131-1682321984287.png" alt="image-20221129205408131"></p><p> 补充：</p><p> <img src="/imgs/image-20221129205550233-1682321984287.png" alt="image-20221129205550233"></p></li></ol><hr><h3 id="C-Servlet代码优化"><a href="#C-Servlet代码优化" class="headerlink" title="C.Servlet代码优化"></a>C.Servlet代码优化</h3><h4 id="①引入"><a href="#①引入" class="headerlink" title="①引入"></a>①引入</h4><p>​以前我们每写一个功能就写对应的Servlet，随着功能不断丰富Servlet个数也越来越多，就不利于管理和编写，因此我们得对Servlet进行归类，对同一个实体的操作方法，写到一个Servlet中。比如：BrandServlet、UserServlet。</p><h4 id="②原理"><a href="#②原理" class="headerlink" title="②原理"></a>②原理</h4><p>​当我们访问BrandServlet时，其就会自动调用BaseServlet里的service方法，service方法就会根据请求路径的最后一段路径（我们约定这段路径写方法名），来调用对应Servlet中的方法。方法里再写些获取请求参数等操作。</p><p>​这就实现了Servlet代码优化。</p><h4 id="③实现步骤"><a href="#③实现步骤" class="headerlink" title="③实现步骤"></a>③实现步骤</h4><ol><li>先造一个基础的Servlet，命名为：BaseServlet。让其继承HttpServlet，重写service方法（重写内容如下：）</li></ol><p>  <img src="/imgs/image-20221130134703517-1682321984287.png" alt="image-20221130134703517"></p><p>  <img src="/imgs/image-20221130124052643-1682321984287.png" alt="image-20221130124052643"></p><p>  补充：</p><ul><li>上图中的this代表：BaseServlet的子类，如：BrandServlet、UserServlet等。</li><li>上图第40行代码中的getMehod方法：第一个参数是方法名，剩下的参数是：被获取方法的参数。该方法会抛异常，因此需要try-catch。</li><li>上图第42行代码中invoke方法：用于执行对应方法。实参req、resp：为第18行代码中的req、resp。该方法也会抛异常，因此也需要try-catch。</li></ul><ol start="2"><li><p>编写BrandServlet（以后对Brand进行操作的Servlet都放在这），让其继承刚才写的BaseServlet。</p><p> BrandServlet的访问路径得改成：&#x2F;brand&#x2F;*</p><p> <img src="/imgs/image-20221130130159491-1682321984287.png" alt="image-20221130130159491"></p><p> 例子：</p><p> <img src="/imgs/image-20221130140102546-1682321984288.png" alt="image-20221130140102546"></p></li></ol><hr><h3 id="D-批量删除"><a href="#D-批量删除" class="headerlink" title="D.批量删除"></a>D.批量删除</h3><p><img src="/imgs/image-20221130162304255-1682321984288.png" alt="image-20221130162304255"></p><p>实现：</p><ol><li><p>编写BrandMapper</p><p> <img src="/imgs/image-20221130162855157-1682321984288.png" alt="image-20221130162855157"></p><p> 由于此SQL语句比较复杂，就不使用注解开发，我们在对应的xml文件中写SQL语句。</p><p> <img src="/imgs/image-20221130170724498-1682321984288.png" alt="image-20221130170724498"></p><p> 如果忘记了如何写SQL语句，可以看笔记：MyBatis练习 –&gt; 删除–批量删除</p></li><li><p>编写BrandService。先在BrandService接口中声明deleteByIds方法，再去BrandService类中实现该方法。</p><p> <img src="/imgs/image-20221130163428292-1682321984288.png" alt="image-20221130163428292"></p></li><li><p>在BrandServlet里写deleteByIds方法。</p><p> <img src="/imgs/image-20221130163957050-1682321984289.png" alt="image-20221130163957050"></p></li><li><p>为批量删除按钮绑定事件，发送异步请求。</p><p> <img src="/imgs/image-20221130164534622-1682321984289.png" alt="image-20221130164534622"></p><p> 在Vue对象里的data部分创建一个selectedIds模型，用于存放被选中的id。</p><p> <img src="/imgs/image-20221130165924711-1682321984289.png" alt="image-20221130165924711"></p><p> 编写deleteByIds方法</p><p> <img src="/imgs/image-20221130170255771-1682321984289.png" alt="image-20221130170255771"></p><p> <img src="/imgs/image-20221130171235331-1682321984289.png" alt="image-20221130171235331"></p><p> <img src="/imgs/image-20221130174320989-1682321984289.png" alt="image-20221130174320989"></p><p> <img src="/imgs/image-20221130171530066-1682321984289.png" alt="image-20221130171530066"></p></li><li><p>完成</p></li></ol><hr><h3 id="E-分页查询"><a href="#E-分页查询" class="headerlink" title="E.分页查询"></a>E.分页查询</h3><h4 id="①复习"><a href="#①复习" class="headerlink" title="①复习"></a>①复习</h4><p>​之前我们在学习SQL的时候有学到分页查询，其用到的关键字为LIMIT </p><p><img src="/imgs/image-20230424154343007.png" alt="image-20230424154343007"></p><p><img src="/imgs/image-20221130180200634-1682321984289.png" alt="image-20221130180200634"></p><h4 id="②分析"><a href="#②分析" class="headerlink" title="②分析"></a>②分析</h4><p><img src="/imgs/image-20221130180822799-1682321984289.png" alt="image-20221130180822799"></p><p>如何才能一次性将后台数据List和totalCount发送给前端呢？将这两个数据封装到一个对象里，然后将对象传递过去进行。</p><h4 id="③实现"><a href="#③实现" class="headerlink" title="③实现"></a>③实现</h4><p><img src="/imgs/image-20221130183614827-1682321984290.png" alt="image-20221130183614827"></p><ol><li>编写BrandMapper</li></ol><p>  分页功能的实现需要后端传：分页结果、总记录数</p><p>  <img src="/imgs/image-20221130184101837-1682321984290.png" alt="image-20221130184101837"></p><ol start="2"><li><p>编写BrandService</p><p> 在BrandService里调用上面的两个SQL，因为这两个结果都需要返回给前端，所以就将数据封装到一个pageBean对象里。</p><p> 在pojo包下编写pageBean</p><p> <img src="/imgs/image-20221130182539066-1682321984290.png" alt="image-20221130182539066"></p><p> 先在BrandService接口中声明selectByPage方法。</p><p> <img src="/imgs/image-20221130184456247-1682321984290.png" alt="image-20221130184456247"></p><p> 在BrandService类中实现该方法</p><p> <img src="/imgs/image-20221130185614307-1682321984290.png" alt="image-20221130185614307"></p><p> <img src="/imgs/image-20221130185737858-1682321984290.png" alt="image-20221130185737858"></p></li><li><p>编写BrandServlet</p></li></ol><pre><code>获取前端发来的分页数据，并进行处理</code></pre><p><img src="/imgs/image-20221130201717396-1682321984290.png" alt="image-20221130201717396"></p><p>​</p><pre><code>3. 后端代码编写完成</code></pre><ol start="3"><li><p>编写前端代码</p><p> <img src="/imgs/image-20221130202431316-1682321984290.png" alt="image-20221130202431316"></p><ol><li><p>对分页工具条进行改造</p><p> <img src="/imgs/image-20221130205610788-1682321984291.png" alt="image-20221130205610788"></p><p> <img src="/imgs/image-20221130205655494-1682321984291.png" alt="image-20221130205655494"></p><p> ​改造Vue对象中的handleSizeChange方法及handleCurrentChange方法</p><p> <img src="/imgs/image-20221130210341041-1682321984291.png" alt="image-20221130210341041"></p></li><li><p>对Vue对象中的selectAll方法进行改造，改成分页查询的代码</p><p> <img src="/imgs/image-20221130204604741-1682321984291.png" alt="image-20221130204604741"></p></li></ol></li><li><p>完成</p></li></ol><hr><h3 id="F-条件查询"><a href="#F-条件查询" class="headerlink" title="F.条件查询"></a>F.条件查询</h3><p><img src="/imgs/image-20221201172950909-1682321984291.png" alt="image-20221201172950909"></p><p><img src="/imgs/image-20221201173535266-1682321984291.png" alt="image-20221201173535266"></p><p>实现：</p><ol><li><p>编写BrandMapper</p><p> <img src="/imgs/image-20221201174444242-1682321984291.png" alt="image-20221201174444242"></p><p> 在对应的xml文件中编写SQL语句：</p><p> <img src="/imgs/image-20221201175615596-1682321984291.png" alt="image-20221201175615596"></p><p> <img src="/imgs/image-20221201180222808-1682321984291.png" alt="image-20221201180222808"></p></li><li><p>编写BrandService</p><ol><li><p>在BrandService接口中编写selectByPageAndCondition方法</p><p> <img src="/imgs/image-20221201180505349-1682321984292.png" alt="image-20221201180505349"></p></li><li><p>在BrandService类中实现该方法</p><p> <img src="/imgs/image-20221201182138878-1682321984292.png" alt="image-20221201182138878"></p><p> <img src="/imgs/image-20221201182016734-1682321984292.png" alt="image-20221201182016734"></p><p> <img src="/imgs/image-20221201182118420-1682321984292.png" alt="image-20221201182118420"></p></li></ol></li><li><p>在brandServlet中编写selectByPageAndCondition方法，在方法里写获取数据、调用service中方法等操作</p><p> <img src="/imgs/image-20221201183858823-1682321984292.png" alt="image-20221201183858823"></p><p> <img src="/imgs/image-20221201182813902-1682321984292.png" alt="image-20221201182813902"></p></li><li><p>后端代码编写完成</p></li></ol><p>​前端代码编写：</p><p><img src="/imgs/image-20221201210322239-1682321984292.png" alt="image-20221201210322239"></p><ol><li><p>为查询按钮绑定单击事件</p><p> <img src="/imgs/image-20221201210416941-1682321984292.png" alt="image-20221201210416941"></p></li><li><p>详见视频</p> <figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.bilibili.com/video/BV1Qf4y1T7Hx/?p=162&amp;spm_id_from=pageDriver&amp;vd_source=9c398663599ac78b625d463b4ffc1ff5</span><br></pre></td></tr></table></figure></li></ol><h2 id="⑥补充"><a href="#⑥补充" class="headerlink" title="⑥补充"></a>⑥补充</h2><ol><li><p><img src="/imgs/image-20221201212936677-1682321984292.png" alt="image-20221201212936677"></p></li><li><p>es6之后我们引入了箭头表达式，可以简化Axios中then部分代码的书写</p><p> es6之前的写法：</p><p> <img src="/imgs/image-20221201212359565-1682321984293.png" alt="image-20221201212359565"></p><p> ​es6之后的写法：（此时then中的this就指的是Vue对象）</p><p> <img src="/imgs/image-20221201212111220-1682321984293.png" alt="image-20221201212111220"></p><p> ​</p></li></ol><p></p>]]></content>
      
      
      <categories>
          
          <category> Java Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ElementUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue</title>
      <link href="/2023/04/24/vue/"/>
      <url>/2023/04/24/vue/</url>
      
        <content type="html"><![CDATA[<h2 id="①概述"><a href="#①概述" class="headerlink" title="①概述"></a>①概述</h2><p><img src="/imgs/image-20221127192947272-1682321667875.png" alt="image-20221127192947272"></p><p>​双向绑定之后，Model中的数据发生变化View中的数据也会跟着发生变化；View中的数据发生变化，model中的数据也会跟着变化，这些变化都是自动完成的。</p><p>​View即HTML等，Model即数据。</p><hr><h2 id="②Vue快速入门"><a href="#②Vue快速入门" class="headerlink" title="②Vue快速入门"></a>②Vue快速入门</h2><ol><li><p>在webapp下建一个js目录，在vue官网下载vue.js文件，并将其放到刚才创建的js目录下。</p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://v2.cn.vuejs.org/v2/guide/installation.html</span><br></pre></td></tr></table></figure><p> <img src="/imgs/image-20221128092019798-1682321667877.png" alt="image-20221128092019798"></p></li><li><p>在webapp下新建HTML页面，写相关代码。</p><ol><li>引入Vue.js文件。</li></ol><p>   <img src="/imgs/image-20221128221027634-1682321667877.png" alt="image-20221128221027634"></p><ol start="2"><li>在script标签里创建Vue核心对象，进行数据绑定。</li></ol><p>   <img src="/imgs/image-20221128155708651-1682321667877.png" alt="image-20221128155708651"></p>   <img src="C:\Users\橙子\AppData\Roaming\Typora\typora-user-images\image-20221128152323193.png" alt="image-20221128152323193" style="zoom:67%;" /><p>  补充：</p><p> el属性的值一般为div标签中的id属性值，即：“#div标签的id值”。</p></li></ol><hr><h2 id="③Vue常用指令"><a href="#③Vue常用指令" class="headerlink" title="③Vue常用指令"></a>③Vue常用指令</h2><ul><li><p>指令：HTML标签上带有v-前缀的特殊属性。</p></li><li><p><img src="/imgs/image-20221128153146940-1682321667877.png" alt="image-20221128153146940"></p></li><li><p><img src="/imgs/image-20221128154515335-1682321667877.png" alt="image-20221128154515335"></p></li><li><p><img src="/imgs/image-20221128155524056-1682321667878.png" alt="image-20221128155524056"></p></li><li><p><img src="/imgs/image-20221128165940492-1682321667878.png" alt="image-20221128165940492"></p></li><li><p>sf1</p><p>  <img src="/imgs/image-20221128170906672-1682321667878.png" alt="image-20221128170906672"></p><p>  ​例子：</p><p>  <img src="/imgs/image-20221128170808623-1682321667878.png" alt="image-20221128170808623"></p><p>  <img src="/imgs/image-20221128171037620-1682321667878.png" alt="image-20221128171037620"></p><p>  <img src="/imgs/image-20221128170728942-1682321667878.png" alt="image-20221128170728942"></p></li></ul><hr><h2 id="④Vue生命周期"><a href="#④Vue生命周期" class="headerlink" title="④Vue生命周期"></a>④Vue生命周期</h2><p><img src="/imgs/image-20221128172227637-1682321667878.png" alt="image-20221128172227637"></p><p>​上面八个阶段中，我们重点关注挂载完成阶段mounted。因为挂载完成后，Vue初始化成功，HTML页面渲染成功，此时我们就会发生异步请求，加载数据。</p><p><img src="/imgs/image-20230424153528754.png" alt="image-20230424153528754"></p><hr><h2 id="⑤案例"><a href="#⑤案例" class="headerlink" title="⑤案例"></a>⑤案例</h2><p>​需求：使用Vue简化品牌列表数据查询和添加功能</p><ul><li><p>查询所有数据</p><p>  <img src="/imgs/image-20221128174544367-1682321667878.png" alt="image-20221128174544367"></p><p>  brand.html：</p><p>  <img src="/imgs/image-20221128181329131-1682321667879.png" alt="image-20221128181329131"></p><p>  <img src="/imgs/image-20221128180953473-1682321667879.png" alt="image-20221128180953473"></p><p>  ​说明：</p><ol><li><p>在Axios的then里使用this（this代表的是window对象），如果在Vue里Axios外面使用this（this代表当前Vue对象）。要想获取Vue里的模型数据，则要在如果在Vue里Axios外面使用this。</p></li><li><p>SelectAllServlet</p><p> 与JSON中案例一样做法。</p></li></ol></li><li><p>新增品牌</p><p>  <img src="/imgs/image-20221128183226881-1682321667879.png" alt="image-20221128183226881"></p><p>  实现：</p><p>  addBrand.html：</p><p>  <img src="/imgs/image-20221128184315288-1682321667879.png" alt="image-20221128184315288"></p><p>  <img src="/imgs/image-20221128184143087-1682321667879.png" alt="image-20221128184143087"></p></li></ul><p>​AddServlet：</p><p>​与JOSN中的案例一样做法。</p>]]></content>
      
      
      <categories>
          
          <category> Java Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web核心（上）</title>
      <link href="/2023/04/24/web%E6%A0%B8%E5%BF%83/"/>
      <url>/2023/04/24/web%E6%A0%B8%E5%BF%83/</url>
      
        <content type="html"><![CDATA[<h2 id="①概述"><a href="#①概述" class="headerlink" title="①概述"></a>①概述</h2><h3 id="A-B-x2F-S架构"><a href="#A-B-x2F-S架构" class="headerlink" title="A.B&#x2F;S架构"></a>A.B&#x2F;S架构</h3><p><img src="/../imgs/image-20221101095153149-1682310001084.png" alt="image-20221101095153149"></p><h3 id="B-浏览器如何访问到数据"><a href="#B-浏览器如何访问到数据" class="headerlink" title="B.浏览器如何访问到数据"></a>B.浏览器如何访问到数据</h3><p><img src="/../imgs/image-20221101095514293-1682310001085.png" alt="image-20221101095514293"></p><p>​浏览器通过数据传输协议HTTP发生请求给web服务器，web服务器收到请求后对HTTP协议进行解析，然后解析请求数据（服务器中存放了两种资源：静态资源、动态资源，动态资源负责逻辑处理和访问数据库，然后将动态资源发生给静态资源进行页面处理），并发送响应数据。</p><hr><h2 id="②HTTP"><a href="#②HTTP" class="headerlink" title="②HTTP"></a>②HTTP</h2><h3 id="A-概述"><a href="#A-概述" class="headerlink" title="A.概述"></a>A.概述</h3><h4 id="①概念"><a href="#①概念" class="headerlink" title="①概念"></a>①概念</h4><p><img src="/../imgs/image-20221101115959217-1682310001085.png" alt="image-20221101115959217"></p><h4 id="②HTTP特点"><a href="#②HTTP特点" class="headerlink" title="②HTTP特点"></a>②HTTP特点</h4><ol><li>基于TCP协议：面向连接，安全（在建立三次握手后再进行数据传输）。</li><li>基于请求-响应模型的：一次请求对应一次响应。</li><li>HTTP协议是无状态的协议：对于事务处理没有记忆能力。即：这次 “请求-响应”数据 并不会记录上一次的 “请求-响应” 的数据。<ul><li>缺点：多次请求间不能共享数据。Java中使用会话技术（Cookie、Session）来解决这个问题。<ul><li>例子：如果在网购时，选择某件商品将其加入购物车（这就完成了一次 “请求-响应” ），然后再点击购物车来查看购买的商品（这又是一次 “请求-响应” ），按照HTTP的无状态的特点，当我们点击购物车时是看不见购物车里有商品的，问了解决这个问题，所以我们就得使用Java中的会话技术来解决这个问题。</li></ul></li><li>优点：速度块。</li></ul></li></ol><h3 id="B-HTTP请求"><a href="#B-HTTP请求" class="headerlink" title="B.HTTP请求"></a>B.HTTP请求</h3><h4 id="①-请求数据格式"><a href="#①-请求数据格式" class="headerlink" title="①.请求数据格式"></a>①.请求数据格式</h4><ul><li><p>请求数据分为3部分：</p><ol><li><p>请求行：请求数据的第一行。其中GET表示请求方式(一共有7种请求方式)， &#x2F; ：表示请求资源路径(url)，HTTP&#x2F;1.1表示协议版本。</p></li><li><p>请求头：第二行开始，格式为key:value形式。</p> <img src="/imgs/image-20230424143722914.png" alt="image-20230424143722914" style="zoom: 67%;" /></li><li><p>请求体：POST请求特有，其位于POST请求的最后一部分，POST请求体与POST请求行之间是有空行隔开的。</p></li></ol></li></ul><h4 id="②-post请求和get请求区别"><a href="#②-post请求和get请求区别" class="headerlink" title="②.post请求和get请求区别"></a>②.post请求和get请求区别</h4><p>​<img src="/imgs/image-20230424143749954.png" alt="image-20230424143749954"></p><ol><li>GET请求请求参数在请求行的请求资源路径中，没有请求体。POST请求请求参数在请求体中。</li><li>由于GET请求请求参数存放在请求资源路径（即url）中，所以请求参数大小有限制。POST请求的请求参数大小没有限制。</li></ol><h3 id="C-HTTP响应"><a href="#C-HTTP响应" class="headerlink" title="C.HTTP响应"></a>C.HTTP响应</h3><h4 id="①响应数据格式"><a href="#①响应数据格式" class="headerlink" title="①响应数据格式"></a>①响应数据格式</h4><p>​<img src="/imgs/image-20230424143803097.png" alt="image-20230424143803097" style="zoom:67%;" /></p><p>​<img src="/imgs/image-20230424143813467.png" alt="image-20230424143813467" style="zoom:67%;" /></p><p>​</p><h4 id="②常见的HTTP响应头"><a href="#②常见的HTTP响应头" class="headerlink" title="②常见的HTTP响应头"></a>②常见的HTTP响应头</h4><p>​<img src="/imgs/image-20230424143825619.png" alt="image-20230424143825619" style="zoom:80%;" /></p><p>​补充：</p><ol><li>Content-Type的作用：告诉浏览器响要用 html 还是 image 去解析响应内容。</li><li>Cache-Control：在缓存时间内可以直接在本地上访问该页面，不用再发送请求，节省时间。</li></ol><h4 id="③响应状态码"><a href="#③响应状态码" class="headerlink" title="③响应状态码"></a>③响应状态码</h4><p><img src="/../imgs/image-20221101160303264-1682310001085.png" alt="image-20221101160303264"></p><p>​常见状态响应码</p><table><thead><tr><th align="center">状态码</th><th align="center">英文描述</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">200</td><td align="center">OK</td><td align="center">请求、响应成功，客户端正常访问到资源</td></tr><tr><td align="center">404</td><td align="center">Not Found</td><td align="center">请求资源不存在，一般是URL输入有误，或者网站资源被删除</td></tr><tr><td align="center">500</td><td align="center">Internal Server Error</td><td align="center">服务器发生不可预期的错误，服务器出现异常了，去看Java代码哪里出错了</td></tr></tbody></table><p>​其它状态响应码见：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://cloud.tencent.com/developer/chapter/13553</span><br></pre></td></tr></table></figure><hr><h2 id="③Web服务器-Tomcat"><a href="#③Web服务器-Tomcat" class="headerlink" title="③Web服务器-Tomcat"></a>③Web服务器-Tomcat</h2><h3 id="A-引入"><a href="#A-引入" class="headerlink" title="A.引入"></a>A.引入</h3><p>​原本我们需要去解析浏览器发给我们的HTTP请求并向浏览器发送响应，但现在不用了，web服务器就可以帮我们完成这些事。</p><h3 id="B-概念"><a href="#B-概念" class="headerlink" title="B.概念"></a>B.概念</h3><ol><li>Web服务器是一个应用软件，对HTTP协议的操作进行封装，使得程序员不必直接对协议进行操作，让Web开发更加便捷。Web服务器的主要功能是 “ 提供网上信息浏览服务 “。</li><li>Web服务器有：jetty:&#x2F;&#x2F; 、WebLogic、WebSphere、Tomcat</li></ol><p>​<strong>总结</strong>：</p><p>​Web服务器作用：</p><ol><li>封装HTTP协议操作，简化开发。</li><li>可以将web项目部署到服务器中，对外提供网上浏览服务。</li></ol><p>​</p><h3 id="C-Tomcat基本使用"><a href="#C-Tomcat基本使用" class="headerlink" title="C.Tomcat基本使用"></a>C.Tomcat基本使用</h3><h4 id="①下载、安装、卸载"><a href="#①下载、安装、卸载" class="headerlink" title="①下载、安装、卸载"></a>①下载、安装、卸载</h4><ul><li><p>下载</p><p>  直接在官网下载即可</p>  <figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://tomcat.apache.org/</span><br></pre></td></tr></table></figure><p>  选哪个版本下载？</p><p>  <img src="/../imgs/image-20221101210234025-1682310001085.png" alt="image-20221101210234025"></p></li><li><p>安装</p><p>  直接解压即可</p></li><li><p>卸载</p><p>  直接将整个tomcat目录删除即可</p></li></ul><h4 id="②Tomcat文件"><a href="#②Tomcat文件" class="headerlink" title="②Tomcat文件"></a>②Tomcat文件</h4><p>​<img src="/imgs/image-20230424143840531.png" alt="image-20230424143840531" style="zoom:80%;" /></p><ul><li>bin：存放可执行文件，其中 “.bat” 后缀的文件属于window的可执行文件， “.sh” 后缀的文件属于Linux的可执行文件。<ul><li>可以执行文件：点击之后直接运行的文件。</li></ul></li><li>conf：存放tomcat的配置文件。</li><li>lib：存放tomcat依赖的jar包。</li><li>logs：日志文件，如果以后web出现了错误，可以在日志文件中找到出错原因。</li><li>temp：存放临时文件。</li><li>webapps：将来将项目放到此目录下就实现了对项目的部署。</li><li>work：工作目录。</li></ul><h4 id="③启动、关闭"><a href="#③启动、关闭" class="headerlink" title="③启动、关闭"></a>③启动、关闭</h4><ul><li><p>启动</p><p>  <img src="/../imgs/image-20221102094759347-1682310001085.png" alt="image-20221102094759347"></p></li><li><p>关闭</p><ol><li>直接 x 掉运行窗口：强制关闭，不使用这种方式，因为会导致数据丢失。</li><li>bin\shutdown.bat：正常关闭</li><li>在运行窗口里输入：ctrl + c。正常关闭 —&gt; 推荐使用</li></ol><p>  在正常关闭的情况下，我们可以释放资源，而强制关闭则不能释放资源。</p></li></ul><h4 id="④配置"><a href="#④配置" class="headerlink" title="④配置"></a>④配置</h4><img src="/imgs/image-20230424143850052.png" alt="image-20230424143850052" style="zoom:80%;" /><p>​<strong>补充</strong>：启动窗口一闪而过，还有一个原因就是没有配置CATALINA_HOME环境变量</p><p>​<img src="/imgs/image-20230424143858259.png" alt="image-20230424143858259" style="zoom:67%;" /></p><p>​解决办法：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.cnblogs.com/wangkang0320/p/7404110.html</span><br></pre></td></tr></table></figure><h4 id="⑤部署"><a href="#⑤部署" class="headerlink" title="⑤部署"></a>⑤部署</h4><ul><li><p>Tomcat项目部署</p><ul><li><p>将项目放到Tomcat文件下的webapps目录下，即部署完成。</p><p>  如果项目比较大，直接将其复制过去会比较慢，所以推荐使用下面将项目打包的方式。</p></li></ul></li><li><p>一般JavaWeb项目会被打成war包，然后将war包放到webapps目录下，Tomcat会自动解压war文件。</p><ul><li>而IDEA中可以使用插件来完成对javaweb项目的打包操作。</li></ul></li></ul><h3 id="D-IDEA中创建maven-web项目"><a href="#D-IDEA中创建maven-web项目" class="headerlink" title="D.IDEA中创建maven web项目"></a>D.IDEA中创建maven web项目</h3><h4 id="①引入"><a href="#①引入" class="headerlink" title="①引入"></a>①引入</h4><p>​部署到tomcat服务器上的项目一般为Java web项目，用IDEA里的maven web就可以帮我们快速创建一个Java web项目了。</p><h4 id="②maven-web项目结构"><a href="#②maven-web项目结构" class="headerlink" title="②maven web项目结构"></a>②maven web项目结构</h4><img src="/imgs/image-20230424143907282.png" alt="image-20230424143907282" style="zoom:80%;" /><ul><li><p>开发中的Maven Web项目与普通的Maven Java项目的区别：</p><ol><li><p>Maven Web项目多了个webapp文件夹（用于存放web资源，如：css、HTML等）。</p></li><li><p>Maven Web项目中的pom.xml文件里需指定项目的打包方式为war。</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure><p> 注意：</p><p> 一个javaweb项目里必须要有webapp这个文件夹，该文件夹里必须要有WEB-INF这个文件，WEB-INF这个文件里又必须有web.xml这个文件。</p></li></ol></li><li><p>部署的Javaweb项目：</p><ol><li><p>如何得到？在IDEA中对项目右键 –&gt; run maven –&gt; package 。生成的打包内容放在该项目的target目录中。</p> <img src="/imgs/image-20230424143916006.png" alt="image-20230424143916006" style="zoom:80%;" /></li><li><p>部署的Java项目结构其实就是开发中的maven web项目结构中的webapp文件夹里的内容，不过WEB-INF文件夹中会有classes文件和lib文件。</p><ul><li>classes文件：存放编译后的Java字节码文件和resources的资源文件。</li><li>lib文件：存放pom.xml中依赖的jar包。</li></ul></li><li><p>将打包好的项目放到tomcat文件夹下的webapps文件里即可完成项目部署，然后就可以通过浏览器来访问了。</p></li></ol></li><li><p>补充：</p><p>  <img src="/../imgs/image-20221102154056588-1682310001085.png" alt="image-20221102154056588"></p></li></ul><p>​</p><h3 id="E-IDEA中创建Maven-Web项目–实现"><a href="#E-IDEA中创建Maven-Web项目–实现" class="headerlink" title="E.IDEA中创建Maven Web项目–实现"></a>E.IDEA中创建Maven Web项目–实现</h3><p>​</p><p>​<img src="/imgs/image-20230424143952502.png" alt="image-20230424143952502"></p><p><img src="/imgs/image-20230424144004559.png" alt="image-20230424144004559"></p><p><img src="/imgs/image-20230424144055434.png" alt="image-20230424144055434"></p><p><img src="/imgs/image-20230424144123015.png" alt="image-20230424144123015"></p><p>最后点击finish即可</p><ol start="5"><li><p>将新建好项目里的pom.xml文件中没用的插件删除掉。删剩如下内容即可：</p><p> <img src="/../imgs/image-20221102171618535-1682310001085.png" alt="image-20221102171618535"></p></li><li><p>补齐缺失的目录结构。在mai目录下建Java目录、resources目录。然后右键mask as 标记成相应的颜色。</p><p> <img src="/../imgs/image-20221102171935911-1682310001085.png" alt="image-20221102171935911"></p><p> <img src="/../imgs/image-20230220103104722-1682310001085.png" alt="image-20230220103104722"></p></li></ol><hr><h3 id="F-IDEA中使用Tomcat"><a href="#F-IDEA中使用Tomcat" class="headerlink" title="F.IDEA中使用Tomcat"></a>F.IDEA中使用Tomcat</h3><h4 id="①引入-1"><a href="#①引入-1" class="headerlink" title="①引入"></a>①引入</h4><p>​在编写web项目的过程中我们需要不停地运行网站进行测试，测试之前我们要先将web项目打包成war包，将war包放到tomcat目录下的webapp文件下，然后再运行网页，每次测试如果都这么做将会非常繁琐，使用我们就得在IDEA中使用Tomcat。</p><h4 id="②集成本地Tomcat"><a href="#②集成本地Tomcat" class="headerlink" title="②集成本地Tomcat"></a>②集成本地Tomcat</h4><ol><li><p>首先将本地Tomcat集成到Idea中</p></li><li><p><img src="/../imgs/image-20221102221348083-1682310001085.png" alt="image-20221102221348083"></p></li><li><p><img src="/imgs/image-20230424144213650.png" alt="image-20230424144213650"></p></li><li><p><img src="/imgs/image-20230424144305124.png" alt="image-20230424144305124"></p></li><li><p>进行项目部署</p><p> <img src="/imgs/image-20230424144316096.png" alt="image-20230424144316096"></p><p> 最后点击apply –&gt; ok即可</p></li><li><p>部署完成后，点击运行符号即可启动项目。</p></li></ol><h4 id="③Tomcat-maven插件"><a href="#③Tomcat-maven插件" class="headerlink" title="③Tomcat maven插件"></a>③Tomcat maven插件</h4><ol><li><p>安装maven helper插件，安装完之后在那里点击“restart idea”。</p> <img src="/imgs/image-20230424144325633.png" alt="image-20230424144325633" style="zoom:50%;" /> </li><li><p>在项目的pom.xml文件里导入tomcat插件</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--tomcat插件--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--注意只支持tomcat7及以下的版本--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--配置访问tomcat时的端口号,默认为8080--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">port</span>&gt;</span>80<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--配置访问该项目的路径，如果不配置会使用默认值--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">path</span>&gt;</span>/<span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>右击项目名 –&gt; run maven –&gt; tomcat7:run  –&gt; 点击如下链接即可访问</p><p> <img src="/../imgs/image-20221103150640685-1682310001085.png" alt="image-20221103150640685"></p></li></ol><hr><h2 id="④Servlet"><a href="#④Servlet" class="headerlink" title="④Servlet"></a>④Servlet</h2><h3 id="A-概述-1"><a href="#A-概述-1" class="headerlink" title="A.概述"></a>A.概述</h3><p>​<img src="/imgs/image-20230424144339044.png" alt="image-20230424144339044"></p><ol><li>Servlet是Java提供的一门动态web资源开发技术。</li><li>Servlet其实就是一个接口，将来我们需要定义servlet接口的实现类，并由web服务器运行servlet。</li></ol><h3 id="B-快速入门"><a href="#B-快速入门" class="headerlink" title="B.快速入门"></a>B.快速入门</h3><h4 id="①Servlet编写"><a href="#①Servlet编写" class="headerlink" title="①Servlet编写"></a>①Servlet编写</h4><p><img src="/../imgs/image-20221103171322067-1682310001086.png" alt="image-20221103171322067"></p><p>​<img src="/imgs/image-20230424144347746.png" alt="image-20230424144347746"></p><p>​上面的访问路径仅作参考</p><p>​<strong>补充</strong>：</p><p>​servlet的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="②说明"><a href="#②说明" class="headerlink" title="②说明"></a>②说明</h4><ol><li>Servlet依赖中的<scope>标签是用于规定依赖范围的，provided表示该依赖只能在编译和测试时使用。为什么要规定这个范围呢？这是因为Tomcat中也包含了Servlet，如果我们项目运行中也使用servlet就会造成冲突。所以得这样做。</li><li>Servlet接口中的service方法是自动执行的，当我们访问Servlet时，Servlet就会自动调用service方法。<ul><li>service方法是Servlet接口中最重要的方法。</li></ul></li></ol><h3 id="C-Servlet执行流程"><a href="#C-Servlet执行流程" class="headerlink" title="C.Servlet执行流程"></a>C.Servlet执行流程</h3><p><img src="/../imgs/image-20221103195232838-1682310001085.png" alt="image-20221103195232838"></p><ol><li><p>我们编写好Servlet后启动Tomcat服务器输入URL就能够访问到Servlet。而访问Servlet的URL由三部分组成：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/web-demo/demo1    各部分对应的内容：</span><br><span class="line">http://localhost:8080 --&gt; 主机上端口为8080的软件，即Tomcat（Tomcat的默认端口号为8080）</span><br><span class="line">web-demo --&gt; 该web项目的访问地址</span><br><span class="line">demo1 --&gt; 该Servlet的访问地址</span><br></pre></td></tr></table></figure></li><li><p>为什么我们访问Servlet时，就能自动访问Servlet接口中的service方法？而我们并没有创建Servlet对象，调用service方法</p><p> 因为Tomcat会帮我们创建Servlet对象并调用service方法。</p></li><li><p>服务器怎么知道Servlet中一定有service方法？</p><p> 因为我们自定义的Servlet实现类，必须实现Servlet接口并复写其方法，而Servlet接口中有service方法。</p></li></ol><hr><h3 id="D-Servlet生命周期"><a href="#D-Servlet生命周期" class="headerlink" title="D.Servlet生命周期"></a>D.Servlet生命周期</h3><h4 id="①概述-1"><a href="#①概述-1" class="headerlink" title="①概述"></a>①概述</h4><p>​对象的生命周期是指一个对象从被创建到被销毁的整个过程。</p><h4 id="②生命周期"><a href="#②生命周期" class="headerlink" title="②生命周期"></a>②生命周期</h4><p>​Servlet运行在Servlet容器中（即web服务器）中，其生命周期由容器来管理，分为4个阶段：</p><ol><li>加载和实例化：默认情况下，当servlet第一次被访问时，由容器创建Servlet对象。</li></ol><ul><li><p>不是默认情况：</p><p><img src="/imgs/image-20230424144407135.png" alt="image-20230424144407135"></p><p>当Servlet需要加载比较多的资源时，我们可以将其设置为服务器启动时创建，这样就可以节省加载时间。</p></li></ul><ol start="2"><li>初始化：在Servlet实例化之后，容器将调用Servlet的<strong>init()<strong>方法初始化这个对象，完成一些如：加载配置文件、创建连接等初始化的工作。</strong>该方法只调用一次。</strong></li><li>请求请求处理：每次请求Servlet时，Servlet容器都会调用Servlet的service()方法对请求进行处理。</li><li>服务终止：当需要释放内存或者容器关闭时，容器就会调用Servlet实例的destroy()方法释放init()方法中申请的资源。在destroy()方法调用之后，容器会释放这个Servelt实例，该实例随后会被Java的垃圾收集器所回收。</li></ol><h3 id="E-Servlet方法"><a href="#E-Servlet方法" class="headerlink" title="E.Servlet方法"></a>E.Servlet方法</h3><img src="/imgs/image-20230424144432101.png" alt="image-20230424144432101" style="zoom:50%;" /><ul><li>说明：getServletConfig()和getServletInfo()这两个方法比较少用<ul><li>getServletInfo()：用于获取作者信息等，这些信息都不重要，所以方法体里写：return “” ，即可。</li><li>getServletConfig()：获取ServletConfig对象，而这个对象由web服务器创建，所以我们获取即可。<ul><li>怎么获取？<ul><li>init()方法的参数就是接收一个ServletConfig对象，所以我们在5个方法外面声明一个ServletConfig对象，然后在init()方法里写：this.config &#x3D; config 。最后在getServletConfig()方法里写：return config 即可。</li></ul></li></ul></li></ul></li></ul><hr><h3 id="F-Servlet体系结构"><a href="#F-Servlet体系结构" class="headerlink" title="F.Servlet体系结构"></a>F.Servlet体系结构</h3><h4 id="①引入-2"><a href="#①引入-2" class="headerlink" title="①引入"></a>①引入</h4><p>​开发中我们最常用的就是Servlet里的service方法，而其它方法都比较少用，但由于得继承servlet接口，因此我们不得不重写其它四个不常用的方法，这就比较麻烦。所以我们引入了HttpServlet类。</p><h4 id="②概述"><a href="#②概述" class="headerlink" title="②概述"></a>②概述</h4><p>​<img src="/imgs/image-20230424144441044.png" alt="image-20230424144441044" style="zoom:80%;" /></p><p>​说明：</p><ol><li>GenericServlet此类比较少使用</li><li>我们将来开发B&#x2F;S结构的web项目，都是针对HTTP协议，所以我们自定义Servlet，会继承HttpServlet。</li></ol><h4 id="③HttpServlet使用"><a href="#③HttpServlet使用" class="headerlink" title="③HttpServlet使用"></a>③HttpServlet使用</h4><ol><li><p>创建一个类，该类继承HttpServlet类。</p></li><li><p>重写HttpServlet类里的doGet方法和doPost方法。</p><ul><li>doGet方法：写Get请求方式的处理逻辑。</li><li>doPost方法：写Post请求方式的处理逻辑。</li></ul></li><li><p>在该类的上方写上@WebServlet(“该servlet的访问路径”)</p><p> <img src="/../imgs/image-20221114174552006-1682310001086.png" alt="image-20221114174552006"></p></li></ol><h4 id="④为什么HttpServlet里分doGet和doPost"><a href="#④为什么HttpServlet里分doGet和doPost" class="headerlink" title="④为什么HttpServlet里分doGet和doPost"></a>④为什么HttpServlet里分doGet和doPost</h4><p>​因为Http请求的方式主要有两种：get、post。而这两种请求中数据存放的位置都不一样，get中的数据放在请求行中，而post中的数据放在请求体中，所以得分开来处理。</p><h4 id="⑤HttpServlet原理"><a href="#⑤HttpServlet原理" class="headerlink" title="⑤HttpServlet原理"></a>⑤HttpServlet原理</h4><p>​获取请求方式，并根据不同的请求方式，调用不同的doXxx方法·。</p><hr><h3 id="G-Servlet-urlPattern配置"><a href="#G-Servlet-urlPattern配置" class="headerlink" title="G.Servlet urlPattern配置"></a>G.Servlet urlPattern配置</h3><p>​Servlet要想被访问，必须配置其访问路径（urlPattern）</p><ol><li><p>一个Servlet，可以配置多个urlPattern。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(urlPatterns = &#123;&quot;/demo1&quot;,&quot;demo2&quot;&#125;)</span></span><br></pre></td></tr></table></figure><p> 可以通过两个路径来访问该servlet。</p></li><li><p>urlPattern配置规则</p><ol><li><p>​</p><p> <img src="/../imgs/image-20221114201428340-1682310001086.png" alt="image-20221114201428340"></p><p> ​需要精确地写上访问路径才能访问到该servlet。路径的开头必须写：&#x2F;</p></li><li><p> <img src="/../imgs/image-20221114201451361-1682310001086.png" alt="image-20221114201451361"></p><p> 说明：* 是通配符，代表任意的意识。路径的开头必须写：&#x2F;</p></li><li><p> ​<img src="/../imgs/image-20221114201953933-1682310001086.png" alt="image-20221114201953933"></p><p> ​如果用这种写法，路径的开头不能写：&#x2F;</p></li><li><p>任意匹配（不使用）</p><p> <img src="/../imgs/image-20221114202714779-1682310001086.png" alt="image-20221114202714779"></p><p> 访问该servlet时，其访问路径可以随便写（即 “hehe” 的位置可以写任意的东西）。</p><p> 注意：</p><ul><li>当我们的项目中的Servlet配置了 “ &#x2F; ”，会覆盖掉tomcat中的DefaultServlet（该servlet在conf文件夹中的web.xml文件里），该Servlet是提供静态资源访问服务的，即：通过该servlet可以访问静态的页面，如果覆盖掉就访问不了静态的页面，所以我们不会使用这种配置方式。</li></ul></li></ol></li></ol><p><img src="/../imgs/image-20221114204459824-1682310001086.png" alt="image-20221114204459824"></p><hr><h3 id="H-XML配置方式编写Servlet"><a href="#H-XML配置方式编写Servlet" class="headerlink" title="H.XML配置方式编写Servlet"></a>H.XML配置方式编写Servlet</h3><p>​Servlet从3.0版本后开始支持使用注解配置（@WebServlet()），3.0版本前只支持XML配置文件的配置方式。</p><p>​步骤：</p><p>​1.编写Servlet类，该类继承HttpServlet类，重写doGet和doPost方法</p><p>​2.在web.xml中配置该Servlet （@WebServlet()等价于下面两步）</p><p>​①Servlet的全类名<img src="/../imgs/image-20221114210521838-1682310001086.png" alt="image-20221114210521838"></p><p>​②Servlet的访问路径<img src="/../imgs/image-20221114210646506-1682310001086.png" alt="image-20221114210646506"></p><p>​</p><hr><h2 id="⑤Request-amp-Response"><a href="#⑤Request-amp-Response" class="headerlink" title="⑤Request &amp; Response"></a>⑤Request &amp; Response</h2><h3 id="A-概述-2"><a href="#A-概述-2" class="headerlink" title="A.概述"></a>A.概述<img src="/../imgs/image-20221114213047329-1682310001086.png" alt="image-20221114213047329"></h3><p>​浏览器发送Http请求数据给web服务器（如：tomcat），tomcat对这些数据进行解析，解析完后将数据存放到request对象里，我们就可以通过request对象来获取请求数据（如：用户的名字和密码）进行相应的逻辑处理；通过response对象我们可以设置响应的数据，tomcat服务器再通过我们的response对象来获取相应的响应数据然后将响应数据发送给浏览器，浏览器再进行解析就可以呈现出信息了。</p><p>总结：</p><ul><li>Request：获取请求数据</li><li>Response：设置响应数据</li></ul><h3 id="B-Request"><a href="#B-Request" class="headerlink" title="B.Request"></a>B.Request</h3><h4 id="①Request继承体系"><a href="#①Request继承体系" class="headerlink" title="①Request继承体系"></a>①Request继承体系</h4><p>​<img src="/imgs/image-20230424144451628.png" alt="image-20230424144451628" style="zoom:80%;" /></p><ol><li><p>为什么RequestFacade是由Tomcat定义的？</p><p> 因为Tomcat需要解析请求数据，将数据封装为request对象，并且创建request对象传递到service方法中，而service方法又是由Tomcat自动调用的，所以RequestFacade是由Tomcat创建的。</p></li><li><p>使用request对象，查阅JavaEE API文档的HttpServletRequest接口。</p><p> request对象属于RequestFacade类，而RequestFacade类实现了HttpServletRequest接口。因此想要看request对象里的方法就去查JavaEE API文档的HttpServletRequest接口 即可。</p></li></ol><h4 id="②Request获取请求数据"><a href="#②Request获取请求数据" class="headerlink" title="②Request获取请求数据"></a>②Request获取请求数据</h4><p><img src="/../imgs/image-20221115142753168-1682310001086.png" alt="image-20221115142753168"></p><p>​以上方法直接通过request对象调用即可。如：</p><p><img src="/../imgs/image-20221115141652298-1682310001086.png" alt="image-20221115141652298"></p><p>​</p><h4 id="③通用方式获取请求参数"><a href="#③通用方式获取请求参数" class="headerlink" title="③通用方式获取请求参数"></a>③通用方式获取请求参数</h4><ul><li><p>引入</p><p>  doGet和doPost里除了获取参数的方式不一样外，其它的处理逻辑都一样，因此我们可以在doPost里调用doGet方法，然后doGet方法里使用通用方式获取请求参数，这样就可以节省代码了。</p></li><li><p>通用方式获取请求参数的方法：</p>  <img src="/imgs/image-20230424144502112.png" alt="image-20230424144502112" style="zoom:67%;" /><p>  ​最常用的就是getParameter()和getParameterValues()。</p></li><li><p>例子</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/servlet-demo2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo2</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//通用方法获取请求参数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//逻辑处理</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        doGet(req,resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="④IDEA模板创建Servlet"><a href="#④IDEA模板创建Servlet" class="headerlink" title="④IDEA模板创建Servlet"></a>④IDEA模板创建Servlet</h4><ul><li><p>引入</p><p>  我们创建Servlet时，先造一个类继承HttpServlet，再重写doGet和doPost，最后写上@WebServlet(“ \xxxx “)。所有的servlet都是按这样的步骤创建，如果不使用模板就会比较慢，所以引入模板创建的方式。</p></li><li><p>模板创建Servlet</p><ol><li><p>修改IDEA中原来Servlet的模板格式，不然的话在创建完Servlet之后仍需要手动修改比较麻烦。</p><p> <img src="/../imgs/image-20221115155357370-1682310001086.png" alt="image-20221115155357370"></p></li><li><p>调用模板</p><p> 右键 –&gt; new –&gt; Servlet –&gt; 写该Servlet的名字 –&gt; OK–&gt; 修改模板中的@WebServlet(“”)的访问路径。</p></li></ol></li></ul><h4 id="⑤请求参数中文乱码–POST解决方案"><a href="#⑤请求参数中文乱码–POST解决方案" class="headerlink" title="⑤请求参数中文乱码–POST解决方案"></a>⑤请求参数中文乱码–POST解决方案</h4><ul><li><p>引入</p><p>  当HTML页面以Post方式提交数据给Servlet时，Servlet中获取到的数据可能是乱码的。<br>  因为用通用方式获取Post方式提交的数据，其底层实际上调用了getReader()方法来获取数据，而该方法默认以ISO&#x2F;IEC 8859编码集读取数据的，如果HTML页面的编码方式不是ISO&#x2F;IEC 8859 ，就会导致数据乱码。</p></li><li><p>解决方案</p><p>  在获取数据之前设置字符输入流的编码集为HTML页面的编码集</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br></pre></td></tr></table></figure><p>  <img src="/../imgs/image-20221115165116748-1682310001086.png" alt="image-20221115165116748"></p></li></ul><h4 id="⑥请求参数中文乱码–GET解决方案"><a href="#⑥请求参数中文乱码–GET解决方案" class="headerlink" title="⑥请求参数中文乱码–GET解决方案"></a>⑥请求参数中文乱码–GET解决方案</h4><ul><li><p>引入</p>  <img src="/imgs/image-20230424144511731.png" alt="image-20230424144511731" style="zoom:67%;" /><p>  ​浏览器并不能识别中文，所以会以HTML页面指定的编码集写成URL编码的形式，然后将此URL编码再发送给web服务器（Tomcat），Tomcat收到后进行URL解码（使用的是ISO-8859-1编码集），这就导致了我们获取请求数据时会出现乱码。而URL编码的过程由浏览器自动完成，URL解码的过程由web服务器自动完成。</p><ol><li><p>URL编码</p><p> ①将字符串按照HTML页面指定的编码方式转换为二进制。</p><p> ②每个字节转换为2个16进制数并在前面加上%。</p><p> 如：将中文 “张三” 使用URL编码，得：</p><p> <img src="/imgs/image-20230424144520487.png" alt="image-20230424144520487"></p><p> ​在UTF-8中，一个中文字符对应三个字节。</p></li><li><p>Java中有工具类可以实现URL编码、解码</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;张三&quot;</span>;</span><br><span class="line"><span class="comment">//URL编码</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> URLEncoder.encode(str,<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line"><span class="comment">//URL解码</span></span><br><span class="line"><span class="type">String</span> <span class="variable">e</span> <span class="operator">=</span> URLDecoder.decode(s.<span class="string">&quot;utf-8&quot;</span>);</span><br></pre></td></tr></table></figure></li></ol></li><li><p>解决方案</p><ol><li>将获取到的请求数据进行编码：转换为字节数组。</li><li>将字节数组解码。</li></ol><p>  例子：</p><p>  <img src="/../imgs/image-20221115175112898-1682310001086.png" alt="image-20221115175112898"></p></li><li><p>其它说明：</p><ol><li>这种解决方式不仅适用于Get请求还适用于Post请求，因此该解决方案属于通用的解决方案。</li><li>Tomcat8.0之后，已将Get请求乱码问题解决，设置默认的编码方式为UTF-8。</li></ol></li></ul><hr><h4 id="⑦请求转发"><a href="#⑦请求转发" class="headerlink" title="⑦请求转发"></a>⑦请求转发</h4><p>- </p><pre><code>&lt;img src=&quot;/imgs/image-20230424144529765.png&quot; alt=&quot;image-20230424144529765&quot; style=&quot;zoom:67%;&quot; /&gt;</code></pre><ul><li><p>请求转发资源间共享数据</p><p>  使用Request对象里的方法：</p>  <img src="/imgs/image-20230424144538865.png" alt="image-20230424144538865" style="zoom:67%;" /><p>  如：</p><p>  <img src="/../imgs/image-20221115204258639-1682310001086.png" alt="image-20221115204258639"></p><p>  <img src="/../imgs/image-20221115204350487-1682310001086.png" alt="image-20221115204350487"></p></li><li><p>请求转发特点</p><ul><li>请求转发不会改变浏览器地址栏的路径。</li><li>请求转发只能发生在当前服务器的内部资源。</li><li>可以在转发的资源间使用request共享数据。</li></ul></li></ul><hr><h3 id="C-Response"><a href="#C-Response" class="headerlink" title="C.Response"></a>C.Response</h3><h4 id="①概述-2"><a href="#①概述-2" class="headerlink" title="①概述"></a>①概述</h4><ol><li><p>Response：使用response对象来设置响应数据，然后web服务器再从response对象中设置的数据中去取相应的数据，如何组成Htpp响应数据发送给浏览器。</p></li><li><p>Response的体系结构：</p><p> ​<img src="/imgs/image-20230424144545909.png" alt="image-20230424144545909" style="zoom:67%;" /></p></li><li><p>为什么ResponseFacade类需要Tomcat来造？</p><p> 因为Servlet接口中的service方法中的参数需要response对象，所以得造这个实现类。</p></li></ol><p></p><p>​</p><h4 id="②Response设置响应数据功能介绍"><a href="#②Response设置响应数据功能介绍" class="headerlink" title="②Response设置响应数据功能介绍"></a>②Response设置响应数据功能介绍</h4><p>​<img src="/imgs/image-20230424144715233.png" alt="image-20230424144715233" style="zoom:67%;" /></p><p>​以上方法都是通过response对象来调用。</p><p>​getWriter()和getOutputStream()的使用：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://blog.csdn.net/daqi1983/article/details/119605463</span><br></pre></td></tr></table></figure><h4 id="③Response完成重定向"><a href="#③Response完成重定向" class="headerlink" title="③Response完成重定向"></a>③Response完成重定向</h4><ol><li><p>重定向</p><p> <img src="/imgs/image-20230424144724173.png" alt="image-20230424144724173"></p><p> 当浏览器向资源A发送请求时，资源A说（请求响应）：“我处理不了，你找别人处理吧，那个人的位置是xxx”。然后浏览器就根据那个地址自动地去找资源B了。这就是重定向。</p></li><li><p>重定向实现</p><p> 在资源A里写：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">response.setStatus(<span class="number">302</span>); <span class="comment">//含义：我处理不了，你找别人处理吧</span></span><br><span class="line">response.setHeader(<span class="string">&quot;location&quot;</span>,<span class="string">&quot;该项目的访问路径/资源B的访问路径&quot;</span>); <span class="comment">//含义：那个人的位置是xxx</span></span><br></pre></td></tr></table></figure><p> 由于上面的代码很多部分都是固定写法，所以可以使用如下简化的方式写：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.sendRedirect(<span class="string">&quot;该项目的访问路径/资源B的访问路径&quot;</span>); <span class="comment">//该方法底层与旧的写法一样。</span></span><br></pre></td></tr></table></figure></li><li><p>重定向特点</p><ul><li>浏览器地址栏路径发生改变。因为浏览器发送了两次请求。</li><li>可以重定向到任意位置的资源（服务器内部、外部均可）。</li><li>由于重定向发送了两次请求，产生了两个不同的request对象，所以不能在多个资源间使用request共享数据。</li></ul></li></ol><h4 id="④路径问题"><a href="#④路径问题" class="headerlink" title="④路径问题"></a>④路径问题</h4><p>​<img src="/imgs/image-20230424144735256.png" alt="image-20230424144735256" style="zoom:80%;" /></p><p>​如何动态获取虚拟目录？</p><p>​使用request对象中的getContextPath()方法获取虚拟目录。如：</p><p>​<img src="/../imgs/image-20221116133115169-1682310001086.png" alt="image-20221116133115169"></p><hr><h4 id="⑤Response响应字符数据"><a href="#⑤Response响应字符数据" class="headerlink" title="⑤Response响应字符数据"></a>⑤Response响应字符数据</h4><ol><li><p>引入</p><p> 通过response对象设置响应数据，web服务器再从response对象里获取响应数据最后发送给客户端，客户端浏览器接收到数据再进行解析就能看到信息了。</p></li><li><p>Response响应字符数据—实现</p><p> ①调用response对象里的getWriter()方法获取字符输出流。</p><p> ②调用字符输出流里的write()方法。write()方法里不仅可以写普通的字符数据，还可以写HTML代码。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">writer.write(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">writer.write(<span class="string">&quot;&lt;h1&gt;aaa&lt;/h1&gt;&quot;</span>);</span><br></pre></td></tr></table></figure><p> ③如果输出的内容中包含中文或HTML代码就要进行响应设置。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);<span class="comment">//此行代码要写在获取字符输出流的前面</span></span><br></pre></td></tr></table></figure><p> ​因为①如果字符输出流的默认编码集是：ISO-8859-1，所以得改，不然中文显示出来会乱码。②浏览器对服务器发送过来的数据默认采用字符的形式进行解析，所以如果发送过来的是HTML代码就会解析不出来，因此得设置一下浏览器的解析方式为：text&#x2F;html。</p></li><li><p>细节点</p><ul><li>字符输入流不需要我们关闭，因为随着响应结束，response对象销毁，由服务器关闭。</li><li>setContentType()方法主要由两个功能：①设置字符输出流的编码集。②设置浏览器的解析方式。</li></ul></li></ol><hr><h4 id="⑥Response响应字节数据"><a href="#⑥Response响应字节数据" class="headerlink" title="⑥Response响应字节数据"></a>⑥Response响应字节数据</h4><p>​实现：</p><ol><li><p>读取想要被输出的字节数据（如：图片、音频、视频等）</p></li><li><p>获取response字节输出流。</p></li><li><p>将输入流中的数据复制到输出流中</p><ul><li><p>IOUtils工具类使用</p><ul><li><p>在pom.xml文件中导入依赖</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IOUtils.copy(输入流,输出流);</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>关闭输入流</p></li></ol><p>​例子：</p><p><img src="/../imgs/image-20221116153359263-1682310001086.png" alt="image-20221116153359263"></p><hr><h3 id="D-应用"><a href="#D-应用" class="headerlink" title="D.应用"></a>D.应用</h3><h4 id="①登录"><a href="#①登录" class="headerlink" title="①登录"></a>①登录</h4><p>​登录操作的流程图：</p><p><img src="/../imgs/image-20221117155148483-1682310001086.png" alt="image-20221117155148483"></p><p>​实现步骤：</p><ol><li><p>在webapp 下建个文件夹html（专门用来放HTML页面），在此文件中建一个登录页面 login.html。</p></li><li><p>在MySQL数据库里建一个数据库，再在数据库里建一张user表，在user表里添加一些数据。</p></li><li><p>Mapper代理开发（见笔记Mybatis –&gt; Mapper代理开发），编码的部分先不写。</p></li><li><p>在java文件夹下建一个包 com.zzc.web（用来放servlet），在此包下，建一个类，该类继承HttpServlet，并重写doGet和doPost方法。在doGet方法里：</p></li><li><p>使用request对象的getParameter()方法，获取请求数据。</p></li><li><p>写Mapper代理开发中的编码部分</p><p> <img src="/../imgs/image-20221117143153606-1682310001086.png" alt="image-20221117143153606"></p></li></ol><pre><code>3. 设置响应数据  ![image-20221117143316925](../imgs/image-20221117143316925-1682310001086.png)4. 修改login.html页面中表单的action为：“该项目的访问路径/该servlet的访问路径”。  如果该项目的访问路径为：/ 。该servlet的访问路径为：/servlet。则action应该为：/servlet。</code></pre><hr><h4 id="②注册"><a href="#②注册" class="headerlink" title="②注册"></a>②注册</h4><p><img src="/../imgs/image-20221117160313570-1682310001086.png" alt="image-20221117160313570"></p><p>​实习步骤：</p><ol><li><p>在webapp下的html文件中建一个注册界面（register,html）。</p></li><li><p>在映射接口UserMapper中添加方法</p><p> 这里使用了注解开发</p><p> <img src="/../imgs/image-20221117165650698-1682310001087.png" alt="image-20221117165650698"></p></li><li><p>在java.zzc.web下新建一个servlet，用于处理注册。</p><ol><li><p>使用request对象中的getParameter方法获取请求数据。</p></li><li><p>调用UserMapper中的selectByUserName根据用户名查询，返回User对象。</p><ol><li><p>建立数据库连接</p><p> <img src="/../imgs/image-20221117170325034-1682310001087.png" alt="image-20221117170325034"></p></li><li><p>根据用户名进行查询</p><p> <img src="/../imgs/image-20221117170408894-1682310001087.png" alt="image-20221117170408894"></p></li></ol></li><li><p>判断User对象是否为null</p><ol><li><p>为null：用户名不存在，调用UserMapper中的add方法添加用户。</p></li><li><p>不为null：用户名重复，返回 “用户名已存在”。</p><p> <img src="/../imgs/image-20221117171506104-1682310001087.png" alt="image-20221117171506104"></p></li></ol></li></ol></li></ol><h4 id="③代码优化"><a href="#③代码优化" class="headerlink" title="③代码优化"></a>③代码优化</h4><p>​每次建立数据库连接时，都会用到下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);java</span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br></pre></td></tr></table></figure><p>​这就会造成如下问题：</p><ol><li><p>代码重复   —&gt;  解决办法：将代码放到自己创建的工具类里</p></li><li><p>每创建一个SqlSessionFactory就会创建一个数据库连接池，如果多次创建SqlSessionFactory，就会造成资源浪费。 —&gt;  解决办法：静态代码块。</p><p> ​</p><p> 实现：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SqlSessionFactoryUtils</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">//静态代码块随着类的加载而自动执行，且只执行一次。</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line">            sqlSessionFactory = <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SqlSessionFactory <span class="title function_">getsqlSessionFactory</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="⑥JSP"><a href="#⑥JSP" class="headerlink" title="⑥JSP"></a>⑥JSP</h2><h3 id="A-概述-3"><a href="#A-概述-3" class="headerlink" title="A.概述"></a>A.概述</h3><h4 id="①引入-3"><a href="#①引入-3" class="headerlink" title="①引入"></a>①引入</h4><p>​我们知道servlet里可以写Java代码，然后也可以通过response对象调用getWriter()来获取输出流对象，输入流对象再调用write()方法，在write()方法里写HTML代码。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">writer.write(<span class="string">&quot;&lt;h1&gt;aaa&lt;/h1&gt;&quot;</span>);</span><br></pre></td></tr></table></figure><p>​在write()方法里写HTML代码不仅书写困难，而且不方便阅读。所以我们引入了JSP。</p><h4 id="②概念"><a href="#②概念" class="headerlink" title="②概念"></a>②概念</h4><ul><li><p>JSP：Java Server Pages，Java服务端页面。</p></li><li><p>JSP里既可以写：HMTL、CSS、JS等静态内容，又可以写Java代码的动态内容。这就很好地解决了引入中的问题。</p>  <img src="/imgs/image-20230424144749300.png" alt="image-20230424144749300" style="zoom:80%;" /></li><li><p>JSP &#x3D; Java + HTML</p></li></ul><p>​</p><hr><h3 id="B-JSP快速入门"><a href="#B-JSP快速入门" class="headerlink" title="B.JSP快速入门"></a>B.JSP快速入门</h3><ol><li><p>导入JSP依赖</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p> 为什么要设置<scope>provided</scope>？</p><p> ​将来项目需要打war包部署到tomcat文件夹的的webapps目录下运行，就要将jsp的jar包删掉，因为tomcat中自带了jsp的jar包，如果不删除的话会出错的。</p></li><li><p>创建JSP文件</p><p> webapp –&gt; 右键 –&gt; new –&gt; JSP&#x2F;JSPX</p></li><li><p>编写HTML标签 和 Java代码</p><p> <img src="/imgs/image-20230424144758983.png" alt="image-20230424144758983"></p><p> ​Java代码写在：&lt;% java代码 %&gt;，“ &lt;% java代码 %&gt; ”被称为JSP脚本。</p></li></ol><hr><h3 id="C-JSP原理"><a href="#C-JSP原理" class="headerlink" title="C.JSP原理"></a>C.JSP原理</h3><ul><li><p><strong>JSP本质上就是一个servlet</strong></p>  <img src="/imgs/image-20230424144806298.png" alt="image-20230424144806298" style="zoom:80%;" /><p>  ​JSP在被访问时，由JSP容器（Tomcat）将其转换为Java文件（Servlet），在由JSP容器（Tomcat）将其编译，最终对外提供服务的其实就是这个字节码文件。</p></li><li><p>JSP –&gt; Servlet是如何转换的？</p><p>  其实就是将JSP中的HTML代码写到 输出流（response调用getWrite()获取到的输出流）的write()方法里，然后将Java代码从JSP脚本中取出来，至此转换完成。</p><p>  ​</p></li></ul><p></p><hr><h3 id="D-JSP脚本"><a href="#D-JSP脚本" class="headerlink" title="D.JSP脚本"></a>D.JSP脚本</h3><h4 id="①概述-3"><a href="#①概述-3" class="headerlink" title="①概述"></a>①概述</h4><ul><li>JSP脚本用于在JSP页面内定义Java代码。</li><li>JSP脚本分类<ul><li>＜％…％＞：JSP转换为servlet时，内容会直接放到＿jspService() 方法之中。</li><li>＜％＝…％＞：JSP转换为servlet时，内容会放到out.print() 中，作为out.print() 的参数。<ul><li>out.print()方法的作用：就是将参数的内容输出到页面中。</li><li>out.print()该方法声明在＿jspService()方法中。</li></ul></li><li>＜％！…％＞：JSP转换为servlet时，内容会放到＿jspService() 方法之外，被类直接包含。即内容放到成员变量的位置，也就是说可以用来定义成员变量和成员方法。</li></ul></li></ul><p>​说明：①JSP脚本里不能写HTML代码，如果需要写可以采取将JSP脚本截断的方式来写。②HTML代码里可以写JSP脚本。详见练习。</p><p>​</p><h4 id="②练习"><a href="#②练习" class="headerlink" title="②练习"></a>②练习</h4><p>​从数据库中获取品牌信息，放到List集合里，然后遍历输出到页面。</p><p><img src="/../imgs/image-20221118114510135-1682310001087.png" alt="image-20221118114510135"></p><p>​实现步骤：</p><p><img src="/../imgs/image-20221118113531799-1682310001087.png" alt="image-20221118113531799"></p><p>​</p><p>​补充：</p><ol><li><p>如果在&lt;%%&gt;里使用System.out.println(“”)，输出结果会显示到IDEA的控制台中。</p></li><li><pre><code class="jsp"> &lt;% for (int i = 0;i &lt; users.size();i++)&#123;     User user = users.get(i); %&gt;     &lt;tr&gt;         &lt;td&gt;&lt;%=user.getUsername()%&gt;&lt;/td&gt;         &lt;td&gt;&lt;%=user.getPassword()%&gt;&lt;/td&gt;     &lt;/tr&gt; &lt;% &#125; %&gt; <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">上面的JSP代码经过tomcat的转换后变成Java文件（Servlet），其转换后的代码变成：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">for (int i = 0;i &lt; users.size();i++)&#123;</span><br><span class="line">User user = users.get(i);</span><br><span class="line"></span><br><span class="line">    out.write(&quot;\r\n&quot;);</span><br><span class="line">    out.write(&quot;                &lt;tr&gt;\r\n&quot;);</span><br><span class="line">    out.write(&quot;                    &lt;td&gt;&quot;);</span><br><span class="line">    out.print(user.getUsername());</span><br><span class="line">    out.write(&quot;&lt;/td&gt;\r\n&quot;);</span><br><span class="line">    out.write(&quot;                    &lt;td&gt;&quot;);</span><br><span class="line">    out.print(user.getPassword());</span><br><span class="line">    out.write(&quot;&lt;/td&gt;\r\n&quot;);</span><br><span class="line">    out.write(&quot;                &lt;/tr&gt;\r\n&quot;);</span><br><span class="line">    out.write(&quot;        &quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre></li></ol><hr><h3 id="E-JSP缺点"><a href="#E-JSP缺点" class="headerlink" title="E.JSP缺点"></a>E.JSP缺点</h3><p>​<img src="/imgs/image-20230424144816905.png" alt="image-20230424144816905" style="zoom:67%;" /></p><hr><h3 id="F-EL表达式"><a href="#F-EL表达式" class="headerlink" title="F.EL表达式"></a>F.EL表达式</h3><h4 id="①引入-4"><a href="#①引入-4" class="headerlink" title="①引入"></a>①引入</h4><p>​网页动态技术迭代到Servlet+JSP阶段时：Servlet负责逻辑处理，封装数据，将数据放到request对象里；JSP从request对象中获取数据，遍历展现数据。但JSP获取数据、遍历数据的操作也会涉及到Java代码，那怎么办呢？使用EL表达式实现获取数据的操作。</p><h4 id="②语法"><a href="#②语法" class="headerlink" title="②语法"></a>②语法</h4><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;表达式&#125;</span><br></pre></td></tr></table></figure><p>​如：</p><p>​${brands} ：获取<strong>域</strong>中存储的key为brands的数据</p><h4 id="③Java中的四大域对象"><a href="#③Java中的四大域对象" class="headerlink" title="③Java中的四大域对象"></a>③Java中的四大域对象</h4><ol><li><p>page：当前页面有效</p></li><li><p>request：当前请求有效</p></li><li><p>session：当前会话有效</p></li><li><p>application：当前应用有效</p><p> 上面四个域对象里都有设置共享数据 setAttribute() 和 获取共享数据 getAttribute()。</p></li></ol><p><img src="/imgs/image-20230424144828016.png" alt="image-20230424144828016"></p><p>​说明：EL表达式获取数据时，会依次从这4个域中寻找，直到找到为止。</p><h4 id="④例子"><a href="#④例子" class="headerlink" title="④例子"></a>④例子</h4><p>​Servlet：</p><p><img src="/../imgs/image-20221118171824134-1682310001087.png" alt="image-20221118171824134"></p><p>​JSP：</p><p><img src="/../imgs/image-20221118172008694-1682310001087.png" alt="image-20221118172008694"></p><p>​如果JSP识别不出EL表达式，则需要加上：&lt;%@page isELIgnored&#x3D;”false”%&gt;。这是因为jsp2.3以及以前的版本默认是不识别EL表达式的，也就是isELIgnored&#x3D;”true”,所以需要在页面加上一句话，isELIgnored&#x3D;”false”，2.4以及之后版本默认是识别EL表达式的。</p><p>​</p><hr><h3 id="G-JSTL标签"><a href="#G-JSTL标签" class="headerlink" title="G.JSTL标签"></a>G.JSTL标签</h3><h4 id="①引入-5"><a href="#①引入-5" class="headerlink" title="①引入"></a>①引入</h4><p>​网页动态技术迭代到Servlet+JSP阶段时：Servlet负责逻辑处理，封装数据，将数据放到request对象里；JSP从request对象中获取数据，遍历展现数据。但JSP获取数据、遍历数据的操作也会涉及到Java代码，那怎么办呢？使用EL表达式实现获取数据的操作，JSTL标签实现数据遍历。这就不会涉及到Java代码了。</p><h4 id="②概述-1"><a href="#②概述-1" class="headerlink" title="②概述"></a>②概述</h4><p>​JSTL：Jsp Standarded Tag Library（JSP标准标签库），使用标签取代JSP页面上的Java代码。</p><h4 id="③JSTL快速入门"><a href="#③JSTL快速入门" class="headerlink" title="③JSTL快速入门"></a>③JSTL快速入门</h4><ol><li><p>导入JSTL相关依赖</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>taglibs<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>standard<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在JSP页面上引入JSTL标签库</p> <figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%<span class="meta">@taglib</span> prefix=<span class="string">&quot;c&quot;</span> uri=<span class="string">&quot;http://java.sun.com/jsp/jstl/core&quot;</span> %&gt;</span><br></pre></td></tr></table></figure><p> prefix：用于定义JSTL标签的前缀，如：<img src="/../imgs/image-20221118180815292-1682310001087.png" alt="image-20221118180815292"></p></li><li><p>使用JSTL</p></li></ol><hr><h4 id="④if标签"><a href="#④if标签" class="headerlink" title="④if标签"></a>④if标签</h4><ul><li><p>语法</p>  <figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:<span class="keyword">if</span> test=<span class="string">&quot;表达式&quot;</span>&gt;</span><br><span class="line">写HTML标签等内容</span><br><span class="line">&lt;/c:<span class="keyword">if</span>&gt;</span><br></pre></td></tr></table></figure></li><li><p>说明</p><ol><li><p>if 标签里一定要有test属性。如果表达式为真，则执行 if 标签包裹起来的内容。</p></li><li><p>if 标签没有else，所以想要写只能再调用一次 if 标签</p> <figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:<span class="keyword">if</span> test=<span class="string">&quot;true&quot;</span>&gt;</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">&lt;/c:<span class="keyword">if</span>&gt;</span><br><span class="line">&lt;c:<span class="keyword">if</span> test=<span class="string">&quot;false&quot;</span>&gt;</span><br><span class="line"><span class="literal">false</span></span><br><span class="line">&lt;/c:<span class="keyword">if</span>&gt;</span><br></pre></td></tr></table></figure></li><li><p>如果表达式中想判断某个值是否符合要求</p> <figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--只能这样写 --&gt;</span><br><span class="line">&lt;c:<span class="keyword">if</span> test=<span class="string">&quot;$&#123;status == 1&#125;&quot;</span>&gt;</span><br><span class="line">&lt;h1&gt;你好！&lt;/h1&gt;</span><br><span class="line">&lt;/c:<span class="keyword">if</span>&gt;</span><br><span class="line">&lt;!--不能这样写 --&gt;</span><br><span class="line">&lt;c:<span class="keyword">if</span> test=<span class="string">&quot;$&#123;status&#125; == 1&quot;</span>&gt;</span><br><span class="line">&lt;h1&gt;你好！&lt;/h1&gt;</span><br><span class="line">&lt;/c:<span class="keyword">if</span>&gt;</span><br></pre></td></tr></table></figure></li></ol></li></ul><hr><h4 id="⑤foreach标签"><a href="#⑤foreach标签" class="headerlink" title="⑤foreach标签"></a>⑤foreach标签</h4><ul><li><p>forEach标签相当于forEach循环</p></li><li><p>语法</p>  <figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:forEach items=<span class="string">&quot;&quot;</span> <span class="keyword">var</span>=<span class="string">&quot;&quot;</span>&gt;</span><br><span class="line">循环内容</span><br><span class="line">&lt;/c:forEach&gt;</span><br></pre></td></tr></table></figure><p>  items：被循环的容器</p><p>  var：遍历产生的临时变量</p><p>  补充：该forEac标签里还有个varStatus属性</p></li><li><p>例子</p><p>  - </p><pre><code>  ![image-20221118212301836](../imgs/image-20221118212301836-1682310001087.png)  注意：当获取brand对象中的属性值时只能像上面这样写 “ brand.属性名 ”，因为将来其内部会将首字母大写再在前面加上get，这样就变成 “ brand.getId ” ，然后根据这个去方法名去找brand类里有没有这个方法。  </code></pre><ul><li><p>上面例子中的 brand.id 是指这条数据在数据库中的id，如果数据库中一共有4条数据，现在将id&#x3D;2的数据删掉，然后再按照上面的方式输出，将来显示的数据的序号就是不连续的，变为1，3，4。为了解决这个问题，我们可以使用varStatus这个属性，将代码改为：</p><p>  <img src="/../imgs/image-20221118215326339-1682310001087.png" alt="image-20221118215326339"></p><p>  <img src="/../imgs/image-20221118215449884-1682310001087.png" alt="image-20221118215449884"></p><p>  <img src="/../imgs/image-20221118215527310-1682310001087.png" alt="image-20221118215527310"></p></li></ul></li></ul><hr><h4 id="⑥普通的foreach标签"><a href="#⑥普通的foreach标签" class="headerlink" title="⑥普通的foreach标签"></a>⑥普通的foreach标签</h4><ul><li><p>语法</p>  <figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:forEach begin=<span class="string">&quot;&quot;</span> end=<span class="string">&quot;&quot;</span> step=<span class="string">&quot;&quot;</span> <span class="keyword">var</span>=<span class="string">&quot;&quot;</span>&gt;</span><br><span class="line">循环内容</span><br><span class="line">&lt;/c:forEach&gt;</span><br><span class="line"></span><br><span class="line">&lt;%-- 这个就是普通的<span class="keyword">for</span>循环 --%&gt;</span><br></pre></td></tr></table></figure><p>  begin：开始数</p><p>  end：结束数</p><p>  step：步长</p></li><li><p>例子</p><p>  <img src="/../imgs/image-20221118213100871-1682310001087.png" alt="image-20221118213100871"></p></li></ul><hr><h2 id="⑦网页动态技术迭代过程"><a href="#⑦网页动态技术迭代过程" class="headerlink" title="⑦网页动态技术迭代过程"></a>⑦网页动态技术迭代过程</h2><p>​<img src="/../imgs/image-20221118123958304-1682310001087.png" alt="image-20221118123958304"></p><ol><li><p>Servlet阶段：想写HTML代码得写在：通过response对象获取的输出流对象的write()方法里，这就比较麻烦。从而诞生了JSP技术。</p></li><li><p>JSP阶段：可以直接在JSP里写HTML代码和Java代码了，但问题是这样写也比较麻烦（Java代码得根据情况进行截断），也不利于阅读。</p></li><li><p>Servlet+JSP阶段：Servlet负责逻辑处理，封装数据，将数据放到request对象里；JSP从request对象中获取数据，遍历展现数据。</p><p> 但JSP获取数据、遍历数据的操作也会涉及到Java代码，那怎么办呢？</p><p> 使用EL表达式实现获取数据的操作，JSTL标签实现数据遍历。这就不会涉及到Java代码了。</p></li><li><p>Servlet+html+ajax阶段：现在流行的技术。</p></li></ol><p>​</p><hr><h2 id="⑧MVC模式和三层架构"><a href="#⑧MVC模式和三层架构" class="headerlink" title="⑧MVC模式和三层架构"></a>⑧MVC模式和三层架构</h2><h3 id="A-MVC模式"><a href="#A-MVC模式" class="headerlink" title="A.MVC模式"></a>A.MVC模式</h3><p><img src="/../imgs/image-20221119105325558-1682310001087.png" alt="image-20221119105325558"></p><h3 id="B-三层架构"><a href="#B-三层架构" class="headerlink" title="B.三层架构"></a>B.三层架构</h3><p><img src="/../imgs/image-20221119105309359-1682310001087.png" alt="image-20221119105309359"></p><h3 id="C-MVC模式和三层架构的区别"><a href="#C-MVC模式和三层架构的区别" class="headerlink" title="C.MVC模式和三层架构的区别"></a>C.MVC模式和三层架构的区别</h3><img src="/imgs/image-20230424144840939.png" alt="image-20230424144840939" style="zoom:80%;" /><p>​三层架构是MVC模式的落地实现。</p><hr>]]></content>
      
      
      <categories>
          
          <category> Java Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web核心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript</title>
      <link href="/2023/04/24/javascript/"/>
      <url>/2023/04/24/javascript/</url>
      
        <content type="html"><![CDATA[<h3 id="①概述"><a href="#①概述" class="headerlink" title="①概述"></a>①概述</h3><ul><li><p>JavaScript是一门跨平台、面向对象的脚本语言，来控制网页行为的，它能使网页可交互。</p><ul><li>脚本语言：即JavaScript属于解释运行语言。</li></ul></li><li><p>JavaScript和Java是完全不同的语言，不论是概念还是设计。但是基础语法类似。</p></li></ul><h3 id="②JavaScript引入方式"><a href="#②JavaScript引入方式" class="headerlink" title="②JavaScript引入方式"></a>②JavaScript引入方式</h3><h4 id="A-内部脚本"><a href="#A-内部脚本" class="headerlink" title="A.内部脚本"></a>A.内部脚本</h4><p><img src="/imgs/image-20221028111130935-1682308787353.png" alt="image-20221028111130935"></p><p>​例子：</p><p><img src="/imgs/image-20221028111251852-1682308787356.png" alt="image-20221028111251852"></p><h4 id="B-外部脚本"><a href="#B-外部脚本" class="headerlink" title="B.外部脚本"></a>B.外部脚本</h4><p><img src="/imgs/image-20221028111903213-1682308787357.png" alt="image-20221028111903213"></p><p>​例子：</p><p><img src="/imgs/image-20221028111935335-1682308787357.png" alt="image-20221028111935335"></p><p>​ </p><h3 id="③JavaScript基础语法"><a href="#③JavaScript基础语法" class="headerlink" title="③JavaScript基础语法"></a>③JavaScript基础语法</h3><h4 id="A-书写语法"><a href="#A-书写语法" class="headerlink" title="A.书写语法"></a>A.书写语法</h4><ol><li><p>JavaScript区分大小写：与Java一样，变量名、函数名以及其它一切东西都是区分大小写的。</p></li><li><p>每行结尾的分号可有可无，但还是写上比较规范。</p></li><li><p>注释：</p><ul><li>单行注释：&#x2F;&#x2F;注释内容</li><li>多行注释：与Java一样</li></ul></li><li><p>大括号代表代码块</p><p> 如：<img src="/imgs/image-20221028121931243-1682308787357.png" alt="image-20221028121931243"></p></li></ol><h4 id="B-输出语句"><a href="#B-输出语句" class="headerlink" title="B.输出语句"></a>B.输出语句</h4><ol><li><p>使用window.alert(“输出内容”)：将内容输出到警告框中。</p><p> 注：”window.”可以省略不写</p></li><li><p>使用document.write(“输出内容”)：将内容输出到HMTL页面当中。</p></li><li><p>使用console.log(“输出内容”)：将内容输出到浏览器的控制台中。</p><p> 注：我们需要在页面中按住F12 或 通过 “鼠标右击，检查” 点击控制台才能看到输出的内容 </p><p> <img src="/imgs/image-20221028122907123-1682308787357.png" alt="image-20221028122907123"></p></li></ol><h4 id="C-变量"><a href="#C-变量" class="headerlink" title="C.变量"></a>C.变量</h4><h5 id="①定义变量"><a href="#①定义变量" class="headerlink" title="①定义变量"></a>①定义变量</h5><p>​<code>变量的声明要写在script标签内</code></p><p>​<code>JavaScript是一门弱类型语言，变量可以存放不同类型的值。</code></p><ul><li><h6 id="ECMAScript6之前"><a href="#ECMAScript6之前" class="headerlink" title="ECMAScript6之前"></a>ECMAScript6之前</h6><p>  使用var关键字来声明变量。</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> test = <span class="number">20</span>;</span></span><br><span class="line"><span class="language-javascript">    test = <span class="string">&quot;张三&quot;</span>;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  var关键字的特点：</p><ol><li>声明的变量为全局变量。</li><li>同一个变量可以重复被定义。</li></ol></li><li><p>ECMAScript6之后</p><p>  新增了<code>let</code>关键字来定义变量。它的用法类似于var，但是所声明的变量，只在let关键字所在的代码块内有效，且不允许重复声明同一个变量。</p><p>  新增了<code>const</code>关键字，用来声明一个只读的常量。一旦声明，常量的值就不能改变。</p></li></ul><h5 id="②变量命名规则"><a href="#②变量命名规则" class="headerlink" title="②变量命名规则"></a>②变量命名规则</h5><p>​<img src="/imgs/image-20221028152434815-1682308787357.png" alt="image-20221028152434815"></p><p>​</p><h4 id="D-数据类型"><a href="#D-数据类型" class="headerlink" title="D.数据类型"></a>D.数据类型</h4><p>​JavaScript中数据类型分为 原始类型（相当于Java中的基本数据类型） 和 引用类型</p><ul><li><p>原始类型</p><p>  <img src="/imgs/image-20221028155428696-1682308787358.png" alt="image-20221028155428696"></p><ul><li>我们可以使用typeof运算符来获取当前变量存储的数据属于哪种数据类型，如：typeof age</li></ul></li><li><p>引用类型</p></li></ul><h4 id="E-运算符"><a href="#E-运算符" class="headerlink" title="E.运算符"></a>E.运算符</h4><h5 id="①概述-1"><a href="#①概述-1" class="headerlink" title="①概述"></a>①概述</h5><p>​<img src="/imgs/image-20230424120735870.png" alt="image-20230424120735870"></p><p>​说明：上面的运算符的应用与Java中的一样，除了 “&#x3D;&#x3D;” 和 “&#x3D;&#x3D;&#x3D;”</p><ul><li><p>&#x3D;&#x3D; 和 &#x3D;&#x3D;&#x3D; 的区别</p><ul><li>&#x3D;&#x3D;： （实际上就是比较其值是否一样，一样返回true，不一样返回false）<ol><li>先判断变量的类型是否一样，如果不一样，则进行类型转换。</li><li>再去比较其值。</li></ol></li><li>&#x3D;&#x3D;&#x3D;：<ol><li>判断变量的类型是否一样，如果不一样，直接返回false。</li><li>再去比较其值。</li></ol></li></ul></li></ul><h5 id="②类型转换"><a href="#②类型转换" class="headerlink" title="②类型转换"></a>②类型转换</h5><ol><li><p>其它类型转为number：</p><ul><li><p>string 转 number：按照字符串的字面值，转为数字；如果字面值不是数字，则转为NaN。</p><p>  一般使用parseInt()方法来将实现string 转 number</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> j = <span class="string">&quot;20&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(<span class="built_in">parseInt</span>(j) + <span class="number">1</span>); <span class="comment">//结果为：21。parseInt(j)：j的字面值为20，所以就转换为数字 20</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> k = <span class="string">&quot;abc&quot;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(<span class="built_in">parseInt</span>(k)); <span class="comment">//结果为：NaN</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>boolean 转 number： true 转为 1；false 转为 0</p></li></ul></li><li><p>其它类型转为boolean：</p><ul><li>number 转 boolean：0 和 NaN转为false，其它的数字转为true。</li><li>string 转 boolean：空字符串(即只有一对引号) 转为false，其它的字符串转为true。</li><li>null 转 boolean：转为false。</li><li>undefined 转 boolean：转为false。</li></ul></li></ol><h4 id="F-流程控制语句"><a href="#F-流程控制语句" class="headerlink" title="F.流程控制语句"></a>F.流程控制语句</h4><h5 id="①概述-2"><a href="#①概述-2" class="headerlink" title="①概述"></a>①概述</h5><p>​<img src="/imgs/image-20221028204104273-1682308787358.png" alt="image-20221028204104273"></p><p>​与Java中的流程控制一模一样。</p><h5 id="②例子"><a href="#②例子" class="headerlink" title="②例子"></a>②例子</h5><ul><li><p>switch</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> i = <span class="number">1</span>;</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">switch</span>(i)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">case</span> <span class="number">1</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">alert</span>(<span class="string">&quot;今天是星期一&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">break</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">case</span> <span class="number">2</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">alert</span>(<span class="string">&quot;今天是星期二&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">break</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">default</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">alert</span>(<span class="string">&quot;输入的信息有误&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">     &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>for</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> sum = <span class="number">0</span>;</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>;i &lt;= <span class="number">100</span>;i++)&#123;   <span class="comment">//输出 1 加到 100 的总和</span></span></span><br><span class="line"><span class="language-javascript">        sum += i;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(sum);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  一般for循环的初始条件都用let来声明，因为我们希望此初始变量只在for循环中使用。</p></li></ul><p>​</p><h4 id="G-函数"><a href="#G-函数" class="headerlink" title="G.函数"></a>G.函数</h4><p>​JavaScript中的函数就是Java中的函数，他们两是一样意思。但它们的声明方式不一样。</p><h5 id="①函数定义"><a href="#①函数定义" class="headerlink" title="①函数定义"></a>①函数定义</h5><ul><li>定义方式一：</li></ul><img src="/imgs/image-20230424120843803.png" alt="image-20230424120843803" style="zoom:67%;" /><ul><li><p>定义方式二：</p>  <img src="/imgs/image-20230424120857593.png" alt="image-20230424120857593" style="zoom:67%;" /><p>  直接写 “函数名(参数值)” 即可实现调用。</p></li></ul><h5 id="②函数特性"><a href="#②函数特性" class="headerlink" title="②函数特性"></a>②函数特性</h5><p>​在JavaScript中函数的调用只与函数名有关，即只通过函数名来确定调用的函数。因此函数A在声明时虽然只声明了两个参数，但调用的时候可以传递一个或两个以上的参数，这就是JavaScript中函数的特性，了解即可。</p><hr><h3 id="④JavaScript对象"><a href="#④JavaScript对象" class="headerlink" title="④JavaScript对象"></a>④JavaScript对象</h3><h4 id="A-Array数组对象"><a href="#A-Array数组对象" class="headerlink" title="A.Array数组对象"></a>A.Array数组对象</h4><h5 id="①数组的定义"><a href="#①数组的定义" class="headerlink" title="①数组的定义"></a>①数组的定义</h5><p><img src="/imgs/image-20221029154604329-1682308787359.png" alt="image-20221029154604329"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(arr);   <span class="comment">//结果为：1，2，3</span></span></span><br><span class="line"><span class="language-javascript">    arr[<span class="number">0</span>] = <span class="number">10</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(arr);   <span class="comment">//结果为：10，2，3</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="②数组的特点"><a href="#②数组的特点" class="headerlink" title="②数组的特点"></a>②数组的特点</h5><p>​JavaScript数组相当于Java中的集合，变长变类型</p><ul><li><p>变长</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span></span><br><span class="line"><span class="language-javascript">    arr[<span class="number">10</span>] = <span class="number">89</span>;   </span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//原本数组的长度为3，现在变成10。arr[3]到arr[8]的元素值为：空字符串,其数据类型为undefined类型。</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>变类型</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span></span><br><span class="line"><span class="language-javascript">    arr[<span class="number">1</span>] = <span class="string">&quot;hello&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(arr); <span class="comment">//结果为：1，hello，3</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="③属性和方法"><a href="#③属性和方法" class="headerlink" title="③属性和方法"></a>③属性和方法</h5><ul><li><p>属性</p><ul><li><p>length：获取数组中元素的个数</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(arr.<span class="property">length</span>);<span class="comment">//结果为3</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>还有其它的属性，见</p>  <figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.w3school.com.cn/jsref/jsref_obj_array.asp</span><br></pre></td></tr></table></figure></li></ul></li><li><p>方法</p><ul><li><p>push：往数组中添加元素</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span></span><br><span class="line"><span class="language-javascript">    arr.<span class="title function_">push</span>(<span class="number">4</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(arr);<span class="comment">//结果为:1,2,3,4</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>splice：删除&#x2F;添加数组中的元素</p><p>  语法：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array.splice(index, howmany, item1, ....., itemX)</span><br></pre></td></tr></table></figure><p>  <img src="/imgs/image-20221029163121470-1682308787359.png" alt="image-20221029163121470"></p><p>  例子：</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span></span><br><span class="line"><span class="language-javascript">    arr.<span class="title function_">splice</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(arr);  <span class="comment">//结果为：1，3，3</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>还有其它方法，这里不多介绍，详见：</p>  <figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.w3school.com.cn/jsref/jsref_splice.asp</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="B-String对象"><a href="#B-String对象" class="headerlink" title="B.String对象"></a>B.String对象</h4><p>​String对象即字符串对象</p><h5 id="①定义"><a href="#①定义" class="headerlink" title="①定义"></a>①定义</h5><p><img src="/imgs/image-20221029165848280-1682308787360.png" alt="image-20221029165848280"></p><h5 id="②属性、方法"><a href="#②属性、方法" class="headerlink" title="②属性、方法"></a>②属性、方法</h5><ul><li><p>属性</p><p>  length：获取字符串的长度</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> str = <span class="string">&quot;hello&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(str.<span class="property">length</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>方法</p><ul><li><p>charAt()：返回在指定位置的字符</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> str = <span class="string">&quot;abc&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(str.<span class="title function_">chartAt</span>(<span class="number">0</span>));<span class="comment">//a</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>IndexOf()：返回字符在数组中第一次出现的位置</p></li><li><p>trim()：去除字符串前后两端的空白字符</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> str = <span class="string">&quot; abc &quot;</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(str.<span class="title function_">trim</span>());<span class="comment">//abc</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>还有其它方法见</p>  <figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.w3school.com.cn/jsref/jsref_obj_string.asp</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="C-自定义对象"><a href="#C-自定义对象" class="headerlink" title="C.自定义对象"></a>C.自定义对象</h4><h5 id="①造对象"><a href="#①造对象" class="headerlink" title="①造对象"></a>①造对象</h5><p><img src="/imgs/image-20221029172936520-1682308787360.png" alt="image-20221029172936520"></p><p>​说明：JavaScript中造对象不需要先造其对应的类，直接造对象即可。</p><h5 id="②例子-1"><a href="#②例子-1" class="headerlink" title="②例子"></a>②例子</h5><p><img src="/imgs/image-20221029173422014-1682308787361.png" alt="image-20221029173422014"></p><hr><h3 id="⑤BOM对象"><a href="#⑤BOM对象" class="headerlink" title="⑤BOM对象"></a>⑤BOM对象</h3><h4 id="A-概述"><a href="#A-概述" class="headerlink" title="A.概述"></a>A.概述</h4><p>​<img src="/imgs/image-20230424120948587.png" alt="image-20230424120948587" style="zoom:80%;" /></p><h4 id="B-Window"><a href="#B-Window" class="headerlink" title="B.Window"></a>B.Window</h4><p>​Window：浏览器窗口对象</p><h5 id="①获取"><a href="#①获取" class="headerlink" title="①获取"></a>①获取</h5><p>​在JavaScript里window对象属于内置对象，直接使用即可。其中**window.**可以省略。</p><h5 id="②属性"><a href="#②属性" class="headerlink" title="②属性"></a>②属性</h5><p><img src="/imgs/image-20221029210121672-1682308787362.png" alt="image-20221029210121672"></p><h5 id="③方法"><a href="#③方法" class="headerlink" title="③方法"></a>③方法</h5><ol><li><p>alert()</p><p> 显示带有一段信息和一个确认按钮的警告框。如：</p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="title function_">alert</span>(<span class="string">&quot;hello&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p> <img src="/imgs/image-20230424121024855.png" alt="image-20230424121024855"></p></li><li><p>confirm()</p><p> 显示带有一段消息以及确认按钮和取消按钮的对话框。</p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">     <span class="title function_">confirm</span>(<span class="string">&quot;确认删除吗？&quot;</span>);   </span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//该方法会返回一个布偶值，如果用户点击确认，返回true，否则返回false。</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//我们可以通过该布偶值来进行相应的操作，如：</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> flag = <span class="title function_">confirm</span>(<span class="string">&quot;确认删除吗？&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">if</span> (flag)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">alert</span>(<span class="string">&quot;删除成功&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p> <img src="/imgs/image-20230424121042317.png" alt="image-20230424121042317"></p></li><li><p>定时器</p><ul><li><p>setTimeout(function,毫秒值)：在一定的时间间隔后执行一个function，只执行一次。</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">print</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">alert</span>(<span class="string">&quot;hhhh&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="built_in">setTimeout</span>(print,<span class="number">1000</span>); <span class="comment">//注意函数名后面不加括号</span></span></span><br><span class="line"><span class="language-javascript">    </span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//等价于</span></span></span><br><span class="line"><span class="language-javascript">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">alert</span>(<span class="string">&quot;hhhh&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;,<span class="number">1000</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>setInterval(function,毫秒值)：在一定的时间间隔后执行一个function，循环执行。可应用于图片的滚动播放。</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">print</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">alert</span>(<span class="string">&quot;111&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="built_in">setInterval</span>(print,<span class="number">3000</span>); <span class="comment">//3000毫秒 = 3秒 //注意函数名后面不加括号</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><h4 id="C-History"><a href="#C-History" class="headerlink" title="C.History"></a>C.History</h4><p>​<img src="/imgs/image-20230424121058369.png" alt="image-20230424121058369" style="zoom:80%;" /></p><h4 id="D-Location"><a href="#D-Location" class="headerlink" title="D.Location"></a>D.Location</h4><h5 id="①概述-3"><a href="#①概述-3" class="headerlink" title="①概述"></a>①概述</h5><p>​<img src="/imgs/image-20230424121115986.png" alt="image-20230424121115986" style="zoom: 80%;" /></p><h5 id="②应用"><a href="#②应用" class="headerlink" title="②应用"></a>②应用</h5><p>​A.显示当前页面URL</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">document</span>.<span class="title function_">write</span>(location.<span class="property">href</span>);<span class="comment">//将当前页面的URL显示到网页中</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​B.跳转到下一个页面</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(<span class="string">&quot;要跳转了&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">location.<span class="property">href</span> = <span class="string">&quot;https://www.baidu.com&quot;</span>; <span class="comment">//当执行到此行代码时，就会跳转到百度</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​可以利用此功能实现用户登录成功后跳转到页面首页。</p><hr><h3 id="⑥DOM对象"><a href="#⑥DOM对象" class="headerlink" title="⑥DOM对象"></a>⑥DOM对象</h3><h4 id="A-概述-1"><a href="#A-概述-1" class="headerlink" title="A.概述"></a>A.概述</h4><h5 id="①什么是DOM"><a href="#①什么是DOM" class="headerlink" title="①什么是DOM"></a>①什么是DOM</h5><ul><li>DOM：Document Object Model 文档对象模型。该体系下包含如下对象：<ul><li>Document：整个文档对象</li><li>Element：元素对象(即标签对象)，在HTML DOM中，将每个HTML元素都封装为一个对象。</li><li>Attribute：属性对象</li><li>Text：文本对象</li><li>Comment：注释对象</li></ul></li></ul><h5 id="②DOM的作用"><a href="#②DOM的作用" class="headerlink" title="②DOM的作用"></a>②DOM的作用</h5><p>​<img src="/imgs/image-20230424121148122.png" alt="image-20230424121148122"></p><h4 id="B-获取Element对象"><a href="#B-获取Element对象" class="headerlink" title="B.获取Element对象"></a>B.获取Element对象</h4><p>​<code>注：Document对象可以直接使用</code></p><p><img src="/imgs/image-20230424121210750.png" alt="image-20230424121210750"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> id = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;id&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> divs = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;div&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> hoobby = <span class="variable language_">document</span>.<span class="title function_">getElementsByName</span>(<span class="string">&quot;hobby&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> clss = <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&quot;cls&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="C-HTML-Element对象的使用"><a href="#C-HTML-Element对象的使用" class="headerlink" title="C.HTML  Element对象的使用"></a>C.HTML  Element对象的使用</h4><h5 id="①img对象"><a href="#①img对象" class="headerlink" title="①img对象"></a>①img对象</h5><p>​该对象里有一个重要的属性：src，通过 src 我们就能修改图片了。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">&quot;img&quot;</span> <span class="attr">src</span>=<span class="string">&quot;1111.jpg&quot;</span>&gt;</span>;</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> img = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;img&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    img.<span class="property">src</span> = <span class="string">&quot;hhh.jpg&quot;</span>; </span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​</p><h5 id="②div对象"><a href="#②div对象" class="headerlink" title="②div对象"></a>②div对象</h5><p>​通过W3School网站我们发现该div对象里没有相应的属性和方法。而<strong>所有的DOM对象都继承于DOM Element对象</strong>，所以我们可以查看DOM Element对象就可以知道div对象可以有哪些属性和方法了。DOM Element对象里有两个比较重要的属性&#x2F;方法：innerHTML 属性、style 属性。</p><ul><li><p>innerHTML 、style</p><ol><li><p><strong>innerHTML</strong> 作用：设置元素内容；<strong>style</strong>作用：设置元素css样式</p></li><li><p>例子：</p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cls1&quot;</span>&gt;</span>我是谁？<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cls2&quot;</span>&gt;</span>你是谁？<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> cls1 = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;div&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        cls1[<span class="number">0</span>].<span class="property">innerHTML</span> = <span class="string">&quot;我是橙子&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> cls2 = <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&quot;cls2&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        cls2[<span class="number">0</span>].<span class="property">style</span>.<span class="property">color</span> = <span class="string">&quot;blue&quot;</span>; </span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//想修改css样式时，只要在style属性后面继续“.”选择相应css属性即可。</span></span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure> <img src="/imgs/image-20230424121316594.png" alt="image-20230424121316594" style="zoom:80%;" /></li></ol></li></ul><h5 id="③input-checkbox对象"><a href="#③input-checkbox对象" class="headerlink" title="③input checkbox对象"></a>③input checkbox对象</h5><ul><li><p>input checkbox对象中有一个比较重要的属性：checked。</p><ul><li>checked属性用于设置或返回 checkbox 是否应被选中。</li></ul></li><li><p>如：</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span>&gt;</span>电影</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span>&gt;</span>写代码</span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> hobby = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;input&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        hobby[<span class="number">0</span>].<span class="property">checked</span> = <span class="literal">true</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">alert</span>(hobby[<span class="number">1</span>].<span class="property">checked</span>);<span class="comment">//false</span></span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>  <img src="/imgs/image-20230424121327070.png" alt="image-20230424121327070" style="zoom:80%;" /></li></ul><p>​</p><p>​</p><h5 id="④其它对象"><a href="#④其它对象" class="headerlink" title="④其它对象"></a>④其它对象</h5><p>​当遇到其它对象时，我们通过W3School来查看该对象有哪些属性和方法，然后根据需要使用。</p><p>​如果查到该<code>对象没有相应的属性方法</code>，则去<code>看DOM Element对象</code>，因为所有的DOM对象都继承于DOM Element对象，所以我们可以查看DOM Element对象就可以知道该对象可以有哪些属性和方法了。<code>DOM Element对象里有两个比较重要的属性/方法：innerHTML 属性、style 属性。</code></p><img src="/imgs/image-20230424121425515.png" alt="image-20230424121425515" style="zoom:80%;" /><p>​W3School网址：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.w3school.com.cn/jsref/dom_obj_document.asp</span><br></pre></td></tr></table></figure><hr><h3 id="⑦事件监听"><a href="#⑦事件监听" class="headerlink" title="⑦事件监听"></a>⑦事件监听</h3><h4 id="A-概述-2"><a href="#A-概述-2" class="headerlink" title="A.概述"></a>A.概述</h4><ul><li>事件：发生在HTML元素上的“事情”。比如：<ul><li>按钮被点击</li><li>鼠标移动到元素上</li><li>按下键盘按键</li></ul></li><li>事件监听：当有事件发生时执行相应的代码。</li></ul><h4 id="B-事件绑定"><a href="#B-事件绑定" class="headerlink" title="B.事件绑定"></a>B.事件绑定</h4><p>​为了让事件和代码联系起来，我们需要事件绑定。</p><img src="/imgs/image-20230424121502228.png" alt="image-20230424121502228" style="zoom:80%;" /><p>​</p><h4 id="C-常见事件"><a href="#C-常见事件" class="headerlink" title="C.常见事件"></a>C.常见事件</h4><ol><li><p><strong>onblur</strong>：元素失去焦点，即当鼠标点击离开该元素时进行相应的操作</p><ul><li>应用：当输入结束输入框的输入时，元素就失去了焦点，我们就可以对用户输入的信息进行验证。</li></ul></li><li><p><strong>onchange</strong>：域的内容被改变</p></li><li><p><strong>onclick</strong>：当用户点击按钮时执行相应操作</p></li><li><p><strong>onfocus</strong>：元素获得焦点。当用户点击输入框时，该输入框就获得焦点，然后执行相应的代码。</p></li><li><p><strong>onmouseout</strong>：鼠标从某元素移开。</p><ul><li>应用：当鼠标从某个元素上移开时，修改其元素的背景色。</li></ul></li><li><p><strong>onmouseover</strong>：鼠标移动到某元素上</p></li><li><p><strong>onkeydown</strong>：某个键盘的键被按下时，执行相应操作</p><ul><li>应用：禁止用户在表单中输入数字。</li></ul></li><li><p><strong>onsubmit</strong>：当表单提交时执行相应操作。</p><ul><li><p>应用：当表单输入内容不合要求时，禁止用户提交表单。onsubmit：返回true，表单可以提交，返回false，则表单不能提交</p>  <img src="/imgs/image-20230424121511770.png" alt="image-20230424121511770" style="zoom:80%;" /></li></ul></li></ol><h3 id="⑧应用–表单验证"><a href="#⑧应用–表单验证" class="headerlink" title="⑧应用–表单验证"></a>⑧应用–表单验证</h3><ul><li><p>需求：</p>  <img src="/imgs/image-20230424121544349.png" alt="image-20230424121544349" style="zoom:80%;" />  </li><li><p>实现：</p>  <img src="/imgs/image-20230424121559566.png" alt="image-20230424121559566" style="zoom:80%;" /><p>  ​</p><p>  注：</p><ol><li><p>输入框失去焦点中的操作步骤（3）、（4）、（5）都是写在步骤（2）中的function里的。</p></li><li><p>功能二中的步骤（3）是写在步骤（2）中的function里的。</p></li><li><p>如果不会可看视频：</p> <figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.bilibili.com/video/BV1Qf4y1T7Hx/?p=83&amp;spm_id_from=pageDriver&amp;vd_source=9c398663599ac78b625d463b4ffc1ff5</span><br></pre></td></tr></table></figure></li></ol></li></ul><h3 id="⑨正则表达式"><a href="#⑨正则表达式" class="headerlink" title="⑨正则表达式"></a>⑨正则表达式</h3><h4 id="A-概念"><a href="#A-概念" class="headerlink" title="A.概念"></a>A.概念</h4><p>​正则表达式定义了字符串组成的规则。可用来判断某字符串是否满住正则表达式，根据正则表达式查找字符串等。</p><h4 id="B-定义"><a href="#B-定义" class="headerlink" title="B.定义"></a>B.定义</h4><p>​<img src="/imgs/image-20230424121613748.png" alt="image-20230424121613748" style="zoom:80%;" /></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> reg = <span class="regexp">/正则表达式/</span>;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="C-语法"><a href="#C-语法" class="headerlink" title="C.语法"></a>C.语法</h4><p>​<img src="/imgs/image-20230424121623369.png" alt="image-20230424121623369" style="zoom:80%;" /></p><h4 id="D-方法"><a href="#D-方法" class="headerlink" title="D.方法"></a>D.方法</h4><p>​正则表达式中有一个test(str)方法，用于判断指定字符串是否符合规则，返回true或false。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> reg = <span class="regexp">/^\w+$/</span>;</span></span><br><span class="line"><span class="language-javascript">    reg.<span class="title function_">test</span>(<span class="string">&quot;abc&quot;</span>);<span class="comment">//true</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="E-应用"><a href="#E-应用" class="headerlink" title="E.应用"></a>E.应用</h4><p>​对用户输入的表数据进行校验。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;#&quot;</span> <span class="attr">method</span>=<span class="string">&quot;get&quot;</span>&gt;</span></span><br><span class="line">        电话号码<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;tel&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> inputTel = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;tel&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        inputTel.<span class="property">onblur</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">           <span class="keyword">var</span> tel = inputTel.<span class="property">value</span>;</span></span><br><span class="line"><span class="language-javascript">           <span class="keyword">var</span> reg = <span class="regexp">/^1\d&#123;10&#125;$/</span>;</span></span><br><span class="line"><span class="language-javascript">           <span class="keyword">var</span> telCheck = reg.<span class="title function_">test</span>(tel);</span></span><br><span class="line"><span class="language-javascript">           <span class="keyword">if</span>(telCheck != <span class="literal">true</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">               <span class="title function_">alert</span>(<span class="string">&quot;输入的电话号码有误&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">           &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS</title>
      <link href="/2023/04/24/css/"/>
      <url>/2023/04/24/css/</url>
      
        <content type="html"><![CDATA[<h3 id="①概述"><a href="#①概述" class="headerlink" title="①概述"></a>①概述</h3><p>​CSS是用于美化页面的，其结合着HTML语言一起使用。CSS的使用涉及到三个方面：</p><ol><li>CSS导入方式</li><li>CSS选择器(要对哪个HTML标签进行操作)</li><li>CSS属性</li></ol><h3 id="②CSS导入方式"><a href="#②CSS导入方式" class="headerlink" title="②CSS导入方式"></a>②CSS导入方式</h3><h4 id="A-内联样式"><a href="#A-内联样式" class="headerlink" title="A.内联样式"></a>A.内联样式</h4><p>​开发中这种导入方式少用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;color:red&quot;</span>&gt;</span></span><br><span class="line">    Hello CSS</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​div属于HTML标签，使用style属性就能指定CSS的样式</p><h4 id="B-内部样式"><a href="#B-内部样式" class="headerlink" title="B.内部样式"></a>B.内部样式</h4><p>​开发中这种导入方式常用</p><p><img src="/../imgs/image-20221027180338864-1682308133292.png" alt="image-20221027180338864"></p><h4 id="C-外部样式"><a href="#C-外部样式" class="headerlink" title="C.外部样式"></a>C.外部样式</h4><p>​开发中这种导入方式常用</p><p><img src="/../imgs/image-20221027180618981-1682308133294.png" alt="image-20221027180618981"></p><p>link标签中的href属性是指要导入修饰p标签的CSS文件的位置，rel属性表明导入的文件属于CSS文件。</p><p><img src="/../imgs/image-20221027180949801-1682308133294.png" alt="image-20221027180949801"></p><p>​上面为选择器。</p><h3 id="③CSS选择器"><a href="#③CSS选择器" class="headerlink" title="③CSS选择器"></a>③CSS选择器</h3><p><img src="/../imgs/image-20221029110857398-1682308133294.png" alt="image-20221029110857398"></p><p>说明：</p><ul><li>标签中的class属性其值可以不唯一，即多个标签中的class属性值可以相同。</li><li>如果标签1和标签2的class属性值如都为cls，选择器为：”.cls{color:red}”。则这两个标签的字体都会变成红色。</li></ul><h3 id="④CSS属性"><a href="#④CSS属性" class="headerlink" title="④CSS属性"></a>④CSS属性</h3><p>​CSS属性即：键值对，如：color:red</p><p>​我们可以在CSS选择器中写多个CSS属性。</p><p>​具体的CSS属性见下链接，这里就不过多赘述，因为不是学习重点。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.w3school.com.cn/index.html</span><br></pre></td></tr></table></figure><p>​</p>]]></content>
      
      
      <categories>
          
          <category> Java Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>html</title>
      <link href="/2023/04/23/html/"/>
      <url>/2023/04/23/html/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是HTML"><a href="#什么是HTML" class="headerlink" title="什么是HTML"></a>什么是HTML</h3><p><img src="/imgs/image-20221007172246485-1682259484191.png" alt="image-20221007172246485"></p><h3 id="HTML快速入门"><a href="#HTML快速入门" class="headerlink" title="HTML快速入门"></a>HTML快速入门</h3><h4 id="A-概述"><a href="#A-概述" class="headerlink" title="A.概述"></a>A.概述</h4><ol><li><p>HTML文件以“ .htm ” 或 “ .html ” 为扩展名。</p></li><li><p>HTML结构标签</p><p> <img src="/imgs/image-20221007185522655-1682259484194.png" alt="image-20221007185522655"></p></li><li><p>HTML标签不区分大小写。</p></li><li><p>HTML标签的属性值用单引号 或 双引号 引起来。</p></li><li><p>HMTL语法松散(了解)</p></li></ol><h5 id="①第一个HTML程序"><a href="#①第一个HTML程序" class="headerlink" title="①第一个HTML程序"></a>①第一个HTML程序</h5><ol><li><p>新建文本文件，后缀名改为 .html</p></li><li><p>编写HTML结构标签</p></li><li><p>在<body>中定义文字</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;html快速入门&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">乾坤未定，你我皆是黑马~</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li></ol><p>​结果：</p><p><img src="/imgs/image-20221007190411713-1682259484194.png" alt="image-20221007190411713"></p><h5 id="②IDEA中写HTML"><a href="#②IDEA中写HTML" class="headerlink" title="②IDEA中写HTML"></a>②IDEA中写HTML</h5><ol><li><p>实现</p><p> 新建一个Java module —&gt; 将module 中的src 文件删除 —&gt; 在该module下建一个文件new directory 命名为html —&gt;</p><p> 选中刚才新建的文件，右键new HTML file ，选HTML 5 file —&gt; 完成</p></li><li><p>建好后的HTML文件标签解析：</p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--html版本标识。!DOCTYPE代表是HTML5版本--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--规定当前页面编码集--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p>​</p><p>​</p><h4 id="B-基础标签"><a href="#B-基础标签" class="headerlink" title="B.基础标签"></a>B.基础标签</h4><p>​<img src="/imgs/image-20221007200439725-1682259484194.png" alt="image-20221007200439725"></p><ul><li><p>补充：</p><ol><li><p><font>标签中有三个属性：face（设置字体，如：宋体）、size（设置字体大小）、color（设置字体颜色）。</p></li><li><p>HTML、CSS中如何表示颜色：</p><ul><li>英文单词：red,pink,blue</li><li>rgb(值1，值2，值3)：值的取值范围为0-255。rgb中的 r 表示红色，g 表示绿色，b 表示蓝色，然后通过不同的值来匹配出不同的颜色，如：rgb(255，0，0)表示红色</li><li>#值1值2值3，值的范围：00-FF（FF：即255），原理与rgb的表示方式一样。</li></ul></li><li><hr>标签中也可以设置颜色属性color。</li></ol></li><li><p>例子：</p><p>  <img src="/imgs/image-20221007200521193-1682259484195.png" alt="image-20221007200521193"></p></li></ul><p>​</p><h4 id="C-图片、音频、视频标签"><a href="#C-图片、音频、视频标签" class="headerlink" title="C.图片、音频、视频标签"></a>C.图片、音频、视频标签</h4><h5 id="①概述"><a href="#①概述" class="headerlink" title="①概述"></a>①概述</h5><p><img src="/imgs/image-20221007210035634-1682259484195.png" alt="image-20221007210035634"></p><p><img src="/imgs/image-20230423223700021.png" alt="image-20230423223700021"></p><p>​使用controls属性时，可以直接写属性名即可。</p><h5 id="②补充"><a href="#②补充" class="headerlink" title="②补充"></a>②补充</h5><ol><li><p>上面三个标签中都可以写height、width属性，其值可以写：数字、百分比</p><ul><li>写数字：其单位默认为px（像素）。</li><li>写百分比：其含义是占页面大小的百分之多少。</li></ul></li><li><p>资源路径：</p><ul><li><p>绝对路径：带盘符</p></li><li><p>相对路径：资源相对于当前HTML页面的位置。不懂？见下面视频链接。</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.bilibili.com/video/BV1Qf4y1T7Hx/?p=63&amp;spm_id_from=pageDriver&amp;vd_source=9c398663599ac78b625d463b4ffc1ff5</span><br></pre></td></tr></table></figure><p>  练习：    </p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./ 代表：当前目录   ./可以省略不写</span><br><span class="line">../ 代表上一级目录</span><br></pre></td></tr></table></figure><p>  <img src="/imgs/image-20221007233250664-1682259484195.png" alt="image-20221007233250664"></p></li></ul></li></ol><h4 id="D-超链接标签"><a href="#D-超链接标签" class="headerlink" title="D.超链接标签"></a>D.超链接标签</h4><h5 id="①概述-1"><a href="#①概述-1" class="headerlink" title="①概述"></a>①概述</h5><p>​<img src="/imgs/image-20230423223605819.png" alt="image-20230423223605819"></p><h5 id="②例子"><a href="#②例子" class="headerlink" title="②例子"></a>②例子</h5><p><img src="/imgs/image-20221008114926972-1682259484195.png" alt="image-20221008114926972"></p><p>​效果展示：</p><p>​<img src="/imgs/image-20221008115017510-1682259484195.png" alt="image-20221008115017510"></p><h4 id="E-列表标签"><a href="#E-列表标签" class="headerlink" title="E.列表标签"></a>E.列表标签</h4><h5 id="①概述-2"><a href="#①概述-2" class="headerlink" title="①概述"></a>①概述</h5><p>​<img src="/imgs/image-20221008115507910-1682259484195.png" alt="image-20221008115507910"></p><h5 id="②例子-1"><a href="#②例子-1" class="headerlink" title="②例子"></a>②例子</h5><p>​<img src="/imgs/image-20221008115529971-1682259484195.png" alt="image-20221008115529971"></p><h4 id="F-表格标签"><a href="#F-表格标签" class="headerlink" title="F.表格标签"></a>F.表格标签</h4><h5 id="①概述-3"><a href="#①概述-3" class="headerlink" title="①概述"></a>①概述</h5><ol><li><p><img src="/imgs/image-20230423223008528.png" alt="image-20230423223008528"></p><p>使用&lt; th &gt;标签后，字体会被加粗 和 居中显示，通常使用在表头。</p></li><li><p>各标签对应的属性：</p><p> <img src="/imgs/image-20221008122830924-1682259484196.png" alt="image-20221008122830924"></p><p> 如果cellspacing值为0，则单元格之间就没有空白，即单元格之间的边框就会合在一起。</p></li><li><p>补充说明：</p><p> <img src="/imgs/image-20221008123156143-1682259484196.png" alt="image-20221008123156143"></p><p> ​该表格的第三行是有四个单元格的，第四行是只有三个单元格的。</p></li></ol><h5 id="②例子-2"><a href="#②例子-2" class="headerlink" title="②例子"></a>②例子</h5><p><img src="/imgs/image-20221008123410654-1682259484196.png" alt="image-20221008123410654"></p><p>​实现的效果：</p><p><img src="/imgs/image-20221008123433251-1682259484196.png" alt="image-20221008123433251"></p><h4 id="G-布局标签"><a href="#G-布局标签" class="headerlink" title="G.布局标签"></a>G.布局标签</h4><p><img src="/imgs/image-20221008141924482-1682259484196.png" alt="image-20221008141924482"></p><h4 id="H-表单标签"><a href="#H-表单标签" class="headerlink" title="H.表单标签"></a>H.表单标签</h4><h5 id="①概述-4"><a href="#①概述-4" class="headerlink" title="①概述"></a>①概述</h5><p>​表单：在页面中主要负责数据采集功能，使用<from>标签定义表单。</p><p>​表单项(或表单元素)：不同类型的input元素、下拉列表、文本域等</p><h5 id="②form标签"><a href="#②form标签" class="headerlink" title="②form标签"></a>②form标签</h5><p>​form标签内有两个属性：</p><ul><li>action：规定当提交表单时向何处发送表单数据，URL。当action&#x3D;”#”，则代表表单提交到当前页面。<ul><li>注意：表单项数据要想被提交，则必须指定其name属性，属性值随便写。</li></ul></li><li>method：指定表单提交的方式。<ul><li>get：默认值<ul><li>请求参数会拼接在URL后边。不安全。</li><li>URL的长度是有限制的，大小为4KB。</li></ul></li><li>post：<ul><li>请求参数会在http请求协议的请求体中，因此对请求参数的大小没有限制。且安全些。</li></ul></li><li>请求参数：即表单项中用户输入的值。</li></ul></li></ul><h5 id="③表单项标签"><a href="#③表单项标签" class="headerlink" title="③表单项标签"></a>③表单项标签</h5><ol><li><p>概述</p><p> <img src="/imgs/image-20221008160648807-1682259484196.png" alt="image-20221008160648807"></p></li><li><p>练习</p></li></ol><ul><li><p>提交按钮</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;注册&quot;</span>&gt;</span> <span class="comment">&lt;!--可以通过value值来改变提交按钮上显示的文本 --&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>lable标签</p><p>该标签的功能是：只要点击表单项附近的文字，输入框就能提示输入。</p><p>解释：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;label&gt;文字&lt;/label&gt;</span><br></pre></td></tr></table></figure><p>​通过点击文件就能跳到相应的输入框中提示输入。但究竟要跳到哪个输入框呢？就要指定label标签中的for属性和那个输入框的id属性，这样label标签就能通过for属性来找到对应的输入框。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span> <span class="attr">id</span>=<span class="string">&quot;travel&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;travel&quot;</span>&gt;</span>旅游<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>单选框</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">性别：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;男&quot;</span>&gt;</span>男</span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;女&quot;</span>&gt;</span>女</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="/imgs/image-20230423222315752.png" alt="image-20230423222315752"></p><p>如果两个单选框的name属性值不一样，就无法实现：多个只能选一个的功能。</p><p>如果不指定value值，提交表单时，其数据值就为：on，此值就没有意义了，所以得指定其值。</p></li><li><p>复选框</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span> 旅游</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>&gt;</span> 电影</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span> <span class="attr">value</span>=<span class="string">&quot;3&quot;</span>&gt;</span> 游戏</span><br></pre></td></tr></table></figure><p>  注意：①如果让复选框都属于爱好这个项目里，那就要要求name属性值都得一样。②每一个复选框都要指定其value值，不然提交表单的时候，数据就会显示为：on，这样数据就没有意义了。</p></li><li><p>提交文件</p><p>应用：上传用户头像等</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">头像：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>隐藏输入</p><p>应用：我们需要用户的id值，但不希望用户自己来输入，此时就可以使用隐藏输入来指定用户的id值了。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>下拉列表</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&#x27;city&#x27;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>北京<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">‘shanghai</span>&gt;</span>上海<span class="tag">&lt;/<span class="name">option</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!--如果option里有value，则提交时将提交value的值，而不是“上海” --&gt;</span>   </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>文本域</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">个人描述<span class="tag">&lt;<span class="name">textarea</span> <span class="attr">cols</span>=<span class="string">&quot;20&quot;</span> <span class="attr">rows</span>=<span class="string">&quot;5&quot;</span> <span class="attr">name</span>=<span class="string">&#x27;desc&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  cols：指定文本域中一行可以写多少个字。</p><p>  rows：指定文本域一共可以写多少行。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis</title>
      <link href="/2023/04/23/mybatis/"/>
      <url>/2023/04/23/mybatis/</url>
      
        <content type="html"><![CDATA[<h3 id="①概述"><a href="#①概述" class="headerlink" title="①概述"></a>①概述</h3><h4 id="A-MyBatis"><a href="#A-MyBatis" class="headerlink" title="A.MyBatis"></a>A.MyBatis</h4><ul><li>MyBatis是一款优秀的持久层框架，用于简化JDBC开发。</li><li>持久层：负责将数据保存到数据库的那一层代码。</li><li>框架：半成品软件，是一套可重复的、通用的、软件基础代码模型。在框架上构建软件会更加高效、规范、通用、可扩展。</li></ul><h4 id="B-JDBC缺点"><a href="#B-JDBC缺点" class="headerlink" title="B.JDBC缺点"></a>B.JDBC缺点</h4><ol><li>硬编码。即在注册驱动、获取连接时，变量值用的都是字符串，代表其值是固定的，不能改变，这就是硬编码。</li><li>操作繁琐。如：将数据装到对象中时。</li></ol><h4 id="C-MyBatis如何解决JDBC的缺点"><a href="#C-MyBatis如何解决JDBC的缺点" class="headerlink" title="C.MyBatis如何解决JDBC的缺点"></a>C.MyBatis如何解决JDBC的缺点</h4><ol><li>硬编码—&gt; 写在配置文件中</li><li>操作繁琐—&gt; 一行代码完，省去了设置值和转载数据的操作。</li></ol><p>​</p><h3 id="②快速入门"><a href="#②快速入门" class="headerlink" title="②快速入门"></a>②快速入门</h3><p>​从数据库中获取数据，然后将其放到一个对象中，再将对象放到一个集合中。</p><h4 id="A-实现步骤"><a href="#A-实现步骤" class="headerlink" title="A.实现步骤"></a>A.实现步骤</h4><p>​新建一个maven项目</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0.导入mybatis依赖，放到pom.xml文件中</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&lt;dependency&gt;</span></span><br><span class="line"><span class="comment">      &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span></span><br><span class="line"><span class="comment">      &lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span></span><br><span class="line"><span class="comment">      &lt;version&gt;3.5.7&lt;/version&gt;</span></span><br><span class="line"><span class="comment">&lt;/dependency&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.导入MySQL数据库驱动：mysql-connector-java-5.1.34.jar</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&lt;dependency&gt;</span></span><br><span class="line"><span class="comment">            &lt;groupId&gt;mysql&lt;/groupId&gt;</span></span><br><span class="line"><span class="comment">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span></span><br><span class="line"><span class="comment">            &lt;version&gt;5.1.34&lt;/version&gt;</span></span><br><span class="line"><span class="comment">        &lt;/dependency&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//2.编写MyBatis核心配置文件 ---&gt; 即：将JDBC中的连接信息写到配置文件中</span></span><br><span class="line"><span class="comment">//2.1在main文件夹下的resources文件中新建一个配置文件：mybatis-config.xml</span></span><br><span class="line"><span class="comment">//2.2在刚才的新建文件中写入配置信息：见补充信息①</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.编写sql映射文件 --&gt; 原来SQL语句是写在代码中的，现在将其写在一个配置文件中，这样可以统一管理SQL语句。</span></span><br><span class="line"><span class="comment">//3.1在main文件夹下的resources文件中新建一个文件：操作的数据库表表名Mapper.xml</span></span><br><span class="line"><span class="comment">//3.2将补充信息2中的配置信息复制到该文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4.加载MyBatis核心配置文件，获取SqlSessionFactory对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;..........&quot;</span>;</span><br><span class="line"><span class="comment">//resource：写MyBatis核心配置文件的路径(路径从resources文件夹下开始写)</span></span><br><span class="line"></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> </span><br><span class="line">    <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br><span class="line"><span class="comment">//SqlSessionFactory类的对象就相当于JDBC中的Connection类的对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//5.获取SqlSession对象</span></span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession(); <span class="comment">//相当于JDBC中获取执行SQL语句的对象。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//6.执行SQL语句</span></span><br><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> sqlSession.selectList(<span class="string">&quot;sql语句的标识&quot;</span>);<span class="comment">//SqlSession里还有其它的方法</span></span><br><span class="line"><span class="comment">//sql语句的标识：在配置sql映射文件中的时候，有定义该sql语句的namespace和id，两者用&quot;.&quot;连接起来。</span></span><br><span class="line"><span class="comment">//为什么要这么写呢？因为到时候会有很多的sql映射文件，一个sql文件里又可能有很多的sql语句，所以就用namespace和id来定位唯一一条sql语句。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//7.释放资源</span></span><br><span class="line">sqlSession.close();<span class="comment">//只要释放SqlSession类的对象的资源即可</span></span><br></pre></td></tr></table></figure><p>​</p><h5 id="补充信息①"><a href="#补充信息①" class="headerlink" title="补充信息①"></a>补充信息①</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">  <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">  <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--上面的东西不用管 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--driver 就相当于jdbc中的注册驱动操作 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--下面三行就是数据库的连接信息 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://127.0.0.1:3306/要连接的数据库?useSSL=false&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span>  <span class="comment">&lt;!--登录数据库的用户名 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1234&quot;</span>/&gt;</span>  <span class="comment">&lt;!--登录数据库的密码 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--resource：写sql映射文件的地址，用于加载sql映射文件的 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;操作的数据库表表名Mapper.xml&quot;</span>/&gt;</span></span><br><span class="line">      </span><br><span class="line">    <span class="comment">&lt;!--如果使用了Mapper代理的方式，就可以简化SQL映射文件的加载，如：</span></span><br><span class="line"><span class="comment"> &lt;package name = &#x27;写resources文件下存放sql映射文件的文件名&#x27;/&gt; </span></span><br><span class="line"><span class="comment"> 这样就可以一次性加载该文件夾下所有的sql映射文件。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​</p><h5 id="补充信息②"><a href="#补充信息②" class="headerlink" title="补充信息②"></a>补充信息②</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">  <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">  <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--上面的东西不用管 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectBlog&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;类的全类名&quot;</span>&gt;</span></span><br><span class="line">    select * from Blog where id = ....</span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--SQL语句要写在对应的标签中，如：上面8-10行代码 --&gt;</span>  </span><br><span class="line">  <span class="comment">&lt;!--可以在mapper标签中写多条sql语句 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​说明</p><ul><li><!--select id="该SQL语句的唯一标识，随便写只要不一样就行" resultType="规定该语句返回的类型，如果要将结果放到某个类中，就写那个类的全类名即可" --></li><li>mapper标签里的namespace：随便写一个即可，但要唯一。</li></ul><h4 id="B-解决视情况映射文件的警告提示"><a href="#B-解决视情况映射文件的警告提示" class="headerlink" title="B.解决视情况映射文件的警告提示"></a>B.解决视情况映射文件的警告提示</h4><ul><li>产生警告的原因：Idea和数据库没有建立连接，不识别表的信息。</li><li>解决方式：在Idea中配置MySQL数据库连接。具体操作，见网址：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://blog.csdn.net/weixin_59118991/article/details/124562952</span><br></pre></td></tr></table></figure><hr><h3 id="③Mapper代理开发"><a href="#③Mapper代理开发" class="headerlink" title="③Mapper代理开发"></a>③Mapper代理开发</h3><h4 id="A-引入"><a href="#A-引入" class="headerlink" title="A.引入"></a>A.引入</h4><p>​上面我们通过MyBatis实现了对MySQL数据库的操作，但在实现步骤6(执行sql语句)中还是会存在硬编码的问题，所以我们引入了Mapper代理开发。这种方式在实际开发中很常用。</p><h4 id="B-实现步骤"><a href="#B-实现步骤" class="headerlink" title="B.实现步骤"></a>B.实现步骤</h4><ol><li><p>在pom.xml文件中导入Mysql依赖、mybatis依赖（见笔记MyBatis快速入门）。</p></li><li><p>在main文件夹下的resources文件下建mybatis核心配置文件(mybatis-config.xml)。(mybatis核心配置文件的内容见笔记MyBatis快速入门)。</p></li><li><p>在main文件夹下的java文件中建两个包：com.zzc.mapper 、com.zzc.pojo，这两个包分别放Mapper接口和数据库表对应的类。</p><p> <img src="/../imgs/image-20221007160103501-1682258537176.png" alt="image-20221007160103501"></p></li><li><p>在resources文件夹下，创建SQL映射文件，文件名为：数据库表表名Mapper.xml。文件内容见：笔记MyBatis快速入门。</p></li><li><p><strong>定义与SQL映射文件同名的Mapper接口，并且将Mapper接口和SQL映射文件放置在同一目录下</strong>。</p><p> 1. </p>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在mapper包中放 “ 与SQL映射文件同名的Mapper接口 ”。</span><br></pre></td></tr></table></figure><p>  如何实现Mapper接口和SQL映射文件放置在同一目录下？前提SQL映射文件是放在main文件夹下的resources文件中。<br>   由于resources与java文件都是在同一个文件层级中，所以那个接口放在什么文件下，你就在resources文件下也建一个相同的文件层次来放SQL映射文件即可。使用new Directory的方式创建文件层级，<strong>但注意文件路径要用“ &#x2F; ”不能用“ . ”</strong> 。<br>  例子：Mapper接口放在了：<img src="/../imgs/image-20220926102308096-1682258537177.png" alt="image-20220926102308096"></p><p>   ​那配置文件UserMapper.xml应该放在哪？在resources下new Directory 命名为：com&#x2F;itheima&#x2F;mapper。然后将UserMapper.xml拖进这个文件里即可。</p></li><li><p><strong>设置SQL映射文件的namespace属性为Mapper接口全限定名</strong>，即：com.xxx.xxx.接口名。如按上面的例子来写，则为：com.itheima.mapper.UserMapper。</p></li><li><p><strong>在Mapper接口中定义方法，方法名就是SQL映射文件中SQL语句的id，并保持与sql语句中的参数类型和返回值类型一致。</strong>如果sql语句返回的是List<User>，则方法的放回值类型也是List<User>。</p></li><li><p><strong>修改MyBatis核心配置文件中的 <mapper resource=""/>，写上现在sql映射文件的地址。</strong></p><p> 文件地址默认从resources文件下开始写。如：sql映射文件放在resources文件夹下的com.zzc.mapper文件下。那就这样写：</p>   <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/zzc/mapper/ExeMapper.xml&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">&lt;!--如果使用了Mapper代理的方式，就可以简化SQL映射文件的加载，如：</span></span><br><span class="line"><span class="comment"> &lt;package name = &#x27;写resources文件下存放sql映射文件的文件名&#x27;/&gt; </span></span><br><span class="line"><span class="comment"> 这样就可以一次性加载该文件夾下所有的sql映射文件。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编码（按照MyBatis快速入门中的步骤4-7进行码，其中第6步替换为下面两步）</p><ol><li><p>通过SqlSession的getMapper方法获取 Mapper接口的代理对象。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mapper接口名 mapper = sqlSession.getMapper(Mapper接口名.class);</span><br></pre></td></tr></table></figure></li><li><p>通过Mapper接口的代理对象，调用Mapper接口中对应方法完成sql的执行。</p></li></ol></li><li><p>编写数据库表对应的类，并放在pojo包下。</p></li><li><p>看看数据库中该表的字段是否与表对应的类的属性名一致，不一致得使用resultMap标签（见笔记MyBatis练习–&gt; 查询–所有数据 —&gt; resultMap标签），不然会导致部分数据不能自动封装到对象中。</p></li><li><p>关闭资源</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlSession.close();</span><br></pre></td></tr></table></figure></li></ol><h4 id="C-实现原理"><a href="#C-实现原理" class="headerlink" title="C.实现原理"></a>C.实现原理</h4><ol><li>当我们通过SqlSession类的对象去调用getMapper(Mapper接口名.class)方法时，实际上就是找到了该接口，由于该接口的目录下还有其对应的SQL映射文件，因此也找到了该映射文件。</li><li>找到映射文件之后也就找到了SQL语句，那到底执行哪条sql呢？通过调用Mapper接口中的方法，通过该方法名我们就找到了sql的id，然后根据id在映射文件中找到具体的sql并执行。</li></ol><hr><h3 id="④MyBatis核心配置文件解释"><a href="#④MyBatis核心配置文件解释" class="headerlink" title="④MyBatis核心配置文件解释"></a>④MyBatis核心配置文件解释</h3><h4 id="A-environent标签"><a href="#A-environent标签" class="headerlink" title="A.environent标签"></a>A.environent标签</h4><ul><li><p>用于配置数据库连接信息，在<environents>标签中可以定义多个environent。</p></li><li><p>每个environent标签都有个id属性，用于标识此environent。</p></li><li><p>我们可以通过environents标签中的default属性来切换不同的environent。即将environent的id赋给default。</p></li><li><p><environent>标签里有个<transactionManager type="JDBC">标签，其作用是管理事务。不用管。</p></li><li><p><environent>标签里有个<dataSource type="POOLED">标签，不用管。</p></li><li><p>类型别名(typeAliases)</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span> = <span class="string">&quot;com.itheima.pojo&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  我们在写sql映射文件时，该文件的配置里需指定返回值的类型，该返回值类型需要使用全类名的方式表示，这样的写法会冗余些，所以我们可以使用类型别名的方式，将某个包下的类用该类的类名来代替全类名。如：</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--某个包com.zzc.pojo下有Person类，Man类 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span> = <span class="string">&quot;com.itheima.pojo&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--使用之后，就可以用person来代替com.zzc.pojo.Person,用Man来代替com.zzc.pojo.Man --&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>注意：配置各个标签时，需要遵循如下图先后顺序，不然报错。</p><ul><li><img src="/../imgs/image-20220926153642399-1682258537177.png" alt="image-20220926153642399"></li></ul></li></ul><h3 id="⑤MybatiX插件"><a href="#⑤MybatiX插件" class="headerlink" title="⑤MybatiX插件"></a>⑤MybatiX插件</h3><h4 id="A-功能介绍"><a href="#A-功能介绍" class="headerlink" title="A.功能介绍"></a>A.功能介绍</h4><p>​此插件可以帮我们快速地完成有些功能如：</p><p>​①</p><p>​<img src="/../imgs/image-20220928221305504-1682258537177.png" alt="image-20220928221305504"></p><p>​只要点击上图中的小鸟就可以跳到相应的SQL映射文件里对应的SQL语句。</p><p>​②映射文件对应的接口里，写下新的抽象方法，按 alt + 回车 ，选 “ mybatis…..”  ，就可以在对应的映射文件中创建相应的SQL语句。</p><p><img src="/../imgs/image-20221117182402031-1682258537177.png" alt="image-20221117182402031"></p><h4 id="B-插件安装"><a href="#B-插件安装" class="headerlink" title="B.插件安装"></a>B.插件安装</h4><p><img src="/../imgs/image-20220928222331498-1682258537177.png" alt="image-20220928222331498"></p><p><img src="/../imgs/image-20220928222432635-1682258537177.png" alt="image-20220928222432635"></p><h3 id="⑥MyBatis练习"><a href="#⑥MyBatis练习" class="headerlink" title="⑥MyBatis练习"></a>⑥MyBatis练习</h3><h4 id="A-查询–所有数据"><a href="#A-查询–所有数据" class="headerlink" title="A.查询–所有数据"></a>A.查询–所有数据</h4><h5 id="①引入"><a href="#①引入" class="headerlink" title="①引入"></a>①引入</h5><p>​MyBatis中，当数据库表的字段名称 和 实体类的属性名称 不一样，则不能自动封装数据。</p><h5 id="②解决方法"><a href="#②解决方法" class="headerlink" title="②解决方法"></a>②解决方法</h5><p>​使用<strong>resultMap</strong>标签</p><p>​<strong>实习步骤</strong>：</p><ol><li>在SQL映射文件中定义resultMap标签。</li><li>在select标签中，使用resultMap属性(其值为resultMap中的id值) 替换 原来的resultType属性。</li></ol><p>​补充：</p><p>​如果使用的是注解开发，则将上面步骤2中的操作替换为：在接口方法上使用@ResultMap(“写resultMap中的id值”)即可。</p><p><img src="/imgs/image-20230423221329390.png" alt="image-20230423221329390"></p><h5 id="③resultMap标签的结构"><a href="#③resultMap标签的结构" class="headerlink" title="③resultMap标签的结构"></a>③resultMap标签的结构</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;getEmpByIdMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;entity.Employee&quot;</span> &gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;st_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;st_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;st_sex&quot;</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;st_email&quot;</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​resultMap标签属性介绍：</p><ul><li>id：唯一标识该resultMap</li><li>type：写原来select标签中的resultType的值。</li><li>resultMap标签里有两个子标签：<ul><li><id column="..." property="..."/> 该标签用于完成主键字段的映射</li><li><result column="..." property="..."/> 该标签用于完成一般字段的映射</li></ul></li><li>上面两个标签中的 column 和 property<ul><li>column：表的列名</li><li>property：实体类的属性名</li></ul></li></ul><h4 id="B-查询–任意某个数据"><a href="#B-查询–任意某个数据" class="headerlink" title="B.查询–任意某个数据"></a>B.查询–任意某个数据</h4><p>​以根据Id来查找数据为例。</p><h5 id="①实现步骤"><a href="#①实现步骤" class="headerlink" title="①实现步骤"></a>①实现步骤</h5><ol><li><p>编写接口方法：Mapper接口</p><ul><li><p>参数为：id，结果为：Brand。</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Brand selectById(int id);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>编写SQL语句：SQL映射文件</p></li></ol><p><img src="/../imgs/image-20221004191005819-1682258537177.png" alt="image-20221004191005819"></p><p>​parameterType：用于设置参数类型，可以省略不写。</p><p>​#{id}的解释见：占位符。</p><h5 id="②参数占位符"><a href="#②参数占位符" class="headerlink" title="②参数占位符"></a>②参数占位符</h5><ol><li><p>参数占位符有两种：#{ } 和 ${ } </p><ul><li>#{形参名}：在编译时会将其替换为 ? ，将来自动设置参数值。目的是防止SQL注入。</li><li>${形参名}：在编译时直接将形参值替换掉${形参名}。会存在SQL注入问题。</li><li>使用时机：参数传递的时候，使用 #{形参名}；表名或列名不固定的情况下：${形参名}</li></ul></li><li><p>SQL语句中特殊字符处理，如：小于号“ &lt; ”，在xml文件中属于标签的开始符号。所以就得使用如下方法进行处理：</p><ul><li>转移字符(小于号对应的转移字符为：” &amp;lt “ )</li><li>CDATA区：<![CDATA[内容]]>。使用时直接打CD就会提示出这个CDATA区。</li></ul></li></ol><h4 id="C-查询–条件查询"><a href="#C-查询–条件查询" class="headerlink" title="C.查询–条件查询"></a>C.查询–条件查询</h4><h5 id="①多条件查询"><a href="#①多条件查询" class="headerlink" title="①多条件查询"></a>①多条件查询</h5><p>​<img src="/../imgs/image-20221005113009918-1682258537177.png" alt="image-20221005113009918"></p><p>​当多条件查询时，Mapper接口中的方法应该怎么写呢？有三种写法：</p><ol><li><p><strong>散装参数</strong>：使用@Param(“SQL中的参数占位符名称”)。如：</p><p> <img src="/../imgs/image-20221005113057692-1682258537178.png" alt="image-20221005113057692"></p><p> ​接口方法中的参数status 设置的是SQL语句中的status参数。</p></li><li><p><strong>实体类封装参数</strong>：需要保证SQL中的参数名 和 实体类属性名对应上。</p><p> <strong>其原理是</strong>：通过SQL中的参数名 来找实体类中是否有同名的属性名，有则调用该属性的get方法来获取其值。</p><p> <strong>例子</strong>：<img src="/../imgs/image-20221005113735701-1682258537178.png" alt="image-20221005113735701"></p></li><li><p><strong>map集合</strong>：需要保证SQL语句中的参数名 和 map集合的键的名称对应上。</p><p> 例子：<img src="/../imgs/image-20221005113935878-1682258537178.png" alt="image-20221005113935878"></p></li></ol><h5 id="②多条件的动态查询"><a href="#②多条件的动态查询" class="headerlink" title="②多条件的动态查询"></a>②多条件的动态查询</h5><ol><li><p><strong>问题引入</strong>：我们需要根据实际情况来动态编写我们的SQL语句。</p></li><li><p><strong>动态SQL语句的实现</strong>：添加相应的标签，如：</p><ul><li>if（用于判断参数是否有值，使用test属性进行条件判断）</li><li>choose (when, otherwise)</li><li>trim (where, set)</li><li>foreach</li></ul></li><li><p>应用例子：</p><p> <strong>if的应用</strong>：</p><p> <img src="/../imgs/image-20221005170413700-1682258537178.png" alt="image-20221005170413700"></p><p> ​当status !&#x3D; null 时，就会执行status &#x3D; #{status}这条SQL语句。</p><p> ​<strong>where的应用</strong>：</p><p> ​如果上图中的status为null，companyName !&#x3D; null，brandName !&#x3D; null。这样就会导致SQL语句变成：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">from</span> tb_brand</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">and</span> company_name <span class="keyword">like</span> #&#123;companyName&#125; <span class="keyword">and</span> brand_name <span class="keyword">like</span> #&#123;brandName&#125;</span><br></pre></td></tr></table></figure><p> ​这样的SQL语句会报错。</p><p> ​所以我们就可以使用<where>标签来代替where关键字，帮我们判断是否需要加连接关键字。如果需要加上，则会加上；如果不需要加上，则会帮我们删除掉。如：</p><p> <img src="/../imgs/image-20221005171330402-1682258537178.png" alt="image-20221005171330402"></p></li></ol><h5 id="③单条件的动态查询"><a href="#③单条件的动态查询" class="headerlink" title="③单条件的动态查询"></a>③单条件的动态查询</h5><ol><li><p>单条件的动态查询：从多个条件中选择一个。</p><p> ​例子：可以从多个条件中选择一个条件作为查询条件。</p></li><li><p><strong>实现</strong>：使用<choose>标签及其子标签<when>、<otherwise>。</p><ul><li><choose>相当于Java中的switch。</li><li><when>相当于Java中的case。</li><li><otherwise>相当于Java中的default。</li></ul></li><li><p>应用：</p><p> <img src="/../imgs/image-20221005211621505-1682258537178.png" alt="image-20221005211621505"></p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">from</span> tb_brand</span><br><span class="line"><span class="keyword">where</span> <span class="number">1</span> <span class="operator">=</span> <span class="number">1</span> </span><br><span class="line"><span class="comment">-- 下面与上面等价</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">from</span> tb_brand</span><br></pre></td></tr></table></figure></li></ol><h5 id="④Like模糊匹配"><a href="#④Like模糊匹配" class="headerlink" title="④Like模糊匹配"></a>④Like模糊匹配</h5><p>​like关键字后面跟着参数占位符时，该怎么实现模糊匹配呢？</p><p>​使用数据库中的concat函数，concat(‘%’,#{数据名,jdbcType&#x3D;数据在数据库中的数据类型},’%’)</p><p>​例子：</p><p>​Mapper下这样写：</p><p><img src="/imgs/image-20230423221434471.png" alt="image-20230423221434471"></p><p>​对应的接口这样写：</p><p><img src="/imgs/image-20230423221445722.png" alt="image-20230423221445722"></p><p>​例子还有：<a href="https://zhuanlan.zhihu.com/p/58297267">mybatis中使用like关键字拼接SQL - 知乎 (zhihu.com)</a></p><h4 id="D-添加数据"><a href="#D-添加数据" class="headerlink" title="D.添加数据"></a>D.添加数据</h4><h5 id="①实现步骤-1"><a href="#①实现步骤-1" class="headerlink" title="①实现步骤"></a>①实现步骤</h5><ol><li>编写接口方法：Mapper接口<ul><li>方法的参数：除了id之外的所有数据（因为id是自增的）</li><li>方法的返回值类型：void（因为我们可以通过是否抛异常，来判断是否添加成功）</li></ul></li><li>编写SQL语句：在SQL映射文件中使用<insert>标签</li></ol><h5 id="②注意"><a href="#②注意" class="headerlink" title="②注意"></a>②注意</h5><p>​<img src="/../imgs/image-20221006115241104-1682258537178.png" alt="image-20221006115241104"></p><h5 id="③应用例子"><a href="#③应用例子" class="headerlink" title="③应用例子"></a>③应用例子</h5><p><img src="/../imgs/image-20221006115120607-1682258537178.png" alt="image-20221006115120607"></p><h4 id="E-添加数据–主键返回"><a href="#E-添加数据–主键返回" class="headerlink" title="E.添加数据–主键返回"></a>E.添加数据–主键返回</h4><p>①引入</p><p>​在数据添加成功后，需要获取插入数据库数据的主键的值。</p><p>​如：添加订单项时，订单项中需要设置所属订单的id。</p><p>②实现</p><p>​在<insert>标签里添加其属性：useGeneratedKeys、keyProperty，如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span> = <span class="string">&quot;addOrder&quot;</span> <span class="attr">useGeneratedKeys</span> =<span class="string">&quot;true&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>useGeneratedKeys：该属性用来设置，是否使用 JDBC 提供的 getGenereatedKeys() 方法。如果设置为true，将获取数据库内部产生的主键并赋值到 keyProperty 属性设置的请求对象的属性中。如果不设置useGeneratedKeys属性，则默认值为false。</li><li>keyProperty：该属性的作用是将插入操作的返回值赋给 PO 类的某个属性，通常为主键对应的属性。如果是联合主键，可以将多个值用逗号隔开。</li></ul><h4 id="F-修改–全部字段"><a href="#F-修改–全部字段" class="headerlink" title="F.修改–全部字段"></a>F.修改–全部字段</h4><h5 id="①实现"><a href="#①实现" class="headerlink" title="①实现"></a>①实现</h5><ol><li>编写接口方法：Mapper接口<ul><li>方法的参数：所有数据</li><li>方法的返回值类型：可以是void（通过是否抛异常来判断是否修改成功），可以是int（通过返回受影响行数来判断是否修改成功）</li></ul></li><li>编写SQL语句：SQL映射文件中使用<update>标签</li></ol><h5 id="②例子"><a href="#②例子" class="headerlink" title="②例子"></a>②例子</h5><p>​<img src="/../imgs/image-20221006150422586-1682258537178.png" alt="image-20221006150422586"></p><h4 id="G-修改–动态字段"><a href="#G-修改–动态字段" class="headerlink" title="G.修改–动态字段"></a>G.修改–动态字段</h4><h5 id="①引入-1"><a href="#①引入-1" class="headerlink" title="①引入"></a>①引入</h5><p>​有时候用户并不需要修改所有的数据，只需要修改某一部分的数据，因此我们就需要用到动态SQL。</p><h5 id="②实现"><a href="#②实现" class="headerlink" title="②实现"></a>②实现</h5><ol><li>编写接口方法：Mapper接口<ul><li>方法的参数：部分数据，将数据封装到对象中</li><li>方法的返回值：void 或 int (返回受影响的行数)</li></ul></li><li>编写SQL语句：SQL映射文件</li></ol><h5 id="③例子"><a href="#③例子" class="headerlink" title="③例子"></a>③例子</h5><p>​<img src="/../imgs/image-20221006153319643-1682258537178.png" alt="image-20221006153319643"></p><p>​<set>标签的作用：</p><ol><li>去除SQL语句后面多余的 “ , ” ，使SQL语句语法正确。</li><li>当set后面没有对应的修改语句时，会自动将set关键字删除。</li></ol><h4 id="H-删除–一个数据"><a href="#H-删除–一个数据" class="headerlink" title="H.删除–一个数据"></a>H.删除–一个数据</h4><h5 id="①实现-1"><a href="#①实现-1" class="headerlink" title="①实现"></a>①实现</h5><ol><li>编写接口方法：Mapper接口<ul><li>方法的参数：id</li><li>方法的返回值类型：void</li></ul></li><li>编写SQL语句：SQL映射文件</li></ol><h5 id="②例子-1"><a href="#②例子-1" class="headerlink" title="②例子"></a>②例子</h5><p><img src="/../imgs/image-20221006155821062-1682258537179.png" alt="image-20221006155821062"></p><h4 id="I-删除–批量删除"><a href="#I-删除–批量删除" class="headerlink" title="I.删除–批量删除"></a>I.删除–批量删除</h4><h5 id="①实现-2"><a href="#①实现-2" class="headerlink" title="①实现"></a>①实现</h5><ol><li><p>编写接口方法：Mapper接口</p><ul><li>方法的参数：id数组（批量删除的数量较多，可以将其存储到一个数组中）</li><li>方法的返回值类型：void</li></ul></li><li><p>编写SQL语句：SQL映射文件</p><p> 形式一：</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteByIds&quot;</span>&gt;</span></span><br><span class="line">delete from tb_brand</span><br><span class="line">where id in</span><br><span class="line"><span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;数组名&quot;</span> <span class="attr">item</span>=<span class="string">&quot;id&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure><p> ​如果使用上面的这种形式，则Mapper接口中的方法需写成：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">deleteByIds</span><span class="params">(<span class="meta">@Param(&quot;数组名&quot;)</span> <span class="type">int</span>[] 数组名)</span>;</span><br></pre></td></tr></table></figure><p> 形式二：</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteByIds&quot;</span>&gt;</span></span><br><span class="line">delete from tb_brand</span><br><span class="line">where id in</span><br><span class="line"><span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;array&quot;</span> <span class="attr">item</span>=<span class="string">&quot;id&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--mybatis会将数组参数，封装为一个Map集合。该Map集合的名字为：arry。 --&gt;</span></span><br></pre></td></tr></table></figure><p> ​如果使用上面的这种形式，则Mapper接口中的方法需写成：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">deleteByIds</span><span class="params">(<span class="type">int</span>[] 数组名)</span>;</span><br></pre></td></tr></table></figure></li></ol><h5 id="②SQL映射文件解释"><a href="#②SQL映射文件解释" class="headerlink" title="②SQL映射文件解释"></a>②SQL映射文件解释</h5><p>​引入：如果要删除多个数据，我们可以这样写：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteByIds&quot;</span>&gt;</span></span><br><span class="line">delete from tb_brand</span><br><span class="line">where id in (?,?,?)</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​但这样写会存在一个问题：一个占位符? 代表一个参数，因此该SQL语句只能删除三条记录，也就是说其删除数据的数量是固定的。如何实现删除任意数量的数据呢？使用<foreach>标签</p><ul><li><foreach>标签： 该标签用于遍历数组的。标签里面有一些属性，如：<ul><li>collection：要遍历的数组名字 或 集合名字</li><li>item：表示集合中每一个元素进行迭代时的别名。</li><li>separator：表示在每次进行迭代之间以什么符号作为分隔符。</li><li>open：表示该语句以什么开始。open&#x3D;”(“，其效果相当于上面第三行代码中 in 后面的 “ ( “</li><li>close：表示该语句以什么结束。close&#x3D;”)”，其效果相当于上面第三行代码中 最后一个问号后面的 “ ) ”。</li></ul></li></ul><h3 id="⑦参数传递"><a href="#⑦参数传递" class="headerlink" title="⑦参数传递"></a>⑦参数传递</h3><p>​MyBatis 接口方法中可以接收各种各样的参数，MyBatis底层对于这些参数进行不同的封装处理方式。</p><h4 id="A-多个参数"><a href="#A-多个参数" class="headerlink" title="A.多个参数"></a>A.多个参数</h4><p>​当接收多个参数时：</p><p>​MyBatis会将参数封装为Map集合，其中value值为参数的值，一个参数将对应两个键名：arg 和 param。即：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">map.put(&quot;arg0&quot;,参数值1)</span><br><span class="line">map.put(&quot;param1&quot;,参数值1)</span><br><span class="line">map.put(&quot;arg0&quot;,参数值2)</span><br><span class="line">map.put(&quot;param1&quot;,参数值2)</span><br></pre></td></tr></table></figure><p>​因此我们可以在SQL语句中通过arg 或 param来获取参数的值，但这种方式不利于阅读，所以我们使用@Param注解来解决这个问题。@Param(“username”)，username将会替换掉Map集合中默认的arg键名。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map.put(&quot;username&quot;,参数值1)</span><br><span class="line">map.put(&quot;param1&quot;,参数值1)</span><br></pre></td></tr></table></figure><p>​因此我们在SQL语句中，可以通过username来获取参数值1。</p><h4 id="B-单个参数"><a href="#B-单个参数" class="headerlink" title="B.单个参数"></a>B.单个参数</h4><ul><li><p><strong>POJO类</strong>：直接使用，属性名 和 参数占位符名称 一致。</p><ul><li><p>POJO类：如有表 user ，与其对应的类 User 就被称为POJO类。</p></li><li><p>例子：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">select</span><span class="params">(User user)</span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>Map集合</strong>：直接使用，但键名 和 参数占位符名称 要一致，不然会出错</p><ul><li><p>例子：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">select</span><span class="params">(Map map)</span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>Collection</strong>：封装为Map集合，推荐使用@Param注解，替换Map集合中默认的arg键名。</p><ul><li>Collection封装为Map后，Collection集合作为value，其对应的键名有两个：arg0、collection，即在SQL语句中写arg0 或 collection 都可以获取到参数的值。</li></ul></li><li><p><strong>List</strong>：封装为Map集合，推荐使用@Param注解，替换Map集合中默认的arg键名。</p><ul><li>List封装为Map后，List集合作为value，其对应的键名有三个：arg0、collection、list，即在SQL语句中写arg0 或 collection  或 list 都可以获取到参数的值。</li></ul></li><li><p><strong>数组</strong>：封装为Map集合，推荐使用@Param注解，替换Map集合中默认的arg键名。</p><ul><li>数组封装为Map后，数组作为value，其对应的键名有两个：arg0、array，即在SQL语句中写arg0 或 array 都可以获取到参数的值。</li></ul></li><li><p><strong>其它类型</strong>：直接使用。</p></li></ul><h4 id="C-练习"><a href="#C-练习" class="headerlink" title="C.练习"></a>C.练习</h4><p>​<img src="/../imgs/image-20221006210550955-1682258537179.png" alt="image-20221006210550955"></p><p>​红色问号的地方应该写：user.username 、user.password。</p><p>​因为通过user就能获取到user对象，再通过对象调属性的方式就能得到对象相应的属性值。</p><h3 id="⑧注解开发"><a href="#⑧注解开发" class="headerlink" title="⑧注解开发"></a>⑧注解开发</h3><h4 id="A-什么是注解开发"><a href="#A-什么是注解开发" class="headerlink" title="A.什么是注解开发"></a>A.什么是注解开发</h4><p>​即将SQL语句写在注解中，然后注解写在Mapper接口的相应方法上面。</p><p><img src="/../imgs/image-20221006220820851-1682258537179.png" alt="image-20221006220820851"></p><p>​除了SQL语句编写的位置不一样外，其它的相关操作（如：SQL语句的执行）都与之前一样。</p><h4 id="B-四种注解"><a href="#B-四种注解" class="headerlink" title="B.四种注解"></a>B.四种注解</h4><ul><li>查询：@Select</li><li>添加：@Insert</li><li>修改：@Update</li><li>删除：@Delete</li></ul><h4 id="C-使用场景"><a href="#C-使用场景" class="headerlink" title="C.使用场景"></a>C.使用场景</h4><p>​当要完成简单的功能时，我们就可以使用注解开发。</p><p>​当要完成复杂的功能时，我们还是用配置文件来写SQL。</p>]]></content>
      
      
      <categories>
          
          <category> Java Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javaweb概述</title>
      <link href="/2023/04/23/javaweb%E6%A6%82%E8%BF%B0/"/>
      <url>/2023/04/23/javaweb%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="一、JavaWeb介绍"><a href="#一、JavaWeb介绍" class="headerlink" title="一、JavaWeb介绍"></a>一、JavaWeb介绍</h3><ol><li><p>web：能够通过浏览器访问的网站。</p></li><li><p>JavaWeb：用Java来开发网站</p></li><li><p>Web互联网系统的三大组成部分：</p><p> <img src="/../imgs/image-20220913105430987-1682257740401.png" alt="image-20220913105430987"></p></li><li><p>学习内容</p><p> <img src="/../imgs/image-20220913110518745-1682257740402.png" alt="image-20220913110518745"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaWeb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库</title>
      <link href="/2023/04/20/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2023/04/20/%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h2 id="基础部分"><a href="#基础部分" class="headerlink" title="基础部分"></a>基础部分</h2><h3 id="一、数据库概述"><a href="#一、数据库概述" class="headerlink" title="一、数据库概述"></a>一、数据库概述</h3><h4 id="1、相关概念"><a href="#1、相关概念" class="headerlink" title="1、相关概念"></a>1、相关概念</h4><ul><li>数据库：存储数据的仓库。简称：DB。</li><li>数据库管理系统：管理数据库的软件，即：可以对数据库中的数据进行增删改查、添加数据库等操作的软件。简称：DBMS。</li><li>SQL：操作和管理关系型数据库的编程语言。</li><li>关系型数据库(RDBMS)：用表进行数据存储的数据库就叫关系型数据库，该表称为二维表。</li></ul><h4 id="2、MySQL数据库安装"><a href="#2、MySQL数据库安装" class="headerlink" title="2、MySQL数据库安装"></a>2、MySQL数据库安装</h4><h5 id="A-下载"><a href="#A-下载" class="headerlink" title="A.下载"></a>A.下载</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://downloads.mysql.com/archives/community/</span><br></pre></td></tr></table></figure><p>​选择需要的版本和电脑位数进行下载，不要下载带debug<img src="/imgs/image-20220913153802678.png" alt="image-20220913153802678"></p><h5 id="B-安装"><a href="#B-安装" class="headerlink" title="B.安装"></a>B.安装</h5><ol><li>对下载好的安装包进行解压</li></ol><h5 id="C-配置"><a href="#C-配置" class="headerlink" title="C.配置"></a>C.配置</h5><h6 id="①配置环境变量"><a href="#①配置环境变量" class="headerlink" title="①配置环境变量"></a>①配置环境变量</h6><p>​a.复制当前MySQL的安装目录。</p><img src="/imgs/image-20230423204928910.png" alt="image-20230423204928910" style="zoom:80%;" /><p>​b.新建一个环境变量</p><p><img src="/imgs/image-20220913155201538.png" alt="image-20220913155201538"></p><img src="/imgs/image-20230423205118768.png" alt="image-20230423205118768" style="zoom: 67%;" /><p>​c.对系统变量中的Path进行编辑</p><p><img src="/imgs/image-20230423205144683.png" alt="image-20230423205144683"></p><h6 id="②配置配置文件信息"><a href="#②配置配置文件信息" class="headerlink" title="②配置配置文件信息"></a>②配置配置文件信息</h6><p>​a.在MySQL的安装目录下新建一个my.ini文件，文件内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[mysql]</span><br><span class="line">default-character-set=utf8</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">character-set-server=utf8</span><br><span class="line">default-storage-engine=INNODB</span><br><span class="line">sql_mode=STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION</span><br></pre></td></tr></table></figure><img src="/imgs/image-20230423205206465.png" alt="image-20230423205206465" style="zoom:67%;" /><p>​b.初始化MySQL</p><p>​在c盘下打开该文件：</p><p><img src="/imgs/image-20220913161859039.png" alt="image-20220913161859039"></p><p>​在该文件下输入：cmd，然后以管理员身份运行</p><p><img src="/imgs/image-20220913162003905.png" alt="image-20220913162003905"></p><p>​将下面的命令复制到cmd中并运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqld --initialize-insecure</span><br></pre></td></tr></table></figure><p>​c.注册MySQL服务</p><p>​复制下面命令，到刚才的cmd中，并运行，接着输入：net start mysql回车，启动MySQL。至此MySQL已经按照完成。</p><p><img src="/imgs/image-20220913163328013.png" alt="image-20220913163328013"></p><h5 id="D-修改MySQL默认的用户名和密码"><a href="#D-修改MySQL默认的用户名和密码" class="headerlink" title="D.修改MySQL默认的用户名和密码"></a>D.修改MySQL默认的用户名和密码</h5><p>​在刚才的cmd中，输入下面命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysqladmin -u root password 1234</span><br><span class="line">//其中root为用户名，1234为用户密码</span><br></pre></td></tr></table></figure><p>如果不懂可以看下面的网站：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://blog.csdn.net/weixin_43214644/article/details/126678750?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%E9%BB%91%E9%A9%ACMySQL%E9%85%8D%E7%BD%AE&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-5-126678750.142^v47^new_blog_pos_by_title,201^v3^add_ask&amp;spm=1018.2226.3001.4187</span><br></pre></td></tr></table></figure><h5 id="E-启动与停止"><a href="#E-启动与停止" class="headerlink" title="E.启动与停止"></a>E.启动与停止</h5><p>​在运行处输入：services.msc — &gt; 找到MySQL —&gt; 右键启动\停止</p><p><img src="/imgs/image-20220916104719913.png" alt="image-20220916104719913"></p><hr><h4 id="3、MySQL数据模型"><a href="#3、MySQL数据模型" class="headerlink" title="3、MySQL数据模型"></a>3、MySQL数据模型</h4><p>​<img src="/imgs/image-20220913172745180.png" alt="image-20220913172745180"></p><p>​在数据库管理系统中，我们可以创建多个数据库（就相当于在硬盘中创建多个文件夹），在数据库里我们可以创建多个数据表（就相当于在硬盘中的那个数据库文件夹下创建多个文件），表中又可以有多条数据（在硬盘中数据也相当于文件）。</p><h4 id="4、Navicat使用"><a href="#4、Navicat使用" class="headerlink" title="4、Navicat使用"></a>4、Navicat使用</h4><p>​Navicat是一款操作MySQL的图形化界面软件。</p><h5 id="A-使用"><a href="#A-使用" class="headerlink" title="A.使用"></a>A.使用</h5><p>​打开navicat点击左上角的连接，将navicat连接到电脑的MySQL。</p><p><img src="/imgs/image-20220914133237052.png" alt="image-20220914133237052"></p><h6 id="①新建数据库"><a href="#①新建数据库" class="headerlink" title="①新建数据库"></a>①新建数据库</h6><p>​<img src="/imgs/image-20220914140226747.png" alt="image-20220914140226747"></p><p>​对上面的图标右击，新建数据库，字符集选UTF-8。</p><h6 id="②修改表的数据"><a href="#②修改表的数据" class="headerlink" title="②修改表的数据"></a>②修改表的数据</h6><p>​选中要修改的表 –&gt; 右键 –&gt; 设计表 –&gt; 直接对要修改的内容进行修改即可</p><h6 id="③编写SQL语句"><a href="#③编写SQL语句" class="headerlink" title="③编写SQL语句"></a>③编写SQL语句</h6><p>​点击顶部中查询图标 –&gt; 新建查询 –&gt; 编写SQL语句 –&gt; 编写完，选中你要执行的语句，右键运行即可</p><h4 id="5、MySQL命名规范"><a href="#5、MySQL命名规范" class="headerlink" title="5、MySQL命名规范"></a>5、MySQL命名规范</h4><ol><li><p>只能使用这些命名：必须只能包含 A–Z, a–z, 0–9, _ 。</p></li><li><p>同一个MySQL软件中，数据库不能同名；同一个库中，表不能重名；同一个表中，字段不能重名</p></li><li><p>必须保证你的字段没有和保留字、数据库系统或常用方法冲突。如果坚持使用，请在SQL语句中使用&#96;（着重号）引起来。如：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#其中order使用``飘号，因为order和系统关键字或系统函数名等预定义标识符重名了</span><br><span class="line">CREATE TABLE `order`();</span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="二、SQL"><a href="#二、SQL" class="headerlink" title="二、SQL"></a>二、SQL</h3><p>​SQL是一门操作关系型数据库的编程语言。</p><h4 id="1、SQL通用语法"><a href="#1、SQL通用语法" class="headerlink" title="1、SQL通用语法"></a>1、SQL通用语法</h4><ul><li><p>SQL语句可以单行或多行书写，以分号结尾。</p></li><li><p>MySQL数据库的SQL语句不区分大小写，但建议关键字采用大写形式。</p></li><li><p>注释：</p><ul><li><p>单行注释：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 方式一:注意注释内容前的空格不要省略 */</span></span><br><span class="line"><span class="comment">-- 注释内容</span></span><br><span class="line"><span class="comment">/* 方式二：该方式是MySQL特有的方式*/</span></span><br><span class="line">#注释内容</span><br></pre></td></tr></table></figure></li><li><p>多行注释：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">注释内容</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="2、SQL分类"><a href="#2、SQL分类" class="headerlink" title="2、SQL分类"></a>2、SQL分类</h4><ul><li>DDL：定义数据库，表等</li><li>DML：对表中的数据进行增删改</li><li>DQL：对表中的数据进行查询</li><li>DCL：创建数据库用户、控制数据库的访问权限</li></ul><h4 id="3、DDL"><a href="#3、DDL" class="headerlink" title="3、DDL"></a>3、DDL</h4><h5 id="A-操作数据库"><a href="#A-操作数据库" class="headerlink" title="A.操作数据库"></a>A.操作数据库</h5><h6 id="①查询"><a href="#①查询" class="headerlink" title="①查询"></a>①查询</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW DATABASES;</span><br></pre></td></tr></table></figure><p>​查询当前数据库管理系统下有多少个数据库。MySQL自带四个数据库，分别为：</p><ul><li>information_schema（存储MySQL中的表和库信息，该数据库使用视图进行数据存储，而视图属于逻辑，所以在磁盘中没有对应的文件夹）</li><li>mysql（存储管理权限的数据库）</li><li>performance_schema（有关性能的数据库）</li><li>sys（与系统有关的数据库）</li></ul><h6 id="②创建数据库"><a href="#②创建数据库" class="headerlink" title="②创建数据库"></a>②创建数据库</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE [IF NOT EXISTS] 数据库名 [DEFAULT CHARSET 字符集] [COLLATE 排序规则];</span><br></pre></td></tr></table></figure><p>​说明：</p><ul><li>方括号为可选项</li><li>如果写了“IF NOT EXISTS”，则先判断要创建的数据库是否存在，不存在再执行创建操作。</li><li>DEFAULT CHARSET ：指定该数据库使用什么字符集（推荐使用utf8mb4），不写则使用默认的字符集</li><li>COLLATE：用于规定字符串的排序规则。<ul><li>MySQL8.0以下版本，默认的CHARSET是Latin1，默认的COLLATE是latin1_swedish_ci。</li><li>从mysql8.0开始，默认的CHARSET已经改为了utf8mb4，默认的COLLATE改为了utf8mb4_0900_ai_ci。</li></ul></li></ul><h6 id="③删除数据库"><a href="#③删除数据库" class="headerlink" title="③删除数据库"></a>③删除数据库</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP DATABASE [IF EXISTS] 数据库名;</span><br></pre></td></tr></table></figure><p>​说明：</p><ul><li>方括号为可选项</li><li>如果写了“IF EXISTS”，先判断要删除的数据库存不存在，存在再执行删除操作。</li></ul><h6 id="④使用数据库"><a href="#④使用数据库" class="headerlink" title="④使用数据库"></a>④使用数据库</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#要想对数据库里的数据进行操作，我们得先进入数据库里，使用如下命令：</span><br><span class="line">USE 数据库名;</span><br><span class="line"></span><br><span class="line">#查看当前使用的是哪个数据库</span><br><span class="line">SELECT DATABASE();</span><br></pre></td></tr></table></figure><h5 id="B-操作表"><a href="#B-操作表" class="headerlink" title="B.操作表"></a>B.操作表</h5><h6 id="①查询表"><a href="#①查询表" class="headerlink" title="①查询表"></a>①查询表</h6><p>​查询当前数据库下所有表名称：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW TABLES;</span><br></pre></td></tr></table></figure><p>​查询表的结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DESC 表名称;</span><br></pre></td></tr></table></figure><p>​查询指定表的建表语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW CREATE TABLE 表名;</span><br></pre></td></tr></table></figure><p>​注意：要想执行上述操作，得先进入相应的数据库中。</p><h6 id="②创建表"><a href="#②创建表" class="headerlink" title="②创建表"></a>②创建表</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名 (</span><br><span class="line">字段1 数据类型1 [COMMENT 字段1注释],</span><br><span class="line">字段2 数据类型2 [COMMENT 字段2注释],</span><br><span class="line">....</span><br><span class="line">字段n 数据类型n [COMMENT 字段n注释]</span><br><span class="line">)[COMMENT 表注释];</span><br><span class="line">-- 这里的注释要用单引号括起来。</span><br><span class="line">/* 字段就相当于表中的列 */</span><br></pre></td></tr></table></figure><p>​注意：最后一行末尾，不能加逗号。</p><h6 id="③删除表"><a href="#③删除表" class="headerlink" title="③删除表"></a>③删除表</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE [IF EXISTS] 表名;</span><br></pre></td></tr></table></figure><ul><li>括号内容为可选项。</li><li>如果选了IF EXISTS ，则先判断要删除的表是否存在，存在才进行删除操作。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TRUNCATE TABLE 表名;</span><br></pre></td></tr></table></figure><ul><li>删除指定表，并重新创建该表，原表中的结构保留了下来。</li><li>不建议使用。</li></ul><h6 id="④修改表"><a href="#④修改表" class="headerlink" title="④修改表"></a>④修改表</h6><p> a.向表中添加字段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 ADD 字段名 类型(长度) [COMMENT 注释] [约束];</span><br></pre></td></tr></table></figure><p>b.修改字段的数据类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 MODIFY 字段名 新数据类型(长度);</span><br></pre></td></tr></table></figure><p>c.修改字段名和字段类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 CHANGE 旧字段名 新字段名 数据类型(长度) [COMMENT 注释] [约束];</span><br></pre></td></tr></table></figure><p>d.修改字段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 DROP 字段名;</span><br></pre></td></tr></table></figure><p>e.修改表名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 RENAME TO 新表名;</span><br></pre></td></tr></table></figure><h4 id="4、DML"><a href="#4、DML" class="headerlink" title="4、DML"></a>4、DML</h4><p>​对表中的数据进行操作。</p><h5 id="A-添加数据"><a href="#A-添加数据" class="headerlink" title="A.添加数据"></a>A.添加数据</h5><p><img src="/imgs/image-20220914144613242.png" alt="image-20220914144613242"></p><p>​注意：</p><ul><li>插入数据时，字符串和日期型数据应该包含在引号当中。</li></ul><h5 id="B-修改数据"><a href="#B-修改数据" class="headerlink" title="B.修改数据"></a>B.修改数据</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE 表名 SET 列1 = 值1,列2 = 值2,... [WHERE 条件];</span><br></pre></td></tr></table></figure><p>​说明：</p><ul><li>修改语句中的条件语句为可选项，如果不加条件，则将所有数据都修改；添加，则修改符合条件的数据。</li></ul><h5 id="C-删除数据"><a href="#C-删除数据" class="headerlink" title="C.删除数据"></a>C.删除数据</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM 表名 [WHERE 条件];</span><br></pre></td></tr></table></figure><p>​说明：</p><ul><li>条件语句是可选项。如果不加条件语句，则将所有数据都删除。如果添加条件语句，则删除符合条件的数据。</li><li>删除的是一整行数据。</li><li>DELETE语句不能删除某一个字段的值(可以使用UPDATE)</li></ul><h4 id="5、DQL"><a href="#5、DQL" class="headerlink" title="5、DQL"></a>5、DQL</h4><p>​对表中的数据进行查询操作。</p><p>​查询语法：（编写时各关键字的顺序不能调换）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">字段列表</span><br><span class="line">FROM</span><br><span class="line">表名列表</span><br><span class="line">WHERE</span><br><span class="line">条件列表</span><br><span class="line">GROUP BY</span><br><span class="line">分组字段</span><br><span class="line">HAVING</span><br><span class="line">分组后条件</span><br><span class="line">ORDER BY</span><br><span class="line">排序字段</span><br><span class="line">LIMIT</span><br><span class="line">分页限定</span><br></pre></td></tr></table></figure><h5 id="A-基础查询"><a href="#A-基础查询" class="headerlink" title="A.基础查询"></a>A.基础查询</h5><h6 id="①查询多个字段"><a href="#①查询多个字段" class="headerlink" title="①查询多个字段"></a>①查询多个字段</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段1,字段2,字段3... FROM 表名;</span><br><span class="line">#如果想查询所有字段，则：</span><br><span class="line">SELECT * FROM 表名; -- 不建议使用，因为有些公司不给用</span><br></pre></td></tr></table></figure><h6 id="②去除重复记录"><a href="#②去除重复记录" class="headerlink" title="②去除重复记录"></a>②去除重复记录</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT 字段列表 FROM 表名;</span><br></pre></td></tr></table></figure><p>​<strong>注意</strong>：DISTINCT 需要放到所有列名的前面，不然会报错。</p><p><img src="/imgs/image-20220914154829174.png" alt="image-20220914154829174"></p><h6 id="③给字段起别名"><a href="#③给字段起别名" class="headerlink" title="③给字段起别名"></a>③给字段起别名</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段1 AS 别名1,字段2 AS 别名2,字段3... FROM 表名;</span><br><span class="line"># AS可以省略，但省略后原始字段名与别名之间得至少有一个空格的间距</span><br><span class="line"># 别名要用单引号包起来</span><br></pre></td></tr></table></figure><h5 id="B-条件查询-WHERE"><a href="#B-条件查询-WHERE" class="headerlink" title="B.条件查询(WHERE)"></a>B.条件查询(WHERE)</h5><h6 id="①格式"><a href="#①格式" class="headerlink" title="①格式"></a>①格式</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表名 WHERE 条件列表;</span><br></pre></td></tr></table></figure><h6 id="②SQL中的条件"><a href="#②SQL中的条件" class="headerlink" title="②SQL中的条件"></a>②SQL中的条件</h6><p><img src="/imgs/image-20220914163900598.png" alt="image-20220914163900598"></p><p>​<strong>说明</strong>：</p><ul><li>日期也可以比较大小，即可以使用：&gt;、&lt;、&gt;&#x3D;、between and等</li><li>null值的比较不能使用 &#x3D; 或  !&#x3D; 。需要使用 is 或 is not 进行比较。</li></ul><h6 id="③应用例子"><a href="#③应用例子" class="headerlink" title="③应用例子"></a>③应用例子</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#查询年龄大于等于20并且小于等于30的学生信息</span><br><span class="line">SELECT * FROM student WHERE age &gt;= 20 AND age &lt;= 30;-- 方式一：</span><br><span class="line">SELECT * FROM student WHERE age BETWEEN 20 AND 30;-- 方式二，包含20、30</span><br><span class="line"></span><br><span class="line">#查询入学日期在&#x27;1998-09-01&#x27; 到 &#x27;1999-09-01&#x27;之间的学生信息</span><br><span class="line">SELECT * FROM student WHERE hire_date BETWEEN &#x27;1998-09-01&#x27; AND &#x27;1999-09-01&#x27;;</span><br><span class="line">SELECT * FROM student WHERE hire_date &gt;= &#x27;1998-09-01&#x27; AND hire_date &lt;= &#x27;1999-09-01&#x27;;</span><br><span class="line"></span><br><span class="line">#查询年龄等于18岁或者年龄等于20岁或者年龄等于22岁的学生信息</span><br><span class="line">SELECT * FROM student WHERE age =18 OR age = 20 OR age = 22;</span><br><span class="line">SELECT * FROM student WHERE age IN (18,20,22);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/imgs/image-20220914171639743.png" alt="image-20220914171639743"></p><h5 id="C-排序查询-ORDER-BY"><a href="#C-排序查询-ORDER-BY" class="headerlink" title="C.排序查询(ORDER BY)"></a>C.排序查询(ORDER BY)</h5><h6 id="①格式-1"><a href="#①格式-1" class="headerlink" title="①格式"></a>①格式</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表名 ORDER BY 排序字段名1 [排序方式1],排序字段名2 [排序方式2] …;</span><br></pre></td></tr></table></figure><p>​按照给定的字段进行排序。排序方式有两种：ASC(升序)、DESC(降序)。当没有显示指明用哪种排序方式时，默认采用ASC。</p><h6 id="②说明"><a href="#②说明" class="headerlink" title="②说明"></a>②说明</h6><p>​如果有多个排序条件，当前边的条件值一样时，才会根据第二条件进行排序。</p><h5 id="D-分组查询-GROUP-BY"><a href="#D-分组查询-GROUP-BY" class="headerlink" title="D.分组查询(GROUP BY)"></a>D.分组查询(GROUP BY)</h5><h6 id="①聚合函数"><a href="#①聚合函数" class="headerlink" title="①聚合函数"></a>①聚合函数</h6><p>​<strong>概念</strong>：将一列数据作为一个整体，进行纵向计算</p><p>​<strong>格式</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 聚合函数名(列名) FROM 表;</span><br></pre></td></tr></table></figure><p>​<strong>聚合函数分类</strong>：</p><p><img src="/imgs/image-20220914180110753.png" alt="image-20220914180110753"></p><p>​<strong>注意</strong>：<strong>null 值不参与所有聚合函数运算</strong></p><p>​<strong>说明</strong>：</p><ol><li><p>COUNT()：括号里只能放<strong>主键</strong> 或 ***** ，不然统计出来的数据不准确。</p><p> COUNT(*)的含义：计算该表中有多少行数据。</p></li></ol><h6 id="②分组查询"><a href="#②分组查询" class="headerlink" title="②分组查询"></a>②分组查询</h6><p>​<strong>概念</strong>：根据某个字段A进行分组，字段值相同的将被分到一起。</p><p>​<strong>格式</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表名 [WHERE 分组前条件限定] GROUP BY 分组字段名 [HAVING 分组后条件过滤];</span><br><span class="line">/*</span><br><span class="line">HVAING 里只能使用：</span><br><span class="line">常数、聚合函数、GROUP BY指定的列名</span><br><span class="line">如果使用其它东西会报错</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>​<strong>注意</strong>：分组后，查询的字段为聚合函数和分组字段，查询其他字段无任何意义。</p><p>​<strong>WHERE 和 HAVING区别</strong>：</p><ul><li>执行时机不一样：WHERE是分组之前进行限定，不满足WHERE条件，则不参与分组，而HAVING是分组之后对结果进行过滤。</li><li>判断的条件不一样：WHERE里不能写聚合函数，HAVING可以。<ul><li>因为执行顺序为：WHERE &gt; 聚合函数 &gt; HAVING</li></ul></li></ul><h5 id="E-分页查询-LIMIT"><a href="#E-分页查询-LIMIT" class="headerlink" title="E.分页查询(LIMIT)"></a>E.分页查询(LIMIT)</h5><h6 id="①语法"><a href="#①语法" class="headerlink" title="①语法"></a>①语法</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表名 LIMIT  起始索引 , 查询条目数;</span><br></pre></td></tr></table></figure><h6 id="②说明-1"><a href="#②说明-1" class="headerlink" title="②说明"></a>②说明</h6><ul><li>起始索引：从0开始，表中第一条数据的索引为0。</li><li>起始索引 &#x3D; （当前页码数 - 1）* 每页显示的条数。</li><li>如果查询的是第一页数据，起始索引可以省略。</li><li>如果查询条目数大于实际表中的条目数，是不会报错的。</li><li>limit是MySQL特有的关键字。<ul><li>Oracle分页查询使用rownumber。</li><li>SQLServer分页查询使用top。</li></ul></li></ul><h5 id="F-DQL语句执行顺序"><a href="#F-DQL语句执行顺序" class="headerlink" title="F.DQL语句执行顺序"></a>F.DQL语句执行顺序</h5><img src="C:\Users\橙子\AppData\Roaming\Typora\typora-user-images\image-20220916215902346.png" alt="image-20220916215902346" style="zoom: 67%;" /><h4 id="6、DCL"><a href="#6、DCL" class="headerlink" title="6、DCL"></a>6、DCL</h4><h5 id="①概念"><a href="#①概念" class="headerlink" title="①概念"></a>①概念</h5><ol><li><p>DCL是用来管理用户和数据库访问权限的SQL语句。即：用来规定哪些用户可以访问数据库服务器了，用户可以访问哪个数据库。</p></li><li><p>MySQL中我们用 “用户名” 和 主机地址 来唯一标识一个用户。主机地址规定了当前用户只能通过哪个地址来访问当前服务器。如：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Host: localhost ;user： root</span><br><span class="line">//代表root用户只能通过localhost这个主机地址来访问当前数据库服务器。</span><br></pre></td></tr></table></figure></li></ol><h5 id="②DCL–管理用户"><a href="#②DCL–管理用户" class="headerlink" title="②DCL–管理用户"></a>②DCL–管理用户</h5><p>作用：规定哪些用户可以登录当前数据库管理系统。</p><h6 id="a-查询用户"><a href="#a-查询用户" class="headerlink" title="a.查询用户"></a>a.查询用户</h6><p>​查看当前数据库管理系统有哪些用户及其用户信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">USE mysql;</span><br><span class="line">SELECT * FROM user;</span><br></pre></td></tr></table></figure><h6 id="b-创建用户"><a href="#b-创建用户" class="headerlink" title="b.创建用户"></a>b.创建用户</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER &#x27;用户名&#x27;@&#x27;主机名&#x27; IDENTIFIED BY &#x27;用户密码&#x27;;</span><br><span class="line">-- 如果想让用户在任意主机上访问到当前数据库，主机名里写 % 即可。</span><br></pre></td></tr></table></figure><p>​注意：用户创建完后可以访问数据库管理系统，但只能访问information_schema这个数据库。</p><h6 id="c-修改用户密码"><a href="#c-修改用户密码" class="headerlink" title="c.修改用户密码"></a>c.修改用户密码</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER USER &#x27;用户名&#x27;@&#x27;主机名&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;新密码&#x27;;</span><br></pre></td></tr></table></figure><h6 id="d-删除用户"><a href="#d-删除用户" class="headerlink" title="d.删除用户"></a>d.删除用户</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP USER &#x27;用户名&#x27;@&#x27;主机名&#x27;;</span><br></pre></td></tr></table></figure><h5 id="③DCL–权限控制"><a href="#③DCL–权限控制" class="headerlink" title="③DCL–权限控制"></a>③DCL–权限控制</h5><p>​作用：在用户登录数据库管理系统后，他们对数据库中的表有哪些操作权限。</p><p>​MySQL中常见的权限：</p><p><img src="/imgs/image-20220917122022874.png" alt="image-20220917122022874"></p><p><strong>USAGE</strong>：连接（登录）权限，建立一个用户，就会自动授予其usage权限。该权限只能用于数据库登录，不能执行任何操作，且该权限不能被回收，即使使用REVOKE也不能删除用户权限。</p><h6 id="a-查询用户拥有的权限"><a href="#a-查询用户拥有的权限" class="headerlink" title="a.查询用户拥有的权限"></a>a.查询用户拥有的权限</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SHOW GRANTS FOR &#x27;用户名&#x27;@&#x27;主机&#x27;;</span><br><span class="line">/*</span><br><span class="line">如果查询的结果为：GRANT USAGE ON *.* TO &#x27;用户名&#x27;@&#x27;主机&#x27;</span><br><span class="line">代表该用户只有登录数据库管理系统的权限。</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h6 id="b-授予权限"><a href="#b-授予权限" class="headerlink" title="b.授予权限"></a>b.授予权限</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT 权限列表 ON 数据库名.表名 TO &#x27;用户名&#x27;@&#x27;主机名&#x27;;</span><br></pre></td></tr></table></figure><h6 id="c-撤销权限"><a href="#c-撤销权限" class="headerlink" title="c.撤销权限"></a>c.撤销权限</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REVOKE 权限列表 ON 数据库名.表名 FROM &#x27;用户名&#x27;@&#x27;主机名&#x27;;</span><br></pre></td></tr></table></figure><h6 id="d-补充"><a href="#d-补充" class="headerlink" title="d.补充"></a>d.补充</h6><ol><li><p>多个权限之间，使用逗号分隔。</p></li><li><p>授权时，数据库名和表名可以使用 * 进行通配，* 的含义是：所有。如：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GRANT 权限列表 ON *.* TO &#x27;用户名&#x27;@&#x27;主机名&#x27;;-- 所有数据库下的所有表</span><br><span class="line">GRANT 权限列表 ON 数据库名.* TO &#x27;用户名&#x27;@&#x27;主机名&#x27;;-- 某个数据库下的所有表</span><br></pre></td></tr></table></figure></li></ol><h4 id="7、数据库中的数据类型"><a href="#7、数据库中的数据类型" class="headerlink" title="7、数据库中的数据类型"></a>7、数据库中的数据类型</h4><h5 id="A-数值类型"><a href="#A-数值类型" class="headerlink" title="A.数值类型"></a>A.数值类型</h5><table><thead><tr><th align="center">在Java中的对应</th><th align="center">数据类型</th><th align="center">大小</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">byte</td><td align="center">TINYINT</td><td align="center">1 byte</td><td align="center">小整数值</td></tr><tr><td align="center">short</td><td align="center">SMALLINT</td><td align="center">2 byte</td><td align="center">大整数值</td></tr><tr><td align="center"></td><td align="center">MEDIUMINT</td><td align="center">3 byte</td><td align="center">大整数值</td></tr><tr><td align="center">int</td><td align="center">INT或INTEGER</td><td align="center">4 byte</td><td align="center">大整数值</td></tr><tr><td align="center">Long</td><td align="center">BIGINT</td><td align="center">8 byte</td><td align="center">极大整数值</td></tr><tr><td align="center">float</td><td align="center">FLOAT(M,D)</td><td align="center">4byte</td><td align="center">单精度浮点数值</td></tr><tr><td align="center">double</td><td align="center">DOUBLE(M,D)</td><td align="center">8 byte</td><td align="center">双精度浮点数值</td></tr><tr><td align="center"></td><td align="center">DECIMAL(M,D)</td><td align="center"></td><td align="center">小数值</td></tr></tbody></table><p>​说明：</p><ul><li><p>DECIMAL是以字符串的形式存储的，以保证存储更高精度的数据</p></li><li><p>DOUBLE、FLOAT、DOUBLE：在使用该类数据类型时，要指明其总长度M和小数点后保留的位数D</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">score DOUBLE(5,2);</span><br><span class="line">/* 数据总长度为5，小数点后保留2位 */</span><br></pre></td></tr></table></figure></li><li><p>补充：数值型数据可以选择有符号和无符号的形式，它们的区别是：表示的数字范围不一样。<img src="/imgs/image-20220916133428507.png" alt="image-20220916133428507"></p><p>  要想使用无符号（不包括负数部分），需要在数据类型后面加上UNSIGNED。</p></li></ul><h5 id="B-日期时间类型"><a href="#B-日期时间类型" class="headerlink" title="B.日期时间类型"></a>B.日期时间类型</h5><table><thead><tr><th align="center">数据类型</th><th align="center">大小</th><th align="center">范围</th><th align="center">格式</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">DATE</td><td align="center">3</td><td align="center">1000-01-01 至 9999-12-31</td><td align="center">YYYY-MM-DD</td><td align="center">年月日</td></tr><tr><td align="center">TIME</td><td align="center">3</td><td align="center">-838：59：59 至 838：59：59</td><td align="center">HH:MM:SS</td><td align="center">时分秒</td></tr><tr><td align="center">YEAR</td><td align="center">1</td><td align="center">1901 至 2155</td><td align="center">YYYY</td><td align="center">年份</td></tr><tr><td align="center">DATETIME</td><td align="center">8</td><td align="center"></td><td align="center">YYYY-MM-DD HH:MM:SS</td><td align="center">年月日时分秒</td></tr><tr><td align="center">TIMESTAMP</td><td align="center">4</td><td align="center">1970-01-01 00:00:00 至 2038-01-19 03:14:07</td><td align="center">YYYY-MM-DD HH:MM:SS</td><td align="center">时间戳</td></tr></tbody></table><p>​说明：</p><ul><li><p>TIMESTAMP：少用，当某个字段声明为这种数据类型时，如果没有赋值，系统就会赋默认的时间值。</p><ul><li><p>给DATE类型数据赋值时，用单引号将数据括起来，年月日之间用“ - ”隔开，如：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;1949-10-1&#x27;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="C-字符串类型"><a href="#C-字符串类型" class="headerlink" title="C.字符串类型"></a>C.字符串类型</h5><p><img src="/imgs/image-20220914100827037.png" alt="image-20220914100827037"></p><p>​最常用的是CHAR、VARCHAR。赋值时，数据用单引号或双引号括起来。</p><h6 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h6><p>​①使用CHAR、VARCHAR时都得指明其最大的存放长度，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name CHAR(10);/* 最多存放10个汉字或10个字母 */</span><br><span class="line">name VARCHAR(10);/* 最多存放10个汉字或10个字母 */</span><br></pre></td></tr></table></figure><p>​②CHAR与VARCHAR的不同</p><ul><li>CAHR：不会根据实际存放数据的大小来决定最终存放空间大小，如：存放数据“张三”，其分配的空间仍为10个字符。其占用2个字符，剩余空间用空格补齐。</li><li>VARCHAR：会根据实际存放数据的大小来决定最终存放空间大小，存放数据“张三”，其分配的空间为2个字符。</li></ul><p>​③总结：</p><ul><li>CHAR：存储性能高，浪费空间。</li><li>VARCHAR：存储性能低，节约空间。</li><li>如果字符串的大小确定，我们使用CHAR；不确定，则使用VARCHAR。</li></ul><hr><h3 id="三、函数"><a href="#三、函数" class="headerlink" title="三、函数"></a>三、函数</h3><h4 id="①概念-1"><a href="#①概念-1" class="headerlink" title="①概念"></a>①概念</h4><p>​函数：与Java中的函数是一个意思</p><h4 id="②MySQL中常见的内置函数"><a href="#②MySQL中常见的内置函数" class="headerlink" title="②MySQL中常见的内置函数"></a>②MySQL中常见的内置函数</h4><h5 id="A-字符串函数"><a href="#A-字符串函数" class="headerlink" title="A.字符串函数"></a>A.字符串函数</h5><p><img src="/imgs/image-20220917133534020.png" alt="image-20220917133534020"></p><p>​注意</p><ol><li>SUBSTRING函数中的起始位置是从1开始的，不是从0开始。</li><li>LPAD(str,n,pad)：如果str的长度大于len指定的值，则截取str到len指定的长度。</li><li>RPAD(str,n,pad)：同理。</li></ol><h6 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#由于业务需求变更，企业员工的工号，统一为5位，目前不足5位数的全部在前面补0。比如：1号员工的工号应该为：00001。</span><br><span class="line">UPDATE emp SET workno = lpad(workno,5,&#x27;0&#x27;);</span><br></pre></td></tr></table></figure><h5 id="B-数值函数"><a href="#B-数值函数" class="headerlink" title="B.数值函数"></a>B.数值函数</h5><p><img src="/imgs/image-20220917141038649.png" alt="image-20220917141038649"></p><h6 id="①补充"><a href="#①补充" class="headerlink" title="①补充"></a>①补充</h6><ol><li><p>向上取整：只要有小数，其结果就为：去除小数后再加1。</p></li><li><p>向下取整：只要有小数，其结果就为：取整数部分。</p></li></ol><h6 id="②例子"><a href="#②例子" class="headerlink" title="②例子"></a>②例子</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#随机生成一个六位的数</span><br><span class="line">SELECT LPAD(FLOOR(RAND() * 1000000),6,&#x27;0&#x27;);</span><br></pre></td></tr></table></figure><h5 id="C-日期函数"><a href="#C-日期函数" class="headerlink" title="C.日期函数"></a>C.日期函数</h5><p><img src="/imgs/image-20220917144159996.png" alt="image-20220917144159996"></p><h6 id="①说明"><a href="#①说明" class="headerlink" title="①说明"></a>①说明</h6><ol><li><p>DATE_ADD(date,INTERVAL expr type)：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">INTERVAL 是固定写法</span><br><span class="line">expr：添加的值，值为正数，代表日期向前移，负数表示日期向后移；</span><br><span class="line">type：添加值的类型，可以为DAY、MONTH、YEAR、hour、minute、second。</span><br><span class="line">*/</span><br><span class="line">#在当前时间上加上天</span><br><span class="line">SELECT DATE_ADD(NOW(),INTERVAL 7 DAY);</span><br></pre></td></tr></table></figure></li><li><p>datediff(date1,date2)：返回的是这两个日期之间相差的天数，其实现方式是：用date1 - date2。</p></li></ol><h6 id="②补充"><a href="#②补充" class="headerlink" title="②补充"></a>②补充</h6><ul><li><p>DATE_FORMAT(日期,表达式)</p><ul><li><p>用于格式化日期，返回用户想要的日期格式。</p></li><li><p>表达式为：</p>  <img src="/imgs/image-20230423204614405.png" alt="image-20230423204614405" style="zoom:80%;" /></li><li><p>例子：</p><ul><li><img src="/imgs/image-20230423204633980.png" alt="image-20230423204633980" style="zoom:80%;" /></li><li><img src="/imgs/image-20230423204649320.png" alt="image-20230423204649320" style="zoom:80%;" /></li></ul></li></ul></li></ul><h5 id="D-流程函数"><a href="#D-流程函数" class="headerlink" title="D.流程函数"></a>D.流程函数</h5><p><img src="/imgs/image-20220917164820707.png" alt="image-20220917164820707"></p><p>​说明：</p><ol><li><p>IF(value,t,f)：value为条件表达式。类似于三元运算符。</p></li><li><p>IFNULL(value1,value2)：value1为NULL，返回value2，注意：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IFNULL(&#x27;&#x27;,123);-- value1的值不是NULL</span><br></pre></td></tr></table></figure></li><li><p>上表中的第三个函数类似于多重if。</p></li><li><p>上表中的第四个函数类似于switch…case…。</p></li></ol><p>练习：</p><p>​①</p><p><img src="/imgs/image-20220917172207506.png" alt="image-20220917172207506"></p><p>​②根据不同的分数段来输出不同的等级</p><p><img src="/imgs/image-20220917172349007.png" alt="image-20220917172349007"></p><h3 id="四、约束"><a href="#四、约束" class="headerlink" title="四、约束"></a>四、约束</h3><h4 id="①概念-2"><a href="#①概念-2" class="headerlink" title="①概念"></a>①概念</h4><p>​约束是作用在字段上的，用于对字段的值加以限制。</p><h4 id="②约束的分类"><a href="#②约束的分类" class="headerlink" title="②约束的分类"></a>②约束的分类</h4><ul><li>非空约束(限制该字段的数据不能为NULL)</li><li>唯一约束(保证该字段的所有数据都是唯一、不可重复的)</li><li>主键约束(主键是一行数据的唯一标识，要求非空且唯一)</li><li>检查约束（MySQL不支持检查约束，我们需要在Java中进行检查约束）</li><li>默认约束(保存数据时，如果未指定该字段的值，则采用默认值)</li><li>外键约束(用来让两张表的数据之间建立连接)</li></ul><p>​补充说明：</p><ol><li>一个字段可以有多个约束，它们之间<strong>用空格隔开</strong>。</li><li>约束使用在创建表的时候，写在每个字段的数据类型后面。</li></ol><h5 id="A-主键约束"><a href="#A-主键约束" class="headerlink" title="A.主键约束"></a>A.主键约束</h5><p>​关键字：<strong>PRIMARY KEY</strong></p><p>​说明：</p><ol><li>被声明为PRIMARY KEY的字段，该字段的值只能是非空且唯一的。</li><li>一张表中只能有一个主键。</li></ol><h5 id="B-唯一约束"><a href="#B-唯一约束" class="headerlink" title="B.唯一约束"></a>B.唯一约束</h5><p>​关键字：<strong>UNIQUE</strong></p><p>​说明：被声明为UNIQUE的字段，其值不能重复，最多只有一个非空记录。</p><h5 id="C-非空约束"><a href="#C-非空约束" class="headerlink" title="C.非空约束"></a>C.非空约束</h5><p>​关键字：<strong>NOT NULL</strong></p><p>​说明：被声明为NOT NULL的字段，其值不能为NULL，即必须有值。</p><h5 id="D-默认约束"><a href="#D-默认约束" class="headerlink" title="D.默认约束"></a>D.默认约束</h5><p>​关键字：<strong>DEFAULT</strong></p><p>​说明：被声明为DEFAULT的字段，如果没有给其赋值，其值为默认值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE student(</span><br><span class="line">    name VARCHAR(4), </span><br><span class="line">score int DEFAULT 0</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO student (name) VALUES (&#x27;Tom&#x27;);-- Tom的成绩默认值为0</span><br><span class="line">INSERT INTO student (name，score) VALUES (&#x27;Jack&#x27;,NULL);-- Jack的成绩为NULL，不是0</span><br></pre></td></tr></table></figure><h5 id="E-检查约束-MySQL8-0-16版本之后出现"><a href="#E-检查约束-MySQL8-0-16版本之后出现" class="headerlink" title="E.检查约束(MySQL8.0.16版本之后出现)"></a>E.检查约束(MySQL8.0.16版本之后出现)</h5><p>​保证字段值满足某一个或多个条件。</p><p>​关键字为：CHECK</p><p>​格式为：CHECK(检查条件)</p><h5 id="F-外键约束"><a href="#F-外键约束" class="headerlink" title="F.外键约束"></a>F.外键约束</h5><h6 id="①作用"><a href="#①作用" class="headerlink" title="①作用"></a>①作用</h6><p>​让表与表之间产生物理上的关系。</p><h6 id="②添加约束"><a href="#②添加约束" class="headerlink" title="②添加约束"></a>②添加约束</h6><ul><li><p>建表时添加约束</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">   列名 数据类型,</span><br><span class="line">   …</span><br><span class="line">   [CONSTRAINT] [外键名称] FOREIGN KEY(外键列名) REFERENCES 主表(主表列名) ON DELETE 行为 ON UPDATE 行为</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>在已有的表基础上添加约束</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 建完表后添加外键约束</span><br><span class="line">ALTER TABLE 表名 ADD [CONSTRAINT 外键名称] FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称) ON UPDATE 行为 ON DELETE 行为;</span><br></pre></td></tr></table></figure><p>  行为：</p><p>  <img src="/imgs/image-20220917202626617.png" alt="image-20220917202626617"></p><p>  其中：NO ACTION和RESTRICT为<strong>默认</strong>设置。</p></li></ul><h6 id="③删除约束"><a href="#③删除约束" class="headerlink" title="③删除约束"></a>③删除约束</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 DROP FOREIGN KEY 外键名称;</span><br></pre></td></tr></table></figure><h6 id="④说明"><a href="#④说明" class="headerlink" title="④说明"></a>④说明</h6><ol><li><p>创建(CREATE)表时就指定外键约束的话，先创建主表，再创建从表。</p></li><li><p>当主表的记录被从表参照时，主表的记录将不允许删除，如果要删除数据，需要先删除从表中依赖该记录的数据，然后才可以删除主表的数据。</p></li></ol><h4 id="③-自增长操作"><a href="#③-自增长操作" class="headerlink" title="③.自增长操作"></a>③.自增长操作</h4><p>​关键字：AUTO_INCREMENT</p><p>​使用要求：被修饰的字段必须是数字类型 且 字段值满足唯一性。</p><p>​举例：</p><p>​当没有指定值 或 赋为NULL 时，都会采用自增的方式进行赋值，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE test(</span><br><span class="line">id INT PRIMARY KEY auto_increment,</span><br><span class="line">name VARCHAR(4) NOT NULL</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO test (name) VALUES (&#x27;Tom&#x27;);</span><br><span class="line">INSERT INTO test (id,name) VALUES (NULL,&#x27;Jack&#x27;);</span><br><span class="line">INSERT INTO test (id,name) VALUES (NULL,&#x27;Mary&#x27;);</span><br><span class="line"></span><br><span class="line">SELECT * FROM test;</span><br></pre></td></tr></table></figure><p>​<img src="/imgs/image-20220915120547387.png" alt="image-20220915120547387"></p><h3 id="五、多表查询"><a href="#五、多表查询" class="headerlink" title="五、多表查询"></a>五、多表查询</h3><h4 id="①多表关系"><a href="#①多表关系" class="headerlink" title="①多表关系"></a>①多表关系</h4><h5 id="A-概述"><a href="#A-概述" class="headerlink" title="A.概述"></a>A.概述</h5><p>​表与表之间主要有三种关系：一对多、多对多、一对一</p><h5 id="B-一对多"><a href="#B-一对多" class="headerlink" title="B.一对多"></a>B.一对多</h5><p>​案例：部门 与 员工的关系</p><p>​实现：在多的一方建立外键，指向一的一方的主键。</p><h5 id="C-多对多"><a href="#C-多对多" class="headerlink" title="C.多对多"></a>C.多对多</h5><p>​案列：学生 与 课程的关系</p><p>​关系：一个学生可以选修多门课程，一门课程也可以供多个学生选择。</p><p>​实现：建立第三张中间表，中间表至少包含两个外键，分别为关联两方主键。</p><p><img src="/imgs/image-20220918102554074.png" alt="image-20220918102554074"></p><h5 id="D-一对一"><a href="#D-一对一" class="headerlink" title="D.一对一"></a>D.一对一</h5><p>​案例：用户 与 用户详情的关系</p><p>​关系：一对一关系，<strong>多用于单表拆分</strong>，将一张表的基础字段放在一张表中，其它详情字段放在另一张表中，以提升效率。</p><p>​实现：在任意一方加入外键，关联另一方的主键，并且设置外键为唯一的(UNIQUE)。</p><h4 id="②多表查询分类"><a href="#②多表查询分类" class="headerlink" title="②多表查询分类"></a>②多表查询分类</h4><p>​多表查询：两张表之间不要求一定存在物理上的联系，换句话说，即使两张表之间没有物理上的联系也可以做多表查询。</p><ol><li>连接查询<ul><li><strong>内连接</strong>：相当于查询A表、B表交集部分数据</li><li><strong>外连接</strong><ol><li>左外连接：查询左表所有数据，以及两张表交集部分数据</li><li>右外连接：查询右表所有数据，以及两张表交集部分数据</li></ol></li><li><strong>自连接</strong>：当前表与自身的连接查询，连接必须使用表别名</li></ul></li><li><strong>子查询</strong></li></ol><hr><h4 id="③内连接"><a href="#③内连接" class="headerlink" title="③内连接"></a>③内连接</h4><p>内连接：对两张表做笛卡尔积，然后再根据WHERE中的条件消除没有意义的笛卡尔积，得到表A，最后再对表A进行其它操作。</p><h5 id="A-内连接查询语法"><a href="#A-内连接查询语法" class="headerlink" title="A.内连接查询语法"></a>A.内连接查询语法</h5><h6 id="①隐式内连接"><a href="#①隐式内连接" class="headerlink" title="①隐式内连接"></a>①隐式内连接</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表1,表2 WHERE 条件;</span><br></pre></td></tr></table></figure><h6 id="②显示内连接"><a href="#②显示内连接" class="headerlink" title="②显示内连接"></a>②显示内连接</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表1 [INNER] JOIN 表2 ON 连接条件;</span><br><span class="line"># INNER关键字可以省略，省不省略结果都一样。</span><br></pre></td></tr></table></figure><p>​</p><h5 id="B-补充"><a href="#B-补充" class="headerlink" title="B.补充"></a>B.补充</h5><ol><li>当表明比较长是，我们可以给表起别名，使用关键字AS(AS可以省略，省略后原表名与别名之间要有空格)。使用表别名之后，就不能再用原表名去调用相应的字段了。</li></ol><h4 id="④外连接"><a href="#④外连接" class="headerlink" title="④外连接"></a>④外连接</h4><h5 id="A-外连接查询语法"><a href="#A-外连接查询语法" class="headerlink" title="A.外连接查询语法"></a>A.外连接查询语法</h5><h6 id="①左外连接"><a href="#①左外连接" class="headerlink" title="①左外连接"></a>①左外连接</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表1 LEFT [OUTER] JOIN 表2 ON 条件...; </span><br></pre></td></tr></table></figure><p>​进行左外连接时，表1作为主表，表2作为副表。表1与表2进行笛卡尔积，根据ON后面的条件消除掉无用的数据，当副表中的数据没有和主表中的数据匹配上，副表自动模拟出NULL与之匹配。</p><h6 id="②右外连接"><a href="#②右外连接" class="headerlink" title="②右外连接"></a>②右外连接</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表1 RIGHT [OUTER] JOIN 表2 ON 条件...; </span><br></pre></td></tr></table></figure><p>​进行右外连接时，表2作为主表，表1作为副表。表1与表2进行笛卡尔积，根据ON后面的条件消除掉无用的数据，当副表中的数据没有和主表中的数据匹配上，副表自动模拟出NULL与之匹配。</p><h5 id="B-说明"><a href="#B-说明" class="headerlink" title="B.说明"></a>B.说明</h5><ol><li>语法中的OUTER关键字可以省略，省略后结果不变。</li><li>左外连接和右外连接可以相互转换。卡发中常用左外连接。</li></ol><h4 id="⑤自连接"><a href="#⑤自连接" class="headerlink" title="⑤自连接"></a>⑤自连接</h4><h5 id="A-自连接查询语法"><a href="#A-自连接查询语法" class="headerlink" title="A.自连接查询语法"></a>A.自连接查询语法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表A 别名A JOIN 表A 别名B ON 条件...;</span><br></pre></td></tr></table></figure><h5 id="B-说明-1"><a href="#B-说明-1" class="headerlink" title="B.说明"></a>B.说明</h5><ol><li><p>自连接必须指明表的别名，不然报错。</p></li><li><p>可以使用 内连接 或 外连接 实现自连接如：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#由于表1和表2都是同一张表，所以这里的内连接也就属于自连接了。</span><br><span class="line">SELECT a.name,b.name FROM emp AS a ,emp AS b WHERE a.maragerid = b.id;</span><br><span class="line"></span><br><span class="line">#由于表1和表2都是同一张表，所以这里的外连接也就属于自连接了。</span><br><span class="line">SELECT a.name,b.name FROM emp AS a LEFT JOIN emp AS b ON a.maragerid = b.id;</span><br></pre></td></tr></table></figure></li></ol><h4 id="⑥联合查询"><a href="#⑥联合查询" class="headerlink" title="⑥联合查询"></a>⑥联合查询</h4><h5 id="A-概念"><a href="#A-概念" class="headerlink" title="A.概念"></a>A.概念</h5><p>​联合查询：把多次查询的结果合并起来，形成一个新的查询结果集。即：把结果B直接跟在结果A的后面，形成一个新的结果。</p><h5 id="B-联合查询语法"><a href="#B-联合查询语法" class="headerlink" title="B.联合查询语法"></a>B.联合查询语法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表A.....</span><br><span class="line">UNION [ALL]</span><br><span class="line">SELECT 字段列表 FROM 表B...;</span><br></pre></td></tr></table></figure><p>​说明：</p><ol><li>如果UNION后面加上ALL，则代表不对合并之后的结果集进行去重。不加ALL，代表对合并后的结果集进行去重。</li></ol><h5 id="C-联合查询的前提条件"><a href="#C-联合查询的前提条件" class="headerlink" title="C.联合查询的前提条件"></a>C.联合查询的前提条件</h5><p>​对于联合查询的多张表的列数必须保持一致，字段类型也需要保持一致。不然报错。</p><h4 id="⑦子查询"><a href="#⑦子查询" class="headerlink" title="⑦子查询"></a>⑦子查询</h4><h5 id="A-概述-1"><a href="#A-概述-1" class="headerlink" title="A.概述"></a>A.概述</h5><ol><li>子查询：SQL语句中嵌套SELECT语句，称为嵌套查询，又称子查询。</li><li>子查询可以出现的位置：<strong>WHERE</strong>之后，<strong>FROM</strong>之后，<strong>SELECT</strong>之后。</li><li>根据子查询结果不同，分为：<ul><li>标量子查询(子查询结果为单个值)</li><li>列子查询(子查询结果为一列)</li><li>行子查询(子查询结果为一行)</li><li>表子查询(子查询结果为多行多列)</li></ul></li></ol><h5 id="B-标量子查询"><a href="#B-标量子查询" class="headerlink" title="B.标量子查询"></a>B.标量子查询</h5><h6 id="①概念-3"><a href="#①概念-3" class="headerlink" title="①概念"></a>①概念</h6><p>​子查询返回的结果是单个值(数字、字符串、日期等)，这种子查询称为：标量子查询。</p><p>​对子查询结果的常用的操作符为：&#x3D;、&lt;&gt; 、&gt; 、&lt; 、&gt;&#x3D; 、&lt;&#x3D;</p><h6 id="②例子-1"><a href="#②例子-1" class="headerlink" title="②例子"></a>②例子</h6><p><img src="/imgs/image-20220919165348118.png" alt="image-20220919165348118"></p><h5 id="C-列子查询"><a href="#C-列子查询" class="headerlink" title="C.列子查询"></a>C.列子查询</h5><h6 id="①概念-4"><a href="#①概念-4" class="headerlink" title="①概念"></a>①概念</h6><p>​子查询返回的结果是一列(一列里可以有多行)，这种子查询称为列子查询。</p><h6 id="②操作符"><a href="#②操作符" class="headerlink" title="②操作符"></a>②操作符</h6><p>​使用如下操作符来操作列子查询返回的结果：</p><p><img src="/imgs/image-20220919172845463.png" alt="image-20220919172845463"></p><h6 id="③例子"><a href="#③例子" class="headerlink" title="③例子"></a>③例子</h6><p>​①</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#查询比 财务部 所有人工资都高的员工信息</span><br><span class="line">-- 1.查询出财务部的部门ID</span><br><span class="line">SELECT id FROM dept WHERE name = &#x27;财务部&#x27;;</span><br><span class="line">-- 2.查询出财务部所有人的工资</span><br><span class="line">SELECT salary FROM emp WHERE dept_id = (SELECT id FROM dept WHERE name = &#x27;财务部&#x27;);</span><br><span class="line">-- 3.查询比 财务部 所有人工资都高的员工信息</span><br><span class="line">SELECT * FROM emp WHERE salary &gt; ALL (SELECT salary FROM emp WHERE dept_id = (SELECT id FROM dept WHERE name = &#x27;财务部&#x27;));</span><br></pre></td></tr></table></figure><p>​②</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#查询比 研发部 其中任意一个人工资高的员工信息</span><br><span class="line">SELECT * FROM emp WHERE salary &gt; SOME (SELECT salary FROM emp WHERE dept_id = (SELECT id FROM dept WHERE name = &#x27;研发部&#x27;));</span><br></pre></td></tr></table></figure><h5 id="D-行子查询"><a href="#D-行子查询" class="headerlink" title="D.行子查询"></a>D.行子查询</h5><h6 id="①概念-5"><a href="#①概念-5" class="headerlink" title="①概念"></a>①概念</h6><p>​子查询返回的结果是一行(一行中可以有多列)，这种子查询称为：行子查询。</p><h6 id="②操作符-1"><a href="#②操作符-1" class="headerlink" title="②操作符"></a>②操作符</h6><p>​对行子查询结果进行操作的操作符有：&#x3D;、&lt;&gt;、IN、NOT IN</p><h6 id="③例子-1"><a href="#③例子-1" class="headerlink" title="③例子"></a>③例子</h6><p>​查询与 “张无忌” 的薪资及直属领导相同的员工信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#1.先查询张无忌的薪资就直属领导</span><br><span class="line">SELECT salary,managerid FROM emp WHERE name = &#x27;张无忌&#x27;;-- 查询到了一行数据,salary = 12000,managerid = 1</span><br><span class="line"></span><br><span class="line">#2.查询与“张无忌”的薪资及直属领导相同的员工信息</span><br><span class="line">SELECT * FROM emp WHERE salary = 12000 AND managerid = 1;</span><br><span class="line"></span><br><span class="line">#如何将1、2中的SQL合成一个SQL</span><br><span class="line">SELECT * FROM emp WHERE (salary,managerid) = (12000,1);-- 与第四行等价</span><br><span class="line"></span><br><span class="line">#(12000,1)是由第一行语句得来的，所以可以用第一行语句替换掉(12000,1)</span><br><span class="line">#最终结果为：</span><br><span class="line">SELECT * FROM emp WHERE (salary,managerid) = (SELECT salary,managerid FROM emp WHERE name = &#x27;张无忌&#x27;;);</span><br></pre></td></tr></table></figure><h5 id="E-表子查询"><a href="#E-表子查询" class="headerlink" title="E.表子查询"></a>E.表子查询</h5><h6 id="①概念-6"><a href="#①概念-6" class="headerlink" title="①概念"></a>①概念</h6><p>​子查询返回的结果是多行多列，即返回一张表。这种子查询称为表子查询。</p><p>​表子查询常写在FROM的后面，将子查询得到的表作为临时表对其再进行相应的查询操作。</p><h6 id="②操作符-2"><a href="#②操作符-2" class="headerlink" title="②操作符"></a>②操作符</h6><p>​对于表子查询返回的结果我们可以使用下面的操作符进行处理：IN</p><h6 id="③例子-2"><a href="#③例子-2" class="headerlink" title="③例子"></a>③例子</h6><p>​①查询与 “鹿杖客” ，“宋远桥”的职位和薪资相同的员工信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#1.查询 “鹿杖客” ，“宋远桥”的职位和薪资</span><br><span class="line">SELECT job,salary FROM emp WHERE name = &#x27;鹿杖客”&#x27; OR name = &#x27;宋远桥&#x27;;-- 返回职位、薪资表</span><br><span class="line">#2查询与 “鹿杖客” ，“宋远桥”的职位和薪资相同的员工信息</span><br><span class="line"></span><br><span class="line">SELECT * FROM emp WHERE (job,salary) IN (SELECT job,salary FROM emp WHERE name = &#x27;鹿杖客”&#x27; OR name = &#x27;宋远桥&#x27;);</span><br><span class="line">-- 只要job和salary满足第二行代码得到的表中的其中一条数据，就会被SELECT</span><br></pre></td></tr></table></figure><p>​</p><p>​②查询入职日期是“2006-01-01” 之后的员工信息，及其部门信息。这里的子查询是放在FROM后面的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#1.先查询入职日期是“2006-01-01”之后的员工信息</span><br><span class="line">SELECT * FROM emp WHERE entrydate &gt; &#x27;2006-01-01&#x27;;</span><br><span class="line">#2.查询这部分员工，对应的部门信息</span><br><span class="line">SELECT e.*,d.* FROM (SELECT * FROM emp WHERE entrydate &gt; &#x27;2006-01-01&#x27;) AS e LEFT JOIN dept AS d ON e.dept_id = d.id;</span><br></pre></td></tr></table></figure><h4 id="⑧多表查询总结"><a href="#⑧多表查询总结" class="headerlink" title="⑧多表查询总结"></a>⑧多表查询总结</h4><p>​多表查询的重点是找到连接条件，通过连接条件就可以消除无用的笛卡尔积。然后再对得到的数据进行查询即可。</p><h3 id="六、事务"><a href="#六、事务" class="headerlink" title="六、事务"></a>六、事务</h3><h4 id="①事务简介"><a href="#①事务简介" class="headerlink" title="①事务简介"></a>①事务简介</h4><h5 id="A-引入"><a href="#A-引入" class="headerlink" title="A.引入"></a>A.引入</h5><p>​假如转账操作需要执行以下三个步骤：（张三向李四转账）</p><p>​1.查询张三账户余额</p><p>​2.张三账户余额 - 1000</p><p>​3.李四账户余额 +1000</p><p>​当上述步骤都正常执行时，就成功完成一次转账任务。但如果执行到步骤2时，系统出现了异常，导致步骤3不能继续执行，这时候就会造成数据的不完整性。为了避免出现这种情况，我们引入了“事务”这一概念。将上述操作放到事务中，当任意一个步骤出现异常时，剩下的步骤不会执行，然后将之前临时修改过的数据都恢复原样（这一过程被称为：回滚事务）。只有当上述步骤都正常执行时，系统才会将临时修改的数据提交，这样才真正把数据库中的数据修改。这样就可以保证数据的正确性和完整性。</p><h5 id="B-概念"><a href="#B-概念" class="headerlink" title="B.概念"></a>B.概念</h5><p>​事务：是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p><h5 id="C-说明"><a href="#C-说明" class="headerlink" title="C.说明"></a>C.说明</h5><p>​在MySQL中，事务是默认自动提交的，也就是说，当执行一条DML语句，MySQL会立即隐式的提交事务。</p><h4 id="②事务操作"><a href="#②事务操作" class="headerlink" title="②事务操作"></a>②事务操作</h4><h5 id="A-方式一"><a href="#A-方式一" class="headerlink" title="A.方式一"></a>A.方式一</h5><h6 id="①语法-1"><a href="#①语法-1" class="headerlink" title="①语法"></a>①语法</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SELECT @@autocommit;-- 查看当前窗口事务的提交方式</span><br><span class="line">#1.设置事务提交方式为手动提交，如果设置1，则代表自动提交事务</span><br><span class="line">SET @@autocommit = 0;</span><br><span class="line"></span><br><span class="line">#2.下面写需要被包在事务里的操作,如：更新操作等</span><br><span class="line">UPDATE .....;</span><br><span class="line"></span><br><span class="line">#3.</span><br><span class="line">COMMIT;-- 提交事务</span><br><span class="line">ROLLBACK;-- 回滚事务</span><br></pre></td></tr></table></figure><h6 id="②说明-2"><a href="#②说明-2" class="headerlink" title="②说明"></a>②说明</h6><ul><li>SET @@autocommit &#x3D; 0;当执行完这条语句之后，事务的提方式变为手动提交，只要没执行COMMIT就不会对数据库中的数据进行修改。其作用范围是：当前窗口有效。</li><li>当执行操作都没有出现异常时，我们才去执行COMMIT，将数据写到数据库中。</li><li>当执行操作出现异常时，我们需要使用ROLLBACK来撤回之前执行相应的操作，此时数据库中的数据并没有被改变。</li></ul><h5 id="B-方式二"><a href="#B-方式二" class="headerlink" title="B.方式二"></a>B.方式二</h5><h6 id="①语法-2"><a href="#①语法-2" class="headerlink" title="①语法"></a>①语法</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#1.</span><br><span class="line">START TRANSACTION;-- 或者写 BEGIN</span><br><span class="line"></span><br><span class="line">#2.下面写需要被包在事务里的操作,如：更新操作等</span><br><span class="line">UPDATE .....;</span><br><span class="line"></span><br><span class="line">#3.</span><br><span class="line">COMMIT;-- 提交事务</span><br><span class="line">ROLLBACK;-- 回滚事务</span><br></pre></td></tr></table></figure><h6 id="②说明-3"><a href="#②说明-3" class="headerlink" title="②说明"></a>②说明</h6><ul><li>这种方式并没有修改事务提交的方式</li><li>当选中第2部分的代码进行执行时，涉及到的数据并没有立即写到数据库中，而是等到执行COMMIT时才会对涉及到的数据写到数据库中。</li><li>当执行操作都没有出现异常时，我们才去执行COMMIT，将数据写到数据库中。</li><li>当执行操作出现异常时，我们需要使用ROLLBACK来撤回之前执行相应的操作，此时数据库中的数据并没有被改变。</li></ul><h4 id="③事务四大特性-ACID"><a href="#③事务四大特性-ACID" class="headerlink" title="③事务四大特性(ACID)"></a>③事务四大特性(ACID)</h4><ol><li>原子性(Atomicity)：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。</li><li>一致性(Consistency)：事务完成时，必须使所有的数据都保持一致状态。如：转账中，两人账户的总钱数是不变的。</li><li>隔离性(Isolation)：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。如：有两并发事务A、B，它们之间不会相互影响。</li><li>持久性(Duration)：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</li></ol><h4 id="④并发事务问题"><a href="#④并发事务问题" class="headerlink" title="④并发事务问题"></a>④并发事务问题</h4><p>​当多个事务共同访问同一个数据库或数据库中的同一张表时，就可能出现并发事务问题。具体的问题有：脏读、不可重复读、幻读</p><h5 id="A-脏读"><a href="#A-脏读" class="headerlink" title="A.脏读"></a>A.脏读</h5><p>​脏读：一个事务读到另一个事务还没有提交的数据。</p><p>​如下图：事务A对数据库中的数据进DB行查询操作，然后对数据进行更新操作，此时事务B也进来对数据库DB进行查询操作，事务B就能读到事务A还没提交的数据了。</p><p><img src="/imgs/image-20220920174038881.png" alt="image-20220920174038881"></p><p>​</p><h5 id="B-不可重复读"><a href="#B-不可重复读" class="headerlink" title="B.不可重复读"></a>B.不可重复读</h5><p>​不可重复读：一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读。</p><p>​如下图：事务B在事务A执行第三步操作之前，对数据进行了修改并提交了事务，此时事务A再读取同一条数据时，数据的内容就发生了改变了。</p><p><img src="/imgs/image-20220920174923913.png" alt="image-20220920174923913"></p><h5 id="C-幻读"><a href="#C-幻读" class="headerlink" title="C.幻读"></a>C.幻读</h5><p>​幻读：一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在，好像出现了“幻影”。</p><p>​如下图：事务A在执行步骤一时，发现数据库DB中没有所查询的记录，然后就执行步骤2来添加数据。但在事务A添加数据之前事务B添加了事务A所要查询的数据并提交事务，这样就会导致事务A在插入数据时失败，然后事务A又对该数据进行查询，发现并没有该数据存在。</p><p><img src="/imgs/image-20220920180611632.png" alt="image-20220920180611632"></p><h4 id="⑤事务隔离级别"><a href="#⑤事务隔离级别" class="headerlink" title="⑤事务隔离级别"></a>⑤事务隔离级别</h4><h5 id="A-引入-1"><a href="#A-引入-1" class="headerlink" title="A.引入"></a>A.引入</h5><p>​为了解决并发事务中的问题，我们引入了事务隔离级别来处理。</p><h5 id="B-事务隔离级别"><a href="#B-事务隔离级别" class="headerlink" title="B.事务隔离级别"></a>B.事务隔离级别</h5><p><img src="/imgs/image-20220920205433460.png" alt="image-20220920205433460"></p><p>​说明：</p><ol><li>×：代表不会出现。</li><li>Serializable的隔离级别最高，但性能最差，Read uncommitted的隔离级别最低，性能最好。</li><li>Repeatable Read是MySQL默认的事务隔离级别，而Oracle数据库的默认事务隔离级别为Read committed。</li><li>当事务的隔离级别为Serializable时，有两个并发事务A、B，事务A正在操作数据库当中的student表，此时事务B也想操作student表，但事务B不能操作，只能等事务A操作完student表之后才能操作。</li></ol><p>​</p><h5 id="C-相关操作"><a href="#C-相关操作" class="headerlink" title="C.相关操作"></a>C.相关操作</h5><h6 id="①查看事务隔离级别"><a href="#①查看事务隔离级别" class="headerlink" title="①查看事务隔离级别"></a>①查看事务隔离级别</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT @@TRANSACTION_ISOLATION;</span><br></pre></td></tr></table></figure><h6 id="②设置事务隔离级别"><a href="#②设置事务隔离级别" class="headerlink" title="②设置事务隔离级别"></a>②设置事务隔离级别</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET [SESSION|GLOBAL] TRANSACTION ISOLATION LEVEL &#123;READ UNCOMMITTED|READ COMMITTED|REPEATABLE READ|SERIALIZABLE&#125;</span><br></pre></td></tr></table></figure><p>​说明</p><ul><li>SESSION：设置事务的隔离级别只在当前窗口有效。</li><li>GLOBAL：设置事务的隔离级别的有效范围为：全部窗口。</li><li>一般我们会使用默认的隔离级别。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDBC</title>
      <link href="/2023/04/20/jdbc/"/>
      <url>/2023/04/20/jdbc/</url>
      
        <content type="html"><![CDATA[<h3 id="一、JDBC简介"><a href="#一、JDBC简介" class="headerlink" title="一、JDBC简介"></a>一、JDBC简介</h3><h4 id="①JDBC概念"><a href="#①JDBC概念" class="headerlink" title="①JDBC概念"></a>①JDBC概念</h4><ul><li>JDBC就是使用Java语言操作关系型数据库的一套API。</li></ul><h4 id="②JDBC本质"><a href="#②JDBC本质" class="headerlink" title="②JDBC本质"></a>②JDBC本质</h4><ul><li>SUN公司定义的一套操作所有关系型数据库的规则，即接口。</li><li>各个数据库厂商去实现这套接口，提供数据库驱动jar包。</li><li>我们可以使用这套(JDBC)编程，真正执行的代码是驱动jar包中的实现类。</li></ul><h4 id="③JDBC好处"><a href="#③JDBC好处" class="headerlink" title="③JDBC好处"></a>③JDBC好处</h4><ul><li>各数据库厂商使用相同的接口，Java代码不需要针对不同数据库分别开发。</li><li>可随时替换底层数据库，访问数据库的Java代码基本不变。</li></ul><h4 id="④补充"><a href="#④补充" class="headerlink" title="④补充"></a>④补充</h4><p>​当我们需要使用不同的数据库时，我们只需要导入不同的数据库驱动jar包即可。</p><img src="/imgs/image-20230423202509764.png" alt="image-20230423202509764" style="zoom: 67%;" /><hr><h3 id="二、JDBC快速入门"><a href="#二、JDBC快速入门" class="headerlink" title="二、JDBC快速入门"></a>二、JDBC快速入门</h3><p>​通过JDBC来连接数据库。</p><h4 id="①实现步骤"><a href="#①实现步骤" class="headerlink" title="①实现步骤"></a>①实现步骤</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0.导入驱动jar包</span></span><br><span class="line">mysql-connector-java-<span class="number">5.1</span><span class="number">.34</span>.jar</span><br><span class="line"><span class="comment">//1.注册驱动</span></span><br><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);<span class="comment">//&quot;com.mysql.jdbc.Driver&quot;是固定的</span></span><br><span class="line"><span class="comment">//2.获取连接</span></span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url,username,password);</span><br><span class="line"><span class="comment">//3.定义SQL语句</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update...&quot;</span>;</span><br><span class="line"><span class="comment">//4.获取执行SQL对象</span></span><br><span class="line"><span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> conn.createStatement();</span><br><span class="line"><span class="comment">//5.执行SQL</span></span><br><span class="line">stmt.execuleUpdate(sql);<span class="comment">//返回受影响的行数，</span></span><br><span class="line"><span class="comment">//6.处理返回结果</span></span><br><span class="line"><span class="comment">//7.释放资源 </span></span><br><span class="line">stmt.close();</span><br><span class="line">conn.close();</span><br><span class="line"><span class="comment">//如果使用到了如下类的对象，就把这些对象的资源释放掉</span></span><br><span class="line"><span class="comment">//Connection、Statement、PreparedStatement、ResultSet</span></span><br></pre></td></tr></table></figure><h4 id="②实现步骤的说明"><a href="#②实现步骤的说明" class="headerlink" title="②实现步骤的说明"></a>②实现步骤的说明</h4><ul><li>注册驱动：说明接下来使用的是哪个驱动。即说明接下来使用的是哪个数据库提供的JDBC接口实现类。</li><li>getConnection(url,username,password)：<ul><li>url：jdbc:mysql:&#x2F;&#x2F;数据库管理系统所在主机的地址(或域名)：3306&#x2F;连接的是数据库管理系统下的哪个数据库。例子：jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;db1。</li><li>username、password：登录数据库管理系统时的用户名和密码。</li></ul></li><li>执行SQL：将SQL语句发送给数据库，让数据库处理这些SQL语句。</li></ul><h4 id="③JDBC-API详解"><a href="#③JDBC-API详解" class="headerlink" title="③JDBC  API详解"></a>③JDBC  API详解</h4><h5 id="A-DriverManager"><a href="#A-DriverManager" class="headerlink" title="A.DriverManager"></a>A.DriverManager</h5><h6 id="①概述"><a href="#①概述" class="headerlink" title="①概述"></a>①概述</h6><p>​DriverManager属于工具类，该类的两个主要功能是：注册驱动、获取数据库连接。</p><h6 id="②注册驱动"><a href="#②注册驱动" class="headerlink" title="②注册驱动"></a>②注册驱动</h6><ul><li><p>实现原理：</p><p>  ​按照JDBC中的实现步骤，我们用Class.forName(“com.mysql.jdbc.Driver”)来注册驱动。该代码底层实现原理是：</p><p>  ​Driver是一个类，该类中有一个静态代码块，静态代码块中调用了DriverManager类中的静态方法registerDriver()，该方法就是用来注册驱动的。</p><p>  ​所以当通过反射来加载Driver类时，同时也执行了Driver类中的静态代码块，也就调用了registerDriver()来注册驱动了。</p></li><li><p>提示：</p><p>  ​如果使用的是MySQL 5之后的驱动jar包，那么就可以省略注册驱动的步骤。</p></li></ul><h6 id="③获取连接"><a href="#③获取连接" class="headerlink" title="③获取连接"></a>③获取连接</h6><p>​调用DriverManager类中的静态方法getConnection(String url,String user,String password)，该方法返回的是一个Connection类的对象。</p><p>​<strong>细节</strong>：</p><ul><li><p>如果连接的是本机MySQL服务器(即地址为127.0.0.1)，并且MySQL服务默认端口是3306，则url可以简写为：jdbc:mysql:&#x2F;&#x2F;&#x2F;数据库名称</p></li><li><p>当我们执行该语句后，运行结果中会显示一个警告：建议以安全的方式连接数据库(SSL)，但这种连接方式会使性能降低，一般不使用。为了不出现这个警告，我们可以在url的最后面加上：?useSSL&#x3D; fasle即可。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://127.0.0.1:3306/db1?useSSL=false&quot;</span>;</span><br></pre></td></tr></table></figure></li></ul><h5 id="B-Connection"><a href="#B-Connection" class="headerlink" title="B.Connection"></a>B.Connection</h5><h6 id="①作用"><a href="#①作用" class="headerlink" title="①作用"></a>①作用</h6><p>​获取执行SQL的对象、管理事务。</p><h6 id="②获取执行SQL对象"><a href="#②获取执行SQL对象" class="headerlink" title="②获取执行SQL对象"></a>②获取执行SQL对象</h6><ol><li>普通执行SQL对象</li></ol>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Statement <span class="title function_">createStatement</span><span class="params">()</span></span><br></pre></td></tr></table></figure><ol start="2"><li>预编译SQL的执行SQL对象：防止SQL注入</li></ol>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PreparedStatement <span class="title function_">prepareStatement</span><span class="params">(sql)</span></span><br><span class="line"><span class="comment">//关闭资源时，记得把PreparedStatement对象也关闭掉</span></span><br></pre></td></tr></table></figure><ol start="3"><li>执行存储过程的对象（少用，了解即可）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CallableStatement prepareCall(sql)</span><br></pre></td></tr></table></figure><h6 id="③事务管理"><a href="#③事务管理" class="headerlink" title="③事务管理"></a>③事务管理</h6><ul><li><p>概述：</p><p>  <img src="/imgs/image-20220921154856156.png" alt="image-20220921154856156"></p><p>  Conncetion中也有三个方法来管理事务，它们分别对应着MySQL中的事务管理的三个步骤。</p><p>  <img src="/imgs/image-20220921155103081.png" alt="image-20220921155103081"></p></li><li><p>使用：</p><p>  开启事务的代码写在执行SQL之前，提交事务的代码写在“处理事务返回的结果”的后面，然后将开启事务到提交事务之间的代码用try包起来，在catch里写回滚事务的代码。</p></li></ul><h5 id="C-Statement"><a href="#C-Statement" class="headerlink" title="C.Statement"></a>C.Statement</h5><h6 id="①作用-1"><a href="#①作用-1" class="headerlink" title="①作用"></a>①作用</h6><p>​执行SQL语句</p><h6 id="②相关方法"><a href="#②相关方法" class="headerlink" title="②相关方法"></a>②相关方法</h6><ol><li><p>int executeUpdate(sql)</p><p> 该方法执行的是DML、DDL语句<br> 返回值：<br>  ①DML语句受影响的行数，我们可以根据返回的行数来判断，该SQL是否执行成功<br> ②DDL语句执行后，执行成功也可能返回0，如：创建数据库或创建表执行成功了，受影响行数也为0</p></li><li><p>ResultSet executeQuery(sql)</p><p> 该方法执行的是DQL语句<br> 返回值：ResultSet结果集对象</p></li></ol><p><code>注意</code>：关闭资源时，记得把ResultSet对象资源也得关闭。</p><h5 id="D-ResultSet"><a href="#D-ResultSet" class="headerlink" title="D.ResultSet"></a>D.ResultSet</h5><h6 id="①概述-1"><a href="#①概述-1" class="headerlink" title="①概述"></a>①概述</h6><p>​ResultSet中存储了通过executeQuery(sql)查询得到的结果。(说明：这里的sql特指DQL语句)</p><p>​由于DQL语句查询得到的结果为：一个数据 或 一行数据 或 一张表</p><p>​所以实际上，ResultSet中存储的是一个数据 或 一行数据 或 一张表。</p><h6 id="②获取查询结果"><a href="#②获取查询结果" class="headerlink" title="②获取查询结果"></a>②获取查询结果</h6><ul><li>boolean next()<ul><li>作用：①将光标从当前位置向下移动一行。(光标的初始位置为：表头) ②判断当前行是否为有效行。</li><li>返回值：<ul><li>true：有效行，代表当前行有数据。</li><li>false：无效行，代表当前行没有数据。</li></ul></li></ul></li><li>xxx getXxx(参数)<ul><li>作用：获取数据</li><li>Xxx：数据类型；如：int getInt(参数)</li><li>参数：二选一<ul><li>①int：列的编号，从1开始。</li><li>②String：列的名称</li></ul></li></ul></li></ul><h6 id="③练习"><a href="#③练习" class="headerlink" title="③练习"></a>③练习</h6><p>​查询account账户表数据，封装为Account对象中，并存储到ArrayList集合中。</p><h5 id="E-PreparedStatement"><a href="#E-PreparedStatement" class="headerlink" title="E.PreparedStatement"></a>E.PreparedStatement</h5><h6 id="①概述-2"><a href="#①概述-2" class="headerlink" title="①概述"></a>①概述</h6><p>​PreparedStatement是一个接口，其继承Statement类。</p><p>​其作用：执行SQL语句，并且能够预防SQL注入。</p><h6 id="②SQL注入"><a href="#②SQL注入" class="headerlink" title="②SQL注入"></a>②SQL注入</h6><p>​SQL注入是通过操作输入来修改事先定义好的SQL语句，用以达到执行代码对服务器进行攻击的方法。</p><p>​如：在登录输入密码时，写入一段SQL代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#如现登录的用户名为张三，其密码为123</span><br><span class="line">SELECT * FROM user_login WHERE name = &#x27;张三&#x27; AND password = &#x27;123&#x27;;-- 如果查询到数据，就代表该用户存在且密码正确，登录成功</span><br><span class="line"></span><br><span class="line">#如果我在输入密码时写了作用的SQL语句：&#x27; or &#x27;1&#x27; = &#x27;1&#x27;</span><br><span class="line">SELECT * FROM user_login WHERE name = &#x27;张三&#x27; AND password = &#x27;&#x27; or &#x27;1&#x27; = &#x27;1&#x27;;</span><br><span class="line">-- 此时用户输入的密码就改变了原来查询语句的面貌，导致WHERE后面的条件永远成立，select就能查询到数据，代表着登录成功了。这就是SQL注入。</span><br></pre></td></tr></table></figure><p>​</p><h6 id="③解决SQL注入"><a href="#③解决SQL注入" class="headerlink" title="③解决SQL注入"></a>③解决SQL注入</h6><p>​<strong>实现步骤</strong>：</p><ol><li><p>获取PreparedStatement对象，用Connection类的对象去调用prepareStatement(sql)方法</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> con.prepareStatement(sql);</span><br></pre></td></tr></table></figure><p> 注意：sql语句中的参数值，使用 “ ? ” 占位符代替，如：</p><p> sql可以为增删改查操作。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from user where username = ? and password = ?&quot;</span>;</span><br></pre></td></tr></table></figure></li><li><p>设置参数。通过PreparedStatement类的对象去调用setXxx(参数1,参数2)去给 “ ? ”赋值。</p><p> 说明：</p><ul><li>Xxx：数据类型；如：setInt(参数1，参数2)</li><li>参数：<ul><li>参数1：? 的位置。第一个?的位置为1。</li><li>参数2：? 的值。</li></ul></li></ul></li><li><p>执行SQL。通过PreparedStatement类的对象调用execuleUpdate()或executeQuery()来执行SQL语句。注意：不用再向这两个方法传递SQL语句。</p></li></ol><h6 id="④解决SQL注入的原理"><a href="#④解决SQL注入的原理" class="headerlink" title="④解决SQL注入的原理"></a>④解决SQL注入的原理</h6><p>​当我们通过setXxx方法来设置占位符 “?” 的值时，会对设置的值进行校验，如果其中涉及到了一些SQL关键字或单引号等会对其进行转移操作，即将这些变成字符串。这样就不会产生SQL注入了。</p><h6 id="⑤PreparedStatement原理"><a href="#⑤PreparedStatement原理" class="headerlink" title="⑤PreparedStatement原理"></a>⑤PreparedStatement原理</h6><ul><li><strong>PreparedStatement的好处</strong><ol><li>预编译SQL，性能提高。</li><li>防止SQL注入：将敏感字符进行转义。</li><li>PreparedStatement<strong>预编译功能默认是关闭的</strong>，<strong>需要我们手动开启</strong>，在获取数据库连接时，在url后面加上“<strong>useServerPrepStmts &#x3D; true</strong>”，<strong>并且在这段代码前加上 &amp; 和前面的内容连起来</strong>。</li></ol></li><li><strong>PreparedStatement原理</strong><ol><li>在获取PreparedStatement对象时，将SQL语句发送给MySQL服务器进行检查，编译(这些步骤很耗时)。</li><li>执行SQL时就不用再进行检查和预编译了，速度更快。</li><li>如果SQL语句的模板一样，则只需要进行一次检查和预编译。</li></ol></li><li><strong>PreparedStatement比以普通的方式执行SQL快在哪里？</strong><ol><li>普通的方式进行SQL：其在执行SQL时才将SQL语句发送给数据库进行检查和编译，最后才真正执行。比预编译耗时。</li><li>普通的方式进行SQL：需要对每一条SQL语句进行检查和编译，预编译的话，只要模板相同就只执行一次检查和编译，节省了时间。</li></ol></li></ul><hr><h4 id="④数据库连接池"><a href="#④数据库连接池" class="headerlink" title="④数据库连接池"></a>④数据库连接池</h4><h5 id="A-概述"><a href="#A-概述" class="headerlink" title="A.概述"></a>A.概述</h5><ol><li>数据库连接池：是个容器，负责分配、管理数据库连接。</li><li>它允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个。—&gt; 资源复用、提高响应效率</li><li>释放空间时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏。—&gt; 避免数据库连接遗漏</li></ol><p>​<strong>好处</strong>：</p><ul><li>资源复用</li><li>提高响应效率</li><li>避免数据库连接遗漏</li></ul><p>​</p><h5 id="B-数据库连接池实现"><a href="#B-数据库连接池实现" class="headerlink" title="B.数据库连接池实现"></a>B.数据库连接池实现</h5><h6 id="①概述-3"><a href="#①概述-3" class="headerlink" title="①概述"></a>①概述</h6><ol><li><p>官方(SUN公司)提供了数据库连接池的标准接口DataSource，该接口由第三方组织实现。</p><ul><li><p>该接口的功能是：获取数据库连接，该接口中有一个方法：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection getConnection()</span><br></pre></td></tr></table></figure></li></ul></li><li><p>常见的数据库连接池：DBCP、C3P0、Druid</p><ul><li>Druid：是阿里巴巴开源的数据库连接池项目。其功能强大，性能优秀。</li></ul></li></ol><h6 id="②Druid使用步骤"><a href="#②Druid使用步骤" class="headerlink" title="②Druid使用步骤"></a>②Druid使用步骤</h6><ol><li><p>导入jar包：druid-1.1.12.jar</p></li><li><p>定义配置文件，文件的后缀为properties。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">driverClassName = com.mysql.jdbc.Driver<span class="comment">//注册数据库驱动，使用哪个数据库就注册哪个数据库驱动</span></span><br><span class="line">url = jdbc:mysql:<span class="comment">//数据库管理系统所在主机的地址(或域名)：3306/连接的是数据库管理系统下的哪个数据库。例子：jdbc:mysql://127.0.0.1:3306/db1。</span></span><br><span class="line">username = 登录数据库的用户</span><br><span class="line">password = 密码</span><br><span class="line">initialSize = <span class="number">5</span> <span class="comment">//初始化连接数量</span></span><br><span class="line">maxActive = <span class="number">10</span> <span class="comment">//最大连接数</span></span><br><span class="line">maxWait = <span class="number">3000</span> <span class="comment">//最大等待时间，单位为毫秒</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//还有其它参数可以设置</span></span><br></pre></td></tr></table></figure></li><li><p>加载配置文件</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Properties</span> <span class="variable">prop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();<span class="comment">//创建配置文件对象</span></span><br><span class="line">prop.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;配置文件的路径&quot;</span>));<span class="comment">//加载配置文件</span></span><br></pre></td></tr></table></figure></li><li><p>获取数据库连接池对象</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DataSource</span> <span class="variable">ds</span> <span class="operator">=</span> DruidDataSourcrFactory.createDataSourcr(prop);<span class="comment">//该方法会抛异常</span></span><br></pre></td></tr></table></figure></li><li><p>获取数据库连接</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> ds.getConnection();</span><br></pre></td></tr></table></figure></li><li><p>获取连接之后，就定义SQL，获取执行SQL的对象，执行SQL，释放资源。</p></li></ol><p>​</p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDBC </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
