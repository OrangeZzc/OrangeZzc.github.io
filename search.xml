<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>快捷键</title>
      <link href="/2023/04/24/%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>/2023/04/24/%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<h5 id="1、代码的整体缩进"><a href="#1、代码的整体缩进" class="headerlink" title="1、代码的整体缩进"></a>1、代码的整体缩进</h5><p><img src="/imgs/image-20220528110436926.png" alt="image-20220528110436926"></p><h5 id="2、快速将多行代码注释掉"><a href="#2、快速将多行代码注释掉" class="headerlink" title="2、快速将多行代码注释掉"></a>2、快速将多行代码注释掉</h5><pre><code> ctrl + /  ，快速将注释掉的代码恢复：ctrl + / </code></pre><h5 id="3、快速删除"><a href="#3、快速删除" class="headerlink" title="3、快速删除"></a>3、快速删除</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl + d</span><br></pre></td></tr></table></figure><h5 id="4、在eclipse中如何对代码快速格式化-代码比较乱时可用"><a href="#4、在eclipse中如何对代码快速格式化-代码比较乱时可用" class="headerlink" title="4、在eclipse中如何对代码快速格式化(代码比较乱时可用)"></a>4、在eclipse中如何对代码快速格式化(代码比较乱时可用)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl + shift + f</span><br></pre></td></tr></table></figure><h5 id="5、在eclipse中如何快速导包"><a href="#5、在eclipse中如何快速导包" class="headerlink" title="5、在eclipse中如何快速导包"></a>5、在eclipse中如何快速导包</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl + shift + o <span class="comment">//程序中需要的包都可以一次性全导进来</span></span><br></pre></td></tr></table></figure><h5 id="6、快速换行"><a href="#6、快速换行" class="headerlink" title="6、快速换行"></a>6、快速换行</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shift + 回车<span class="comment">//快速向下换行</span></span><br><span class="line">ctrl + shift + 回车<span class="comment">//快速向上回车</span></span><br></pre></td></tr></table></figure><h5 id="7、快速将此行代码上下移动"><a href="#7、快速将此行代码上下移动" class="headerlink" title="7、快速将此行代码上下移动"></a>7、快速将此行代码上下移动</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Alt + 上下键</span><br></pre></td></tr></table></figure><h5 id="8、想查看自己写的类的内容"><a href="#8、想查看自己写的类的内容" class="headerlink" title="8、想查看自己写的类的内容"></a>8、想查看自己写的类的内容</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">点击该类名，然后按住Alt + 左/右键进行查看及返回</span><br></pre></td></tr></table></figure><h5 id="9、当方法的形参有多个时，调用该方法时可按TAB键快速跳到下一个填写的位置。"><a href="#9、当方法的形参有多个时，调用该方法时可按TAB键快速跳到下一个填写的位置。" class="headerlink" title="9、当方法的形参有多个时，调用该方法时可按TAB键快速跳到下一个填写的位置。"></a>9、当方法的形参有多个时，调用该方法时可按TAB键快速跳到下一个填写的位置。</h5><h5 id="10、可在属性或者类前使用文档注释，这样用到这个类或属性时，就能显示该类或属性的相关注释。"><a href="#10、可在属性或者类前使用文档注释，这样用到这个类或属性时，就能显示该类或属性的相关注释。" class="headerlink" title="10、可在属性或者类前使用文档注释，这样用到这个类或属性时，就能显示该类或属性的相关注释。"></a>10、可在属性或者类前使用文档注释，这样用到这个类或属性时，就能显示该类或属性的相关注释。</h5><p><img src="/imgs/image-20230424211957129.png" alt="image-20230424211957129"></p><h5 id="11、复制指定行的代码"><a href="#11、复制指定行的代码" class="headerlink" title="11、复制指定行的代码"></a>11、复制指定行的代码</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl + alt + down 或 ctrl + alt + up</span><br></pre></td></tr></table></figure><h5 id="12查看源码"><a href="#12查看源码" class="headerlink" title="12查看源码"></a>12查看源码</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl + 选中指定的结构 或 ctrl + shift + t</span><br></pre></td></tr></table></figure><h5 id="13、退回到前一个编辑的页面"><a href="#13、退回到前一个编辑的页面" class="headerlink" title="13、退回到前一个编辑的页面"></a>13、退回到前一个编辑的页面</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alt + left</span><br></pre></td></tr></table></figure><h5 id="14、进入到下一个编辑的页面-针对于上面那条来说的"><a href="#14、进入到下一个编辑的页面-针对于上面那条来说的" class="headerlink" title="14、进入到下一个编辑的页面(针对于上面那条来说的)"></a>14、进入到下一个编辑的页面(针对于上面那条来说的)</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alt + right</span><br></pre></td></tr></table></figure><h5 id="15、光标选中指定的类，查看继承树结构"><a href="#15、光标选中指定的类，查看继承树结构" class="headerlink" title="15、光标选中指定的类，查看继承树结构"></a>15、光标选中指定的类，查看继承树结构</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl + t</span><br></pre></td></tr></table></figure><h5 id="16、在当前类中，显示类结构，并支持搜索指定的方法、属性等"><a href="#16、在当前类中，显示类结构，并支持搜索指定的方法、属性等" class="headerlink" title="16、在当前类中，显示类结构，并支持搜索指定的方法、属性等"></a>16、在当前类中，显示类结构，并支持搜索指定的方法、属性等</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl + o</span><br></pre></td></tr></table></figure><h5 id="17、批量修改指定的变量名、方法名、类名等"><a href="#17、批量修改指定的变量名、方法名、类名等" class="headerlink" title="17、批量修改指定的变量名、方法名、类名等"></a>17、批量修改指定的变量名、方法名、类名等</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alt + shift + r</span><br></pre></td></tr></table></figure><h5 id="18、选中的结构的大小写的切换：变成大写"><a href="#18、选中的结构的大小写的切换：变成大写" class="headerlink" title="18、选中的结构的大小写的切换：变成大写"></a>18、选中的结构的大小写的切换：变成大写</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl + shift + x</span><br></pre></td></tr></table></figure><h5 id="19、选中的结构的大小写的切换：变成小写"><a href="#19、选中的结构的大小写的切换：变成小写" class="headerlink" title="19、选中的结构的大小写的切换：变成小写"></a>19、选中的结构的大小写的切换：变成小写</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl + shift + y</span><br></pre></td></tr></table></figure><h5 id="20、调出生成-getter-x2F-setter-x2F-构造器等结构"><a href="#20、调出生成-getter-x2F-setter-x2F-构造器等结构" class="headerlink" title="20、调出生成 getter&#x2F;setter&#x2F;构造器等结构"></a>20、调出生成 getter&#x2F;setter&#x2F;构造器等结构</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alt + shift + s</span><br></pre></td></tr></table></figure><h5 id="21、快速查找：参照选中的-Word-快速定位到下一个"><a href="#21、快速查找：参照选中的-Word-快速定位到下一个" class="headerlink" title="21、快速查找：参照选中的 Word 快速定位到下一个"></a>21、快速查找：参照选中的 Word 快速定位到下一个</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl + k</span><br></pre></td></tr></table></figure><h5 id="22、查看指定的结构使用过的地方"><a href="#22、查看指定的结构使用过的地方" class="headerlink" title="22、查看指定的结构使用过的地方"></a>22、查看指定的结构使用过的地方</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl + alt + g</span><br></pre></td></tr></table></figure><h5 id="23、整列编辑"><a href="#23、整列编辑" class="headerlink" title="23、整列编辑"></a>23、整列编辑</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alt + 鼠标左键</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 快捷键 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机知识</title>
      <link href="/2023/04/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9F%A5%E8%AF%86/"/>
      <url>/2023/04/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h4 id="1、冯诺依曼体系结构"><a href="#1、冯诺依曼体系结构" class="headerlink" title="1、冯诺依曼体系结构"></a>1、冯诺依曼体系结构</h4><p><img src="/imgs/cdn.learnku.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto" alt="点击查看图片来源"></p><h4 id="2、时钟"><a href="#2、时钟" class="headerlink" title="2、时钟"></a>2、时钟</h4><p>每台计算机都有一个内置时钟，该时钟以固定速度发射电子脉冲。时钟速度越快，在给定的时间内执行的指令就越多，速度的计算单位是Hz,1Hz相当于每秒1个脉冲，相当于处理一个指令。</p><h4 id="3、存储设备"><a href="#3、存储设备" class="headerlink" title="3、存储设备"></a>3、存储设备</h4><p>内存中的信息在断电时会丢失数据。存储设备主要有以下三种：</p><ol><li>硬盘（如：C、D盘）</li><li>光盘（CD和DVD）</li><li>USB闪存驱动器</li><li>软驱（已淘汰；分为A盘和B盘）</li></ol><h4 id="4、内存-RAM"><a href="#4、内存-RAM" class="headerlink" title="4、内存(RAM)"></a>4、内存(RAM)</h4><ol><li><p>字节（B）和位（b），一字节有8位。</p><p> 1KB&#x3D;1024B</p><p> 1MB&#x3D;1024KB</p><p> 1GB&#x3D;1024MB</p><p> 1TB&#x3D;1024GB</p></li><li><p>一个程序和它的数据在被CPU执行前必须移动到计算机的内存中。如果CPU想调用硬盘中的数据，要先将硬盘中的数据调入内存中，再从内存调入CPU。</p></li><li><p>一个计算具有的RAM越多，它的运行速度越快，但此规律是有限的。（如：当平时满负荷时，还是没占满RAM中的空间，此时通过再增加RAM的空间来提高速度就没有意义了。）</p></li><li><p>如果计算机的速度比较慢，改变比较大的提速方式是：增加固态硬盘。</p></li></ol><h4 id="5、屏幕分辨率"><a href="#5、屏幕分辨率" class="headerlink" title="5、屏幕分辨率"></a>5、屏幕分辨率</h4><ol><li><p>什么是屏幕分辨率：是指设备水平方向和垂直方向上显示的像素数。如：分辨率为2160*1440，代表垂直方向上有1440个像素，水平方向上有2160个像素。（像素：一个小的颜色块）</p></li><li><p>单凭分辨率并不能区分出那个的画质更细腻，得根据像素密度来判断。</p><p> <img src="/imgs/image-20230424211456893.png" alt="image-20230424211456893"></p><p> 像素密度越大，画质越细腻。</p> <!--屏幕尺寸：即屏幕对角线--></li></ol><h4 id="6、操作系统"><a href="#6、操作系统" class="headerlink" title="6、操作系统"></a>6、操作系统</h4><p>为应用程序提高服务，直接与硬件打交道。</p><p><img src="/imgs/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20220512165341.jpg" alt="微信图片编辑_20220512165341"></p><h4 id="7、万维网"><a href="#7、万维网" class="headerlink" title="7、万维网"></a>7、万维网</h4><ol><li><p>万维网分为Web客户端和Web服务器。www可以让Web客户端（常用浏览器）访问Web服务器上的页面。</p></li><li><p>URL即网址，网址所包含的资源通过http协议传输给用户。</p></li><li><p>B&#x2F;S架构和C&#x2F;S架构</p><p> ①B&#x2F;S架构中的B(browser)是指通过Web客户端进行的访问</p><p> ②S:server     C:clinet</p></li></ol><h4 id="8、常用的DOS命令"><a href="#8、常用的DOS命令" class="headerlink" title="8、常用的DOS命令"></a>8、常用的DOS命令</h4><ol><li><p>切换盘符：</p><p> 盘号+冒号，如：d：</p></li><li><p><img src="/imgs/image-20220517165847928.png" alt="image-20220517165847928"></p></li></ol><p>注：如果某个目录中有文件，使用rd是不能把该目录删除的。</p><h4 id="9、Java版本"><a href="#9、Java版本" class="headerlink" title="9、Java版本"></a>9、Java版本</h4><p>JDK1.5之后的（包括1.5版本）版本都改名为JDK*.0，如：JDK1.6就相当于JDK6.0，JDK1.8就相当于JDK8.0。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java语法基础概述</title>
      <link href="/2023/04/24/java%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0/"/>
      <url>/2023/04/24/java%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="一、Java基础概述"><a href="#一、Java基础概述" class="headerlink" title="一、Java基础概述"></a>一、Java基础概述</h3><h4 id="一、Java语言的特点"><a href="#一、Java语言的特点" class="headerlink" title="一、Java语言的特点"></a>一、Java语言的特点</h4><p><img src="/imgs/image-20220517203631087.png" alt="image-20220517203631087"></p><p>特点三：跨平台性</p><ol><li>跨平台性：一个Java应用程序可以运行在不同系统。</li><li>原理：在需要运行Java应用程序的系统上安装Ja</li><li>va虚拟机（即JVM）即可。然后由JVM负责Java程序在该系统中的运行。</li></ol><h4 id="二、Java语言的核心机制–垃圾回收"><a href="#二、Java语言的核心机制–垃圾回收" class="headerlink" title="二、Java语言的核心机制–垃圾回收"></a>二、Java语言的核心机制–垃圾回收</h4><p>​垃圾回收：不再使用的内存空间应回收</p><p>​垃圾回收在Java程序运行中自动进行，程序员无法精确控制和干预。</p><p>​虽然有了垃圾回收机制，但Java程序中还是会出现内存泄漏和内存溢出问题。</p><h4 id="三、JDK、JRE、JVM"><a href="#三、JDK、JRE、JVM" class="headerlink" title="三、JDK、JRE、JVM"></a>三、JDK、JRE、JVM</h4><ol><li><p>什么是JDK、JRE</p><p> JDK（Java开发工具包）是提供给开发人员使用的，其中包含了Java的开发工具，也包括JRE。（其中的开发工具包括：编译工具、打包工具等）</p><p> JRE（Java运行环境，编译时会用到），其包括JVM和Java程序所需要的核心类库等。</p></li><li><p>JDK、JRE、JVM三者的关系</p></li></ol><p><img src="/imgs/image-20230424210820561.png" alt="image-20230424210820561"></p><h4 id="四、用Java前为什么需要配置环境变量path"><a href="#四、用Java前为什么需要配置环境变量path" class="headerlink" title="四、用Java前为什么需要配置环境变量path"></a>四、用Java前为什么需要配置环境变量path</h4><p>​JDK文件下有个bin目录（该目录是用来存放开发工具的），bin目录里有javac、java等这些文件，这些文件在我们编译时会用到。在配置环境变量前，想用这些文件只能在bin目录下使用，其他目录下使用不了，因此需要将javac、java等文件的目录路径配置到环境变量中，以使其他目录也能使用这些文件。</p><hr><p>​那么是配置path环境变量呢？因为系统执行一个命令，会先在当前目录下寻找是否有该命令，有则执行，否则到path环境变量下找。</p><p>​补充：</p><p>​环境变量中：“%变量名%”的含义是调用变量的值。</p><h4 id="五、Java程序的执行过程"><a href="#五、Java程序的执行过程" class="headerlink" title="五、Java程序的执行过程"></a>五、Java程序的执行过程</h4><p><img src="/imgs/image-20220518102921794.png" alt="image-20220518102921794"></p><h4 id="六、注释"><a href="#六、注释" class="headerlink" title="六、注释"></a>六、注释</h4><p>​当行注释、多行注释、文档注释（Java特有）</p><p>​什么是文档注释：将文档注释的内容以网页的形式展示</p><p>​文档注释的格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="七、补充知识："><a href="#七、补充知识：" class="headerlink" title="七、补充知识："></a>七、补充知识：</h4><p>1、一个Java源文件中可以声明多个class（类），但只能有一个类被声明为public。且public只能放在与文件名同名的类上。</p><p>2、main方法是程序的入口。</p><p>3、  </p><p><img src="/imgs/image-20230424210900016.png" alt="image-20230424210900016"></p>]]></content>
      
      
      <categories>
          
          <category> Java语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git</title>
      <link href="/2023/04/24/git/"/>
      <url>/2023/04/24/git/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SSM整合</title>
      <link href="/2023/04/24/SSM%E6%95%B4%E5%90%88/"/>
      <url>/2023/04/24/SSM%E6%95%B4%E5%90%88/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringMvc</title>
      <link href="/2023/04/24/SpringMvc/"/>
      <url>/2023/04/24/SpringMvc/</url>
      
        <content type="html"><![CDATA[<p><strong>SpringMVC</strong></p><h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><h4 id="1-什么是SpringMVC"><a href="#1-什么是SpringMVC" class="headerlink" title="1.什么是SpringMVC"></a>1.什么是SpringMVC</h4><ul><li>SpringMVC隶属于Spring框架，其与servlet一样都是处理web开发中的表现层（即：接收前段发过来的请求和数据，然后经过处理之后将处理结果响应给前端），<strong>SpringMVC完全可以替换掉servlet</strong>。</li><li>SpringMVC与servlet相比使用更简单、开发更快捷、灵活性更强。</li><li>SpringMVC是使用Java编写的。</li><li>REST是一种软件架构风格，可以降低开发的复杂性，提高系统的可伸缩性，后期的应用也是非常广泛。</li></ul><h4 id="2-学习内容及目标"><a href="#2-学习内容及目标" class="headerlink" title="2.学习内容及目标"></a>2.学习内容及目标</h4><p>​学习内容：</p><img src="C:\Users\橙子\AppData\Roaming\Typora\typora-user-images\image-20230206174240874.png" alt="image-20230206174240874" style="zoom:80%;" /><p>​学习目标：</p><img src="C:\Users\橙子\AppData\Roaming\Typora\typora-user-images\image-20230206174315215.png" alt="image-20230206174315215" style="zoom:80%;" /><hr><h3 id="二、SpringMVC"><a href="#二、SpringMVC" class="headerlink" title="二、SpringMVC"></a>二、SpringMVC</h3><h4 id="1-入门案例（重点回顾）"><a href="#1-入门案例（重点回顾）" class="headerlink" title="1.入门案例（重点回顾）"></a>1.入门案例（重点回顾）</h4><h5 id="A-案例制作"><a href="#A-案例制作" class="headerlink" title="A.案例制作"></a>A.案例制作</h5><p>​步骤：</p><ol><li><p>创建Maven项目</p></li><li><p>在pom.xml文件中导入所需坐标（SpringMVC+Servlet）</p></li></ol>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--servlet--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span> <span class="comment">&lt;!--避免与tomcat中的插件产生冲突，得指定servlet的作用范围为provide--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--springmvc--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="comment">&lt;!--版本号要与spring的一样--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--SpringMVC是基于Spring的，但在pom.xml中只导入了spring-webmvc jar包的原因是它会自动依赖spring相关坐标--&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li><p>创建SpringMVC控制器类（等同于我们前面做的Servlet）</p><p> 3.1 在Java文件下创建一个包com.zzc.controller，专门用来放SpringMVC控制器类。</p><p> 控制器类的类名一般为：表名+Controller。</p><p> 3.2 控制器类内部定义一个方法（方法名随意），用于处理外部的请求，一般处理完请求后我们都是将JSON数据返回给外部，所以该方法返回值类型为String。</p><p> 3.3 使用@RequestMapping注解来设置当前访问路径</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用@Controller定义Bean</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="comment">//设置当前访问路径，使用@RequestMapping</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/save&quot;)</span></span><br><span class="line">    <span class="comment">//设置操作的返回值类型</span></span><br><span class="line">    <span class="meta">@ResponseBody</span>  <span class="comment">//将return返回的东西整体作为响应的内容给到外部</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//该方法里写处理请求的一些操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;user save ...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;SpringMVC&#x27;&#125;&quot;</span>;<span class="comment">//返回Json数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 解释：</p><ul><li>@Controller：因为SpringMVC隶属于Spring，所以也需要将该控制器类定义成bean。</li></ul></li><li><p>在com.zzc.config包下创建springmvc的配置类，加载springmvc对应的bean。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建SpringMVC的配置类，加载SpringMVC对应的bean</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.zzc.controller&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义一个servlet容器的配置类，在里面加载SpringMVC的配置，继承AbstractDispatcherServletInitializer并重写其方法。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletContainerInitConfig</span> <span class="keyword">extends</span> <span class="title class_">AbstractDispatcherServletInitializer</span> &#123;</span><br><span class="line">    <span class="comment">//加载SpringMvc容器配置</span></span><br><span class="line">    <span class="keyword">protected</span> WebApplicationContext <span class="title function_">createServletApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个空的容器</span></span><br><span class="line">        <span class="type">AnnotationConfigWebApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigWebApplicationContext</span>();</span><br><span class="line">        <span class="comment">//让容器加载springmvc配置类</span></span><br><span class="line">        context.register(SpringMvcConfig.class);</span><br><span class="line">        <span class="keyword">return</span> context;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置哪些请求归SpringMvc处理</span></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="comment">//所有请求都交由SpringMVC处理</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;/&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加载Spring容器配置</span></span><br><span class="line">    <span class="comment">//如果创建Servlet容器时需要加载非SpringMVC对应的bean，使用当前方法进行，使用方式和createServletApplicationContext相同。</span></span><br><span class="line">    <span class="keyword">protected</span> WebApplicationContext <span class="title function_">createRootApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 解释：</p><ul><li>当Tomcat容器启动时就会加载servlet容器的配置类，然后servlet容器的配置类再加载SpringMVC配置类，从而就将SpringMVC对应的bean加载进来。</li><li><img src="/imgs/image-20230208101001092.png" alt="image-20230208101001092"></li></ul></li><li><p>查看pom.xml文件中是否有tomcat插件，如果没有就加上，否则无法通过浏览器访问web程序。</p> <img src="C:\Users\橙子\AppData\Roaming\Typora\typora-user-images\image-20230208101337553.png" alt="image-20230208101337553" style="zoom:80%;" /></li><li><p>完成。</p></li></ol><h5 id="B-入门案例总结"><a href="#B-入门案例总结" class="headerlink" title="B.入门案例总结"></a>B.入门案例总结</h5><p><img src="/imgs/image-20230208103500872.png" alt="image-20230208103500872"></p><hr><h5 id="C-入门案例工作流程分析"><a href="#C-入门案例工作流程分析" class="headerlink" title="C.入门案例工作流程分析"></a>C.入门案例工作流程分析</h5><p><img src="/imgs/image-20230208150009120.png" alt="image-20230208150009120"></p><p><img src="/imgs/image-20230208150409217.png" alt="image-20230208150409217"></p><hr><h5 id="D-bean加载控制"><a href="#D-bean加载控制" class="headerlink" title="D.bean加载控制"></a>D.bean加载控制</h5><h6 id="①问题引入"><a href="#①问题引入" class="headerlink" title="①问题引入"></a>①问题引入</h6><p>​项目的大致层次结构如下，SpringMVC需要加载com.itheima.controller包下的bean，Spring也需要加载com.itheima包下的bean，这样就就会造成Spring也加载了SpringMVC中的bean，这样的结构显然不是我们想要的，我们只想让Spring加载Spring自己的bean。那怎么做呢？</p><p>​<img src="C:\Users\橙子\AppData\Roaming\Typora\typora-user-images\image-20230209150428566.png" alt="image-20230209150428566" style="zoom:80%;" /></p><p>​</p><h6 id="②解决方法一（推荐使用）"><a href="#②解决方法一（推荐使用）" class="headerlink" title="②解决方法一（推荐使用）"></a>②解决方法一（推荐使用）</h6><p>​Spring加载的bean设定扫描范围为精确扫描，具体到<code>service</code>包，<code>dao</code>包等</p><h6 id="③解决方法二"><a href="#③解决方法二" class="headerlink" title="③解决方法二"></a>③解决方法二</h6><p>​Spring加载的bean设定扫描范围<code>com.itheima</code>，排除掉<code>controller</code>包内的bean</p><p>​在SpringConfig配置类中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(value = &quot;com.itheima&quot;,</span></span><br><span class="line"><span class="meta">    excludeFilters = @ComponentScan.Filter(</span></span><br><span class="line"><span class="meta">            type = FilterType.ANNOTATION,</span></span><br><span class="line"><span class="meta">            classes = Controller.class</span></span><br><span class="line"><span class="meta">    ))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​解释：</p><p>​<img src="C:\Users\橙子\AppData\Roaming\Typora\typora-user-images\image-20230209152150951.png" alt="image-20230209152150951" style="zoom:80%;" /></p><p>​测试：<img src="/imgs/image-20230209153037222.png" alt="image-20230209153037222"></p><p>​运行结果为：打印UserController对象的地址。</p><p>​明明在SpringConfig中写好不加载com.itheima.controller包下的使用@Controller注解的bean，但为什么能在spring容器中获取到呢？这是因为SpringConfig的扫描路径为：com.itheima，所以在扫描包的时候也会扫描到com.itheima.config包，SpringMvcConfig上有一个@Configuration注解，也会被Spring扫描到，SpringMvcConfig上又有一个@ComponentScan，把controller包下的类又扫描进来了，所以Spring容器中就有了UserController对象。那接下来怎么做才能不加载controller包下的bean到Spring容器中呢？其实只要将SpringMvcConfig类放到com包下就行，这样Spring就扫描不到SpringMvcConfig，自然就不会加载到controller包下的bean。</p><p>​</p><p>​补充：</p><p>​有了Spring的配置类，要想在tomcat服务器启动将其加载，我们需要修改ServletContainersInitConfig。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletContainerInitConfig</span> <span class="keyword">extends</span> <span class="title class_">AbstractDispatcherServletInitializer</span> &#123;</span><br><span class="line">    <span class="comment">//加载SpringMvc配置</span></span><br><span class="line">    <span class="keyword">protected</span> WebApplicationContext <span class="title function_">createServletApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigWebApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigWebApplicationContext</span>();</span><br><span class="line">        context.register(SpringMvcConfig.class);</span><br><span class="line">        <span class="keyword">return</span> context;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置哪些请求归SpringMvc处理</span></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;/&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加载Spring容器配置</span></span><br><span class="line">    <span class="keyword">protected</span> WebApplicationContext <span class="title function_">createRootApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个空的容器</span></span><br><span class="line">        <span class="type">AnnotationConfigWebApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigWebApplicationContext</span>();</span><br><span class="line">        <span class="comment">//将Spring配置类加载到容器中</span></span><br><span class="line">        context.register(SpringConfig.class);</span><br><span class="line">        <span class="keyword">return</span> context;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="C:\Users\橙子\AppData\Roaming\Typora\typora-user-images\image-20230209160312241.png" alt="image-20230209160312241" style="zoom:80%;" /><hr><h4 id="2-PostMan工具的使用"><a href="#2-PostMan工具的使用" class="headerlink" title="2.PostMan工具的使用"></a>2.PostMan工具的使用</h4><p>​PostMan是用于网页测试和发送网页http请求的软件。</p><h5 id="A-下载"><a href="#A-下载" class="headerlink" title="A.下载"></a>A.下载</h5><p>​<a href="https://www.postman.com/downloads/">https://www.postman.com/downloads/</a></p><p><img src="/imgs/image-20230209170728907.png" alt="image-20230209170728907"></p><p>​下载完双击就可以运行了。</p><h5 id="B-登录注册"><a href="#B-登录注册" class="headerlink" title="B.登录注册"></a>B.登录注册</h5><p>​首次打开postman需要注册，然后自动登录，跳转到postman</p><p><img src="/imgs/image-20230209172106810.png" alt="image-20230209172106810"></p><h5 id="C-工作空间"><a href="#C-工作空间" class="headerlink" title="C.工作空间"></a>C.工作空间</h5><p>​<strong>工作空间</strong>用于记录每次操作的痕迹，即：保持此次操作的内容。</p><h6 id="①新建工作空间"><a href="#①新建工作空间" class="headerlink" title="①新建工作空间"></a>①新建工作空间</h6><img src="C:\Users\橙子\AppData\Roaming\Typora\typora-user-images\image-20230209172536465.png" alt="image-20230209172536465" style="zoom:80%;" /><img src="C:\Users\橙子\AppData\Roaming\Typora\typora-user-images\image-20230209172508303.png" alt="image-20230209172508303" style="zoom:80%;" /><h6 id="②切换工作空间"><a href="#②切换工作空间" class="headerlink" title="②切换工作空间"></a>②切换工作空间</h6><p><img src="/imgs/image-20230209172701725.png" alt="image-20230209172701725"></p><h5 id="D-发送请求"><a href="#D-发送请求" class="headerlink" title="D.发送请求"></a>D.发送请求</h5><p>​进入到工作空间后，将概述页关闭（如下：）</p><p><img src="/imgs/image-20230209172829873.png" alt="image-20230209172829873"></p><p>​然后点击下图中的加号，创建请求：</p><img src="C:\Users\橙子\AppData\Roaming\Typora\typora-user-images\image-20230209172927766.png" alt="image-20230209172927766" style="zoom:80%;" /><p>​发送请求：</p><p><img src="/imgs/image-20230209173040642.png" alt="image-20230209173040642"></p><p>​查看响应数据：</p><p><img src="/imgs/image-20230209173158347.png" alt="image-20230209173158347"></p><p>​pretty：响应的原始数据</p><p>​Preview：响应的页面信息</p><h5 id="E-保存请求"><a href="#E-保存请求" class="headerlink" title="E.保存请求"></a>E.保存请求</h5><img src="C:\Users\橙子\AppData\Roaming\Typora\typora-user-images\image-20230209173704752.png" alt="image-20230209173704752" style="zoom:80%;" /><img src="C:\Users\橙子\AppData\Roaming\Typora\typora-user-images\image-20230209173539869.png" alt="image-20230209173539869" style="zoom:50%;" /><h5 id="F-查看之前保存的请求"><a href="#F-查看之前保存的请求" class="headerlink" title="F.查看之前保存的请求"></a>F.查看之前保存的请求</h5><p><img src="/imgs/image-20230209173809358.png" alt="image-20230209173809358"></p><hr><h4 id="3-请求与响应（重点回顾）"><a href="#3-请求与响应（重点回顾）" class="headerlink" title="3.请求与响应（重点回顾）"></a>3.请求与响应（重点回顾）</h4><h5 id="A-设置请求映射路径"><a href="#A-设置请求映射路径" class="headerlink" title="A.设置请求映射路径"></a>A.设置请求映射路径</h5><h6 id="①问题引入-1"><a href="#①问题引入-1" class="headerlink" title="①问题引入"></a>①问题引入</h6><p>​如果不同的控制器类内，处理请求的路径都一样，如：</p><img src="C:\Users\橙子\AppData\Roaming\Typora\typora-user-images\image-20230210113553198.png" alt="image-20230210113553198" style="zoom:80%;" /><p>​当访问<a href="http://localhost/save%E6%97%B6%E5%B0%B1%E4%BC%9A%E6%8A%A5%E9%94%99%EF%BC%8C%E5%9B%A0%E4%B8%BA%E5%90%8C%E6%97%B6%E5%AD%98%E5%9C%A8%E4%B8%A4%E4%B8%AA%E7%9B%B8%E5%90%8C%E7%9A%84%E8%AE%BF%E9%97%AE%E8%B7%AF%E5%BE%84%EF%BC%8C%E5%AF%BC%E8%87%B4%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8D%E7%9F%A5%E9%81%93%E8%AF%A5%E8%AE%BF%E9%97%AE%E5%93%AA%E4%B8%AA%E3%80%82">http://localhost/save时就会报错，因为同时存在两个相同的访问路径，导致服务器不知道该访问哪个。</a></p><h6 id="②解决"><a href="#②解决" class="headerlink" title="②解决"></a>②解决</h6><p>​在请求映射路径上加上本模块的名字即可，如：</p><img src="C:\Users\橙子\AppData\Roaming\Typora\typora-user-images\image-20230210114013462.png" alt="image-20230210114013462" style="zoom:80%;" /><p>​这样就可以解决请求访问路径一样的问题。</p><p>​但如果类中的请求处理方法很多时，每个方法的请求映射路径上都得加上“user”或“book”，那就会很麻烦且耦合度高。我们只需要在类上面使用@RequestMapping，代表该模块的访问前缀。如：</p><img src="C:\Users\橙子\AppData\Roaming\Typora\typora-user-images\image-20230210114701394.png" alt="image-20230210114701394" style="zoom:80%;" /><p>​</p><p><img src="/imgs/image-20230210114826156.png" alt="image-20230210114826156"></p><hr><h5 id="B-请求参数"><a href="#B-请求参数" class="headerlink" title="B.请求参数"></a>B.请求参数</h5><h6 id="①利用postman发送get请求"><a href="#①利用postman发送get请求" class="headerlink" title="①利用postman发送get请求"></a>①利用postman发送get请求</h6><p>​在postman上选择请求方式，输入请求路径并携带参数：</p><p><img src="/imgs/image-20230210135348259.png" alt="image-20230210135348259"></p><p>​补充：</p><p><img src="/imgs/image-20230210135722859.png" alt="image-20230210135722859"></p><h6 id="②利用postman发送post请求"><a href="#②利用postman发送post请求" class="headerlink" title="②利用postman发送post请求"></a>②利用postman发送post请求</h6><p>​通过post请求发送表单数据，而不是JSON数据<img src="/imgs/image-20230210140349103.png" alt="image-20230210140349103"></p><p>​</p><hr><h6 id="③获取请求参数"><a href="#③获取请求参数" class="headerlink" title="③获取请求参数"></a>③获取请求参数</h6><p>​在Servlet中对于post请求和get请求是分别由dopost、doget进行处理的，而<strong>在SpringMvc中无论是Post请求还是Get请求，其处理的方式都是一样的。</strong></p><p>​<strong>操作：</strong>我们只需要在请求映射路径对应的方法的形参中加上请求参数的名字即可获取请求参数的值。</p><p>​<img src="C:\Users\橙子\AppData\Roaming\Typora\typora-user-images\image-20230210141728105.png" alt="image-20230210141728105" style="zoom:80%;" /></p><p>​如果需要接收请求发过来的多个参数，直接在方法的形参中添加多个即可，如：</p><img src="C:\Users\橙子\AppData\Roaming\Typora\typora-user-images\image-20230210144049008.png" alt="image-20230210144049008" style="zoom:80%;" /><hr><h6 id="④post请求中文乱码问题"><a href="#④post请求中文乱码问题" class="headerlink" title="④post请求中文乱码问题"></a>④post请求中文乱码问题</h6><p>​我们在发送post请求的时候，使用了中文，则会出现乱码，怎么解决？见下图。<img src="C:\Users\橙子\AppData\Roaming\Typora\typora-user-images\image-20230210144429217.png" alt="image-20230210144429217" style="zoom:80%;" /></p><hr><h5 id="C-五种类型参数传递（了解）"><a href="#C-五种类型参数传递（了解）" class="headerlink" title="C.五种类型参数传递（了解）"></a>C.五种类型参数传递（了解）</h5><h6 id="①普通参数"><a href="#①普通参数" class="headerlink" title="①普通参数"></a>①普通参数</h6><ol><li><p>普通参数：url地址传参，<strong>地址上的参数名与形参变量名相同</strong>，定义形参即可接收参数。</p><p> 发送请求与参数：localhost:8080&#x2F;user&#x2F;commonParam?name&#x3D;Helsing&amp;age&#x3D;1024</p><p> 后台接收参数：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/commonParam&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">commonParam</span><span class="params">(String name,<span class="type">int</span> age)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;普通参数传递name --&gt; &quot;</span> + name);</span><br><span class="line">        System.out.println(<span class="string">&quot;普通参数传递age --&gt; &quot;</span> + age);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;commonParam&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <img src="C:\Users\橙子\AppData\Roaming\Typora\typora-user-images\image-20230212123625724.png" alt="image-20230212123625724" style="zoom:80%;" /> </li><li><p>如果形参与地址上的参数名不一致该如何解决？例如地址上的参数名为<code>username</code>，而形参变量名为<code>name</code>，因为前端给的是<code>username</code>，后台接收使用的是<code>name</code>，两个名称对不上，会导致接收数据失败。</p><p> 解决方案：使用<code>@RequestParam</code>注解</p><p> 发送请求与参数：localhost:8080&#x2F;user&#x2F;commonParam?username&#x3D;Helsing&amp;age&#x3D;1024</p><p> 后台接收参数：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/commonParam&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">commonParam</span><span class="params">(<span class="meta">@RequestParam(&quot;username&quot;)</span> String name, <span class="type">int</span> age)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;普通参数传递name --&gt; &quot;</span> + name);</span><br><span class="line">        System.out.println(<span class="string">&quot;普通参数传递age --&gt; &quot;</span> + age);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;commonParam&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h6 id="②POJO数据类型"><a href="#②POJO数据类型" class="headerlink" title="②POJO数据类型"></a>②POJO数据类型</h6><p>​简单数据类型一般处理的是参数个数比较少的请求，如果参数比较多，那么后台接收参数的时候就比较复杂，这个时候我们可以考虑使用POJO数据类型。</p><p>​POJO参数：<strong>请求参数名与形参对象属性名相同，定义POJO类型形参即可接收参数</strong>。但<strong>注意：</strong>pojo类中的属性要提供get&#x2F;set方法。</p><p>​操作：</p><ol><li><p>准备好pojo类</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>发送请求和参数：localhost:8080&#x2F;user&#x2F;pojoParam?name&#x3D;Helsing&amp;age&#x3D;1024</p><p> 后台接收参数:</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//POJO参数：请求参数与形参对象中的属性对应即可完成参数传递</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/pojoParam&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">pojoParam</span><span class="params">(User user)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;POJO参数传递user --&gt; &quot;</span> + user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;pojo param&#x27;&#125;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><img src="C:\Users\橙子\AppData\Roaming\Typora\typora-user-images\image-20230212130819978.png" alt="image-20230212130819978" style="zoom:80%;" /><p>​<strong>注意：</strong></p><ul><li>POJO参数接收，前端GET和POST发送请求数据的方式不变。</li><li>请求参数key的名称要和POJO中属性的名称一致，否则无法自动封装。</li></ul><p>​<strong>实现原理：</strong></p><p>​处理该请求执行pojoParam方法时，会先造一个User对象，因为请求中传递过来的参数名为：name和age，接着就会在这两个参数的首字母大写再在前面加上get，变成getName和getAge，最后查看User类中是否有getName和getAge方法，如果有就调用这两个完成完成对对象属性的赋值；如果没有，那传递过来的参数就不能封装到User对象中。</p><h6 id="③嵌套POJO数据类型"><a href="#③嵌套POJO数据类型" class="headerlink" title="③嵌套POJO数据类型"></a>③嵌套POJO数据类型</h6><p>​准备好两个POJO类：</p><img src="C:\Users\橙子\AppData\Roaming\Typora\typora-user-images\image-20230214141223624.png" alt="image-20230214141223624" style="zoom:80%;" /><img src="C:\Users\橙子\AppData\Roaming\Typora\typora-user-images\image-20230214141239557.png" alt="image-20230214141239557" style="zoom:80%;" /><p>​我们将Address类，嵌套在User类中</p><img src="C:\Users\橙子\AppData\Roaming\Typora\typora-user-images\image-20230214141346608.png" alt="image-20230214141346608" style="zoom:80%;" /><p>嵌套POJO参数：请求参数名与形参对象属性名相同，按照对象层次结构关系即可接收嵌套POJO属性参数，如：localhost:8080&#x2F;user&#x2F;pojoParam?name&#x3D;Helsing&amp;age&#x3D;1024&amp;address.province&#x3D;Beijing&amp;address.city&#x3D;Beijing</p><p><strong>后台接收参数：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/pojoParam&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">pojoParam</span><span class="params">(User user)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;POJO参数传递user --&gt; &quot;</span> + user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;pojo param&#x27;&#125;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/imgs/image-20230214141638712.png" alt="image-20230214141638712"></p><p>​<strong>注意：</strong>请求参数key的名称要和POJO中属性的名称一致，否则无法自动封装。</p><p>​原理：与POJO数据类型中的原理一样。</p><h6 id="④数组类型"><a href="#④数组类型" class="headerlink" title="④数组类型"></a>④数组类型</h6><ul><li><p><strong>引入：</strong>举个简单的例子，如果前端需要获取用户的爱好，爱好绝大多数情况下都是多选，如何发送请求数据和接收数据呢?</p></li><li><p>数组参数：请求参数名与形参对象属性名相同且请求参数为多个，定义数组类型即可接收参数。</p></li><li><p>发送请求和参数：localhost:8080&#x2F;user&#x2F;arrayParam?hobbies&#x3D;sing&amp;hobbies&#x3D;jump&amp;hobbies&#x3D;rap&amp;hobbies&#x3D;basketball</p></li><li><p>后台接收参数：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/arrayParam&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">arrayParam</span><span class="params">(String[] hobbies)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;数组参数传递user --&gt; &quot;</span> + Arrays.toString(hobbies));</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;array param&#x27;&#125;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="/imgs/image-20230214142124679.png" alt="image-20230214142124679"></p><h6 id="⑤集合类型"><a href="#⑤集合类型" class="headerlink" title="⑤集合类型"></a>⑤集合类型</h6><ul><li><p><strong>引入：</strong>数组能接收多个值，那么集合是否也可以实现这个功能呢?</p><ul><li><p>发送请求和参数：localhost:8080&#x2F;user&#x2F;listParam?hobbies&#x3D;sing&amp;hobbies&#x3D;jump&amp;hobbies&#x3D;rap&amp;hobbies&#x3D;basketball</p></li><li><p>后台接收参数：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/listParam&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">listParam</span><span class="params">(List hobbies)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;集合参数传递user --&gt; &quot;</span> + hobbies);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;list param&#x27;&#125;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  运行程序，报错：java.lang.IllegalArgumentException: Cannot generate variable name for non-typed Collection parameter type</p><ul><li><p>错误原因：SpringMVC将List看做是一个POJO对象来处理，将其创建一个对象并准备把前端的数据封装到对象中，但是List是一个接口无法创建对象，所以报错。</p></li><li><p>解决方案是：使用<code>@RequestParam</code>注解</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/listParam&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">listParam</span><span class="params">(<span class="meta">@RequestParam</span> List hobbies)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;集合参数传递user --&gt; &quot;</span> + hobbies);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;list param&#x27;&#125;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <img src="/imgs/image-20230214144318164.png" alt="image-20230214144318164"></p></li></ul></li></ul></li></ul><hr><h5 id="D-JSON数据传输参数"><a href="#D-JSON数据传输参数" class="headerlink" title="D.JSON数据传输参数"></a>D.JSON数据传输参数</h5><h6 id="①引入"><a href="#①引入" class="headerlink" title="①引入"></a>①引入</h6><p>​现在比较流行的开发方式为异步调用。前后台以异步方式进行交换，传输的数据使用的是JSON，所以前端如果发送的是JSON数据，该如何接收?</p><p>​对于JSON数据类型，我们常见的有三种:</p><ul><li>json普通数组（[“value1”,”value2”,”value3”,…]）</li><li>json对象（{key1:value1,key2:value2,…}）</li><li>json对象数组（[{key1:value1,…},{key2:value2,…}]）</li></ul><p>​下面我们就来学习以上三种数据类型，前端如何发送，后端如何接收。</p><h6 id="②环境准备"><a href="#②环境准备" class="headerlink" title="②环境准备"></a>②环境准备</h6><ol><li><p>在pom.xml文件中导入JSON依赖</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p> ​</p></li><li><p>开启SpringMVC注解支持</p><p> 在SpringMVC配置类SpringMvcConfig上使用@EnableWebMvc注解，开启SpringMVC的注解支持，这里面就包含了将JSON转换成对象的功能。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.blog.controller&quot;)</span></span><br><span class="line"><span class="comment">//开启json数据类型自动转换</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 解释：根据之前学的知识可知，前端传递过来的数据如果是JSON数据，我们需要将JSON数据转换为对应的对象，再通过此对象进行数据处理，所以就需要JSON转对象的操作，而SpringMvc中得使用@EnableWebMvc注解的方式才能将JSON数据转为对象。</p></li><li><p>在PostMan发送JSON数据</p><p> <img src="/imgs/image-20230214162514614.png" alt="image-20230214162514614"></p></li><li><p>看接收什么类型的JSON数据</p></li></ol><h6 id="③接收JSON普通数组"><a href="#③接收JSON普通数组" class="headerlink" title="③接收JSON普通数组"></a>③接收JSON普通数组</h6><p>​PostMan发送JSON普通数组</p><p><img src="/imgs/image-20230214162514614.png" alt="image-20230214162514614"></p><p>​后台接收参数，参数前添加@RequestBody</p><p>​使用<code>@RequestBody</code>注解将外部传递的json数组数据映射到形参的集合对象中作为数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/jsonArrayParam&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">jsonArrayParam</span><span class="params">(<span class="meta">@RequestBody</span> List&lt;String&gt; hobbies)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;JSON数组参数传递hobbies --&gt; &quot;</span> + hobbies);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;json array param&#x27;&#125;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="C:\Users\橙子\AppData\Roaming\Typora\typora-user-images\image-20230214163723040.png" alt="image-20230214163723040" style="zoom:80%;" /><h6 id="④接收JSON对象"><a href="#④接收JSON对象" class="headerlink" title="④接收JSON对象"></a>④接收JSON对象</h6><p>​在PostMan发送JSON数据：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;菲茨罗伊&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="string">&quot;27&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;address&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;city&quot;</span><span class="punctuation">:</span><span class="string">&quot;萨尔沃&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;province&quot;</span><span class="punctuation">:</span><span class="string">&quot;外域&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>​接收请求参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/jsonPojoParam&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">jsonPojoParam</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;JSON对象参数传递user --&gt; &quot;</span> + user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;json pojo param&#x27;&#125;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​使用<code>@RequestBody</code>注解将请求体中的数据放到形参user中</p><p>​注：User类的结构见：本笔记中 请求与响应–&gt;五种类型参数传递 –&gt; 嵌套POJO数据类型 </p><h6 id="⑤接收JSON对象数组"><a href="#⑤接收JSON对象数组" class="headerlink" title="⑤接收JSON对象数组"></a>⑤接收JSON对象数组</h6><p>​postMan发送JSON数据</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;菲茨罗伊&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="string">&quot;27&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;address&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;city&quot;</span><span class="punctuation">:</span><span class="string">&quot;萨尔沃&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;province&quot;</span><span class="punctuation">:</span><span class="string">&quot;外域&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;地平线&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="string">&quot;136&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;address&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;city&quot;</span><span class="punctuation">:</span><span class="string">&quot;奥林匹斯&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;province&quot;</span><span class="punctuation">:</span><span class="string">&quot;外域&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p>​</p><p>​后台接收请求参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/jsonPojoListParam&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">jsonPojoListParam</span><span class="params">(<span class="meta">@RequestBody</span> List&lt;User&gt; users)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;JSON对象数组参数传递user --&gt; &quot;</span> + users);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;json pojo list param&#x27;&#125;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​@RequestBody：将请求体中的数据放到形参users中</p><img src="C:\Users\橙子\AppData\Roaming\Typora\typora-user-images\image-20230214164734294.png" alt="image-20230214164734294" style="zoom:80%;" /><h6 id="⑥小结"><a href="#⑥小结" class="headerlink" title="⑥小结"></a>⑥小结</h6><img src="C:\Users\橙子\AppData\Roaming\Typora\typora-user-images\image-20230214165730776.png" alt="image-20230214165730776" style="zoom:80%;" /><img src="C:\Users\橙子\AppData\Roaming\Typora\typora-user-images\image-20230214165809691.png" alt="image-20230214165809691" style="zoom:80%;" /><p><code>@RequestBody</code>与<code>@RequestParam</code>区别：</p><p>@RequestBody：用于接收JSON数据；@RequestParam：用于接收非JSON数据。</p><hr><h5 id="E-日期类型参数传递"><a href="#E-日期类型参数传递" class="headerlink" title="E.日期类型参数传递"></a>E.日期类型参数传递</h5><h6 id="①引入-1"><a href="#①引入-1" class="headerlink" title="①引入"></a>①引入</h6><p>​日期类型比较特殊，因为对于日期的格式有N多中输入方式，比如：</p><ul><li>2088-08-18</li><li>2088&#x2F;08&#x2F;18</li><li>08&#x2F;18&#x2F;2088</li><li>。。。</li></ul><p>​针对这么多日期格式，SpringMVC该如何接收呢？下面我们来开始学习</p><p>​</p><h6 id="②操作"><a href="#②操作" class="headerlink" title="②操作"></a>②操作</h6><p>​后台接收日期数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/dateParam&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">dateParam</span><span class="params">(Date date)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;参数传递date --&gt; &quot;</span> + date);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;date param&#x27;&#125;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​如果发送过来的日期格式为：yyyy&#x2F;mm&#x2F;dd，则参数像上面这样写就能接收到数据了；如果发送过来的日期格式不是这样或者日期后面带上时间，那就要在参数前面使用<code>@DateTimeFormat</code>注解指定日期的格式如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/dateParam&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">dateParam</span><span class="params">(Date date1,<span class="meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)</span> Date date2)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;参数传递date1 --&gt; &quot;</span> + date1);</span><br><span class="line">    System.out.println(<span class="string">&quot;参数传递date2 --&gt; &quot;</span> + date2);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;date param&#x27;&#125;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/dateParam&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">dateParam</span><span class="params">(Date date1,</span></span><br><span class="line"><span class="params">                        <span class="meta">@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)</span> Date date2,</span></span><br><span class="line"><span class="params">                        <span class="meta">@DateTimeFormat(pattern =&quot;yyyy/MM/dd HH:mm:ss&quot;)</span> Date date3)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;参数传递date1 --&gt; &quot;</span> + date1);</span><br><span class="line">    System.out.println(<span class="string">&quot;参数传递date2 --&gt; &quot;</span> + date2);</span><br><span class="line">    System.out.println(<span class="string">&quot;参数传递date3 --&gt; &quot;</span> + date3);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;date param&#x27;&#125;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>为什么yyyy&#x2F;mm&#x2F;dd这种日期格式就不需要在形参前面指定日期格式呢？<ul><li>因为SpringMVC默认支持的字符串转日期的格式为<code>yyyy/MM/dd</code>，如果不符合其默认格式，SpringMVC就无法进行格式转换，需指定日期格式才能转换。</li></ul></li></ul><img src="C:\Users\橙子\AppData\Roaming\Typora\typora-user-images\image-20230214181042311.png" alt="image-20230214181042311" style="zoom:80%;" /><h6 id="③内部实现原理"><a href="#③内部实现原理" class="headerlink" title="③内部实现原理"></a>③内部实现原理</h6><p>​我们首先先来思考一个问题：</p><ul><li>前端传递字符串，后端使用日期Date接收</li><li>前端传递JSON数据，后端使用对象接收</li><li>前端传递字符串，后端使用Integer接收</li><li>后台需要的数据类型有很多种，在数据的传递过程中存在很多类型的转换</li></ul><p>​问：谁来做这个类型转换?</p><p>​答：SpringMVC</p><p>​问：SpringMVC是如何实现类型转换的?</p><p>​答：SpringMVC中提供了很多类型转换接口和实现类</p><img src="C:\Users\橙子\AppData\Roaming\Typora\typora-user-images\image-20230214183219137.png" alt="image-20230214183219137" style="zoom:80%;" /><img src="C:\Users\橙子\AppData\Roaming\Typora\typora-user-images\image-20230214183247974.png" alt="image-20230214183247974" style="zoom:80%;" /><img src="C:\Users\橙子\AppData\Roaming\Typora\typora-user-images\image-20230214183310048.png" alt="image-20230214183310048" style="zoom:80%;" /><hr><h5 id="F-响应"><a href="#F-响应" class="headerlink" title="F.响应"></a>F.响应</h5><h6 id="①引入-2"><a href="#①引入-2" class="headerlink" title="①引入"></a>①引入</h6><p>​SpringMVC接收到请求和数据后，进行一些了的处理，当然这个处理可以是转发给Service，Service层再调用Dao层完成的，不管怎样，处理完以后，都需要将结果告知给用户。</p><p>​比如：根据用户ID查询用户信息、查询用户列表、新增用户等。<br>对于响应，主要就包含两部分内容：</p><ul><li>响应页面</li><li>响应数据<ul><li>文本数据</li><li>json数据</li></ul></li></ul><p>​因为异步调用是目前常用的主流方式，所以我们需要更关注的就是如何返回JSON数据，对于其他只需要认识了解即可。</p><h6 id="②响应页面-x2F-跳转页面-了解"><a href="#②响应页面-x2F-跳转页面-了解" class="headerlink" title="②响应页面&#x2F;跳转页面(了解)"></a>②响应页面&#x2F;跳转页面(了解)</h6><p><img src="/imgs/image-20230215110329583.png" alt="image-20230215110329583"></p><img src="C:\Users\橙子\AppData\Roaming\Typora\typora-user-images\image-20230215114519158.png" alt="image-20230215114519158" style="zoom:80%;" /><h6 id="③返回文本数据-了解"><a href="#③返回文本数据-了解" class="headerlink" title="③返回文本数据(了解)"></a>③返回文本数据(了解)</h6><p>​使用@ResponseBody，方法返回值类型设置为String。</p><p><img src="/imgs/image-20230215110935952.png" alt="image-20230215110935952"></p><p>​如果不写@ResponseBody，则会将response text当成页面名去寻找，找不到报404。</p><img src="C:\Users\橙子\AppData\Roaming\Typora\typora-user-images\image-20230215114536141.png" alt="image-20230215114536141" style="zoom:80%;" /><h6 id="④响应JSON数据"><a href="#④响应JSON数据" class="headerlink" title="④响应JSON数据"></a>④响应JSON数据</h6><ul><li><p>响应POJO对象</p><p>  如果想将对象返回给前端页面，那需要将对象转换为前端能够识别的JSON数据，如何实现对象转JSON？使用@ResponseBody注解即可。方法的返回值类型写对象的类型。如：</p>  <img src="C:\Users\橙子\AppData\Roaming\Typora\typora-user-images\image-20230215121210639.png" alt="image-20230215121210639" style="zoom:80%;" />  <img src="C:\Users\橙子\AppData\Roaming\Typora\typora-user-images\image-20230215121505921.png" alt="image-20230215121505921" style="zoom:80%;" /><p>  ​</p><p>  ​@ResponseBody注解是如何将对象转换为JSON数据的呢？</p><p>  ​是因为<code>HttpMessageConverter</code>接口帮我们实现了对象与JSON之间的转换工作，我们只需要在<code>SpringMvcConfig</code>配置类上加上<code>@EnableWebMvc</code>注解即可。</p></li></ul><p>​</p><ul><li><p>响应POJO集合对象</p>  <img src="C:\Users\橙子\AppData\Roaming\Typora\typora-user-images\image-20230215121928638.png" alt="image-20230215121928638" style="zoom:80%;" /><p>  <img src="/imgs/image-20230215121941180.png" alt="image-20230215121941180"></p></li></ul><h6 id="⑤-ResponseBody说明"><a href="#⑤-ResponseBody说明" class="headerlink" title="⑤@ResponseBody说明"></a>⑤@ResponseBody说明</h6><ul><li>@respondbody：将控制器的返回值转换为前端能够识别的数据类型，然后再响应出去。如果控制器返回值类型为String，那就不需要转换，因为前端能够识别String类型数据；如果控制器返回值类型为对象，那就要需要将对象转换为JSON数据，这样前端才能识别。</li><li>该注解可以写在类上或者方法上。写在类上就是该类下的所有方法都有@ReponseBody功能。</li><li>当方法上有@ReponseBody注解后<ul><li>方法的返回值为字符串，会将其作为文本内容直接响应给前端</li><li>方法的返回值为对象，会将对象转换成JSON响应给前端<ul><li>转换功能并不是SpringMVC实现的，而是由JSON依赖的jar实现的。</li></ul></li></ul></li></ul><hr><h4 id="4-REST风格"><a href="#4-REST风格" class="headerlink" title="4.REST风格"></a>4.REST风格</h4><h5 id="A-REST简介"><a href="#A-REST简介" class="headerlink" title="A.REST简介"></a>A.REST简介</h5><h6 id="①什么是REST及其书写"><a href="#①什么是REST及其书写" class="headerlink" title="①什么是REST及其书写"></a>①什么是REST及其书写</h6><ul><li>REST是一种访问网络资源的格式，<strong>即：对网络访问路径（url）规定了一种新的书写格式。</strong><ul><li><strong>传统风格资源描述形式</strong><ul><li><a href="http://localhost/user/getById?id=1">http://localhost/user/getById?id=1</a>  查询id为1的用户信息</li><li><a href="http://localhost/user/saveUser">http://localhost/user/saveUser</a>  保存用户信息</li></ul></li><li><strong>REST风格描述形式</strong><ul><li><code>http://localhost/user/1</code></li><li><code>http://localhost/user</code></li></ul></li></ul></li><li>传统方式一般是一个请求url对应一种操作，这样做不仅麻烦，而且也不安全，通过请求的<code>URL</code>地址，就大致能推测出该<code>URL</code>实现的是什么操作，反观REST风格的描述，请求地址变简洁了，而且只看请求<code>URL</code>并不很容易能猜出来该<code>UR</code>L的具体功能，所以**<code>REST</code>的优点有：**<ul><li>隐藏资源的访问行为，无法通过地址得知该资源是何种操作</li><li>书写简化</li></ul></li><li>那么问题也随之而来，一个相同的<code>URL</code>地址既可以是增加操作，也可以是修改或者查询，那么我们该如何区分该请求到底是什么操作呢？<ul><li>按照REST风格访问资源时，使用<code>行为动作</code>区分对资源进行了何种操作，<strong>即：通过请求方式进行区分</strong><ul><li><code>http://localhost/users</code> <strong>查询</strong>全部用户信息 <strong>GET</strong>（查询）</li><li><code>http://localhost/users/1</code> <strong>查询指定</strong>用户信息 <strong>GET</strong>（查询）</li><li><code>http://localhost/users</code> <strong>添加</strong>用户信息 <strong>POST</strong>（新增&#x2F;保存）</li><li><code>http://localhost/users</code> <strong>修改</strong>用户信息 <strong>PUT</strong>（修改&#x2F;更新）</li><li><code>http://localhost/users/1</code> <strong>删除</strong>用户信息 <strong>DELETE</strong>（删除）</li><li>补充：REST提供了很多种请求方式，但SpringMVC只能识别八种，而在这八种中最常用的就是：get&#x2F;post&#x2F;put&#x2F;delete这四种</li></ul></li></ul></li></ul><h6 id="②编写REST注意事项"><a href="#②编写REST注意事项" class="headerlink" title="②编写REST注意事项"></a>②编写REST注意事项</h6><img src="C:\Users\橙子\AppData\Roaming\Typora\typora-user-images\image-20230215150743002.png" alt="image-20230215150743002" style="zoom:80%;" /><h6 id="③RESTful"><a href="#③RESTful" class="headerlink" title="③RESTful"></a>③RESTful</h6><p>​<strong>RESTful：</strong>就是使用REST风格进行编写URL的编写</p><hr><h5 id="B-RESTful入门案例"><a href="#B-RESTful入门案例" class="headerlink" title="B.RESTful入门案例"></a>B.RESTful入门案例</h5><h6 id="①环境准备"><a href="#①环境准备" class="headerlink" title="①环境准备"></a>①环境准备</h6><ul><li><p>pom.xml文件导入相关依赖</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>创建对应的配置类</p>  <img src="C:\Users\橙子\AppData\Roaming\Typora\typora-user-images\image-20230215165945908.png" alt="image-20230215165945908" style="zoom: 50%;" />  <img src="C:\Users\橙子\AppData\Roaming\Typora\typora-user-images\image-20230215170019943.png" alt="image-20230215170019943" style="zoom:50%;" /></li><li><p>编写POJO类</p>  <img src="C:\Users\橙子\AppData\Roaming\Typora\typora-user-images\image-20230215170112597.png" alt="image-20230215170112597" style="zoom: 50%;" /></li><li><p>编写UserController</p>  <img src="C:\Users\橙子\AppData\Roaming\Typora\typora-user-images\image-20230215170207288.png" alt="image-20230215170207288" style="zoom:80%;" /></li></ul><hr><h6 id="②思路分析"><a href="#②思路分析" class="headerlink" title="②思路分析"></a>②思路分析</h6><ul><li>需求：将UserController中各请求路径修改为使用REST风格编写的形式。</li><li>分析：将请求路径全部改为：&#x2F;users，再根据请求的操作选择响应的请求方式。<ul><li>查询操作 –&gt; 选择get请求</li><li>修改&#x2F;更新 –&gt; 选择put请求</li><li>新增&#x2F;保存 –&gt; 选择post请求</li><li>删除 –&gt; 选择delete请求</li></ul></li></ul><h6 id="③实现"><a href="#③实现" class="headerlink" title="③实现"></a>③实现</h6><ul><li><p>保存</p>  <img src="C:\Users\橙子\AppData\Roaming\Typora\typora-user-images\image-20230215173227669.png" alt="image-20230215173227669" style="zoom:80%;" /><p>  指定了请求方式为post后，如果是其它请求方式访问，那就会报错。</p><p>  发送POST请求与参数：</p>  <img src="C:\Users\橙子\AppData\Roaming\Typora\typora-user-images\image-20230215173503443.png" alt="image-20230215173503443" style="zoom:80%;" />  </li><li><p>删除</p><p>  将请求路径更改为<code>/users</code>，并设置当前请求方法为<code>DELETE</code></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/users&quot;,method = RequestMethod.DELETE)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">delete</span><span class="params">(Integer id)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;user delete ...&quot;</span> + id);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;user delete&#x27;&#125;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  但是现在的删除方法没有携带所要删除数据的id，所以针对RESTful的开发，如何携带&#x2F;获取数据参数?</p><ul><li><p>如何获取参数？</p><ul><li><p>由于使用REST风格后，请求参数将直接写在请求路径中，如：localhost:8080&#x2F;users&#x2F;9421，所以得在形参id前面使用<code>@PathVariable</code>注解，表示形参id的值将来自于请求路径中。那形参id的值具体在请求路径中的哪个位置呢？那就得在请求路径中标出来，如：</p><p>  <img src="/imgs/image-20230215174411518.png" alt="image-20230215174411518"></p><p>  补充知识：</p><p>  <img src="/imgs/image-20230215174528161.png" alt="image-20230215174528161"></p><p>  ​</p></li></ul><p></p></li><li><p>如何发送参数？</p><p>  直接在请求路径后面加上即可，如：localhost:8080&#x2F;users&#x2F;9421，其中9421就为参数。</p></li></ul></li><li><p>修改</p><p>  将请求路径更改为<code>/users</code>，并设置当前请求方法为<code>PUT</code></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/users&quot;,method = RequestMethod.PUT)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">update</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;user update ...&quot;</span> + user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;user update&#x27;&#125;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  在postman发送<code>PUT</code>请求<code>localhost:8080/users</code>，访问并携带参数</p>  <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;菲茨罗伊&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="string">&quot;27&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>  <img src="/imgs/image-20230215175524865.png" alt="image-20230215175524865"></p></li><li><p>根据ID查询</p><p>  将请求路径更改为<code>/users/&#123;id&#125;</code>，并设置当前请求方法为<code>GET</code></p><p>  在postman发送<code>GET</code>请求访问<code>localhost:8080/users/2077</code></p><p>  <img src="/imgs/image-20230215175640342.png" alt="image-20230215175640342"></p></li><li><p>查询所有</p><p>  将请求路径更改为<code>/users</code>，并设置当前请求方法为<code>GET</code></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;/users&quot;,method = RequestMethod.GET)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getAll</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;user getAll ...&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;user getAll&#x27;&#125;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  在postman发送<code>GET</code>请求访问<code>localhost:8080/users</code></p><p>  <img src="/imgs/image-20230215175729420.png" alt="image-20230215175729420"></p></li></ul><p>​修改完后的代码为：</p><img src="C:\Users\橙子\AppData\Roaming\Typora\typora-user-images\image-20230215180236493.png" alt="image-20230215180236493" style="zoom:80%;" /><p>​从整体代码来看，有些臃肿，好多代码都是重复的，下一小节我们就会来解决这个问题。</p><hr><h6 id="④总结"><a href="#④总结" class="headerlink" title="④总结"></a>④总结</h6><ul><li><p>将请求路径使用REST风格编写，只需修改@RequestMapping注解的value为：表名+s，再通过@RequestMapping注解的属性method指定其请求的方式，即可完成REST风格编写。</p><ul><li>不同操作选择不同的请求方式：<ul><li>查询操作 –&gt; 选择get请求</li><li>修改&#x2F;更新 –&gt; 选择put请求</li><li>新增&#x2F;保存 –&gt; 选择post请求</li><li>删除 –&gt; 选择delete请求</li></ul></li></ul></li><li><p>如果处理请求的方法中有形参，那就像这样写来获取：</p>  <img src="C:\Users\橙子\AppData\Roaming\Typora\typora-user-images\image-20230215180909090.png" alt="image-20230215180909090" style="zoom:67%;" /><p>  同时请求中的参数得写在请求路径中，如：<code>http://localhost:8080/users/2077</code></p></li><li><p>如果处理请求的方法中的形参的值是从JSON数据中获得，那在postman中发送请求的地址仍为原来的写法和做法，@RequestMapping注解中的value值仍为：表明+s，只需在方法参数前加上@RequestBody即可。</p><p>  <img src="/imgs/image-20230215181655394.png" alt="image-20230215181655394"></p></li><li><p>以后开发中都使用REST风格进行开发</p><ul><li>如果发送请求参数超过1个时，将数据封装到POJO类里，然后使用JSON格式来发送数据，接收数据时在参数前使用@RequestBody。</li></ul></li><li><p>如果发送请求参数为1个时，可以采用@PathVariable注解接收请求路径参数，通常用于传递id值。</p></li></ul><hr><h5 id="C-RESTful简化开发（标准开发）"><a href="#C-RESTful简化开发（标准开发）" class="headerlink" title="C.RESTful简化开发（标准开发）"></a>C.RESTful简化开发（标准开发）</h5><h6 id="①引入-3"><a href="#①引入-3" class="headerlink" title="①引入"></a>①引入</h6><p>​RESTful入门案例中，代码中有很多地方存在冗余，为了减少冗余就产生了本章内容。</p><p>​RESTful入门案例代码：</p><img src="C:\Users\橙子\AppData\Roaming\Typora\typora-user-images\image-20230216100225253.png" alt="image-20230216100225253" style="zoom:80%;" /><h6 id="②简化"><a href="#②简化" class="headerlink" title="②简化"></a>②简化</h6><ul><li><p>每个方法的@RequestMapping注解中都定义了访问路径&#x2F;users，重复性太高。</p><ul><li><p>解决方案：将<code>@RequestMapping</code>提到类上面，用来定义所有方法共同的访问路径。</p>  <img src="C:\Users\橙子\AppData\Roaming\Typora\typora-user-images\image-20230216101648365.png" alt="image-20230216101648365" style="zoom:80%;" /><p>  <img src="/imgs/image-20230216101718205.png" alt="image-20230216101718205"></p></li></ul></li><li><p>修改后的代码中，每个方法的@RequestMapping注解中都要使用method属性定义请求方式，重复性太高。</p><ul><li><p>解决方案：使用<code>@GetMapping</code>、<code>@PostMapping</code>、<code>@PutMapping</code>、<code>@DeleteMapping</code>代替</p><p>  <img src="/imgs/image-20230216102314423.png" alt="image-20230216102314423"></p><p>  <img src="/imgs/image-20230216102343728.png" alt="image-20230216102343728"></p></li></ul></li><li><p>上面修改过的代码中，每个方法响应json都需要加上@ResponseBody注解，重复性太高。</p><ul><li>解决方案：<ul><li>将<code>@ResponseBody</code>提到类上面，让所有的方法都有<code>@ResponseBody</code>的功能</li><li>使用<code>@RestController</code>注解替换<code>@Controller</code>与<code>@ResponseBody</code>注解，简化书写</li></ul></li></ul></li></ul><p>最终修改后的代码：</p><img src="C:\Users\橙子\AppData\Roaming\Typora\typora-user-images\image-20230216101146154.png" alt="image-20230216101146154" style="zoom:80%;" /><hr><h5 id="D-RESTful案例"><a href="#D-RESTful案例" class="headerlink" title="D.RESTful案例"></a>D.RESTful案例</h5><h6 id="①需求分析及案例步骤"><a href="#①需求分析及案例步骤" class="headerlink" title="①需求分析及案例步骤"></a>①需求分析及案例步骤</h6><p>​见<a href="https://cyborg2077.github.io/2022/09/08/SpringMVC/#%E9%A1%B5%E9%9D%A2%E8%AE%BF%E9%97%AE%E5%A4%84%E7%90%86">SpringMVC | Kyle’s Blog (cyborg2077.github.io)</a> </p><p><img src="/imgs/image-20230216125454219.png" alt="image-20230216125454219"></p><h6 id="②环境准备-1"><a href="#②环境准备-1" class="headerlink" title="②环境准备"></a>②环境准备</h6><p>​见<a href="https://cyborg2077.github.io/2022/09/08/SpringMVC/#%E9%A1%B5%E9%9D%A2%E8%AE%BF%E9%97%AE%E5%A4%84%E7%90%86">SpringMVC | Kyle’s Blog (cyborg2077.github.io)</a></p><p>​<img src="/imgs/image-20230216125552030.png" alt="image-20230216125552030"></p><h6 id="③后台接口开发"><a href="#③后台接口开发" class="headerlink" title="③后台接口开发"></a>③后台接口开发</h6><p>​<img src="/imgs/image-20230216125642859.png" alt="image-20230216125642859"></p><h6 id="④页面访问处理"><a href="#④页面访问处理" class="headerlink" title="④页面访问处理"></a>④页面访问处理</h6><ul><li><p><strong>引入</strong></p>  <img src="C:\Users\橙子\AppData\Roaming\Typora\typora-user-images\image-20230216125843461.png" alt="image-20230216125843461" style="zoom:80%;" />  <p>  ​如果想访问上图中的静态资源，如pages文件下的books.html页面，输入访问地址：htttp:&#x2F;&#x2F;localhost:8080&#x2F;pages&#x2F;books.html，页面会报404。这是为什么呢？</p><p>  ​这是因为在ServletContainersInitConfig类中设置了将所有请求拦截下来交给SpringMVC处理</p>  <img src="C:\Users\橙子\AppData\Roaming\Typora\typora-user-images\image-20230216130614822.png" alt="image-20230216130614822" style="zoom:80%;" /><p>  ​因此SpringMVC就会拿着这个请求去控制在类中找是否有请求路径匹配上该路径，结果没有匹配上，所以就报404了。</p><p>  ​那怎么办呢？</p><p>  ​我们需要重写建一个类处理这个问题。</p></li><li><p><strong>解决</strong></p><ul><li><p>在config包下新建一个类：SpringMvcSupport，让该类继承WebMvcConfigurationSupport类，重写WebMvcConfigurationSupport类里的addResourceHandlers方法（该方法的作用是：添加资源过滤）</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcSupport</span> <span class="keyword">extends</span> <span class="title class_">WebMvcConfigurationSupport</span> &#123;</span><br><span class="line">    <span class="comment">//设置静态资源访问过滤，当前类需要设置为配置类，并被扫描加载</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">//当访问/pages/xxx时候，从/pages目录下查找内容</span></span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/pages/**&quot;</span>).addResourceLocations(<span class="string">&quot;/pages/&quot;</span>);</span><br><span class="line">        <span class="comment">//当访问/js/xxx时候，从/js目录下查找内容</span></span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/js/**&quot;</span>).addResourceLocations(<span class="string">&quot;/js/&quot;</span>);</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/css/**&quot;</span>).addResourceLocations(<span class="string">&quot;/css/&quot;</span>);</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/plugins/**&quot;</span>).addResourceLocations(<span class="string">&quot;/plugins/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//registry.addResourceHandler：添加资源处理器，括号里写处理什么资源</span></span><br><span class="line"><span class="comment">//非SpringMVC的请求都应放行</span></span><br></pre></td></tr></table></figure><p>  该配置类是在config目录下，SpringMVC扫描的是controller包，所以该配置类还未生效，要想生效需要将SpringMvcConfig配置类进行修改</p><p>  <img src="/imgs/image-20230216131537544.png" alt="image-20230216131537544"></p></li><li><p>补充：对于静态的web资源，SpringMVC不需要拦截，将这些资源交给Tomcat服务器处理。</p></li></ul></li></ul><h6 id="⑤修改页面"><a href="#⑤修改页面" class="headerlink" title="⑤修改页面"></a>⑤修改页面</h6><p>​我们只需要修改<code>saveBook()</code>和<code>getAll()</code>这两个函数就行</p><ul><li>当调用<code>getAll()</code>函数时，我们需要将响应的JSON数据赋给dataList即可，而响应JSON数据我们在上一小节已经完成了</li><li>当调用<code>saveBook()</code>函数时，发送POST请求，并将formData的数据响应给后台，我们这里的操作只是在控制台输出了一下</li></ul><p>​见：<a href="https://cyborg2077.github.io/2022/09/08/SpringMVC/#%E9%A1%B5%E9%9D%A2%E8%AE%BF%E9%97%AE%E5%A4%84%E7%90%86">SpringMVC | Kyle’s Blog (cyborg2077.github.io)</a></p><p><img src="/imgs/image-20230217121341976.png" alt="image-20230217121341976"></p><p><img src="/imgs/image-20230217121354738.png" alt="image-20230217121354738"></p><p>​</p><p>​如果看不懂<code>saveBook()</code>和<code>getAll()</code>这两个函数里面代码，就打开IDEA看之前编写的web程序的前页面代码，别人写的是简化的代码。</p><hr>]]></content>
      
      
      <categories>
          
          <category> SSM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMvc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring</title>
      <link href="/2023/04/24/Spring/"/>
      <url>/2023/04/24/Spring/</url>
      
        <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><h4 id="1-为什么要学Spring"><a href="#1-为什么要学Spring" class="headerlink" title="1.为什么要学Spring"></a>1.为什么要学Spring</h4><p><img src="/imgs/image-20221209134713389.png" alt="image-20221209134713389"></p><h4 id="2-学什么"><a href="#2-学什么" class="headerlink" title="2.学什么"></a>2.学什么</h4><p>​学IoC、AOP技术（这两个技术用于简化开发）、事务处理；学Spring如何与MyBatis进行框架整合。</p><p><img src="/imgs/image-20230424213113214.png" alt="image-20230424213113214"></p><h4 id="3-如何学"><a href="#3-如何学" class="headerlink" title="3.如何学"></a>3.如何学</h4><p>​<img src="/imgs/image-20221209135618342.png" alt="image-20221209135618342"></p><h4 id="4-Spring家族和Spring发展史"><a href="#4-Spring家族和Spring发展史" class="headerlink" title="4.Spring家族和Spring发展史"></a>4.Spring家族和Spring发展史</h4><ul><li>Spring家族<ul><li>Spring不单是一门技术而是一堆技术的总称，Spring里包括了这些技术，如：Spring Framework（Spring框架，它是其它Spring技术的基础）、Spring Boot、Spring Cloud等。</li></ul></li><li>Spring发展史<ul><li>其是由IBM公司中的EJB思想发展而来的，2004年正式推出Spring1.0（使用配置文件开发），2006年推出Spring2.0（引入注解开发），2009年推出了Spring3.0（可以使用纯注解开发），2013年推出了Spring4.0（根据JDK的版本对部分API进行调整），2017年推出Spring5.0（其完全支持JDK8.0版本）</li></ul></li></ul><hr><h2 id="二、Spring-Framework"><a href="#二、Spring-Framework" class="headerlink" title="二、Spring Framework"></a>二、Spring Framework</h2><h3 id="1-框架及学路线"><a href="#1-框架及学路线" class="headerlink" title="(1).框架及学路线"></a>(1).框架及学路线</h3><h5 id="A-框架"><a href="#A-框架" class="headerlink" title="A.框架"></a>A.框架</h5><p><img src="/imgs/image-20221209170603105.png" alt="image-20221209170603105"></p><ul><li><p>核心层</p><p>  Core Container：核心容器，这个模块是Spring最核心的模块，其他的都需要依赖该模块。其装的是一个一个的对象。</p></li><li><p>AOP(Aspect Oriented Programming)：面向切面编程，它依赖核心层容器，目的是在不改变原有代码的前提下对其进行功能增强。</p></li><li><p>Aspects：AOP是思想，Aspects是对AOP思想的具体实现。</p></li><li><p>Data Access：数据访问，Spring全家桶中有对数据访问的具体实现技术。</p></li><li><p>Data Integration：数据集成，Spring支持整合其他的数据层解决方案，比如Mybatis。</p></li><li><p>Transactions：事务，Spring中事务管理是Spring AOP的一个具体实现，也是后期学习的重点内容。</p></li><li><p>Web层</p><p>  这一层的内容将在SpringMVC框架具体学习。</p></li><li><p>Test层</p><p>  Spring主要整合了Junit来完成单元测试和集成测试。</p></li></ul><h5 id="B-学习路线"><a href="#B-学习路线" class="headerlink" title="B.学习路线"></a>B.学习路线</h5><p>​Spring Framework学习路线：① –&gt; ② –&gt; ③ –&gt; ④ </p><p><img src="/imgs/image-20221209171058140.png" alt="image-20221209171058140"></p><hr><h3 id="2-核心容器"><a href="#2-核心容器" class="headerlink" title="(2).核心容器"></a>(2).核心容器</h3><h4 id="1-IOC相关内容"><a href="#1-IOC相关内容" class="headerlink" title="1.IOC相关内容"></a>1.IOC相关内容</h4><h5 id="A-概念"><a href="#A-概念" class="headerlink" title="A.概念"></a>A.概念</h5><h6 id="①引入"><a href="#①引入" class="headerlink" title="①引入"></a>①引入</h6><p>​想在业务逻辑层中使用新的BookDaoImpl2，只能将原来业务逻辑层中的BookDao bookDao &#x3D; new BookDaoImpl1() 替换成 BookDao bookDao &#x3D; new BookDaoImpl2()。要想项目发生改变，还得重新编译运行、再重新部署到Tomcat。这样一套操作下来就非常麻烦，所以就得降低业务层的耦合度。</p><p><img src="/imgs/image-20221222133627213.png" alt="image-20221222133627213"></p><h6 id="②Ioc、Ioc容器、DI"><a href="#②Ioc、Ioc容器、DI" class="headerlink" title="②Ioc、Ioc容器、DI"></a>②Ioc、Ioc容器、DI</h6><ul><li><p>Ioc（Inversion of Control）控制反转</p><p>  为降低耦合度，由主动new产生对象转为由<strong>外部</strong>提供对象，而此过程此过程中对象创建控制权由程序转移到外部，此思想称为控制反转。</p></li><li><p>Ioc容器</p><ul><li><p>Spring实现了这种思想。而Ioc概念中提到的外部就是指Spring的<strong>核心容器</strong>，因此核心容器又被称为Ioc容器。</p></li><li><p>我们将来将对象放到容器中，Ioc容器就会在我们需要的时候自动将对象给我们。</p></li><li><p>IOC容器负责对象的创建、初始化等一系列工作，其中包含了数据层和业务层的类对象，被创建或被管理的对象在IOC容器中统称为<strong>Bean</strong>。</p></li></ul></li><li><p>DI（Dependency Injection）依赖注入</p><p>  在容器中建立bean与bean之间的依赖关系的整个过程，称为依赖注入。如：</p><p>  <img src="/imgs/image-20221222140136077.png" alt="image-20221222140136077"></p><p>  service对象需要依赖dao对象，因此我们需要手动将service对象与dao对象进行捆绑，形成一种依赖关系，当我们使用service对象时，就会自动将dao对象也传给我们了。</p></li><li><p>  <img src="/imgs/image-20221222140853003.png" alt="image-20221222140853003"></p></li></ul><hr><h5 id="B-Ioc入门案例"><a href="#B-Ioc入门案例" class="headerlink" title="B.Ioc入门案例"></a>B.Ioc入门案例</h5><h6 id="①思路分析"><a href="#①思路分析" class="headerlink" title="①思路分析"></a>①思路分析</h6><img src="/imgs/image-20230424213158959.png" alt="image-20230424213158959" style="zoom:67%;" /><h6 id="②实现步骤"><a href="#②实现步骤" class="headerlink" title="②实现步骤"></a>②实现步骤</h6><p>1.导入Spring依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.创建Spring配置文件，配置对应类作为Spring管理的bean</p><ol><li><p>在resource下右键 –&gt; new –&gt; spring config –&gt; 命名为：applicationContext.xml。</p></li><li><p>使用bean标签。其里面有两个属性：</p><ul><li><p>class：写需要放到Ioc容器里的对象的全类名</p></li><li><p>id：用于唯一标识该bean对象。</p></li><li><p>例子：</p><p>  <img src="/imgs/image-20221222162003002.png" alt="image-20221222162003002"></p></li></ul></li></ol><p>3.获取Ioc容器对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Spring配置文件文件名 对象名 = new ClassPathXml Spring配置文件文件名(&quot;&quot;spring 配置文件的文件名.xml&quot;&quot;);</span></span><br><span class="line"><span class="comment">//例子：</span></span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;spring 配置文件的文件名.xml&quot;</span>);</span><br></pre></td></tr></table></figure><p>4.获取Ioc容器中的bean对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用Ioc容器对象中的getBean(&quot;bean对象的id&quot;)</span></span><br><span class="line"><span class="type">BookService</span> <span class="variable">bookService</span> <span class="operator">=</span> (BookService) context.getBean(<span class="string">&quot;bookService&quot;</span>);</span><br></pre></td></tr></table></figure><p>5.至此Ioc快速入门结束。</p><hr><h5 id="C-DI快速入门"><a href="#C-DI快速入门" class="headerlink" title="C.DI快速入门"></a>C.DI快速入门</h5><h6 id="①思路分析-1"><a href="#①思路分析-1" class="headerlink" title="①思路分析"></a>①思路分析</h6><img src="/imgs/image-20230424213235698.png" alt="image-20230424213235698" style="zoom:67%;" /><h6 id="②实现步骤-1"><a href="#②实现步骤-1" class="headerlink" title="②实现步骤"></a>②实现步骤</h6><ol><li><p>删除BookServiceImpl中使用new的方式创建的dao对象</p> <img src="/imgs/image-20230424213245221.png" alt="image-20230424213245221" style="zoom:67%;" /> </li><li><p>在BookServiceImpl中提供bookDao的setter方法</p> <img src="/imgs/image-20230424213307440.png" alt="image-20230424213307440" style="zoom:67%;" /><p> setBookDao方法会被谁调用？答案：Ioc容器</p></li><li><p>在配置文件中添加依赖注入的配置</p><p> 由于是在BookServiceImpl中调用Dao对象，所以就在Spring配置文件中bean对象BookServiceImpl里绑定dao对象。</p><p> <img src="/imgs/image-20221222174813428.png" alt="image-20221222174813428"></p><p> 如果对property标签中的name属性和ref属性不清楚，可以看如下图：</p><p> <img src="/imgs/image-20221222175446854.png" alt="image-20221222175446854"></p></li><li><p>至此DI快速入门结束</p></li></ol><hr><h5 id="D-bean基础配置"><a href="#D-bean基础配置" class="headerlink" title="D.bean基础配置"></a>D.bean基础配置</h5><h6 id="①bean别名"><a href="#①bean别名" class="headerlink" title="①bean别名"></a>①bean别名</h6><img src="/imgs/image-20230424213336864.png" alt="image-20230424213336864" style="zoom:80%;" /><h6 id="②bean作用范围"><a href="#②bean作用范围" class="headerlink" title="②bean作用范围"></a>②bean作用范围</h6><ol><li><p>什么是bean的作用范围？</p><p> 控制bean实例创建的数量，即：在获取bean对象时，此对象与上一次获取的对象的地址不一样，或与上一次获取的对象的地址值一样。</p></li><li><p>如何设置bean的作用范围</p><p> 通过在bean标签中添加scope属性</p> <img src="/imgs/image-20230424213354750.png" alt="image-20230424213354750" style="zoom:80%;" /> </li><li><p>为什么Spring中bean的作用范围默认为单例？</p><p> ①如果作用范围为非单例，则每一次获取bean对象，Ioc容器就会创建一次该bean对象的实例，这样就会导致容器中出现很多实例，容器容量就会受到挑战。</p><p> ②我们一般会将dao层（数据库层对象）的对象等放到Ioc容器中，我们一般只会调用这些dao层对象中的方法，因此也就没有必要造不同bean对象的多个实例。</p></li><li><p> <img src="/imgs/image-20221223130304673.png" alt="image-20221223130304673"></p><p> <img src="/imgs/image-20221223130854910.png" alt="image-20221223130854910"></p></li></ol><h5 id="E-bean实例化"><a href="#E-bean实例化" class="headerlink" title="E.bean实例化"></a>E.bean实例化</h5><h6 id="①方式一：空参构造器"><a href="#①方式一：空参构造器" class="headerlink" title="①方式一：空参构造器"></a>①方式一：空参构造器</h6><p>​如果像下面那样格式配置bean对象，则Ioc容器在创建bean对象时，使用bean对象所在类的<strong>空参构造器</strong>来创建对象的。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>​如果bean对象所在类没有提供空参构造器，那么程序在运行时会报<strong>BeanCreationException</strong>。</p><h6 id="②方式二：静态工厂（了解）"><a href="#②方式二：静态工厂（了解）" class="headerlink" title="②方式二：静态工厂（了解）"></a>②方式二：静态工厂（了解）</h6><p>​如果bean对象是通过静态工厂的形式创建对象，</p><p><img src="/imgs/image-20221223162241746.png" alt="image-20221223162241746"></p><p>​则在配置bean对象时，就得像下面那样写：</p><p><img src="/imgs/image-20221223162508462.png" alt="image-20221223162508462"></p><p>​</p><h6 id="③方式三：实例工厂（了解）"><a href="#③方式三：实例工厂（了解）" class="headerlink" title="③方式三：实例工厂（了解）"></a>③方式三：实例工厂（了解）</h6><p>​如果使用下图中实例工厂的方式创建对象，<img src="/imgs/image-20221223164538675.png" alt="image-20221223164538675"></p><p>​则在配置bean时，就得这样写：</p><p><img src="/imgs/image-20221223165503978.png" alt="image-20221223165503978"></p><p>​测试：</p><p><img src="/imgs/image-20221223165612561.png" alt="image-20221223165612561"></p><h6 id="④方式四：实例工厂–改进（理解掌握）"><a href="#④方式四：实例工厂–改进（理解掌握）" class="headerlink" title="④方式四：实例工厂–改进（理解掌握）"></a>④方式四：实例工厂–改进（理解掌握）</h6><p>​方式三中，在配置bean时，存在以下问题：</p><p><img src="/imgs/image-20230424213429597.png" alt="image-20230424213429597"></p><p>​因此Spring针对这些问题，作出了改进。</p><p>​实现步骤：</p><ol><li><p>重新造一个实例工厂。该工厂类需继承FactoryBean接口，并重写两个方法。</p><p> <img src="/imgs/image-20221223181639044.png" alt="image-20221223181639044"></p><p> FactoryBean接口中还有一个方法：isSingleton()</p><p> ​①该方法可以不重写</p><p> ​②该方法的作用：设置创建的bean对象是否为单例</p><p> ​如果想设置为非单例，则需重写isSingleton()</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> ​如果想设置为单例，则不需要重新该方法，因为该方法默认返回的就是true。</p></li><li><p>配置bean</p><p> <img src="/imgs/image-20221223181917283.png" alt="image-20221223181917283"></p></li><li><p>完成</p></li></ol><p>​<strong>这种配置方式在Spring去整合其他框架的时候会被用到，所以这种方式需要我们理解掌握。</strong></p><hr><h5 id="F-bean生命周期"><a href="#F-bean生命周期" class="headerlink" title="F.bean生命周期"></a>F.bean生命周期</h5><h6 id="①bean生命周期"><a href="#①bean生命周期" class="headerlink" title="①bean生命周期"></a>①bean生命周期</h6><p>​bean从创建到销毁的整个过程。</p><p><img src="/imgs/image-20221224155358902.png" alt="image-20221224155358902"></p><h6 id="②bean生命周期控制"><a href="#②bean生命周期控制" class="headerlink" title="②bean生命周期控制"></a>②bean生命周期控制</h6><p>​bean生命周期控制：在bean创建后到销毁前做一些事请。</p><ul><li><p>实现方式一：配置文件</p><ol><li><p>在bean对象所在类，里写两个方法：init()、destory()，分别代表在bean对象创建后进行初始化处理、在bean对象销毁前进行的操作。</p><p> <img src="/imgs/image-20221224143350212.png" alt="image-20221224143350212"></p></li><li><p>在配置文件中设置</p><p> <img src="/imgs/image-20221224143434785.png" alt="image-20221224143434785"></p><p> 这样设置完后，init()、destory()就会自动执行。</p></li><li><p>测试</p><p> <img src="/imgs/image-20221224143744234.png" alt="image-20221224143744234"></p><p> 测试结果中并没有执行destory方法，这是因为：程序结束后并没给机会给bean对象进行销毁操作。要想执行我们定义的destory方法，得调用容器对象（图中的ctx）中的close方法，而close方法在ApplicationContext接口中并没有定义，只在其子类中有定义，所以上图中的代码就变成这样：</p><p> <img src="/imgs/image-20221224144150770.png" alt="image-20221224144150770"></p><p> 这样做就能执行我们定义的destory方法了。</p><p> 但调用close方法属于暴力关闭容器的方式，所以我们也可以调用容器对象中的注册钩子方法来实现。注册钩子方法：该方法的作用就是在程序关闭之前，先将容器关闭掉。</p><p> <img src="/imgs/image-20221224144708464.png" alt="image-20221224144708464"></p><p> 补充：我们可以在程序中的任意位置调用注册钩子的方法。</p></li></ol><p>  总结：将来Tomcat会帮我们完成关闭容器的操作，所以对于关闭容器的close方法、注册钩子方法，我们了解即可。</p></li><li><p>实现方式二（了解）：bean对象所在类实现InitializingBean, DisposableBean接口</p><p>  这种方式是对方式一的简化，省去了在bean标签中设置init-method、destroy-method。</p><p>  <img src="/imgs/image-20230424214750024.png" alt="image-20230424214750024"></p><p>  程序在设置完bean对象的属性后就会自动执行afterPropertiesSet()方法进行bean的初始化操作，在容器销毁时就会自动执行destory方法，进行相应操作。</p></li></ul><hr><h4 id="2-DI相关内容"><a href="#2-DI相关内容" class="headerlink" title="2.DI相关内容"></a>2.DI相关内容</h4><h5 id="A-概述"><a href="#A-概述" class="headerlink" title="A.概述"></a>A.概述</h5><img src="/imgs/image-20230424214835715.png" alt="image-20230424214835715" style="zoom:80%;" /><h5 id="B-依赖注入方式–setter注入"><a href="#B-依赖注入方式–setter注入" class="headerlink" title="B.依赖注入方式–setter注入"></a>B.依赖注入方式–setter注入</h5><h6 id="①引用类型"><a href="#①引用类型" class="headerlink" title="①引用类型"></a>①引用类型</h6><p><img src="/imgs/image-20221224165425695.png" alt="image-20221224165425695"></p><h6 id="②简单类型"><a href="#②简单类型" class="headerlink" title="②简单类型"></a>②简单类型</h6><p>​简单类型（基本数据类型+String）</p><p><img src="/imgs/image-20221224171527451.png" alt="image-20221224171527451"></p><hr><h5 id="C-依赖注入方式–构造器注入"><a href="#C-依赖注入方式–构造器注入" class="headerlink" title="C.依赖注入方式–构造器注入"></a>C.依赖注入方式–构造器注入</h5><h6 id="①引用类型-1"><a href="#①引用类型-1" class="headerlink" title="①引用类型"></a>①引用类型</h6><img src="/imgs/image-20230424214907555.png" alt="image-20230424214907555" style="zoom:80%;" /><p>​</p><h6 id="②简单类型-1"><a href="#②简单类型-1" class="headerlink" title="②简单类型"></a>②简单类型</h6><p>​简单类型（基本数据类型+String）</p><p><img src="/imgs/image-20221224175210101.png" alt="image-20221224175210101"></p><p>​</p><h5 id="D-依赖注入方式选择"><a href="#D-依赖注入方式选择" class="headerlink" title="D.依赖注入方式选择"></a>D.依赖注入方式选择</h5><p>​如果使用别人写的bean，那就看别人写的bean中提供什么，如果提供了setter和构造器，那就选setter注入；如果只提供构造器，那就用构造器注入。</p><p>​自己开发过程中就使用setter注入。</p><hr><h5 id="E-依赖自动装配"><a href="#E-依赖自动装配" class="headerlink" title="E.依赖自动装配"></a>E.依赖自动装配</h5><h6 id="①概述"><a href="#①概述" class="headerlink" title="①概述"></a>①概述</h6><p>​引入：手动实现依赖注入比较麻烦，那有没有自动完成依赖注入的功能呢？答案是有的，Spring就实现了自动完成依赖注入的功能。</p><p>​自动装配：IOC容器根据bean所依赖的资源在容器中<strong>自动查找并注入到bean</strong>中的过程称为<strong>自动装配</strong>。</p><p>​自动装配方式：①按类型（这种方式常用） ②按名称</p><p>​</p><h6 id="②实现"><a href="#②实现" class="headerlink" title="②实现"></a>②实现</h6><ol><li><p>在bean所在类写对应set方法。</p> <img src="/imgs/image-20230424215005517.png" alt="image-20230424215005517" style="zoom:80%;" /></li><li><p>在bean标签中使用autowire属性。</p><ol><li><p>按类型装配（推荐使用）</p><p> <img src="/imgs/image-20230424215022495.png" alt="image-20230424215022495"></p><p> 注意：</p><ol><li>既然是按类型注入了，那么bean对象的id属性写不写都无所谓了。</li><li>需要注入属性的类中对应属性的 setter 方法不能省略。</li><li>被注入的对象必须要被Spring的IOC容器管理，不然自动装配失败。</li><li>按照类型在Spring的IOC容器中如果找到多个对象，会报 NoUniqueBeanDefinitionException。</li></ol></li><li><p>按名称装配（不推荐使用）</p><p> <img src="/imgs/image-20230424215031081.png" alt="image-20230424215031081"></p><p> 注意：</p><ol><li>根据类中属性的名字来查找Ioc容器中是否有与其一样的id bean对象。</li><li>当找不到时，会注入Nul。</li></ol></li></ol></li></ol><h6 id="③补充说明"><a href="#③补充说明" class="headerlink" title="③补充说明"></a>③补充说明</h6><p><img src="/imgs/image-20230104173549292.png" alt="image-20230104173549292"></p><hr><h5 id="F-集合注入"><a href="#F-集合注入" class="headerlink" title="F.集合注入"></a>F.集合注入</h5><h6 id="①引入-1"><a href="#①引入-1" class="headerlink" title="①引入"></a>①引入</h6><p>​数组和集合的注入是不能实现依赖自动装配的，所以我们得学如何利用setter注入的方式实现数组和集合注入。</p><h6 id="②实现-1"><a href="#②实现-1" class="headerlink" title="②实现"></a>②实现</h6><p>​环境准备：</p><img src="/imgs/image-20230424215056586.png" alt="image-20230424215056586" style="zoom:67%;" /><img src="/imgs/image-20230424215113111.png" alt="image-20230424215113111" style="zoom:67%;" /><ul><li><p>数组注入</p><p>  <img src="/imgs/image-20230105142635082.png" alt="image-20230105142635082"></p></li><li><p>List注入</p><p>  <img src="/imgs/image-20230105142658517.png" alt="image-20230105142658517"></p></li><li><p>Set注入</p><p>  <img src="/imgs/image-20230105142729594.png" alt="image-20230105142729594"></p></li><li><p>Map注入</p><p>  <img src="/imgs/image-20230105142824050.png" alt="image-20230105142824050"></p></li><li><p>Properties注入</p><p>  <img src="/imgs/image-20230105142948020.png" alt="image-20230105142948020"></p></li></ul><h6 id="③说明"><a href="#③说明" class="headerlink" title="③说明"></a>③说明</h6><ol><li>集合中要添加引用类型，只需要把<code>&lt;value&gt;</code>标签改成<code>&lt;bean ref=&quot;beanid&quot;&gt;</code>标签，这种方式用的比较少。</li><li>总的来说，集合注入在开发中很少使用，一般都是在框架的初始化时使用。</li></ol><hr><h4 id="3-IOC-x2F-DI配置管理第三方bean"><a href="#3-IOC-x2F-DI配置管理第三方bean" class="headerlink" title="3.IOC&#x2F;DI配置管理第三方bean"></a>3.IOC&#x2F;DI配置管理第三方bean</h4><h5 id="A-管理思路"><a href="#A-管理思路" class="headerlink" title="A.管理思路"></a>A.管理思路</h5><ol><li>先在pom.xml文件中导入，bean对象所需依赖。</li><li>观察该bean对象中的构造器及set方法，来选择使用构造器注入还是setter注入。</li><li>在IOC容器中编写bean对象。（如果不知道该bean对象的名字，就上网查）</li></ol><h5 id="B-例子"><a href="#B-例子" class="headerlink" title="B.例子"></a>B.例子</h5><p>​如：数据源Druid(德鲁伊)，其bean对象是：DruidDataSource。（如果不知道bean对象的名字，就上网查）</p><p>​实现步骤：</p><ol><li><p>先在pom.xml文件中导入bean对象所依赖的jar包。</p><p> <img src="/imgs/image-20230424215147588.png" alt="image-20230424215147588"></p></li><li><p>看一下bean对象 DruidDataSource 中的源码，来判断将来使用的是setter注入还是构造器注入。</p><p> bean对象 DruidDataSource 中的构造器如下：</p><p> <img src="/imgs/image-20230105155558861.png" alt="image-20230105155558861"></p><p> Druid是用来连接数据库的，连接数据库就需要知道：url（连接哪个数据库）、username、password等信息，显然无法通过构造器的形式就能配置完连接数据库所需要的信息，因此将来只能使用setter注入。而bean对象 DruidDataSource 中确实通过了关于username、password等属性的set方法。</p></li><li><p>在IOC容器中编写bean对象。</p><p> <img src="/imgs/image-20230105160140296.png" alt="image-20230105160140296"></p></li><li><p>完成。</p></li></ol><h5 id="C-加载properties文件"><a href="#C-加载properties文件" class="headerlink" title="C.加载properties文件"></a>C.加载properties文件</h5><h6 id="①引入-2"><a href="#①引入-2" class="headerlink" title="①引入"></a>①引入</h6><p>​上面的例子中，在编写bean对象时，我们直接将数据库的连接信息写到了bean对象中，而之前我们都是将数据库的连接信息写到一个配置文件中，那如何在bean对象里加载这些配置文件呢？</p><h6 id="②实现-2"><a href="#②实现-2" class="headerlink" title="②实现"></a>②实现</h6><p>​环境准备：</p><p><img src="/imgs/image-20230424215214860.png" alt="image-20230424215214860"></p><p>​</p><p>​<strong>开始：</strong></p><ol><li><p>在spring配置文件中加载配置文件。</p><ol><li><p>在spring配置文件中开启一个新的空间 context。</p><p> <img src="/imgs/image-20230424215222865.png" alt="image-20230424215222865"></p></li><li><p>在新开启的空间中加载需要的配置文件</p><p> <img src="/imgs/image-20230424215229482.png" alt="image-20230424215229482"></p><p> 当有多个properties配置文件需要被加载，该如何配置？见下面 补充：2。</p></li></ol></li><li><p>使用属性占位符${ } 读取properties配置文件中的属性。</p><p> <img src="/imgs/image-20230424215235940.png" alt="image-20230424215235940"></p></li><li><p>完成。</p></li></ol><h6 id="③补充"><a href="#③补充" class="headerlink" title="③补充"></a>③补充</h6><p>​1.</p><img src="/imgs/image-20230424215302964.png" alt="image-20230424215302964" style="zoom:67%;" /><p>​<img src="/imgs/image-20230424215312650.png" alt="image-20230424215312650" style="zoom: 80%;" /></p><p>​</p><p>​2.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--方式一 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;jdbc.properties,jdbc2.properties&quot;</span> <span class="attr">system-properties-mode</span>=<span class="string">&quot;NEVER&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--方式二--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;*.properties&quot;</span> <span class="attr">system-properties-mode</span>=<span class="string">&quot;NEVER&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--方式三 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:*.properties&quot;</span> <span class="attr">system-properties-mode</span>=<span class="string">&quot;NEVER&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--方式四--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath*:*.properties&quot;</span> <span class="attr">system-properties-mode</span>=<span class="string">&quot;NEVER&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--system-properties-mode=&quot;NEVER&quot;的说明见 补充：1--&gt;</span></span><br></pre></td></tr></table></figure><p>​说明：</p><ol><li>方式一：可以实现，如果配置文件多的话，则需要写很多东西。</li><li>方式二：*.properties 代表所有以properties结尾的文件都会被加载，可以解决方式一的问题，但是不标准。</li><li>方式三：方式二的标准写法。classpath：代表的是从根路径下开始查找，但是只能查询当前项目的根路径。</li><li>方式四：不仅可以加载当前项目还可以加载当前项目所依赖的所有项目的根路径下的properties配置文件。</li></ol><hr><h4 id="4-核心容器"><a href="#4-核心容器" class="headerlink" title="4.核心容器"></a>4.核心容器</h4><h5 id="A-获取容器对象的两种方式"><a href="#A-获取容器对象的两种方式" class="headerlink" title="A.获取容器对象的两种方式"></a>A.获取容器对象的两种方式</h5><p><img src="/imgs/image-20230424215354115.png" alt="image-20230424215354115"></p><h5 id="B-获取bean对象的三种方式"><a href="#B-获取bean对象的三种方式" class="headerlink" title="B.获取bean对象的三种方式"></a>B.获取bean对象的三种方式</h5><p><img src="/imgs/image-20230424215403796.png" alt="image-20230424215403796"></p><h5 id="C-容器类层次结构"><a href="#C-容器类层次结构" class="headerlink" title="C.容器类层次结构"></a>C.容器类层次结构</h5><p><img src="/imgs/image-20230424215423906.png" alt="image-20230424215423906"></p><p>总结：</p><ol><li>ApplicataionContext接口的顶层接口是BeanFactory。</li><li>我们也可以BeanFactory接口来获取容器对象（但现在已经不这样做了），BeanFactory创建完毕后，所有的bean对象均为延迟加载。</li><li>通过ApplicationContext接口创建容器对象时，所有的bean对象均为立即加载。</li></ol><h4 id="5-核心容器总结"><a href="#5-核心容器总结" class="headerlink" title="5.核心容器总结"></a>5.核心容器总结</h4><h5 id="A-容器相关"><a href="#A-容器相关" class="headerlink" title="A.容器相关"></a>A.容器相关</h5><p><img src="/imgs/image-20230108162435652.png" alt="image-20230108162435652"></p><h5 id="B-bean相关"><a href="#B-bean相关" class="headerlink" title="B.bean相关"></a>B.bean相关</h5><p><img src="/imgs/image-20230424215449208.png" alt="image-20230424215449208"></p><h5 id="C-依赖注入相关"><a href="#C-依赖注入相关" class="headerlink" title="C.依赖注入相关"></a>C.依赖注入相关</h5><p><img src="/imgs/image-20230424215508976.png" alt="image-20230424215508976"></p><p>​如果不懂，详见笔记：“DI相关内容”。</p><hr><h3 id="3-IOC-x2F-DI注解开发"><a href="#3-IOC-x2F-DI注解开发" class="headerlink" title="(3).IOC&#x2F;DI注解开发"></a>(3).IOC&#x2F;DI注解开发</h3><h4 id="1-引入"><a href="#1-引入" class="headerlink" title="1.引入"></a>1.引入</h4><p>​Spring的IOC&#x2F;DI对应的配置开发就已经讲解完成，但是使用起来相对来说还是比较复杂的，复杂的地方在<code>配置文件</code>。<br>Spring到底是如何简化代码开发的呢?<br>要想真正简化开发，就需要用到Spring的注解开发，Spring对注解支持的版本历程:</p><ul><li>2.0版开始支持注解</li><li>2.5版注解功能趋于完善</li><li>3.0版支持纯注解开发</li></ul><p>关于注解开发，这里会讲解两块内容注解开发定义bean和纯注解开发。<br>注解开发定义bean用的是2.5版提供的注解，纯注解开发用的是3.0版提供的注解。</p><hr><h4 id="2-注解开发定义bean"><a href="#2-注解开发定义bean" class="headerlink" title="2.注解开发定义bean"></a>2.注解开发定义bean</h4><h5 id="A-环境准备"><a href="#A-环境准备" class="headerlink" title="A.环境准备"></a>A.环境准备</h5><ol><li><p>创建一个maven项目。</p></li><li><p>在pom.xml里添加spring依赖。</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在resources文件下添加applicationContext.xml spring配置文件。</p><p> 在resource下右键 –&gt; new –&gt; spring config –&gt; 命名为：applicationContext.xml。</p></li></ol><h5 id="B-注解开发定义bean实现"><a href="#B-注解开发定义bean实现" class="headerlink" title="B.注解开发定义bean实现"></a>B.注解开发定义bean实现</h5><ol><li><p>在需要被IOC容器管理的bean对象所在类的上面<strong>使用 @Component 注解</strong>。</p><p> 格式：<code>@Component(&quot;写bean的id&quot;)</code></p><p> 如：</p><p> <img src="/imgs/image-20230424220825573.png" alt="image-20230424220825573"></p><p> 补充：</p><p> ①如果在写@Component注解时没有配bean的 id ，则默认其 id 为当前类名首字母小，然后通过默认的bean id来获取bean对象，当然也可以通过类型来获取bean对象（见笔记：核心容器 –&gt; 核心容器–&gt; 获取bean对象的三种方式）。</p><p> ②通过注解的方式定义bean就代替了原来在spring配置文件中定义bean的方式。</p></li><li><p>配置Spring的注解包扫描。</p><p> 为了让Spring框架能够扫描到写在类上的注解，需要在配置文件上进行包扫描。</p><p> <img src="/imgs/image-20230424220839841.png" alt="image-20230424220839841"></p><p> 注意：在配置注解包扫描之前要先配置一个新的空间 context（上图中的①），然后再配置注解包扫描（上图中的②）。</p><p> 说明：</p><ul><li>component：组件，Spring将管理的bean视作自己的一个组件。</li><li>scan：扫描</li><li>base-package指定Spring框架扫描的包路径，它会扫描指定包及其子包中的所有类上的注解。</li><li>包路径越多如：com.blog.dao.impl，扫描的范围越小速度越快</li><li>包路径越少如：com.blog，扫描的范围越大速度越慢</li><li>一般扫描到项目的组织名称即Maven的groupId下如：com.blog即可。</li></ul><p> 补充：</p><p> <img src="/imgs/image-20230424220850887.png" alt="image-20230424220850887"></p></li></ol><hr><h4 id="3-纯注解开发"><a href="#3-纯注解开发" class="headerlink" title="3.纯注解开发"></a>3.纯注解开发</h4><h5 id="A-引入"><a href="#A-引入" class="headerlink" title="A.引入"></a>A.引入</h5><p>​为了进一步简化开发，我们将使用配置类来代替配置文件，达到简化开发目的，如何编写配置类呢？见下面。</p><h5 id="B-环境准备"><a href="#B-环境准备" class="headerlink" title="B.环境准备"></a>B.环境准备</h5><p>​在pom.xml里添加spring依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="C-纯注解开发实现"><a href="#C-纯注解开发实现" class="headerlink" title="C.纯注解开发实现"></a>C.纯注解开发实现</h5><ol><li><p>在Java文件夹下，<strong>新建一个包com.zzc.config</strong>用于放配置文件。在该包下<strong>建一个类，命名为SpringConfig</strong>。</p></li><li><p>在刚才新建的类上面使用 @Configuration 注解、@ComponentScan注解</p><p> <img src="/imgs/image-20230424220901903.png" alt="image-20230424220901903"></p><p> 说明：</p><p> ①@Configuration注解，将其标识为一个配置类，用于替换掉applicationContext.XML配置文件。</p><p> ②@ComponentScan用于替换原配置文件中的包扫描&lt;context:component-scan base-package&#x3D;””&#x2F;&gt;。</p></li><li><p>使用注解开发定义bean。（不懂？见笔记IOC&#x2F;DI注解开发 –&gt; 注解开发定义bean）</p></li><li><p>获取容器对象。使用<strong>AnnotationConfigApplicationContext</strong>类获取容器对象。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AnnotationConfigApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(spring配置类类名.class);</span><br><span class="line"><span class="comment">//例子：</span></span><br><span class="line"><span class="type">AnnotationConfigApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br></pre></td></tr></table></figure></li><li><p>获取bean对象。（跟以前一样）</p></li><li><p>完成。</p></li></ol><p>​补充说明：</p><p>​<img src="/imgs/image-20230424220914757.png" alt="image-20230424220914757"></p><hr><h4 id="4-注解开发bean的作用范围和生命周期"><a href="#4-注解开发bean的作用范围和生命周期" class="headerlink" title="4.注解开发bean的作用范围和生命周期"></a>4.注解开发bean的作用范围和生命周期</h4><h5 id="A-bean的作用范围"><a href="#A-bean的作用范围" class="headerlink" title="A.bean的作用范围"></a>A.bean的作用范围</h5><p>​bean的作用范围：规定bean是单例还是非单例</p><p>​在bean对象所在类上面使用@scope注解即可。scope的值可以为：singleton（单例），prototype（非单例）。</p><p><img src="/imgs/image-20230424220923504.png" alt="image-20230424220923504"></p><p>​如果不写@Sope注解或写@Scope注解但没标名是singleton、prototype，这种情况下默认是singleton。</p><h5 id="B-bean的生命周期"><a href="#B-bean的生命周期" class="headerlink" title="B.bean的生命周期"></a>B.bean的生命周期</h5><p>​在bean对象所在类里声明两个方法。（这两个方法名可以随便取）</p><img src="C:\Users\橙子\AppData\Roaming\Typora\typora-user-images\image-20230110115439171.png" alt="image-20230110115439171" style="zoom:80%;" /><p>​然后分别在这两个方法上面<strong>使用@PostConstruct 和 @PreDestroy注解即可。用于表明这两个方法分别为初始化方法和销毁方法。</strong></p><img src="/imgs/image-20230424220953700.png" alt="image-20230424220953700" style="zoom:67%;" /><h5 id="C-补充"><a href="#C-补充" class="headerlink" title="C.补充"></a>C.补充</h5><p><img src="/imgs/image-20230110120116362.png" alt="image-20230110120116362"></p><hr><h4 id="5-注解开发依赖注入"><a href="#5-注解开发依赖注入" class="headerlink" title="5.注解开发依赖注入"></a>5.注解开发依赖注入</h4><h5 id="A-引入-1"><a href="#A-引入-1" class="headerlink" title="A.引入"></a>A.引入</h5><p>​在纯注解开发阶段，spring只提供了自动装配的注入方式，因为setter注入及构造器注入不再符合简化开发的理念，所以spring就把setter注入及构造器注入给阉割掉了。</p><h5 id="B-注解实现按照类型注入"><a href="#B-注解实现按照类型注入" class="headerlink" title="B.注解实现按照类型注入"></a>B.注解实现按照类型注入</h5><p>​使用**@Autowired注解<strong>，并且</strong>不用写对应的set方法**，如：</p><img src="/imgs/image-20230424221008755.png" alt="image-20230424221008755" style="zoom:67%;" /><p>​<strong>注意：</strong>使用自动装配时，<strong>bean对象所在的类要提供无参的构造器</strong>，不然IOC容器无法创造该bean对象。</p><p><img src="/imgs/image-20230424221023146.png" alt="image-20230424221023146"></p><hr><h5 id="C-注解实现按照名称注入"><a href="#C-注解实现按照名称注入" class="headerlink" title="C.注解实现按照名称注入"></a>C.注解实现按照名称注入</h5><p>​使用@Autowired 和 @Qualifier注解，并且也不需要对应的set方法，如：</p><img src="/imgs/image-20230424221036509.png" alt="image-20230424221036509" style="zoom:67%;" /><p>​注意：</p><p>​①**@Qualifier不能独立使用，必须和@Autowired一起使用**</p><p>​②<strong>注意：</strong>使用自动装配时，<strong>bean对象所在的类要提供无参的构造器</strong>，不然IOC容器无法创造该bean对象。</p><hr><h5 id="D-简单数据类型注入"><a href="#D-简单数据类型注入" class="headerlink" title="D.简单数据类型注入"></a>D.简单数据类型注入</h5><p>​使用@value注解，如：</p><p><img src="/imgs/image-20230424221050237.png" alt="image-20230424221050237"></p><p>​简单数据类型：int、string、char、boolean等。</p><hr><h5 id="E-注解读取properties配置文件"><a href="#E-注解读取properties配置文件" class="headerlink" title="E.注解读取properties配置文件"></a>E.注解读取properties配置文件</h5><h6 id="①环境准备"><a href="#①环境准备" class="headerlink" title="①环境准备"></a>①环境准备</h6><p>​<img src="/imgs/image-20230424221100366.png" alt="image-20230424221100366" style="zoom:67%;" /></p><h6 id="②实现-3"><a href="#②实现-3" class="headerlink" title="②实现"></a>②实现</h6><ol><li><p>在<strong>spring配置类</strong>上面<strong>使用 @PropertySource 注解</strong>，再写上配置文件的路径（从resources下开始写）。</p><p> <img src="/imgs/image-20230424221119598.png" alt="image-20230424221119598"></p></li><li><p>使用 <strong>${ }</strong> 读取配置文件中的数据，如：</p><p> <img src="/imgs/image-20230424221126651.png" alt="image-20230424221126651"></p></li></ol><h6 id="③补充说明-1"><a href="#③补充说明-1" class="headerlink" title="③补充说明"></a>③补充说明</h6><img src="/imgs/image-20230424221140015.png" alt="image-20230424221140015" style="zoom:67%;" /><hr><h4 id="6-IOC-x2F-DI注解开发管理第三方bean"><a href="#6-IOC-x2F-DI注解开发管理第三方bean" class="headerlink" title="6.IOC&#x2F;DI注解开发管理第三方bean"></a>6.IOC&#x2F;DI注解开发管理第三方bean</h4><h5 id="A-管理第三方bean"><a href="#A-管理第三方bean" class="headerlink" title="A.管理第三方bean"></a>A.管理第三方bean</h5><h6 id="①环境准备-1"><a href="#①环境准备-1" class="headerlink" title="①环境准备"></a>①环境准备</h6><p>​在pom.xml文件中导入被管理bean所需要的jar包。如：此次需要管理的是阿里公司提供的数据源druid中的 DruidDataSource对象。</p><p><img src="/imgs/image-20230424221156814.png" alt="image-20230424221156814"></p><h6 id="②操作"><a href="#②操作" class="headerlink" title="②操作"></a>②操作</h6><ol><li><p>在java文件夹下的com.itheima.config包下新建一个配置类，命名为：xxxConfig。</p></li><li><p>在新建配置类里定义一个方法获取要管理的对象，<strong>方法名</strong>最好命名为：bean对象的id，返回值类型：该bean对象的类型，该方法不需要参数。在方法里通过new的方式造该bean对象，如果需要对该对象的属性进行赋值，就掉该对象相应的方法进行赋值。最后在该方法上面使用@bean注解（表明当前方法的返回值类型是一个bean）。</p><p> <img src="/imgs/image-20230424221211228.png" alt="image-20230424221211228"></p><p> ​补充：通过@bean注解来声明bean对象的id，@bean(“bean 的id”)。</p></li><li><p>加载该配置类到spring配置文件中。</p><ul><li><p><strong>方式一：</strong>导入式（推荐使用）</p><p>  使用@Import(“新建配置类类名.class”)注解</p><p>  <img src="/imgs/image-20230424221222205.png" alt="image-20230424221222205"></p><p>  注意：</p><p>  <img src="/imgs/image-20230424221229170.png" alt="image-20230424221229170"></p></li><li><p><strong>方式二：</strong>包扫描（这种方式<strong>不推荐使用</strong>，因为在使用@ComponentScan注解扫描包时，不知道具体扫描了哪些配置类）</p><p>  ①在刚才新建的配置类上面加上 @Configuration注解。</p><p>  ②在spring配置类上面加个@ComponentScan(“新建配置类所在包的名字”) 注解</p><p>  <img src="/imgs/image-20230424221237332.png" alt="image-20230424221237332"></p></li></ul></li></ol><hr><h5 id="B-为第三方bean实现依赖注入"><a href="#B-为第三方bean实现依赖注入" class="headerlink" title="B.为第三方bean实现依赖注入"></a>B.为第三方bean实现依赖注入</h5><h6 id="①简单数据类型"><a href="#①简单数据类型" class="headerlink" title="①简单数据类型"></a>①简单数据类型</h6><p>​使用<code>@Value</code>注解</p><img src="/imgs/image-20230424221246456.png" alt="image-20230424221246456" style="zoom:67%;" /><p>​</p><p>​拓展：</p><p>​现在的数据库连接四要素还是写在代码中，需要做的是将这些内容提取到jdbc.properties配置文件，在上面我们已经实现过了，这里再来复习一遍。</p><p><img src="/imgs/image-20230424221409552.png" alt="image-20230424221409552"></p><p><img src="/imgs/image-20230424221425302.png" alt="image-20230424221425302"></p><h6 id="②引用数据类型"><a href="#②引用数据类型" class="headerlink" title="②引用数据类型"></a>②引用数据类型</h6><p>​假如上面的第三方bean dataSource里需要注入一个对象bookDao，那怎么做？</p><ol><li><p>首先IOC容器中有bookDao这个对象。</p><p> 当bookDao属于自己定义的bean时，使用@ComponentScan注解将其放到IOC容器，如果bookDao属于第三方bean，则使用@Import注解将其放到IOC容器中。</p></li><li><p>在获得dataSource bean对象的那个方法的形参中写参数如：</p><p> <img src="/imgs/image-20230424221447976.png" alt="image-20230424221447976"></p><p> 参数名可以随便起</p></li></ol><p><img src="/imgs/image-20230424221458680.png" alt="image-20230424221458680"></p><hr><h4 id="7-注解开发总结"><a href="#7-注解开发总结" class="headerlink" title="7.注解开发总结"></a>7.注解开发总结</h4><p><img src="/imgs/image-20230424221514445.png" alt="image-20230424221514445"></p><hr><h3 id="4-Spring整合"><a href="#4-Spring整合" class="headerlink" title="(4).Spring整合"></a>(4).Spring整合</h3><h4 id="1-Spring整合MyBatis"><a href="#1-Spring整合MyBatis" class="headerlink" title="1.Spring整合MyBatis"></a>1.Spring整合MyBatis</h4><h5 id="A-思路分析"><a href="#A-思路分析" class="headerlink" title="A.思路分析"></a>A.思路分析</h5><ol><li><p>Mybatis程序核心中哪些对象可以交给Spring进行管理呢？</p><p> 从图中可以获取到，真正需要交给Spring管理的是SqlSessionFactory。因为有了SqlSessionFactory才有SqlSession。</p> <img src="/imgs/image-20230424221527670.png" alt="image-20230424221527670" style="zoom:67%;" /> </li><li><p>SqlSessionFactory是怎么来的呢？</p><p> 其是由mybatis核心配置文件得来的，而mybatis核心配置文件中最重要的是下图中红色框部分。</p><p> <img src="/imgs/image-20230424221539305.png" alt="image-20230424221539305"></p></li></ol><h5 id="B-环境准备-1"><a href="#B-环境准备-1" class="headerlink" title="B.环境准备"></a>B.环境准备</h5><p>​①在resources文件夹下建一个文件，命名为：jdbc.properties。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jdbc.driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">jdbc.url</span>=<span class="string">jdbc:mysql://localhost:13306/spring_db</span></span><br><span class="line"><span class="attr">jdbc.username</span>=<span class="string">连接数据库的用户名</span></span><br><span class="line"><span class="attr">jdbc.password</span>=<span class="string">数据库密码</span></span><br></pre></td></tr></table></figure><p>​</p><h5 id="C-实现"><a href="#C-实现" class="headerlink" title="C.实现"></a>C.实现</h5><ol><li><p>导入Spring整合MyBatis的相关依赖。</p><p> 在pom.xml文件中导入如下jar包：</p> <img src="/imgs/image-20230424221634238.png" alt="image-20230424221634238" style="zoom: 80%;" /> <img src="/imgs/image-20230424221645538.png" alt="image-20230424221645538" style="zoom:80%;" /><p> ​说明：Spring整合其它框架时，都是由其它框架提供与Spring的整合包的，因为Spring并不懂其它框架的内容，因此Spring只需要提供一些接口，让其它框架按照这些接口制定整合包就行。</p></li><li><p>在Java文件夹下建com.zzc.config包，在该包下建Spring的配置类。</p><p> <img src="/imgs/image-20230115111501577.png" alt="image-20230115111501577"></p></li><li><p>将阿里公司提供的数据库连接池技术Druid中的对象<strong>DataSource</strong>放到IOC容器中。</p><p> ①在Java文件夹下的com.zzc.config包下建一个配置类，命名为JdbcConfig。</p><p> ②在Spring配置类上使用@PropertySource(“配置文件地址（从resources下开始些）”)，加载jdbc.properties配置文件。</p><p> ③编写该配置类。</p><p> <img src="/imgs/image-20230114204219460.png" alt="image-20230114204219460"></p><p> ④在Spring配置类上使用@Import注解将dataSource对象放到IOC容器中。</p><p> <img src="/imgs/image-20230114204446812.png" alt="image-20230114204446812"></p></li><li><p>将MyBatis核心程序中的<strong>SqlSessionFactory</strong>对象放到IOC容器中。</p></li></ol><p>  ①在com.zzc.config包下建一个配置类，类名为：MyBatisConfig。</p><p>  ②编写该配置类</p>  <img src="/imgs/image-20230424221737721.png" alt="image-20230424221737721" style="zoom: 67%;" /><p>  ​</p><p><code>说明：</code></p><ul><li><p>SqlSessionFactoryBean是FactoryBean的一个子类，在该类中将SqlSessionFactory的创建进行了封装，简化对象的创建，我们只需要将其需要的内容设置即可。</p></li><li><p>方法中有一个参数为dataSource，当前Spring容器中已经创建了Druid数据源，类型刚好是DataSource类型，此时在初始化SqlSessionFactoryBean这个对象的时候，发现需要使用DataSource对象，而容器中刚好有这么一个对象，就自动加载了DruidDataSource对象。</p></li><li><p>MyBatisConfig配置类中代码与MyBatis核心配置文件中代码的对应关系。</p><p>  <img src="/imgs/image-20230114211231900.png" alt="image-20230114211231900"></p><p>  <img src="/imgs/image-20230114212513308.png" alt="image-20230114212513308"></p><p>  说明：</p></li><li><p>这个MapperScannerConfigurer对象也是MyBatis提供的专用于整合的jar包中的类，用来处理原始配置文件中的mappers相关配置，<strong>加载数据层的Mapper接口类</strong>。</p></li><li><p>MapperScannerConfigurer有一个核心属性basePackage，就是用来设置所扫描的包路径。</p></li><li><p><img src="/imgs/image-20230224180743437.png" alt="image-20230224180743437"></p></li></ul><p>  ③将该bean对象放到IOC容器中。</p><p>  <img src="/imgs/image-20230114210118992.png" alt="image-20230114210118992"></p><ol start="5"><li><p>修改Service层实现类中的部分代码</p><p>   未引入Spring框架时，Service层想调用数据层中的代码得这样写：</p><p>   <img src="/imgs/image-20230114233337396.png" alt="image-20230114233337396"></p><p>   但有了Spring之后，就可以这样写：</p><p> <img src="/imgs/image-20230114234840200.png" alt="image-20230114234840200"></p><p>  解释说明：</p><p>   为什么UserMapper对象可以通过@Autowired自动装配完成依赖注入？</p><p>   当执行到MyBatisConfig配置类中的如下代码时：</p><p>   <img src="/imgs/image-20230424221944044.png" alt="image-20230424221944044"></p><p>  Mapper包下的相关接口类就会全部加载，也就是说UserMapper这个对象就会被放到IOC容器中，因此就可以完成自动装配。</p><p> 自动代理出的实现类对象</p></li><li><p>运行测试</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//加载Spring配置类，获取容器对象</span></span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> context.getBean(UserService.class);<span class="comment">//从IOC容器获取service对象</span></span><br><span class="line">        List&lt;User&gt; users = userService.selectAll();<span class="comment">//执行service对象中的方法</span></span><br><span class="line">        System.out.println(users);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将原来MyBatis核心配置文件删掉即可，完成。</p></li></ol><hr><h4 id="2-Spring整合JUnit"><a href="#2-Spring整合JUnit" class="headerlink" title="2.Spring整合JUnit"></a>2.Spring整合JUnit</h4><p>​实现步骤：</p><p>​①在pom.xml文件中导入JUnit依赖和Spring整合JUnit的依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​②在test文件夹下建一个com.zzc.service包专门用来放测试service层的类。</p><p>​在该包下建一个AccountServiceTest测试类。</p><p><img src="/imgs/image-20230115135058631.png" alt="image-20230115135058631"></p><p>​③编写AccountServiceTest测试类。</p><p>​使用@RunWith和@ContextConfiguration注解</p><p><img src="/imgs/image-20230115135650844.png" alt="image-20230115135650844"></p><p>​④编写测试方法。使用@Test注解。</p><p><img src="/imgs/image-20230424222132054.png" alt="image-20230424222132054"></p><p>​<strong>注意:</strong></p><ul><li>单元测试，如果测试的是注解配置类，则使用@ContextConfiguration(classes &#x3D; 配置类.class)。</li><li>单元测试，如果测试的是配置文件，则使用@ContextConfiguration(locations&#x3D;{配置文件名,…})。</li><li>Spring整合Junit后，Junit运行后是基于Spring环境运行的，所以Spring提供了一个专用的类运行器，这个务必要设置，这个类运行器就在Spring的测试专用包中提供的，导入的坐标就是这个东西SpringJUnit4ClassRunner。</li><li>上面两个配置都是固定格式，当需要测试哪个bean时，使用自动装配加载对应的对象，下面的工作就和以前做Junit单元测试完全一样了</li></ul><hr><h3 id="5-AOP"><a href="#5-AOP" class="headerlink" title="(5).AOP"></a>(5).AOP</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h4><h5 id="A-引入-2"><a href="#A-引入-2" class="headerlink" title="A.引入"></a>A.引入</h5><p>​前面我们在介绍Spring的时候说过，Spring有两个核心的概念，一个是<code>IOC/DI</code>，一个是<code>AOP</code>。</p><p>​前面已经对<code>IOC/DI</code>进行了系统的学习，接下来要学习它的另一个核心内容，就是<code>AOP</code>。</p><h5 id="B-AOP简介"><a href="#B-AOP简介" class="headerlink" title="B.AOP简介"></a>B.AOP简介</h5><ul><li>AOP(Aspect Oriented Programming)是一种面向切面编程的思想。<ul><li>我们之前学的OOP(Object Oriented Programming)面向对象编程 也是一种编程思想。</li></ul></li><li>AOP作用：<strong>在不惊动原始设计的基础上为其进行功能增强。即：在不修改原始代码的情况下就能实现功能增强。</strong></li><li>“在不修改原始代码的情况下就能实现功能增强” 这体现了：Spring的 “无入侵式” 或 “无侵入式” 的思想。</li></ul><h5 id="C-AOP概念介绍"><a href="#C-AOP概念介绍" class="headerlink" title="C.AOP概念介绍"></a>C.AOP概念介绍</h5><h6 id="①引入-3"><a href="#①引入-3" class="headerlink" title="①引入"></a>①引入</h6><img src="/imgs/image-20230424222206394.png" alt="image-20230424222206394" style="zoom:67%;" /><p>代码的内容很简单，就是测试一下万次执行的耗时<br>当在App类中从容器中获取bookDao对象后，分别执行其save，delete，update和select方法后会有如下的打印结果：</p><img src="/imgs/image-20230424222228517.png" alt="image-20230424222228517" style="zoom:67%;" /><p><img src="/imgs/image-20230115164305908.png" alt="image-20230115164305908"></p><p><img src="/imgs/image-20230115164324854.png" alt="image-20230115164324854"></p><h6 id="②AOP概念"><a href="#②AOP概念" class="headerlink" title="②AOP概念"></a>②AOP概念</h6><ul><li><strong>通知</strong>：在上图中，我们把希望把其它方法也有的功能抽出来，重新写成一个方法，那么这个方法就被称为“通知”。</li><li><strong>连接点</strong>：上图右边所有的方法都被称为“连接点”。</li><li><strong>切入点</strong>：需要功能加强的方法就叫“切入点”。</li><li><strong>切面</strong>：将通知和切入点联系起来。哪些切入点需要用到哪些通知，就靠切面来联系。</li><li><strong>通知类</strong>：通知所在的类，就被称为 “通知类”。</li></ul><p>上面是个人理解（平时理解记这就行），下面是对这些概念的标准解释：</p><p><img src="/imgs/image-20230424222252943.png" alt="image-20230424222252943"></p><hr><h4 id="2-AOP实现"><a href="#2-AOP实现" class="headerlink" title="2.AOP实现"></a>2.AOP实现</h4><h5 id="A-需求分析"><a href="#A-需求分析" class="headerlink" title="A.需求分析"></a>A.需求分析</h5><p>​测算接口执行效率，但是这个案例稍微复杂了点，我们对其进行简化。在方法执行前输出当前系统时间。</p><p><img src="/imgs/image-20230424222308482.png" alt="image-20230424222308482"></p><h5 id="B-环境准备-2"><a href="#B-环境准备-2" class="headerlink" title="B.环境准备"></a>B.环境准备</h5><p>​<img src="/imgs/image-20230424222327630.png" alt="image-20230424222327630"><img src="/imgs/image-20230116131834694.png" alt="image-20230116131834694"></p><p><img src="/imgs/image-20230424222359126.png" alt="image-20230424222359126"></p><p><img src="/imgs/image-20230424222406657.png" alt="image-20230424222406657"></p><h5 id="C-实现-1"><a href="#C-实现-1" class="headerlink" title="C.实现"></a>C.实现</h5><ol><li><p>在pom.xml文件中导入依赖。</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p> 因为<code>spring-context</code>中已经导入了<code>spring-aop</code>，所以不需要再单独导入<code>spring-aop</code>。<br> 导入AspectJ的jar包，AspectJ是AOP思想的一个具体实现，Spring有自己的AOP实现，但是相比于AspectJ来说比较麻烦，所以我们直接采用Spring整合ApsectJ的方式进行AOP开发。</p></li><li><p>定义接口和实现类。</p><p> 准备环境的时候我们已经完成了。</p></li><li><p>定义通知类和通知。</p><p> 在java文件夹下建com.zzc.aop包，专门用来放通知类。</p><p> 通知就是将共性功能抽取出来后形成的方法，共性功能指的就是当前系统时间的打印。<br> <strong>类名和方法名没有要求，可以任意。</strong></p><p> <img src="/imgs/image-20230424222424561.png" alt="image-20230424222424561"></p></li><li><p>定义切入点。</p><p> 在通知类中定义一个私有、没有返回值、没有参数的方法（方法名可以随便起），在该方法上面使用@Pointcut(“execution(切入点方法的返回值类型 切入点的位置)”)</p><p> 如：BookDaoImpl中有两个方法，分别是update()和save()，我们要增强的是update方法，那么该如何定义呢？</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">    <span class="comment">//定义切入点：</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(void com.blog.dao.impl.BookDaoImpl.update())&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span> &#123; <span class="comment">//切入点定义依托一个不具有实际意义的方法进行，即无参数、无返回值、方法体无实际逻辑。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>定义切面。</p><p> <img src="/imgs/image-20230116155111606.png" alt="image-20230116155111606"></p><p> 绑定切入点与通知关系，并指定通知添加到原始连接点的具体执行位置。</p><p> <strong>说明:</strong>@Before翻译过来是之前，也就是说通知会在切入点方法执行之前执行，除此之前还有其他四种类型，后面会讲。<br> 那这里就会在执行update()之前，来执行我们的method()，输出当前毫秒值。</p></li><li><p>将通知类配给容器并标识其为切面类。</p><p> <img src="/imgs/image-20230424222439108.png" alt="image-20230424222439108"></p></li><li><p>开启注解格式AOP功能。</p><p> 在Spring配置类上使用@EnableAspectJAutoProxy注解</p><p> <img src="/imgs/image-20230424222446312.png" alt="image-20230424222446312"></p></li><li><p>运行程序。</p><p> <img src="/imgs/image-20230424222452449.png" alt="image-20230424222452449"></p></li></ol><hr><h4 id="3-AOP工作流程"><a href="#3-AOP工作流程" class="headerlink" title="3.AOP工作流程"></a>3.AOP工作流程</h4><p><img src="/imgs/image-20230424222513789.png" alt="image-20230424222513789"></p><p><strong>SpringAOP的本质：其底层使用的是代理模式。</strong></p><hr><h4 id="4-AOP配置管理"><a href="#4-AOP配置管理" class="headerlink" title="4.AOP配置管理"></a>4.AOP配置管理</h4><h5 id="A-AOP切入点表达式"><a href="#A-AOP切入点表达式" class="headerlink" title="A.AOP切入点表达式"></a>A.AOP切入点表达式</h5><h6 id="①语法格式"><a href="#①语法格式" class="headerlink" title="①语法格式"></a>①语法格式</h6><p>​首先明确两个概念：</p><ul><li>切入点：要进行增强的方法。</li><li>切入点表达式：要进行增强的方法的描述方式。</li></ul><p>​<strong>切入点表达式标准格式：</strong></p><p><img src="/imgs/image-20230117153101811.png" alt="image-20230117153101811"></p><p>​例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">execution(<span class="keyword">void</span> com.blog.dao.BookDao.update())</span><br><span class="line">execution(<span class="keyword">void</span> com.blog.dao.impl.BookDaoImpl.update())</span><br><span class="line"><span class="comment">//上面两种写法最终执行的结果都一样，因为调用接口方法的时候最终运行的还是其实现类的方法。</span></span><br></pre></td></tr></table></figure><p>​</p><h6 id="②通配符"><a href="#②通配符" class="headerlink" title="②通配符"></a>②通配符</h6><p>​引入：对于需要增强的方法，我们都需要对应地写一个切入点表达式，如果需要增强的方法有很多，那岂不是要写很多切入点表达式？有没有简化的方式呢？有的，那就是使用调配符。</p><p>​通配符：</p><ul><li><p><code>*</code> ：单个独立的任意符号，可以独立出现，也可以作为前缀或者后缀的匹配符出现。</p><p>  如：</p><p>  <img src="/imgs/image-20230424222656355.png" alt="image-20230424222656355"></p></li><li><p><code>..</code> ：任意多个连续的任意符号，可以独立出现，常用于简化包名与参数的书写。</p><p>  如：</p><p>  <img src="/imgs/image-20230424222701908.png" alt="image-20230424222701908"></p></li><li><p><code>+</code> ：专用于匹配子类类型，其只能写在接口名或类名的后面。（<strong>此通配符少用</strong>）</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">execution(* *..*Service+.*(..))</span><br><span class="line"><span class="comment">//表示：任意包下以Service结尾的任意接口名或类名下的子类里的任意参数任意返回值类型的任意方法。</span></span><br></pre></td></tr></table></figure></li></ul><hr><h6 id="③书写技巧"><a href="#③书写技巧" class="headerlink" title="③书写技巧"></a>③书写技巧</h6><p>​对于切入点表达式的编写其实是很灵活的，那么在编写的时候，有没有什么好的技巧让我们用用：</p><ul><li><strong>所有代码按照标准规范开发，否则以下技巧全部失效</strong>。</li><li>描述<strong>切入点通常描述接口</strong>，而不描述实现类，如果描述到实现类，就出现紧耦合了。</li><li>访问控制修饰符针对接口开发均采用public描述（写切入点表达式时，可省略访问控制修饰符描述）。</li><li>返回值类型对于增删改类使用精准类型加速匹配，对于查询类使用<code>*</code>通配快速描述。（增删改操作返回的都是boolean，使用准确的类型可以加速匹配；对于查询类其返回的类型不规定，适合使用 * 通配）</li><li><code>包名</code>书写尽量不使用<code>..</code>匹配，效率过低，常用<code>*</code>做单个包描述匹配，或精准匹配。</li><li><code>接口名/类名</code>书写名称与模块相关的采用<code>*</code>匹配，例如UserService书写成<code>*Service</code>，绑定业务层接口名。</li><li>方法名书写以<code>动词</code>进行<code>精准匹配</code>，名词采用<code>*</code>匹配，例如<code>getById</code>书写成<code>getBy*</code>，<code>selectAll</code>书写成<code>selectAll</code>。</li><li>参数规则较为复杂，根据业务方法灵活调整。</li><li>通常<strong>不使用异常作为匹配规则</strong>。</li></ul><hr><h5 id="B-AOP通知类型"><a href="#B-AOP通知类型" class="headerlink" title="B.AOP通知类型"></a>B.AOP通知类型</h5><h6 id="①类型介绍"><a href="#①类型介绍" class="headerlink" title="①类型介绍"></a>①类型介绍</h6><p>​AOP通知描述了抽取的共性功能，根据共性功能抽取的位置不同，最终运行代码时要将其加入到合理的位置</p><p>那么具体可以将通知添加到哪里呢？一共提供了5种通知类型</p><ul><li>前置通知（在原始方法的前面实现功能增强）</li><li>后置通知（在原始方法的后面实现功能增强）</li><li>环绕通知（重点）（在原始方法的前面及后面实现功能增强）</li><li>返回后通知（了解）</li><li>抛出异常后通知（了解）</li></ul><h6 id="②环境准备"><a href="#②环境准备" class="headerlink" title="②环境准备"></a>②环境准备</h6><p>​1.在pom.xml文件中导入：Spring、SpringAOP（导入Spring jar包时会同时导入SpringAO，因为Spring依赖于SpringAOP）、Aspect(不懂？见笔记：AOP –&gt; AOP实现 –&gt; 实现 –&gt; 导入依赖)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Aspectjar包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​2.添加BookDao和BookDaoImpl类</p><p><img src="/imgs/image-20230424222733195.png" alt="image-20230424222733195"></p><p><img src="/imgs/image-20230424222740815.png" alt="image-20230424222740815"></p><p>​3.创建Spring配置类</p><p><img src="/imgs/image-20230424222750628.png" alt="image-20230424222750628"></p><p>​4.添加通知类</p><p>​<img src="/imgs/image-20230424222802565.png" alt="image-20230424222802565" style="zoom:67%;" /></p><h6 id="③通知类型的使用"><a href="#③通知类型的使用" class="headerlink" title="③通知类型的使用"></a>③通知类型的使用</h6><ul><li><p><strong>前置通知</strong></p><p>  如：想将通知类中的before通知方法添加到切入点update的前面执行</p><p>  在before通知方法前面<strong>使用@Before注解</strong></p><p>  <img src="/imgs/image-20230424222814463.png" alt="image-20230424222814463"></p><p>  运行结果：</p><p>  <img src="/imgs/image-20230424222835001.png" alt="image-20230424222835001"></p></li><li><p><strong>后置通知</strong></p><p>  如：想将通知类中的after通知方法添加到切入点update的后面执行</p><p>  在after通知方法前面使用**@After注解**</p><p>  <img src="/imgs/image-20230424222852490.png" alt="image-20230424222852490"></p><p>  运行结果：</p><p>  <img src="/imgs/image-20230424222902567.png" alt="image-20230424222902567"></p></li><li><p><strong>环绕通知</strong></p><p>  如：想要将arround通知方法中的内容加到切入点update的前后</p><p>  在arround通知方法上使用**@Around注解**</p><p>  <img src="/imgs/image-20230424222911023.png" alt="image-20230424222911023"></p><p>  运行结果：</p><p>  <img src="/imgs/image-20230424222917337.png" alt="image-20230424222917337"></p><p>  运行结果中，通知的内容打印出来，但是原始方法的内容却没有被执行。</p><p>  因为环绕通知需要在原始方法的前后进行增强，所以环绕通知就必须要能对原始操作进行调用，具体如何实现?</p><p>  在arround通知方法的参数中添加 ProceedingJoinPoint，同时在需要的位置使用proceed()调用原始操作。</p><p>  <img src="/imgs/image-20230424222928318.png" alt="image-20230424222928318"></p><p>  运行结果：</p><p>  <img src="/imgs/image-20230424222933296.png" alt="image-20230424222933296"></p><p>  <strong>注意：如果原始方法有返回值，则通知方法也要有返回值（通常设置为Object这样更通用），不然会报错。</strong></p><p>  <strong>关于 ProceedingJoinPoint的补充：</strong></p><p>  ProceedingJoinPoint：代表原始方法的执行对象，我们可以通过ProceedingJoinPoint中的方法getSignature()来获取一次签名的信息，签名信息中包含了此原始方法属于哪个类或接口、原始方法的方法名等，这些信息都是通过签名信息的对象中的方法获得。如：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around(&quot;servicePt()&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runSpeed</span><span class="params">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="comment">//获取一次签名信息</span></span><br><span class="line">    <span class="type">Signature</span> <span class="variable">signature</span> <span class="operator">=</span> proceedingJoinPoint.getSignature();</span><br><span class="line">    <span class="comment">//通过通过签名信息的对象获取原始方法属于哪个接口或类</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">typeName</span> <span class="operator">=</span> signature.getDeclaringTypeName();</span><br><span class="line">    <span class="comment">//通过下面的方法就可以获得该原始方法具体属于哪个类或接口</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">typeName</span> <span class="operator">=</span> signature.getDeclaringType();</span><br><span class="line">    <span class="comment">//获取原始方法的方法名</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> signature.getName();</span><br><span class="line">    System.out.println(<span class="string">&quot;原始方法 &quot;</span> + typeName + <span class="string">&quot;.&quot;</span> + methodName + <span class="string">&quot; 耗时&quot;</span> + (end - start) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>返回后通知</strong>（了解）</p><p>  返回后通知：在原始方法正常结束后执行通知方法。如果原始方法中抛异常了，那就不能执行通知方法（因为原始方法不是正常结束）。</p><p>  <strong>操作：</strong>在通知上面使用<code>@AfterReturning注解</code>。如：</p><p>  <img src="/imgs/image-20230424223019749.png" alt="image-20230424223019749"></p><p>  其与后置通知的区别：</p><p>  后置通知：不管原始方法有没有抛出异常都会被执行。</p><p>  返回后通知：只会在原始方法不抛出异常的情况下执行。</p></li><li><p><strong>异常后通知</strong>（了解）</p><p>  <strong>异常后通知：</strong>只有当方法抛出异常后才执行。</p><p>  操作：在通知方法上面使用@AfterThrowing，如：</p><p>  <img src="/imgs/image-20230424223033013.png" alt="image-20230424223033013"></p></li></ul><h6 id="④环绕通知的注意事项"><a href="#④环绕通知的注意事项" class="headerlink" title="④环绕通知的注意事项"></a>④环绕通知的注意事项</h6><ol><li><strong>环绕通知必须依赖形参ProceedingJoinPoint才能实现对原始方法的调用</strong>，进而实现原始方法调用前后同时添加通知。</li><li><strong>通知中如果未使用ProceedingJoinPoint对原始方法进行调用将跳过原始方法的执行</strong>，形成隔离原始方法的效果。这种效果可以运用在权限隔离上，当判断符合某种权限后才执行原始方法。</li><li>对原始方法的调用可以不接收返回值，通知方法设置成void即可，如果接收返回值，最好设定为Object类型。</li><li>原始方法的返回值如果是void类型，通知方法的返回值类型可以设置成void,也可以设置成Object。</li><li>由于无法预知原始方法运行后是否会抛出异常，因此环绕通知方法必须要处理Throwable异常。</li></ol><hr><h5 id="C-AOP通知获取数据"><a href="#C-AOP通知获取数据" class="headerlink" title="C.AOP通知获取数据"></a>C.AOP通知获取数据</h5><h6 id="①获取切入点方法的实参"><a href="#①获取切入点方法的实参" class="headerlink" title="①获取切入点方法的实参"></a>①获取切入点方法的实参</h6><ol><li><p><strong>对于前置通知、后置通知、返回后通知及异常后通知</strong> 获取切入点方法的形参，在通知方法的参数上加上JoinPoint接口，然后在方法里调用JoinPoint的getArgs()方法就可以得到一个类型为Object的数组，数组里装的就是切入点方法中的形参值。</p><p> 如：</p><p> <img src="/imgs/image-20230424223043817.png" alt="image-20230424223043817"></p></li><li><p><strong>对于环绕通知。</strong>直接调用ProceedingJoinPoint接口中的getArgs()方法即可。补充：ProceedingJoinPoint接口是JoinPoint的子接口，所以getArgs()方法也是从ProceedingJoinPoint接口中继承而来。</p><p> 如：</p><p> <img src="/imgs/image-20230119134933061.png" alt="image-20230119134933061"></p><p> <strong>如果通知的参数中有多个参数，ProceedingJoinPoint一定要放到所有参数的前面。</strong></p><p> <strong>注意：</strong></p><ul><li><p>pjp.proceed()方法是有两个构造方法，分别是:</p></li><li><p>proceed()</p></li></ul></li></ol><ul><li><p>proceed(Object[] object)  参数是从pjp.getArgs()方法中自动获取的</p></li><li><p>调用无参数的proceed，当原始方法有参数，会在调用的过程中自动传入参数。</p></li><li><p>所以调用这两个方法的任意一个都可以完成功能。</p></li><li><p>但是当需要修改原始方法的参数时，就只能采用带有参数的方法，如下：</p><p>  <img src="/imgs/image-20230424223059637.png" alt="image-20230424223059637"></p><p>  有了这个特性后，我们就可以在环绕通知中对原始方法的参数进行拦截过滤，避免由于参数的问题导致程序无法正确运行，还可以根据参数来给予不同的权限，提高代码的健壮性。</p></li></ul><hr><h6 id="②获取切入点方法的返回值"><a href="#②获取切入点方法的返回值" class="headerlink" title="②获取切入点方法的返回值"></a>②获取切入点方法的返回值</h6><p>​<strong>只有环绕通知和返回后通知可以实现获取切入点方法的返回值</strong>，其它通知类型不能获取。</p><ol><li><p><strong>环绕通知</strong></p><p> 环绕通知中，pjp.proceed()对原始方法的调用时，其返回的值就是切入点方法的返回值，我们可以对该返回值进行一些操作，然后再将操作完的值返回。</p><p> <img src="/imgs/image-20230424223135115.png" alt="image-20230424223135115"></p><p> ​<strong>如果通知的参数中有多个参数，ProceedingJoinPoint一定要放到所有参数的前面。</strong></p></li><li><p><strong>返回后通知</strong><br> ①在返回后通知的形参中加一个形参，形参类型可以是Object类型也可以是其它类型（但要和切入点方法中形参类型对应上，），形参名随便起。<br> ②在@AfterReturning注解中加上returning &#x3D; “形参名”，表明如果原始方法（切入点方法）中有返回值，那就把原始方法的返回值赋给通知类中刚才起的参数。</p><p> 例子：</p><p> <img src="/imgs/image-20230424223142655.png" alt="image-20230424223142655"></p><p> ​<strong>注意：</strong></p><ol><li>afterReturning方法参数类型的问题<br> 参数类型可以写成其它类型，但是为了能匹配更多的参数类型，建议写成Object类型</li><li>afterReturning方法参数的顺序问题<br> 如果存在JoinPoint参数，<strong>则必须将其放在第一位</strong>，否则运行将报错。</li></ol> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">(JoinPoint jp,Object res)</span></span><br></pre></td></tr></table></figure></li></ol><hr><h6 id="③获取切入点方法的异常（了解）"><a href="#③获取切入点方法的异常（了解）" class="headerlink" title="③获取切入点方法的异常（了解）"></a>③获取切入点方法的异常（了解）</h6><p>​<strong>只有环绕通知和抛出异常后通知可以获取。</strong></p><ol><li><p>环绕通知</p> <img src="/imgs/image-20230424223155164.png" alt="image-20230424223155164" style="zoom:67%;" /> </li><li><p>抛出异常后通知</p><p> 在抛出异常后通知的参数中加入一个参数，参数名可以随便起；然后在@AfterThrowing注解中添加属性throwing，其值为：刚才添加的参数的名字。</p><p> <img src="/imgs/image-20230424223207500.png" alt="image-20230424223207500"></p></li></ol><hr><h4 id="5-案例"><a href="#5-案例" class="headerlink" title="5.案例"></a>5.案例</h4><h5 id="A-需求"><a href="#A-需求" class="headerlink" title="A.需求"></a>A.需求</h5><p><img src="/imgs/image-20230424223228449.png" alt="image-20230424223228449"></p><h5 id="B-分析"><a href="#B-分析" class="headerlink" title="B.分析"></a>B.分析</h5><p><img src="/imgs/image-20230424223233502.png" alt="image-20230424223233502"></p><h5 id="C-实现-2"><a href="#C-实现-2" class="headerlink" title="C.实现"></a>C.实现</h5><p><img src="/imgs/image-20230424223238920.png" alt="image-20230424223238920"></p><h5 id="D-总结"><a href="#D-总结" class="headerlink" title="D.总结"></a>D.总结</h5><p>​如果开发中有相同的、大量使用的功能需要在很多地方加的话，AOP是不二之选。使用AOP开发能够减少许多共享功能的开发。</p><hr><h4 id="6-AOP总结"><a href="#6-AOP总结" class="headerlink" title="6.AOP总结"></a>6.AOP总结</h4><p><img src="/imgs/image-20230424223306273.png" alt="image-20230424223306273"></p><p>​<code>切入点表达式：</code></p><p><img src="/imgs/image-20230424223318880.png" alt="image-20230424223318880"></p><p>​<code>通知类型：</code></p><p><img src="/imgs/image-20230424223324689.png" alt="image-20230424223324689"></p><p>​</p><p><img src="/imgs/image-20230424223329708.png" alt="image-20230424223329708"></p><hr><h3 id="6-AOP事务管理"><a href="#6-AOP事务管理" class="headerlink" title="(6)AOP事务管理"></a>(6)AOP事务管理</h3><h4 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1.概述"></a>1.概述</h4><h5 id="①Spring事务"><a href="#①Spring事务" class="headerlink" title="①Spring事务"></a>①Spring事务</h5><ul><li>事务作用：在数据层保障一系列的数据库操作同成功同失败</li><li>Spring事务作用：在<strong>数据层</strong>或<strong>业务层</strong>保障一系列的数据库操作同成功同失败。如：在转账业务中需要调用数据层中的转出操作和转入操作，我们需要保证这两个操作需同时成功或同时失败，因此就会用Spring事务。<strong>以后要求数据层中的一系列操作同时成功或失败，那就使用Spring事务。</strong></li></ul><h5 id="②Spring怎么实现事务"><a href="#②Spring怎么实现事务" class="headerlink" title="②Spring怎么实现事务"></a>②Spring怎么实现事务</h5><p>​Spring为了管理事务，提供了一个平台事务管理器<strong>PlatformTransactionManager</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PlatformTransactionManager</span> <span class="keyword">extends</span> <span class="title class_">TransactionManager</span> &#123;</span><br><span class="line">    TransactionStatus <span class="title function_">getTransaction</span><span class="params">(<span class="meta">@Nullable</span> TransactionDefinition var1)</span> <span class="keyword">throws</span> TransactionException;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">(TransactionStatus var1)</span> <span class="keyword">throws</span> TransactionException;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">rollback</span><span class="params">(TransactionStatus var1)</span> <span class="keyword">throws</span> TransactionException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​commit是用来提交事务，rollback是用来回滚事务。</p><p>​PlatformTransactionManager只是一个接口，Spring还为其提供了一个具体的实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceTransactionManager</span> <span class="keyword">extends</span> <span class="title class_">AbstractPlatformTransactionManager</span> <span class="keyword">implements</span> <span class="title class_">ResourceTransactionManager</span>, InitializingBean &#123;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> enforceReadOnly;</span><br><span class="line">···</span><br><span class="line">···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​从名称上可以看出，我们只需要给它一个DataSource对象，它就可以帮你去在业务层管理事务。<strong>其内部采用的是JDBC的事务</strong>。所以说如果你持久层采用的是JDBC相关的技术，就可以采用这个事务管理器来管理你的事务。而Mybatis内部采用的就是JDBC的事务，所以后期我们Spring整合Mybatis就采用的这个<strong>DataSourceTransactionManager</strong>事务管理器。</p><h4 id="2-实现"><a href="#2-实现" class="headerlink" title="2.实现"></a>2.实现</h4><p>​①配置事务管理器。</p><p>​JdbcConfig类中配置事务管理器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//配置事务管理器，mybatis使用的是jdbc事务</span></span><br><span class="line"><span class="meta">@Bean</span>   <span class="comment">//将其放到spring容器中管理</span></span><br><span class="line"><span class="keyword">public</span> PlatformTransactionManager <span class="title function_">platformTransactionManager</span><span class="params">(DataSource dataSource)</span>&#123;</span><br><span class="line">    <span class="type">DataSourceTransactionManager</span> <span class="variable">transactionManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>();</span><br><span class="line">    <span class="comment">//如果使用的不是jdbc事务，那就将第四、五行的代码换掉就行，其它代码不变。</span></span><br><span class="line">    transactionManager.setDataSource(dataSource);</span><br><span class="line">    <span class="keyword">return</span> transactionManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​②在Spring配置文件中开启事务注解@EnableTransactionManagement</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.blog&quot;)</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;jdbc.properties&quot;)</span></span><br><span class="line"><span class="comment">//开启事务注解:</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="meta">@Import(&#123;JdbcConfig.class, MyBatisConfig.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​③在需要开启事务的业务层方法对应的接口上使用<code>@Transactional</code>注解。</p><p>​注意:<code>@Transactional</code>可以写在接口上、接口方法上、实现类上和实现类方法上</p><ul><li>写在接口上，该接口的所有实现类的所有方法都会有事务</li><li>写在接口方法上，该接口的所有实现类的该方法都会有事务</li><li>写在实现类上，该类中的所有方法都会有事务</li><li>写在实现类方法上，该方法上有事务</li></ul><p>​</p><h4 id="3-例子"><a href="#3-例子" class="headerlink" title="3.例子"></a>3.例子</h4><p>​见链接：<a href="https://cyborg2077.github.io/2022/08/29/Spring/#AOP%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86">Spring | Kyle’s Blog (cyborg2077.github.io)</a></p><img src="/imgs/image-20230424223438942.png" alt="image-20230424223438942" style="zoom:67%;" /><hr><h4 id="4-Spring事务角色"><a href="#4-Spring事务角色" class="headerlink" title="4.Spring事务角色"></a>4.Spring事务角色</h4><h5 id="①引入-4"><a href="#①引入-4" class="headerlink" title="①引入"></a>①引入</h5><p>​Spring中是如何实现事务管理的呢？见下面。</p><h5 id="②"><a href="#②" class="headerlink" title="②"></a>②</h5><img src="/imgs/image-20230424223452220.png" alt="image-20230424223452220" style="zoom:67%;" /><p><code>补充：</code></p><p><img src="/imgs/image-20230424223510296.png" alt="image-20230424223510296"></p><img src="/imgs/image-20230424223525584.png" alt="image-20230424223525584" style="zoom:67%;" /><p><img src="/imgs/image-20230424223533090.png" alt="image-20230424223533090"></p><p><strong>注意：</strong>目前的事务管理是<strong>基于</strong><code>DataSourceTransactionManager</code>和<code>SqlSessionFactoryBean</code><strong>使用的是同一个数据源</strong>，如果不使用同一个数据源那将无法实现Spring事务管理。即：</p><p><img src="/imgs/image-20230424223545844.png" alt="image-20230424223545844"></p><p><img src="/imgs/image-20230424223553554.png" alt="image-20230424223553554"></p><hr><h4 id="5-Spring事务属性"><a href="#5-Spring事务属性" class="headerlink" title="5.Spring事务属性"></a>5.Spring事务属性</h4><h5 id="A-事务配置"><a href="#A-事务配置" class="headerlink" title="A.事务配置"></a>A.事务配置</h5><p><img src="/imgs/image-20230424223559424.png" alt="image-20230424223559424"></p><p>​对上图的补充：</p><p><img src="/imgs/image-20230424223607443.png" alt="image-20230424223607443"></p><p>上面这些属性都可以在<code>@Transactional</code>注解的参数上进行设置。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(rollbackFor = &#123;IOException.class&#125;)</span></span><br></pre></td></tr></table></figure><ul><li>readOnly：true只读事务，false读写事务，增删改要设为false,查询设为true。</li><li>timeout：设置超时时间单位秒，在多长时间之内事务没有提交成功就自动回滚，-1表示不设置超时时间。</li><li>rollbackFor：当出现指定异常进行事务回滚</li><li>noRollbackFor：当出现指定异常不进行事务回滚</li></ul><p>思考:出现异常事务会自动回滚，这个是我们之前就已经知道的</p><ul><li>noRollbackFor是设定对于指定的异常不回滚，这个好理解</li><li>rollbackFor是指定回滚异常，对于异常事务不应该都回滚么，为什么还要指定?<ul><li>事实上<strong>Spring的事务只会对<code>Error异常</code>和<code>RuntimeException异常</code>（运行时异常）及其子类进行事务回滚</strong>，其他的异常类型是不会回滚的。因此需要根据实际情况针对指定的异常进行回滚。</li></ul></li></ul><hr><h5 id="B-事务传播行为"><a href="#B-事务传播行为" class="headerlink" title="B.事务传播行为"></a>B.事务传播行为</h5><h6 id="①引入-5"><a href="#①引入-5" class="headerlink" title="①引入"></a>①引入</h6><p>​见：<a href="https://cyborg2077.github.io/2022/08/29/Spring/#Spring%E4%BA%8B%E5%8A%A1%E8%A7%92%E8%89%B2">Spring | Kyle’s Blog (cyborg2077.github.io)</a></p><p><img src="/imgs/image-20230424223647175.png" alt="image-20230424223647175"></p><h6 id="②实现-4"><a href="#②实现-4" class="headerlink" title="②实现"></a>②实现</h6><p>​在使用@Transactional注解中的propagation属性，达到事务协调员是否加入事务管理员的事务及事务协调员是否自己开启新事务的目的。</p><p>​propagation属性的值可以为：</p><p>​<img src="/imgs/image-20230424223700452.png" alt="image-20230424223700452"></p><p>​<code>说明：图中的 “无” 代表：无事务或不开启事务。“ T ”代表：事务T。</code></p><hr><h3 id="三、如何看Spring报错"><a href="#三、如何看Spring报错" class="headerlink" title="三、如何看Spring报错"></a>三、如何看Spring报错</h3><p>​从最下面的报错开始看，看不懂再往前面看。</p>]]></content>
      
      
      <categories>
          
          <category> SSM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven(基础部分)</title>
      <link href="/2023/04/24/Maven%EF%BC%88%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86%EF%BC%89/"/>
      <url>/2023/04/24/Maven%EF%BC%88%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="基础部分"><a href="#基础部分" class="headerlink" title="基础部分"></a>基础部分</h2><img src="/imgs/image-20230424212708817.png" alt="image-20230424212708817" style="zoom:67%;" /><h3 id="一、Maven简介"><a href="#一、Maven简介" class="headerlink" title="一、Maven简介"></a>一、Maven简介</h3><h4 id="①引入"><a href="#①引入" class="headerlink" title="①引入"></a>①引入</h4><p>​在Javaweb开发中，需要使用大量的jar包，我们手动去导入，如何能够让一个东西自动帮我导入和配置这个jar包。由此，Maven诞生了！</p><h4 id="②Maven介绍"><a href="#②Maven介绍" class="headerlink" title="②Maven介绍"></a>②Maven介绍</h4><ul><li><p>Maven的本质：项目管理工具，将项目开发和管理过程抽象成一个项目对象模型(POM)。</p></li><li><p>Maven是用Java语言编写的。他管理的东西统统以面向对象的形式进行设计，最终它把一个项目看成一个对象，而这个对象叫做<strong>POM</strong>(project object model)，即项目对象模型。</p><ul><li><p>我们说一个项目就是一个对象，作为对象的行为、对象的属性都有哪些呢？</p><p>  Maven说我们需要编写一个pom.xml文件，Maven通过加载这个配置文件就可以知道我们项目的相关信息了！到这里我们知道了Maven离不开一个叫pom.xml的文件。因为这个文件代表就一个项目。</p></li></ul></li><li><p>那Maven是如何帮我们进行项目资源管理的呢？这就需要用到Maven中的第二个东西：<strong>依赖管理</strong>。这也是它的第二个核心！</p><ul><li><p>所谓依赖管理就是maven对项目所有依赖资源的一种管理，它和项目之间是一种双向关系，即当我们做项目的时候maven的依赖管理可以帮助你去管理你所需要的其他资源，当其他的项目需要依赖我们项目的时候，maven也会把我们的项目当作一种资源去进行管理，这就是一种双向关系。</p></li><li><p>那maven的依赖管理它管理的这些资源存在哪儿呢？</p><p>  主要有三个位置：<strong>本地仓库</strong>，<strong>私服</strong>，<strong>中央仓库</strong></p><p>  本地仓库顾名思义就是存储在本地的一种资源仓库，如果本地仓库中没有相关资源，可以去私服上获取，私服也是一个资源仓库，只不过不在本地，是一种远程仓库，如果私服上也没有相关资源，可以去中央仓库去获取，中央仓库也是一种远程仓库。</p></li></ul></li><li><p>Maven除了帮我们管理项目资源之外还能帮助我们对项目进行构建，管理项目的整个生命周期，当然它的这些功能需要使用一些相关的插件来完成，当然整个生命周期过程中插件是需要配合使用的，单独一个无法完成完整的生命周期。</p></li><li><p>Maven的结构：蓝色部分</p></li></ul><p><img src="/imgs/image-20220922171857394.png" alt="image-20220922171857394"></p><h4 id="③Maven的作用"><a href="#③Maven的作用" class="headerlink" title="③Maven的作用"></a>③Maven的作用</h4><ul><li>项目构建：提供标准的、跨平台的自动化项目构建方式。</li><li>依赖管理：方便快捷的管理项目依赖的资源(jar包)，避免资源间的版本冲突问题。</li><li>统一开发结构：提供标准的、统一的项目结构。</li></ul><h3 id="二、Maven安装"><a href="#二、Maven安装" class="headerlink" title="二、Maven安装"></a>二、Maven安装</h3><h4 id="①Maven下载"><a href="#①Maven下载" class="headerlink" title="①Maven下载"></a>①Maven下载</h4><p>​下载地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://maven.apache.org/</span><br></pre></td></tr></table></figure><p><img src="/imgs/e1c3db1cb7684619b01d64a9dd5be733.png" alt="在这里插入图片描述"></p><h4 id="②Maven解压与配置"><a href="#②Maven解压与配置" class="headerlink" title="②Maven解压与配置"></a>②Maven解压与配置</h4><ol><li><p>下载完后对文件进行解压。</p><p> 解压后，点击文件会有如下的目录。各目录结构说明：</p><p> bin：可执行程序目录，</p><p> boot：maven自身的启动加载器</p><p> conf：maven配置文件的存放目录</p><p> lib：maven运行所需库的存放目录</p></li><li><p>配置环境变量。</p><ol><li><p>复制地址</p><p> <img src="/imgs/image-20220922205845783.png" alt="image-20220922205845783"></p></li><li><p>设置变量，值为刚才复制的地址。</p><p> <img src="/imgs/image-20220922205658237.png" alt="image-20220922205658237"></p></li><li><p>配置PATH变量。</p><p> <img src="/imgs/image-20220922210100136.png" alt="image-20220922210100136"></p><p> <img src="/imgs/image-20220922210200520.png" alt="image-20220922210200520"></p></li></ol></li></ol><h4 id="③检查安装是否成功"><a href="#③检查安装是否成功" class="headerlink" title="③检查安装是否成功"></a>③检查安装是否成功</h4><p>​在cmd中输入：mvn</p><p>​出现如下界面代表安装成功</p><p><img src="/imgs/image-20220922210552840.png" alt="image-20220922210552840"></p><h4 id="④配置本地仓库"><a href="#④配置本地仓库" class="headerlink" title="④配置本地仓库"></a>④配置本地仓库</h4><p>​Maven默认将本地仓库安装在C盘的用户文件夹下，为了减少C盘内存压力，我们需要将本地仓库的位置修改一下。</p><p>​实现步骤：</p><ol><li>打开Maven安装目录中的conf文件，找到settings.xml文件，该文件要以记事本的方式打开。</li><li><img src="/imgs/image-20220923103326411.png" alt="image-20220923103326411"></li></ol><h4 id="⑤配置阿里云镜像仓库"><a href="#⑤配置阿里云镜像仓库" class="headerlink" title="⑤配置阿里云镜像仓库"></a>⑤配置阿里云镜像仓库</h4><p>​我们下载东西去哪下载呢？其实Maven已经帮我们配置好下载的地址了，但这个下载地址在境外，下载速度会很慢，所以我们就使用阿里云的仓库(因为与中央仓库一模一样，被称为镜像仓库)，这样下载速度就会很快。</p><p>​实现步骤：</p><ol><li><p>找到刚才配置本地仓库位置的文件。</p></li><li><p>在这文件里找到settings，在settings里找到mirrors。</p></li><li><p>写如下配置：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;mirror&gt;</span><br><span class="line">&lt;!--此镜像的唯一标识，用于区分不同的mirror元素，随便起，只要唯一即可 --&gt;</span><br><span class="line">      &lt;id&gt;aliyunmaven&lt;/id&gt;</span><br><span class="line">      &lt;!--对哪种仓库进行镜像，简单来说就是替代哪个仓库 --&gt;</span><br><span class="line">      &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;</span><br><span class="line">      &lt;!--镜像名称，随便起 --&gt;</span><br><span class="line">      &lt;name&gt;阿里云公共仓库&lt;/name&gt;</span><br><span class="line">      &lt;!--镜像URL，到时候访问替代镜像仓库时就找下面的URL --&gt;</span><br><span class="line">      &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt;</span><br><span class="line">&lt;/mirror&gt;</span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="三、Maven基础概念"><a href="#三、Maven基础概念" class="headerlink" title="三、Maven基础概念"></a>三、Maven基础概念</h3><h4 id="①仓库"><a href="#①仓库" class="headerlink" title="①仓库"></a>①仓库</h4><p>​仓库：存放各种jar包的地方。</p><p><img src="/imgs/075884d223d44ae3815e345994628aa1.png" alt="在这里插入图片描述"></p><h5 id="A-上图的解释"><a href="#A-上图的解释" class="headerlink" title="A.上图的解释"></a>A.上图的解释</h5><p>​当我们需要各种jar包，电脑上又没有时，我们就需要在云端上的计算机下载jar包，此计算机被称为中央仓库，该中央仓库由Maven公司管理，存放着99%的jar包。但中央仓库在境外，下载速度很慢，所以就建立一个中间计算机，被称为私服。当我们需要jar包时，就先看一下本机中是否有该jar包，有则直接使用，没有去私服看看有没有该jar包，如果私服中没有，则私服向中央仓库下载jar包，然后私服再返回该jar包给我们。如果私服有该jar包，则直接从私服中获取jar包即可。</p><h5 id="B-仓库分类"><a href="#B-仓库分类" class="headerlink" title="B.仓库分类"></a>B.仓库分类</h5><h6 id="①本地仓库"><a href="#①本地仓库" class="headerlink" title="①本地仓库"></a>①本地仓库</h6><p>​自己电脑上存储jar包的仓库，连接远程仓库获取jar包。</p><h6 id="②远程仓库"><a href="#②远程仓库" class="headerlink" title="②远程仓库"></a>②远程仓库</h6><ul><li>中央仓库：Maven团维护，存储所有jar包的仓库。</li><li>私服：部门&#x2F;公司范围内存储jar包的仓库，从中央仓库获取jar包。<ul><li>私服的作用：<ol><li>保存具有版权的资源，包含购买或自主研发的jar。</li><li>一定范围内共享资源，能做到仅对内不对外开放。</li></ol></li></ul></li></ul><h4 id="②坐标"><a href="#②坐标" class="headerlink" title="②坐标"></a>②坐标</h4><h5 id="A-什么是坐标"><a href="#A-什么是坐标" class="headerlink" title="A.什么是坐标"></a>A.什么是坐标</h5><p>​用于标识中央仓库中jar包的位置。</p><h5 id="B-Maven坐标组成"><a href="#B-Maven坐标组成" class="headerlink" title="B.Maven坐标组成"></a>B.Maven坐标组成</h5><ul><li><strong>groupId</strong>：定义当前资源隶属组织名称（通常是域名反写，如：org.mybatis；com.itheima）。</li><li><strong>artifactId</strong>：定义当前资源的名称（通常是项目或模块名称，如：crm，sms）。</li><li><strong>version</strong>：定义当前资源的版本号。</li><li><strong>packaging</strong>：定义资源的打包方式(<strong>但这不包括在maven坐标内</strong>)，取值一般有如下三种：<ul><li>jar：该资源打成jar包，默认是jar java工程打包为jar。</li><li>war：该资源打成war包 web工程打包为war。</li><li>pom：该资源是一个父资源（表明使用maven分模块管理），打包时只生成一个pom.xml不生成jar或其他包结构</li></ul></li></ul><h5 id="C-Maven坐标的作用"><a href="#C-Maven坐标的作用" class="headerlink" title="C.Maven坐标的作用"></a>C.Maven坐标的作用</h5><p>​让Maven帮我们下载、管理我们需要的jar包。</p><p>​</p><hr><h3 id="四、如何创建Maven项目"><a href="#四、如何创建Maven项目" class="headerlink" title="四、如何创建Maven项目"></a>四、如何创建Maven项目</h3><h4 id="①没有workspace的情况下创建Maven项目"><a href="#①没有workspace的情况下创建Maven项目" class="headerlink" title="①没有workspace的情况下创建Maven项目"></a>①没有workspace的情况下创建Maven项目</h4><p>​实现步骤</p><ol><li><p>File –&gt; empty project –&gt; Next –&gt; project名 –&gt; Finsh</p></li><li><p>设置sdk版本为1.8s</p><p> <img src="/imgs/image-20220923153510092.png" alt="image-20220923153510092"></p></li><li><p>配置Maven。点击File –&gt; Setting —&gt; 搜索框中搜索Maven</p></li></ol><p>  <img src="/imgs/image-20220923163736097.png" alt="image-20220923163736097"></p><ol start="4"><li>点击下面的图标，新建一个module。</li></ol><p>  <img src="/imgs/image-20220923153439047.png" alt="image-20220923153439047"></p><p>  <img src="/imgs/image-20220923153726261.png" alt="image-20220923153726261"></p><p>  选择创建new module –&gt; Maven（<strong>取消“create from archetype”的勾选</strong>） –&gt; Next</p><p>  <img src="/imgs/image-20220923153939290.png" alt="image-20220923153939290"></p><ol start="5"><li>在test中右键 –&gt; new Files，补充文件resources –&gt; 将相应的文件用对应的Mark as标记。文件示例图如下：</li></ol><p>  <img src="/imgs/image-20220923154318513.png" alt="image-20220923154318513"></p><ol start="6"><li>步骤5中的文件标记操作，也可以通过选中对应文件，再右击 —&gt; Mark Directory As 进行设置。</li></ol><h4 id="②在已有workspace下创建Maven的Java项目-module"><a href="#②在已有workspace下创建Maven的Java项目-module" class="headerlink" title="②在已有workspace下创建Maven的Java项目(module)"></a>②在已有workspace下创建Maven的Java项目(module)</h4><p>​实现步骤：</p><ol><li><p>点击下面的图标，新建一个module —&gt; 使用quickstart模板(<strong>勾选“create from archetype”</strong>)</p><p> <img src="/imgs/image-20220923153439047.png" alt="image-20220923153439047"></p></li><li><p><img src="/imgs/image-20220923153939290.png" alt="image-20220923153939290"></p></li><li><p>一直Next –&gt; Finsh —&gt; ok</p></li><li><p>建好的module中mian文件和test文件下都没有resources，如果需要可以右键new diretory。</p></li><li><p>将mian文件和test文件下的java文件、resources文件进行标记。选中文件，右键Mark Directory As 进行设置。设置成如下图的图例即可。</p><p> <img src="/imgs/image-20220923154318513.png" alt="image-20220923154318513"></p></li><li><p>将test文件下的Java文件中类删掉、main文件下的Java文件中的类也删掉。</p></li></ol><h4 id="③在已有workspace下创建Maven的web项目"><a href="#③在已有workspace下创建Maven的web项目" class="headerlink" title="③在已有workspace下创建Maven的web项目"></a>③在已有workspace下创建Maven的web项目</h4><p>​实现步骤：</p><ol><li><p>点击下面的图标，新建一个module —&gt; 使用webapp模板(<strong>勾选“create from archetype”</strong>)</p><p> <img src="/imgs/image-20220923153439047.png" alt="image-20220923153439047"></p></li><li><p><img src="/imgs/image-20220923153939290.png" alt="image-20220923153939290"></p><p> 一直点击Next —&gt; Finsh —&gt; ok</p></li><li><p>建好的module，文件并不完整，因此需要补充。</p><ul><li>在main文件下 –&gt; new diretory </li><li>在src下，new diretory  建test文件。在test文件下，new diretory 建Java文件和resources文件</li></ul></li><li><p>将文件都mark Directory As。</p><p> <img src="/imgs/image-20220923173705048.png" alt="image-20220923173705048"></p></li></ol><h3 id="五、IDEA中Maven构建按钮的使用及设置"><a href="#五、IDEA中Maven构建按钮的使用及设置" class="headerlink" title="五、IDEA中Maven构建按钮的使用及设置"></a>五、IDEA中Maven构建按钮的使用及设置</h3><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.bilibili.com/video/BV1Ah411S7ZE?p=9&amp;spm_id_from=pageDriver&amp;vd_source=9c398663599ac78b625d463b4ffc1ff5</span><br></pre></td></tr></table></figure><h3 id="六、如何导入jar包"><a href="#六、如何导入jar包" class="headerlink" title="六、如何导入jar包"></a>六、如何导入jar包</h3><p>​1、在下面的网站中找到你需要jar包。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://mvnrepository.com/</span><br></pre></td></tr></table></figure><p>​2、复制Maven的配置文件，将其粘贴到idea中的pom.xml文件的dependencies标签里。</p><p><img src="/imgs/image-20220923180424457.png" alt="image-20220923180424457"></p><p>​3、刷新 —&gt; OK</p><h3 id="七、pom-xml文件配置详解"><a href="#七、pom-xml文件配置详解" class="headerlink" title="七、pom.xml文件配置详解"></a>七、pom.xml文件配置详解</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--上面三行不用管 --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--指定pom的模型版本，默认是4.0.0，不用管 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--当前项目打包方式，web工程打包为war，java工程打包为jar，先了解 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--组织ID，通常是用域名反写 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.zzc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目ID,通常为项目名称 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>java01<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目的版本号,SNAPSHOT: 开发版,release: 完成版--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--上面三行代码就组成了坐标 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--上面三行代码是当前项目的坐标，当别的项目需要用到本项目时就可以通过该坐标来找到 --&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--设置当前工程所用到的所有jar包 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--具体的一个jar包 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--构建 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--设置插件，将所有用到的插件放到plugins标签里--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--具体的插件配置 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="八、tomcat插件安装"><a href="#八、tomcat插件安装" class="headerlink" title="八、tomcat插件安装"></a>八、tomcat插件安装</h3><p>​见视频：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.bilibili.com/video/BV1Ah411S7ZE/?p=11&amp;spm_id_from=pageDriver&amp;vd_source=9c398663599ac78b625d463b4ffc1ff5</span><br></pre></td></tr></table></figure><h3 id="九、依赖管理"><a href="#九、依赖管理" class="headerlink" title="九、依赖管理"></a>九、依赖管理</h3><h4 id="①什么是依赖"><a href="#①什么是依赖" class="headerlink" title="①什么是依赖"></a>①什么是依赖</h4><p>​当前项目用到的jar包，这个jar包就被称为依赖。</p><h4 id="①依赖传递"><a href="#①依赖传递" class="headerlink" title="①依赖传递"></a>①依赖传递</h4><p>​当项目用到了jar包A，而这个jar包A又用到了jar包B时，该项目也可以使用jar包B了。这就是依赖传递。</p><p>​依赖传递分为：（直接依赖于间接依赖属于相对的概念）</p><ul><li>直接依赖：对于当前项目来说，jar包A就是直接依赖。</li><li>间接依赖：对于当前项目来说，jar包B就是间接依赖。</li></ul><h4 id="③依赖传递冲突问题"><a href="#③依赖传递冲突问题" class="headerlink" title="③依赖传递冲突问题"></a>③依赖传递冲突问题</h4><h5 id="A-概述"><a href="#A-概述" class="headerlink" title="A.概述"></a>A.概述</h5><p>​当项目中出现相同的jar包(但版本不一样)时，该用哪个jar包呢？这就是依赖冲突问题。</p><h5 id="B-解决办法"><a href="#B-解决办法" class="headerlink" title="B.解决办法"></a>B.解决办法</h5><ol><li>路径优先：当依赖中出现相同资源时，层级越深，优先级越低，反之则越高。</li><li>声明优先：当资源在相同层级被依赖时，配置顺序靠前的覆盖靠后的。</li><li>特殊优先：当同一个配置文件中配置了相同资源的不同版本时，后配置的覆盖先配置的。</li></ol><h4 id="④可选依赖"><a href="#④可选依赖" class="headerlink" title="④可选依赖"></a>④可选依赖</h4><h5 id="A-概述-1"><a href="#A-概述-1" class="headerlink" title="A.概述"></a>A.概述</h5><p>​可选依赖指的是：对外隐藏当前所依赖的资源</p><h5 id="B-实现步骤"><a href="#B-实现步骤" class="headerlink" title="B.实现步骤"></a>B.实现步骤</h5><p>​在想要隐藏的资源的依赖中加上<code>&lt;optional&gt;</code> 标签即可。如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>Junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="⑤排除依赖"><a href="#⑤排除依赖" class="headerlink" title="⑤排除依赖"></a>⑤排除依赖</h4><h5 id="A-概述-2"><a href="#A-概述-2" class="headerlink" title="A.概述"></a>A.概述</h5><p>​当我们不需要某些间接依赖时，可以将其删除掉。</p><h5 id="B-实现步骤-1"><a href="#B-实现步骤-1" class="headerlink" title="B.实现步骤"></a>B.实现步骤</h5><p>​如：当前项目用到了jar包A，jar包A中用到了jar包B，而当前项目不需要jar包B。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">dependencies&gt;</span><br><span class="line"><span class="comment">&lt;!--jar包A --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.zzc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>A<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!--exclusion:排除的意思 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--jar包B --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.zzc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>B<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--不用写jar包B的版本号 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="⑥依赖范围"><a href="#⑥依赖范围" class="headerlink" title="⑥依赖范围"></a>⑥依赖范围</h4><ul><li>依赖的jar包默认情况下可以在任何地方使用，可以通过scope标签设定其作用范围。</li><li>作用范围<ul><li>主程序范围有效(main文件夹范围内有效)</li><li>测试程序范围有效(test文件夹范围内)</li><li>是否参与打包(项目打包的时候是否将jar包放进去)</li></ul></li><li>依赖范围：</li></ul><table><thead><tr><th align="center">scope</th><th align="center">主程序范围</th><th align="center">测试程序范围</th><th align="center">打包</th></tr></thead><tbody><tr><td align="center">compile( 默认)</td><td align="center">有效</td><td align="center">有效</td><td align="center">参与打包</td></tr><tr><td align="center">test</td><td align="center"></td><td align="center">有效</td><td align="center"></td></tr><tr><td align="center">provided</td><td align="center">有效</td><td align="center">有效</td><td align="center"></td></tr><tr><td align="center">runtime</td><td align="center"></td><td align="center"></td><td align="center">参与打包</td></tr></tbody></table><p>​我们可以在idea中右边找到maven，点击就可以看到每个jar包后面会显示其作用范围。</p><h3 id="十、生命周期与插件"><a href="#十、生命周期与插件" class="headerlink" title="十、生命周期与插件"></a>十、生命周期与插件</h3><h4 id="①概念"><a href="#①概念" class="headerlink" title="①概念"></a>①概念</h4><h5 id="A-项目构建"><a href="#A-项目构建" class="headerlink" title="A.项目构建"></a>A.项目构建</h5><p>​项目构建：一个项目从编写源代码到编译，测试，运行，打包，部署，运行的过程。</p><ul><li>清理：将以前编译得到的旧的class字节码文件删除，为下一次编译做准备。</li><li>编译：将JAVA源程序编译成class字节码文件。</li><li>测试：自动测试，自动junit程序。</li><li>报告：测试程序执行的结果。</li><li>打包：动态WEB工程打WAR包，JAVA工程打JAR包。</li><li>安装：Maven特定的概念–将打包得到的文件复制到“仓库”中的指定位置。</li><li>部署：将动态WEB工程生成的WAR包复制 到Servlet容器的指定目录下，使其可以运行。</li></ul><h5 id="B-生命周期"><a href="#B-生命周期" class="headerlink" title="B.生命周期"></a>B.生命周期</h5><p>​生命周期：项目构建对应着一个生命周期。</p><ul><li>生命周期可以划分为三个阶段：<ul><li>clean阶段：清除工作。</li><li>default阶段：核心工作，如：编译，测试，打包，部署等。</li><li>site阶段：产生报告，发布站点等。</li></ul></li></ul><h6 id="a-clear生命周期"><a href="#a-clear生命周期" class="headerlink" title="a.clear生命周期"></a>a.clear生命周期</h6><p>​clean：清理工作</p><ul><li>pre-clean：执行一些在clean之前的工作</li><li>clean：移除上一次构建产生的所有文件</li><li>post-clean：执行一些在clean之后立刻完成的工作</li></ul><h6 id="b-default生命周期"><a href="#b-default生命周期" class="headerlink" title="b.default生命周期"></a>b.default生命周期</h6><p><img src="/imgs/f3e17822127a45a883774c43a3d17996.png" alt="在这里插入图片描述"></p><h6 id="c-site生命周期"><a href="#c-site生命周期" class="headerlink" title="c.site生命周期"></a>c.site生命周期</h6><p>​site：产生报告，发布站点等</p><ul><li>pre-site：执行一些在生成站点文档之前的工作</li><li>site：生成项目的站点文档</li><li>post-site：执行一些在生成站点文档之后完成的工作，为部署做准备</li><li>site-deploy：将生成的站点文档部署到特定的服务器上</li></ul><h4 id="②插件"><a href="#②插件" class="headerlink" title="②插件"></a>②插件</h4><ul><li><p>谁帮我们完成生命周期中每一个具体的事请呢？插件，<strong>生命周期里每一件事都对应着一个插件</strong>。</p></li><li><p>默认maven在在各个生命周期上绑定有预设的概念。</p></li><li><p>通过插件可以自定义其它功能。如：</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-source-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">&lt;!--插件执行位置 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--插件具体的执行位置 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">excution</span>&gt;</span></span><br><span class="line">           <span class="comment">&lt;!--插件的打包方式(有些插件可以写，有些不行)。当执行到当前插件时会将插件打包 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--当goal属性的值为test-jar时，是对测试代码打包--&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">goal</span>&gt;</span> <span class="comment">&lt;!--为jar时，是对main中的源码打包 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--在生命周期的什么位置上执行此插件 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">phase</span>&gt;</span>generate-test-resources<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">excution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA快捷键</title>
      <link href="/2023/04/24/IDEA%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>/2023/04/24/IDEA%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java语法（高级部分）</title>
      <link href="/2023/04/24/Java%E8%AF%AD%E6%B3%95%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/"/>
      <url>/2023/04/24/Java%E8%AF%AD%E6%B3%95%EF%BC%88%E9%AB%98%E7%BA%A7%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="三、Java高级编程"><a href="#三、Java高级编程" class="headerlink" title="三、Java高级编程"></a>三、Java高级编程</h1><h2 id="1、多线程"><a href="#1、多线程" class="headerlink" title="1、多线程"></a>1、多线程</h2><h3 id="A-基本概念"><a href="#A-基本概念" class="headerlink" title="A.基本概念"></a>A.基本概念</h3><h4 id="①程序"><a href="#①程序" class="headerlink" title="①程序"></a>①程序</h4><p>​是为完成特定任务、用某种语言编写的一组指令的集合。即指一段静态的代码，静态对象。</p><h4 id="②进程"><a href="#②进程" class="headerlink" title="②进程"></a>②进程</h4><p>​正在运行的一个程序。是一个动态的过程：有它自身的产生、存在和消亡的过程——生命周期。</p><h4 id="③线程"><a href="#③线程" class="headerlink" title="③线程"></a>③线程</h4><p>​进程可进一步细化为多个线程，是一个程序内部的一条执行路径。若一个进程同一时间并行执行多个线程，就是支持多线程的。一个进程最少有一个线程。</p><p>​说明：线程作为调度和执行的最小单位</p><h4 id="④进程、线程在JVM中的内存分配情况"><a href="#④进程、线程在JVM中的内存分配情况" class="headerlink" title="④进程、线程在JVM中的内存分配情况"></a>④进程、线程在JVM中的内存分配情况</h4><p>​一个进程只能拥有一个堆和一个方法区。一个线程独立拥有一个虚拟机栈（也就是我们常说的栈）和一个程序计算器。一个进程中的多个线程共享该进程中的堆和方法区。</p><p><img src="/imgs/image-20220803173353832.png" alt="image-20220803173353832"></p><p>​多个线程操作共享的系统资源可能就会带来安全的隐患。</p><h4 id="⑤单核与多核CPU"><a href="#⑤单核与多核CPU" class="headerlink" title="⑤单核与多核CPU"></a>⑤单核与多核CPU</h4><p>​<strong>单核CPU</strong>，其实是一种假的多线程，因为在一个时间单元内，也只能执行一个线程的任务。例如：虽然电脑有多个程序同时运行着，其实CPU是先执行一个线程一段时间，再执行另一个线程一段时间，……但是因为CPU时间单元特别短，因此以为是多线程的。</p><p>​<strong>多核CPU</strong>在同一时间内可以执行多个线程，因此多核CPU才能更好的发挥多线程的效率（现在的服务器都是多核的）。</p><h4 id="⑥并行与并发"><a href="#⑥并行与并发" class="headerlink" title="⑥并行与并发"></a>⑥并行与并发</h4><p>​<strong>并行：</strong>多个CPU同时执行多个任务。比如：多个人同时做不同的事。</p><p>​<strong>并发：</strong>一个CPU(采用时间片)“同时”执行多个任务。</p><h4 id="⑦多线程的好处"><a href="#⑦多线程的好处" class="headerlink" title="⑦多线程的好处"></a>⑦多线程的好处</h4><ul><li>提高应用程序的响应。对图形化界更有意义，可增强用户体验</li><li>提高计算机系统CPU的利用率</li><li>改善程序结构。将既长又复杂的进程分为多个线程，独立运行，利于理解和修改</li></ul><h4 id="⑧何时使用多线程"><a href="#⑧何时使用多线程" class="headerlink" title="⑧何时使用多线程"></a>⑧何时使用多线程</h4><ul><li>程序需要同时执行两个或多个任务。</li><li>程序需要实现一些需要等待的任务时，如：用户输入、文件读写操作、网络操作、搜索等。</li><li>需要一些后台运行的程序时。</li></ul><h3 id="B-线程的创建和使用"><a href="#B-线程的创建和使用" class="headerlink" title="B.线程的创建和使用"></a>B.线程的创建和使用</h3><h4 id="①多线程创建–方式一"><a href="#①多线程创建–方式一" class="headerlink" title="①多线程创建–方式一"></a>①多线程创建–方式一</h4><p>​A.创建一个继承于Thread类的子类</p><p>​B.重写Thread类的run()方法 –&gt; 将此线程执行的操作声明在run()方法中</p><p>​C.创建Thread类的子类的对象</p><p>​D.提高此对象调用start()方法。start()方法里做两件事：①启动当前线程 ②调用当前线程的run()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWrold</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadTest</span> <span class="variable">threadTest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadTest</span>();</span><br><span class="line">        threadTest.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">              System.out.println(<span class="string">&quot;******main()******&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadTest</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​一开始是在主线程（即main方法）中执行第3、4行代码，当执行完第4行代码后，就创建另一个线程了。该线程执行了线程对象中的run()方法，与此同时主线程中调用start()方法之后的代码也会同时执行，所以体现了多线程的概念。由于是同时执行，加上涉及到输出语句时，所以其运行的结果每次都不一样。</p><p>​<strong>注意：</strong></p><p>​①我们不能通过直接调用run()的方式启动线程。只能通过调用start()方法来启动线程。</p><p>​②如果想启动多个线程，只能先造多个线程对象，然后再各自调用start()方法。</p><p>​③当线程之间执行的事情不一样时，就得造不同的Thread类的子类。</p><p>​④上面的创建方式可以更简洁———创建Thread类的匿名子类</p><p>​因为创建的Thread子类的对象只使用一次，导致其类也只使用一次，所以就产生了这种写法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">25</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i % <span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">             System.out.println(<span class="string">&quot;******main()******&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><h4 id="②多线程创建–方式二"><a href="#②多线程创建–方式二" class="headerlink" title="②多线程创建–方式二"></a>②多线程创建–方式二</h4><p>​<strong>创建步骤：</strong></p><ol><li>创建一个实现了Runnable接口的类</li><li>实现类去实现Runnable中的抽象方法：run()</li><li>创建实现类的对象</li><li>将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象</li><li>通过Thread类的对象调用start()，start方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWrold</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(myThread);</span><br><span class="line">        t1.start();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Thread t2 = new Thread(myThread);</span></span><br><span class="line">        <span class="comment">//t2.start();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;<span class="comment">//写线程要执行的代码</span></span><br><span class="line">        System.out.println(<span class="string">&quot;12&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p><p>​如果用这种方式创建多个线程，并且这些线程执行的内容是一样的，那只需要这样做就行：上面的第7、8行代码</p><p>​补充：</p><p><img src="/imgs/image-20220805111247184.png" alt="image-20220805111247184"></p><p>​此时三个线程t1、t2、t3共用一个Window1对象w，因此这三个线程也就共用Window1对象w里的属性。因此<strong>定义在实现类里的属性为共享数据</strong>。</p><h4 id="③方式一-amp-方式二的对比"><a href="#③方式一-amp-方式二的对比" class="headerlink" title="③方式一&amp;方式二的对比"></a>③方式一&amp;方式二的对比</h4><p>开发中：优先选择：实现Runnable接口的方式</p><p>原因：①实现的方式没有类的单继承性的局限性</p><p>​   ②实现的方式更合适来处理多个线程有共享数据的情况</p><p>两者联系：class Thread implements Runnable</p><p>相同点：两种方式都需要重写run()，将线程要执行的逻辑声明在run()中。</p><hr><h3 id="C-Thread类常用方法的使用"><a href="#C-Thread类常用方法的使用" class="headerlink" title="C.Thread类常用方法的使用"></a>C.Thread类常用方法的使用</h3><h4 id="①start"><a href="#①start" class="headerlink" title="①start()"></a>①start()</h4><p>​start()方法的作用：启动当前线程；调用当前线程的run()</p><p>​谁调用start()方法，谁就是线程。t1.start()，t1就是线程。</p><h4 id="②run"><a href="#②run" class="headerlink" title="②run()"></a>②run()</h4><p>​通常需要重写Thread类中的此方法，将创建的线程要执行的操作声明在此方法中</p><h4 id="③currentThread"><a href="#③currentThread" class="headerlink" title="③currentThread()"></a>③currentThread()</h4><p>​该方法属于静态方法，返回执行当前代码的线程</p><p>​使用：Thread.currentThread()</p><h4 id="④getName"><a href="#④getName" class="headerlink" title="④getName()"></a>④getName()</h4><p>​获取当前线程的名字</p><p>​使用：</p><p>​①通过Thread类的子类的对象调用 </p><p>​②Thread.currentThread().getName()调用</p><h4 id="⑤setName"><a href="#⑤setName" class="headerlink" title="⑤setName()"></a>⑤setName()</h4><p>​设置当前线程的名字</p><p>​使用：</p><p>​①通过Thread类的子类的对象调用 ，只能在调用start方法前调用。</p><p>​②Thread.currentThread().setName()调用。如果想要修改主线程（main线程）的名字，只能通过此方法修改</p><p>​补充：</p><p>​也可以通过构造器的方式给线程命名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadTest</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hhhh&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//通过构造器给线程命名</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreadTest</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="⑥yield"><a href="#⑥yield" class="headerlink" title="⑥yield()"></a>⑥yield()</h4><p>​该方法是static方法</p><p>​释放当前cpu的执行权。释放后，可能被其他线程抢到了执行权，也可能还是刚才的线程抢到执行权。</p><p>​说明：</p><ul><li>在Thread类的子类里可以直接使用该方法，否则得通过Thread.currentThread().yield()或Thread.yield()调用</li></ul><h4 id="⑦join"><a href="#⑦join" class="headerlink" title="⑦join()"></a>⑦join()</h4><p>​在线程 a 中调用线程 b 的 join() 方法，即让b线程加入到a线程中，此时线程 a 进入阻塞状态，直到线程 b 执行完run()方法为止，线程 a才继续执行剩下的代码。</p><p>​应用：当线程a需要另一个线程b中的数据时，就可以让线程b加入（join）到线程a中执行。等线程b执行完后，就有数据了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用法：在线程a中使用b.join();</span></span><br></pre></td></tr></table></figure><p>​注意：该方法本身会抛出异常，所以得使用try-catch-finally或throws对其进行处理。</p><h4 id="⑧stop"><a href="#⑧stop" class="headerlink" title="⑧stop()"></a>⑧stop()</h4><p>​执行此方法时，强制结束当前线程。不推荐使用。（因为已经过时）</p><h4 id="⑨sleep-long-millis"><a href="#⑨sleep-long-millis" class="headerlink" title="⑨sleep(long millis)"></a>⑨sleep(long millis)</h4><p>​millis的单位为毫秒，1000毫秒等于1秒。该方法是静态方法，可通过Thread调用</p><p>​让当前线程“睡眠”指定的millis毫秒。在指定的millis毫秒时间内，当前线程是阻塞状态（即不执行）。过了指定的时间后，就等CPU分配资源，分配到资源后该线程才继续执行。</p><p>​注意：该方法本身会抛出异常，所以得使用try-catch-finally或throws对其进行处理。如果是在run()方法里调用sleep()方法，那只能使用try-catch-finally进行异常处理，因为父类中的run()方法在声明时并没有用throws。</p><h4 id="⑩isAlive"><a href="#⑩isAlive" class="headerlink" title="⑩isAlive()"></a>⑩isAlive()</h4><p>​判断当前线程是否存活。是，返回true；否则返回false。</p><h3 id="D-线程调度"><a href="#D-线程调度" class="headerlink" title="D.线程调度"></a>D.线程调度</h3><h4 id="①调度策略"><a href="#①调度策略" class="headerlink" title="①调度策略"></a>①调度策略</h4><p>​<strong>时间片：</strong>每个线程都执行固定的一段时间</p><p>​<strong>抢占式：</strong></p><p>​根据线程的优先级来调度，优先级越高，先被CPU调度的概率越大。</p><p>​<strong>线程的优先级：</strong></p><p>​MIN_PRIORITY &#x3D; 1</p><p>​NORM_PRIORITY &#x3D; 5   – 默认优先级</p><p>​MAX_PRIORITY &#x3D; 10</p><p>​以上属性都声明在Thread类里，且这些属性都为静态属性，可以通过Thread来调用</p><p>​<strong>说明：</strong>高优先级的线程要抢占低优先级线程CPU的执行权。但是只是从概论上讲，高优先级的线程高概率的情况下被执行。并不意味着只有当高优先级的线程执行完以后，低优先级的线程才执行。</p><h4 id="②如何获取和设置当前线程的优先级"><a href="#②如何获取和设置当前线程的优先级" class="headerlink" title="②如何获取和设置当前线程的优先级"></a>②如何获取和设置当前线程的优先级</h4><ul><li>getPriority()：获取线程优先级p</li><li>setPriority(int p)：设置线程的优先级</li></ul><h3 id="E-线程的生命周期"><a href="#E-线程的生命周期" class="headerlink" title="E.线程的生命周期"></a>E.线程的生命周期</h3><p>​记住线程生命周期里的几种状态及各状态之间是怎么转换的</p><p><img src="/imgs/image-20220805161848541.png" alt="image-20220805161848541"></p><p>​线程只有唯一的最终状态：死亡</p><p>​</p><h3 id="F-线程同步"><a href="#F-线程同步" class="headerlink" title="F.线程同步"></a>F.线程同步</h3><h4 id="①引言"><a href="#①引言" class="headerlink" title="①引言"></a>①引言</h4><p>​当多个线程操作共享数据时，就可能会出现线程安全问题。</p><p>​<strong>出现线程安全问题的原因：</strong></p><p>​当某个线程操作共享数据的过程中，尚未操作完成，其他线程参与进来，也操作共享数据。</p><p>​<strong>如何解决线程安全问题：</strong></p><p>​当一个线程a在操作共享数据的时候，其他线程不能参与进来。直到线程a操作完共享数据时，其他线程才可以开始操作共享数据。这种情况即使线程a出现了阻塞，也不能改变。</p><p>​<strong>同步机制</strong></p><p>​在Java中，我们通过同步机制，来解决线程的安全问题。</p><h4 id="②实现同步机制的方式一：同步代码块"><a href="#②实现同步机制的方式一：同步代码块" class="headerlink" title="②实现同步机制的方式一：同步代码块"></a>②实现同步机制的方式一：同步代码块</h4><p>​<strong>格式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(同步监视器)&#123;</span><br><span class="line"><span class="comment">//需要被同步的代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//快捷键alt + shift + j</span></span><br></pre></td></tr></table></figure><p>​<strong>说明：</strong></p><ol><li><p>操作共享数据的代码，即为需要同步的代码 –&gt; 不能包含代码多了，也不能包含代码少了。</p></li><li><p>共享数据：多个线程共同操作的变量。</p></li><li><p>同步监视器，俗称：锁。任何一个类的对象，都可以充当锁。但要注意：<strong>多个线程必须要共用一把锁</strong>。如果还出现线程不安全问题，大部分是因为没有共用一把锁。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="comment">//通常就用obj来充当锁了</span></span><br><span class="line"><span class="comment">/*拓展：</span></span><br><span class="line"><span class="comment">如果是在多线程的创建方式二（即：实现Runnable接口的方式）里使用同步机制一，那么锁可以考虑用this代替，如：synchronized(this)&#123;&#125;，最终能不能用this，还得看是否造了唯一的一个实现类的对象，是则可以使用this</span></span><br><span class="line"><span class="comment">如果是在多线程的创建方式一（即：继承Thread类的方式）里使用同步机制一，就不可以用this来代替锁。可以使用“继承Thread类的类名.class”,这涉及到反射的知识，后面再讲。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p> ​</p></li></ol><p></p><h4 id="③实现同步机制—方式二"><a href="#③实现同步机制—方式二" class="headerlink" title="③实现同步机制—方式二"></a>③实现同步机制—方式二</h4><p>​<strong>同步方法</strong></p><p>​如果操作共享数据的代码完整的声明在一个方法中，我们不妨将此方法声明为同步方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//格式：在void前加上synchronized即可</span></span><br><span class="line"><span class="comment">//run()方法也可以声明为同步方法，但得看声明为同步方法之后实际的逻辑合不合理</span></span><br></pre></td></tr></table></figure><p>​实现Runnable()接口的方式创建线程，然后想使用同步方法的形式解决线程安全问题,做法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">前提：所有操作共享数据的代码都在同步方法里</span></span><br><span class="line"><span class="comment">然后在 “返回值” 前加上synchronized即可</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>​继承Thread类的形式创建线程，然后想使用同步方法的形式解决线程安全问题,做法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">前提：所有操作共享数据的代码都在同步方法里</span></span><br><span class="line"><span class="comment">然后在 “返回值” 前加上synchronized，并将该方法声明为static的</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>​说明：</p><ol><li><p>同步方法仍然涉及到同步监视器，只是不需要我们显示的声明</p></li><li><p>非静态的同步方法，同步监视器是：this</p><p> 静态的同步方法，同步监视器是：当前类本身，即：类名.class</p></li></ol><h4 id="④如何判定锁只有一把"><a href="#④如何判定锁只有一把" class="headerlink" title="④如何判定锁只有一把"></a>④如何判定锁只有一把</h4><p>​A.当用实现Runnable()接口的方式创建线程时，你只需要看该实现类是否只创建了一个对象。是，则大概率是只有一把锁。</p><p>​B.用继承Thread类的方式创建线程的情况就比较容易判断出来，故不再赘述。</p><p>​C.this出现在一个类里，则代表当前类的对象，如：this出现在MyThread类里，this则代表MyThread的对象，如果MyThread类的对象只创建了一个，则this就指那唯一的一个MyThread类的对象</p><p>​<strong>总结</strong></p><p>​如果不确定是否只有一把锁，那么这样做准没错：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用同步代码块的方式：</span></span><br><span class="line"><span class="comment">synchronized(当前类的类名.class)&#123;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">使用同步方法的方式：</span></span><br><span class="line"><span class="comment">在void前加synchronized且将此方法声明为static</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="⑤线程的死锁问题"><a href="#⑤线程的死锁问题" class="headerlink" title="⑤线程的死锁问题"></a>⑤线程的死锁问题</h4><p>​<strong>定义</strong><img src="/imgs/image-20220807095717871.png" alt="image-20220807095717871"></p><p>​<strong>说明</strong><img src="/imgs/image-20220807095742472.png" alt="image-20220807095742472"></p><p>​我们在写同步时，要避免死锁。</p><p>​<strong>解决方法</strong><img src="/imgs/image-20220807101431078.png" alt="image-20220807101431078"></p><p>​</p><h4 id="⑥实现同步机制–方式三"><a href="#⑥实现同步机制–方式三" class="headerlink" title="⑥实现同步机制–方式三"></a>⑥实现同步机制–方式三</h4><p>​<strong>Lock锁</strong> - - - JDK5.0新增，Lock是一个接口，其实现类为ReentrantLock()</p><p>​<strong>实现步骤</strong></p><ol><li>在run()方法外面创建ReentrantLock()对象</li><li>将需要被同步的代码用try包起来，再在try{ }后面加上finally</li><li>在try结构的开头用ReentrantLock()对象调用锁定方法：lock()</li><li>在finally结构中用ReentrantLock()对象调用解锁方法：unlock()</li></ol><p>​<strong>说明</strong></p><ol><li><p>调用lock()方法之后的代码就只能同一时间只有一个线程执行，从而达到了线程安全的目的，当执行到unlock()时，就解锁了。</p></li><li><p>如果在实现Runnable()接口的方式里用Lock的方式解决线程安全问题，则ReentrantLock()对象就不用加static，因为这种创建线程的方式本身就有共享属性的特性，导致同步锁也只有创建了一把，符合要求，因此不用加static。</p></li><li><p>而如果在继承Thread的方式里用Lock的方式解决线程安全问题，则ReentrantLock()对象需要加static，如果不加static就会各自的ReentrantLock()对象，导致调用lock()时每个线程都各自有一把锁，这就不符合唯一一把锁的原则。所有得加static。</p></li></ol><h4 id="⑦synchronized-与-Lock的异同"><a href="#⑦synchronized-与-Lock的异同" class="headerlink" title="⑦synchronized 与 Lock的异同"></a>⑦synchronized 与 Lock的异同</h4><p><img src="/imgs/image-20220807110510173.png" alt="image-20220807110510173"></p><h3 id="G-线程的通信"><a href="#G-线程的通信" class="headerlink" title="G.线程的通信"></a>G.线程的通信</h3><h4 id="①涉及到的三个方法"><a href="#①涉及到的三个方法" class="headerlink" title="①涉及到的三个方法"></a>①涉及到的三个方法</h4><ol><li>wait()：一旦执行此方法，当前线程就会进入阻塞状态，并释放其占有的同步监视器。</li><li>notify：一旦执行此方法，就会唤醒被wait的一个线程。如果有多个线程被wait，就唤醒优先级高的那个，如果优先级一样，则随机唤醒。</li><li>notifyAll()：：一旦执行此方法，就会唤醒所有被wait的线程。</li></ol><h4 id="②注意"><a href="#②注意" class="headerlink" title="②注意"></a>②注意</h4><ol><li>上面三个方法必须使用在同步代码块或同步方法中</li><li>上面三个方法的调用者必须是同步代码块或同步方法中的同步监视器。否则，会出现IllegalMonitorStateException异常。如：如果同步监视器为obj，则想调用这三个方法，只能通过obj来调用；如果同步监视器为this，则想调用这三个方法，只能通过this来调用。</li><li>上面三个方法是定义在java.lang.Object类中。</li></ol><h4 id="③线程通信例子"><a href="#③线程通信例子" class="headerlink" title="③线程通信例子"></a>③线程通信例子</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//notify()和wait()的应用例子</span></span><br><span class="line"><span class="comment">//实现两个线程互相对话，输入1结束通信</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread2</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread2</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(thread2);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(thread2);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (MyThread2.class)&#123;</span><br><span class="line">                MyThread2.class.notify();</span><br><span class="line">                System.out.println(<span class="string">&quot;请&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;输入相应的内容，输入1结束此次输入&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">                <span class="keyword">if</span> (Integer.parseInt(s1) != <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        MyThread2.class.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/imgs/image-20220807164435613.png" alt="image-20220807164435613"></p><h3 id="H-sleep-和wait-的异同"><a href="#H-sleep-和wait-的异同" class="headerlink" title="H.sleep()和wait()的异同"></a>H.sleep()和wait()的异同</h3><p>​<strong>相同点</strong></p><p>​一旦执行方法，都可以使得当前的线程进入阻塞状态。</p><p>​<strong>不同点</strong></p><ol><li>两个方法声明的位置不同：sleep()声明在Thread类中，wait()声明在Object类中</li><li>调用的要求不同：sleep()可以在任何需要的场景下调用，wait()必须使用在同步代码块或同步方法中。</li><li>关于是否释放同步监视器：如果两个方法都使用在同步代码块或同步方法中，sleep()不会释放同步监视器，而wait()会释放同步监视器。</li></ol><h3 id="I-JDK5-0新增线程创建方式–实现Callable接口"><a href="#I-JDK5-0新增线程创建方式–实现Callable接口" class="headerlink" title="I.JDK5.0新增线程创建方式–实现Callable接口"></a>I.JDK5.0新增线程创建方式–实现Callable接口</h3><h4 id="①实现步骤"><a href="#①实现步骤" class="headerlink" title="①实现步骤"></a>①实现步骤</h4><ol><li><p>创建一个实现Callable接口的实现类</p></li><li><p>在实现类中实现call方法，将此线程需要执行的操作声明在call()中。</p><p> — |  该call()方法有返回值，可以返回基本数据类型（因为基本数据类型可以转换为包装类），如果不需要返回值，则return null。</p><p> — |  该call()方法声明在Callable接口时就可以throws异常，因此重写的时候也可以抛异常</p></li><li><p>创建Callable接口实现类的对象</p></li><li><p>将此Callable接口实现类的对象作为参数传递到FutureTask构造器中，创建FutureTask的对象</p></li><li><p>将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用Thread对象调用start()方法。</p><p> 如果对call()方法中的返回值感兴趣，则执行步骤6，否则执行到步骤5即可</p></li><li><p>获取Callable方法的返回值。用刚才FutureTask类创建的对象调用get()方法。</p><p> — | get()返回值即为FutureTask构造器参数Callable实现类重写的call()的返回值，即call()的返回值。</p><p> — | get()方法本身有异常，可以用try-catch-finally来处理</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Object 变量名=FutureTask的对象.get();</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="②补充"><a href="#②补充" class="headerlink" title="②补充"></a>②补充</h4><ol><li><p>什么情况下需要Callable方法的返回值呢？</p><p> ​当一个线程需要用到另一个线程的运行结果时，就需要返回值</p></li><li><p>实现Runnable接口和Callable接口的比较</p></li></ol><p><img src="/imgs/image-20220807221213859.png" alt="image-20220807221213859"></p><h3 id="J-JDK5-0新增线程创建方式—使用线程池"><a href="#J-JDK5-0新增线程创建方式—使用线程池" class="headerlink" title="J.JDK5.0新增线程创建方式—使用线程池"></a>J.JDK5.0新增线程创建方式—使用线程池</h3><p>​实际开发中最常用的线程创建方式—–线程池</p><h4 id="①思路"><a href="#①思路" class="headerlink" title="①思路"></a>①思路</h4><p>​提前创建好多个线程，放入线程池中，使用时直接获取，使用完后不是直接销毁而是放回池中。可以避免频繁创建销毁、实现重复利用。</p><h4 id="②使用线程池的好处"><a href="#②使用线程池的好处" class="headerlink" title="②使用线程池的好处"></a>②使用线程池的好处</h4><p><em>&gt;</em> 提高响应速度（减少了创建新线程的时间）</p><p><em>&gt;</em> 降低资源消耗（重复利用线程池中线程，不需要每次都创建）</p><p>*&gt;*便于线程管理，如：corePoolSize：核心池的大小；maximumPoolSize：最大线程数；keepAliveTime：线程没有任务时最多保持多长时间后会终止；…..</p><h4 id="③实现步骤"><a href="#③实现步骤" class="headerlink" title="③实现步骤"></a>③实现步骤</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Thread1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWrold</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">    <span class="comment">//1.提供指定线程数量的线程池</span></span><br><span class="line">  <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//2.启动一个线程。调用execute()或submit()</span></span><br><span class="line">        service.execute(<span class="keyword">new</span> <span class="title class_">Thread1</span>());</span><br><span class="line">   <span class="comment">//3.关闭连接池</span></span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="④补充说明："><a href="#④补充说明：" class="headerlink" title="④补充说明："></a>④补充说明：</h4><ol><li><p>调用execute()时需要传递一个参数，该参数为实现Runnable接口的实现类的对象。因为在造线程池时，并没有指定线程要干什么，所以就得往该方法中传递参数，明确当前线程干什么。该方法就是用来启动线程的。</p></li><li><p>调用submit()时需要递一个参数，该参数为实现Callable接口的实现类的对象。为什么要传参数？原因同上。</p></li><li><p>execute()或submit()方法一次只能启动一个线程</p></li><li><p>如果每个线程干的事情都不一样，那么就得造不同的Runnable或Callable的实现类，然后再造不同的实现类对象。</p></li><li><p>如果想获取call()方法的返回值，直接在调用submit()方法的时候在后面加上“.get()”即可，如：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">o1</span> <span class="operator">=</span> service.submit(t2).get();</span><br><span class="line"><span class="comment">//别忘了get()本身是带有异常的，因此要用try-catch-finally或throws进行处理</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="⑤设置线程池的属性"><a href="#⑤设置线程池的属性" class="headerlink" title="⑤设置线程池的属性"></a>⑤设置线程池的属性</h4><ol><li>将上面实现步骤1中得到的对象（service）强转为ThreadPoolExecutor类型</li><li>将强转后的得到的对象调用相应属性的set方法即可，如：setKeepAliveTime，setCoorePoolSize等</li></ol><h3 id="L-小结"><a href="#L-小结" class="headerlink" title="L.小结"></a>L.小结</h3><h4 id="①释放锁的操作"><a href="#①释放锁的操作" class="headerlink" title="①释放锁的操作"></a>①释放锁的操作</h4><p><img src="/imgs/image-20220809123241609.png" alt="image-20220809123241609"></p><h4 id="②不会释放锁的操作"><a href="#②不会释放锁的操作" class="headerlink" title="②不会释放锁的操作"></a>②不会释放锁的操作</h4><p><img src="/imgs/image-20220809123614655.png" alt="image-20220809123614655"></p><hr><h2 id="2、常用类"><a href="#2、常用类" class="headerlink" title="2、常用类"></a>2、常用类</h2><h3 id="A-String类"><a href="#A-String类" class="headerlink" title="A.String类"></a>A.String类</h3><h4 id="①给字符串赋值的方式有两种"><a href="#①给字符串赋值的方式有两种" class="headerlink" title="①给字符串赋值的方式有两种"></a>①给字符串赋值的方式有两种</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.通过字面量的方式</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="comment">//2.通过new的方式</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;123&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="②概述"><a href="#②概述" class="headerlink" title="②概述"></a>②概述</h4><p>​a.String声明为final的，不可被继承</p><p>​b.String实现了Serializable接口：表示字符串是支持序列化的。即：该对象可以通过网络进行传输。</p><p>​实现了Comparable接口，表示字符串可以比较大小。</p><p>​c.String内部定义了final char[] value用于存储字符串数据</p><p>​d.通过字面量的方式给一个字符串赋值，此时的字符串值声明在方法区中的字符串常量池中。</p><p>​e.字符串常量池中是不会存储相同内容的字符串的。</p><p>​f.String代表不可变的字符序列，简称不可变性。即：无论对字符串进行什么操作都不能改变其值，都得重新造。体现：</p><ol><li>当对字符串重新赋值时，需要重新指定内存区，不能使用原有的value进行赋值。如:</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s1=<span class="string">&quot;abc&quot;</span>;</span><br><span class="line">String s2=<span class="string">&quot;abc&quot;</span>;</span><br><span class="line">s1=<span class="string">&quot;Hello&quot;</span>;</span><br></pre></td></tr></table></figure><p>此时的内存结构如下：<img src="/imgs/20201006104300710.png" alt="在这里插入图片描述"></p><pre><code> 2.当对现有的字符串进行连接操作时，也需要重新指定内存区，不能使用原有的value进行赋值。</code></pre><p>​3.当调用String的replace（）方法修改指定字符或字符串时，也需要重新指定内存区，不能使用原有的value进行赋值。</p><h4 id="③字符串两种赋值方式的区别"><a href="#③字符串两种赋值方式的区别" class="headerlink" title="③字符串两种赋值方式的区别"></a>③字符串两种赋值方式的区别</h4><p>​<img src="/imgs/image-20220809173757763.png" alt="image-20220809173757763"></p><p>​如果将str2改成def，则内存中先会在字符串常量池中造个def，然后将此def的地址赋给value。</p><h4 id="④面试题"><a href="#④面试题" class="headerlink" title="④面试题"></a>④面试题</h4><p>​<img src="/imgs/image-20220809182652824.png" alt="image-20220809182652824"></p><h4 id="⑤字面量赋值的细节"><a href="#⑤字面量赋值的细节" class="headerlink" title="⑤字面量赋值的细节"></a>⑤字面量赋值的细节</h4><ul><li><p>常量与常量的拼接结果在常量池。且常量池中不会存在相同内容的常量。</p></li><li><p>只要其中有一个是变量，就是在堆空间中创建一个对象，该对象再指向方法区中的字符串常量池中的字符串 。</p></li></ul><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;world&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;helloworld&quot;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span> + <span class="string">&quot;world&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> s1 + <span class="string">&quot;world&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> s1 + s2;</span><br><span class="line">System.out.println(s3 == s4);<span class="comment">//truue</span></span><br><span class="line">System.out.println(s3 == s5);<span class="comment">//false</span></span><br><span class="line">System.out.println(s3 == s6);<span class="comment">//false</span></span><br><span class="line">System.out.println(s5 == s6);<span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>​内存解析：</p><img src="/imgs/image-20230424202223552.png" alt="image-20230424202223552" style="zoom:50%;" /><h4 id="⑥intern"><a href="#⑥intern" class="headerlink" title="⑥intern()"></a>⑥intern()</h4><p>​使用：字符串变量调用</p><p>​intern()返回的是调用该方法的字符串在字符串常量池中的地址值。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;456&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> s1.intern();<span class="comment">//返回的是“123”在字符串常量池中的地址值。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> (s1 + s2).intern();<span class="comment">//返回的是“123456”在字符串常量池中的地址值。</span></span><br></pre></td></tr></table></figure><h4 id="⑦-String类常用方法"><a href="#⑦-String类常用方法" class="headerlink" title="⑦.String类常用方法"></a>⑦.String类常用方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="type">int</span> <span class="title function_">length</span><span class="params">()</span>：返回字符串的长度： <span class="keyword">return</span> value.length</span><br><span class="line">&gt; <span class="type">char</span> <span class="title function_">charAt</span><span class="params">(<span class="type">int</span> index)</span>： 返回某索引处的字符<span class="keyword">return</span> value[index] 索引从<span class="number">0</span>开始</span><br><span class="line">&gt; <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>：判断是否是空字符串：<span class="keyword">return</span> value.length == <span class="number">0</span></span><br><span class="line">&gt; String <span class="title function_">toLowerCase</span><span class="params">()</span>：使用默认语言环境，将String 中的所有字符转换为小写</span><br><span class="line">&gt; String <span class="title function_">toUpperCase</span><span class="params">()</span>：使用默认语言环境，将 String 中的所有字符转换为大写</span><br><span class="line">&gt; String <span class="title function_">trim</span><span class="params">()</span>：返回字符串的副本，将该字符串的首个字符前的空格、最后一个字符后面的空格去掉</span><br><span class="line">&gt; <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>：比较字符串的内容是否相同</span><br><span class="line">&gt; <span class="type">boolean</span> <span class="title function_">equalsIgnoreCase</span><span class="params">(String anotherString)</span>：与equals方法类似，忽略大小写</span><br><span class="line">&gt; String <span class="title function_">concat</span><span class="params">(String str)</span>：将指定字符串连接到此字符串的结尾。 等价于用“+”</span><br><span class="line">&gt; <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(String anotherString)</span>：比较两个字符串内容的大小</span><br><span class="line">&gt; String <span class="title function_">substring</span><span class="params">(<span class="type">int</span> beginIndex)</span>：返回一个新的字符串，它是此字符串的从beginIndex开始截取到最后的一个子字符串。</span><br><span class="line">&gt; String <span class="title function_">substring</span><span class="params">(<span class="type">int</span> beginIndex, <span class="type">int</span> endIndex)</span> ：返回一个新字符串，它是此字符串从beginIndex开始截取到endIndex(不包含)的一个子字符串。</span><br><span class="line">&gt; <span class="type">boolean</span> <span class="title function_">endsWith</span><span class="params">(String suffix)</span>：测试此字符串是否以指定的后缀结束，suffix可以是多个字符、一个字符。区分大小写</span><br><span class="line">&gt; <span class="type">boolean</span> <span class="title function_">startsWith</span><span class="params">(String prefix)</span>：测试此字符串是否以指定的前缀开始，区分大小写</span><br><span class="line">&gt; <span class="type">boolean</span> <span class="title function_">startsWith</span><span class="params">(String prefix, <span class="type">int</span> toffset)</span>：测试此字符串从指定索引开始的子字符串是否以指定前缀开始</span><br><span class="line">&gt; <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(CharSequence s)</span>：当且仅当此字符串包含指定的 <span class="type">char</span> 值序列时，返回 <span class="literal">true</span></span><br><span class="line">&gt; <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(String str)</span>：返回指定子字符串在此字符串中第一次出现处的索引</span><br><span class="line">&gt; <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(String str, <span class="type">int</span> fromIndex)</span>：返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始找</span><br><span class="line">&gt; <span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(String str)</span>：返回指定子字符串在此字符串中最右边出现处的索引</span><br><span class="line">&gt; <span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(String str, <span class="type">int</span> fromIndex)</span>：返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始从右往左找</span><br><span class="line"><span class="comment">//注：indexOf和lastIndexOf方法如果未找到都是返回-1</span></span><br><span class="line"></span><br><span class="line">&gt; String <span class="title function_">replace</span><span class="params">(<span class="type">char</span> oldChar, <span class="type">char</span> newChar)</span>：返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。</span><br><span class="line">&gt; String <span class="title function_">replace</span><span class="params">(CharSequence target, CharSequence replacement)</span>：将字符串中所有出现target的地方全替换成replacement</span><br><span class="line">&gt; String <span class="title function_">replaceAll</span><span class="params">(String regex, String replacement)</span> ： 使 用 给 定 的replacement 替换此字符串所有满足给定的正则表达式的子字符串。</span><br><span class="line">&gt; String <span class="title function_">replaceFirst</span><span class="params">(String regex, String replacement)</span> ： 使 用 给 定 的replacement 替换此字符串满足给定的正则表达式的第一个子字符串。</span><br><span class="line">&gt; <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(String regex)</span>：告知此字符串是否满足给定的正则表达式。</span><br><span class="line">&gt; String[] split(String regex)：根据给定正则表达式的匹配拆分此字符串。</span><br><span class="line">&gt; String[] split(String regex, <span class="type">int</span> limit)：根据匹配给定的正则表达式来拆分此字符串，最多不超过limit个，如果超过了，剩下的全部都放到最后一个元素中。</span><br></pre></td></tr></table></figure><h4 id="⑧String-与-char-之间的转换"><a href="#⑧String-与-char-之间的转换" class="headerlink" title="⑧String 与 char[]之间的转换"></a>⑧String 与 char[]之间的转换</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//String --&gt; char[]：调用String的toCharArray()</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">char</span>[] c1 = s1.toCharArray();</span><br><span class="line"><span class="comment">//char[] --&gt; String：调用String的构造器</span></span><br><span class="line"><span class="type">char</span>[] c2 = <span class="keyword">new</span> <span class="title class_">char</span>[]&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(c2);<span class="comment">//s2: &quot;abc&quot;</span></span><br></pre></td></tr></table></figure><h4 id="⑨String-与byte-之间的转换"><a href="#⑨String-与byte-之间的转换" class="headerlink" title="⑨String 与byte[]之间的转换"></a>⑨String 与byte[]之间的转换</h4><p>编码：字符串 —&gt; 字节或字节数组（通俗来讲：看得懂 —&gt; 看不懂的二进制数据）</p><p>解码：编码的逆过程，字节 —&gt; 字符串（通俗来讲：看不懂的二进制数据 —&gt; 看得懂）</p><p><strong>编码：</strong>String —&gt; byte[ ]：调用String的getBytes()</p><p><strong>解码：</strong>byte[ ] —&gt; String：调用String的构造器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//String ---&gt; byte[]</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">byte</span>[] b1 = s1.getBytes();<span class="comment">//getBytes可以选择不同的参数，如果不选参数，意味着：在转换为byte时使用默认的编码集（如果IDEA设置的编码集为UTF-8，则转换时就用UTF-8进行编码），如果选择带参的，此参数为你要指定的编码集，如：s1.getBytes(&quot;gbk&quot;)</span></span><br><span class="line"><span class="comment">//byte[] ---&gt; String</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(b1);<span class="comment">//使用默认的编码集进行解码</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(b1,<span class="string">&quot;gbk&quot;</span>);<span class="comment">//使用指定的编码集进行解码</span></span><br></pre></td></tr></table></figure><p>​<strong>注意：</strong></p><p>​编码和解码要使用相同的编码集，不然会出现乱码</p><h4 id="⑩String-和-StringBuffer、StringBuilder的转换"><a href="#⑩String-和-StringBuffer、StringBuilder的转换" class="headerlink" title="⑩String 和 StringBuffer、StringBuilder的转换"></a>⑩String 和 StringBuffer、StringBuilder的转换</h4><p>​A.String –&gt; StringBuffer、StringBuilder</p><p>​调用StringBuffer、StringBuilder构造器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(s1);</span><br></pre></td></tr></table></figure><p>​B.StringBuffer、StringBuilder –&gt; String</p><p>​调用String构造器；StringBuffer、StringBuilder的toString()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(sb1);<span class="comment">//调用String构造器</span></span><br></pre></td></tr></table></figure><hr><h3 id="B-StringBuffer类"><a href="#B-StringBuffer类" class="headerlink" title="B.StringBuffer类"></a>B.StringBuffer类</h3><h4 id="①创建格式"><a href="#①创建格式" class="headerlink" title="①创建格式"></a>①创建格式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;abc&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="②常用方法"><a href="#②常用方法" class="headerlink" title="②常用方法"></a>②常用方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; StringBuffer <span class="title function_">append</span><span class="params">(xxx)</span>：提供了很多的append()方法，用于对原有的字符串进行添加，“xxx”可以是任意多个字符</span><br><span class="line">&gt; StringBuffer <span class="title function_">delete</span><span class="params">(<span class="type">int</span> start,<span class="type">int</span> end)</span>：删除指定位置的内容，原有的数据会改变，删除的内容不包含end位置上的字符</span><br><span class="line">&gt; StringBuffer <span class="title function_">replace</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end, String str)</span>：把[start,end)位置替换为str，str的长度可以是任意的。</span><br><span class="line">&gt; StringBuffer <span class="title function_">insert</span><span class="params">(<span class="type">int</span> offset, xxx)</span>：在指定位置插入xxx</span><br><span class="line">&gt; StringBuffer <span class="title function_">reverse</span><span class="params">()</span> ：把当前字符序列逆转</span><br><span class="line"></span><br><span class="line">此外，还定义了如下的方法：（同String）</span><br><span class="line"></span><br><span class="line">&gt; <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(String str)</span></span><br><span class="line">&gt; <span class="keyword">public</span> String <span class="title function_">substring</span><span class="params">(<span class="type">int</span> start,<span class="type">int</span> end)</span>，注意：要获取其返回的值</span><br><span class="line">&gt; <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">length</span><span class="params">()</span></span><br><span class="line">&gt; <span class="keyword">public</span> <span class="type">char</span> <span class="title function_">charAt</span><span class="params">(<span class="type">int</span> n )</span></span><br><span class="line">&gt; <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCharAt</span><span class="params">(<span class="type">int</span> n ,<span class="type">char</span> ch)</span></span><br><span class="line"><span class="comment">//上面的方法都是通过StringBuffer对象来调用</span></span><br></pre></td></tr></table></figure><p>​总结：</p><p>​增：append(xxx)</p><p>​删：delete(int start,int end)</p><p>​改：setCharAt(int n,char ch) &#x2F; replace(int start, int end, String str)</p><p>​查：charAt(int n)</p><p>​插：insert(int offset,xxx)</p><p>​长度：length()</p><p>​遍历：toString</p><h4 id="③补充"><a href="#③补充" class="headerlink" title="③补充"></a>③补充</h4><p>​如果在开发中需要频繁地对字符串进行修改，可以使用StringBuffer(int capacity) 来指定大点char数组的初始长度，进而避免对char数组进行多次扩容造执行效率下降。</p><h3 id="C-StringBuilder类"><a href="#C-StringBuilder类" class="headerlink" title="C.StringBuilder类"></a>C.StringBuilder类</h3><h4 id="①创建格式-1"><a href="#①创建格式-1" class="headerlink" title="①创建格式"></a>①创建格式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;abc&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="②常用方法-1"><a href="#②常用方法-1" class="headerlink" title="②常用方法"></a>②常用方法</h4><p>与StringBuffer中的常用方法一样，只是StringBuilder中的方法线程不安全，StringBuffer中的方法线程安全。所以参考StringBuffer的常用方法即可。</p><h4 id="③补充-1"><a href="#③补充-1" class="headerlink" title="③补充"></a>③补充</h4><p>​如果在开发中需要频繁地对字符串进行修改，可以使用StringBuilder(int capacity)来指定大点char数组的初始长度，进而避免对char数组进行多次扩容造执行效率下降。</p><h3 id="D-String-StringBuffer-StringBuilder三者异同"><a href="#D-String-StringBuffer-StringBuilder三者异同" class="headerlink" title="D.String StringBuffer StringBuilder三者异同"></a>D.String StringBuffer StringBuilder三者异同</h3><p><strong>String：</strong>不可变的字符序列；底层使用char[]数组存储。<br><strong>StringBuffer：</strong>可变的字符序列；线程安全的，效率低；底层使用char[]数组存储。<br><strong>StringBuilder：</strong>jdk5.0新增的；可变的字符序列；线程不安全的，效率高；底层使用char[]数组存储。</p><p>它们底层都是用char数组进行存储的，为什么StringBuffer和StringBuilder就是可变字符序列呢？</p><p>源码分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>();<span class="comment">//char value[] = new char[0];</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);<span class="comment">//char value[] = new char[]&#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();<span class="comment">//char value[] = new char[16];底层创建了一个长度是16的char型数组</span></span><br><span class="line">sb1.append(<span class="string">&#x27;a&#x27;</span>);<span class="comment">//value[0] = &#x27;a&#x27;;</span></span><br><span class="line">sb1.append(<span class="string">&#x27;b&#x27;</span>);<span class="comment">//value[1] = &#x27;b&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;abc&quot;</span>);<span class="comment">//char value[] = new char[&quot;abc&quot;.length() + 16];底层创建了一个长度为19的char数组</span></span><br></pre></td></tr></table></figure><p>​问题1：sb2.length()是指sb2字符串的长度，因此为3</p><p>​问题2：扩容问题：如果要添加的数据底层数组盛不下了，那就需要扩容底层得到数组。默认情况下，扩容为原来容量的2倍 + 2，同时将原有的元素复制到新的数组中。</p><p>三者效率排序：StringBuilder &gt; StringBuffer &gt; String</p><h3 id="E-JDK8之前日期时间API"><a href="#E-JDK8之前日期时间API" class="headerlink" title="E.JDK8之前日期时间API"></a>E.JDK8之前日期时间API</h3><h4 id="①java-lang-System类"><a href="#①java-lang-System类" class="headerlink" title="①java.lang.System类"></a>①java.lang.System类</h4><p>System类提供的public static long currentTimeMillis()用来返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差。称为<strong>时间戳</strong>。</p><p>此方法适于计算时间差、或用来表示订单号</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">System.out.println(time);</span><br></pre></td></tr></table></figure><h4 id="②java-util-Date类"><a href="#②java-util-Date类" class="headerlink" title="②java.util.Date类"></a>②java.util.Date类</h4><ol><li><p>两个构造器的使用</p><p> 构造器一：Date()：创建一个对应当前时间的Date对象</p><p> 构造器二：Date(long date)：创建指定时间戳的Date对象，实参一定记得加L，因为是long型数据</p></li><li><p>两个方法的使用</p><p> toString()：显示当前的年、月、日、时、分、秒</p><p> getTime()：获取当前Date对象对应的毫秒数（即：当前Date对象的时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差）。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//上面的方法都是通过Date对象来调用</span></span><br></pre></td></tr></table></figure></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">System.out.println(date);<span class="comment">//Sun Aug 14 11:17:23 CST 2022</span></span><br></pre></td></tr></table></figure><h4 id="③java-sql-Date类"><a href="#③java-sql-Date类" class="headerlink" title="③java.sql.Date类"></a>③java.sql.Date类</h4><p>​该类是java.util.Date类的子类。其对应着数据库中的日期类型的变量。日常中，我们通常用java.util.Date，涉及到数据库的时候再用java.sql.Date</p><p>​A.如何实例化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.sql.<span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.sql.Date(<span class="number">12345678L</span>);</span><br><span class="line"><span class="comment">//其构造器中放时间戳</span></span><br><span class="line">System.out.println(date);<span class="comment">//输出年月日</span></span><br></pre></td></tr></table></figure><p>​B.java.until.Date –&gt; java.sql.Date</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如何将java.until.Date的对象转换为java.sql.Date对象</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">java.sql.<span class="type">Date</span> <span class="variable">date2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.sql.Date(date1.getTime());</span><br></pre></td></tr></table></figure><h4 id="④-SimpleDateFormat"><a href="#④-SimpleDateFormat" class="headerlink" title="④.SimpleDateFormat"></a>④.SimpleDateFormat</h4><p>​<strong>概述</strong></p><p>​SimpleDateFormat属于java.text包下的一个类。</p><p>​SimpleDateFormat的使用：SimpleDateFormat是对日期Date类的格式化和解析。</p><p>​格式化：日期 —&gt; 字符串</p><p>​解析：格式化的 逆过程，字符串 —&gt; 日期</p><p>​格式化和解析是都调用非静态的方法，因此想用得先实例化SimpleDateFormat。</p><p>​<strong>具体实现</strong></p><p>​实例化：</p><ul><li><p>使用空参的构造器（使用默认的方式格式化和解析），开发中不用</p></li><li><p>使用带参的构造器（用指定的方式格式化和解析）</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开发中一般使用这种指定的方式的构造器</span></span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);</span><br><span class="line"><span class="comment">//参数可以自己搭配，y -- year;M --&gt; month;d --&gt; day</span></span><br></pre></td></tr></table></figure></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">格式化：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- 用SimpleDateFormat对象调用format(Date date)方法</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">解析：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- 用SimpleDateFormat对象调用parse(String str)方法，该方法返回的是util下Date的对象</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注意：①parse方法本身会抛异常，因此需对此进行异常处理。②如果使用空参的构造器，那么参数str就得按照默认的格式来写；使用带参的构造器，那么参数str就得按照你指定的格式来写。不然抛异常。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//****************使用默认的方式格式化和解析***************</span></span><br><span class="line"><span class="comment">//1.实例化SimpleDateFormat()</span></span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.格式化：日期 --&gt; 字符串</span></span><br><span class="line"> <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();<span class="comment">//</span></span><br><span class="line"> <span class="type">String</span> <span class="variable">format</span> <span class="operator">=</span> sdf.format(date);</span><br><span class="line">System.out.println(format);<span class="comment">//22-8-14 上午10:28</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.解析：字符串 ---&gt; 日期</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;22-8-14 上午10:28&quot;</span>;</span><br><span class="line"><span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> sdf.parse(s1);<span class="comment">//使用默认的方式格式化，那么解析时字符串就得符合默认方式的格式（像s1的这种格式），不然会报错。</span></span><br></pre></td></tr></table></figure><p>​<strong>练习</strong></p><p><img src="/imgs/image-20220814113529332.png" alt="image-20220814113529332"></p><h4 id="⑤Calendar日历类"><a href="#⑤Calendar日历类" class="headerlink" title="⑤Calendar日历类"></a>⑤Calendar日历类</h4><p>​<strong>概述</strong> </p><p>​Date类表示的时间不通用（就有些国家的人看不懂），且其中的有些方法已经过时了，所以我们引入Calendar类。</p><p>​Calender是一个抽象类</p><p>​<strong>实列化</strong></p><ul><li><p>方式一：创建其子类（GregorianCalendar）的对象，这种方法少用</p></li><li><p>方式二：调用Calender的静态方法getInstance()。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Calendar</span> <span class="variable">instance</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line"><span class="comment">//instance：当前时间的对象</span></span><br><span class="line"><span class="comment">//getInstance()方法实际上返回的是GregorianCalendar类的对象</span></span><br></pre></td></tr></table></figure><p>  <strong>常用方法</strong></p><p>  下面的方法通过Calendar对象来调用</p></li></ul><p>​A.get()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">获取Calendar类中的一些属性，如：</span><br><span class="line"></span><br><span class="line">YEAR、MONTH、DAY_OF_WEEK、HOUR_OF_DAY 、MINUTE、SECOND、DAY_OF_MONTH、DAY_OF_YEAR</span><br><span class="line">//这些属性都是静态的，通过Calendar类就可以调用。然后把这些属性放进get()方法的（）中即可获取。</span><br><span class="line">/*属性含义：</span><br><span class="line">DAY_OF_WEEK：当前时间是这个星期的第几天</span><br><span class="line">HOUR_OF_DAY：当前时间是一天中的第几个小时</span><br><span class="line">DAY_OF_YEAR：当前时间是一年中的第几天</span><br><span class="line">DAY_OF_MONTH：当前时间是一个月中的第几天</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>​B.set()</p><p>​修改Calendar类的对象中的属性，set()方法的形参放Calender类的属性和修改的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Calendar</span> <span class="variable">instance</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">instance.set(Calendar.DAY_OF_MONTH,<span class="number">22</span>);</span><br></pre></td></tr></table></figure><p>​C.add()</p><p>​对Calendar类的对象中的属性值进行加减操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Calendar</span> <span class="variable">instance</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">instance.set(Calendar.DAY_OF_MONTH,<span class="number">3</span>);<span class="comment">//如：DAY_OF_MONTH 本来为22，加3后，DAY_OF_MONTH = 25；修第二个形参可以为负数</span></span><br></pre></td></tr></table></figure><p>​D.getTime()</p><p>​该方法的作用：Calendat类—&gt; Date类，返回一个Date类的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Calendar</span> <span class="variable">instance</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> instance.getTime();</span><br></pre></td></tr></table></figure><p>​E.setTime()</p><p>​该方法的作用：Date类 —&gt; Calendar类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="type">Calendar</span> <span class="variable">instance</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">instance.setTime(date1);<span class="comment">//将date对象对应的时间赋给Calendar类对象instance，因此这两对象的对应的时间是一样的</span></span><br></pre></td></tr></table></figure><p>​F.补充：</p><p>​获取月份时：一月是0，二月是1，以此类推，12月是11</p><p>​获取星期时，周日是1，周一是2，周二是3，。。。。。周六是7</p><hr><h3 id="H-JDK8中新日期时间API"><a href="#H-JDK8中新日期时间API" class="headerlink" title="H.JDK8中新日期时间API"></a>H.JDK8中新日期时间API</h3><h4 id="①引言-1"><a href="#①引言-1" class="headerlink" title="①引言"></a>①引言</h4><p>​为什么需要新的时间API？</p><p>​因为旧的时间API存在以下问题：</p><p><img src="/imgs/image-20220814210204062.png" alt="image-20220814210204062"></p><p>​</p><h4 id="②LocalDate、LocalTime、LocalDateTime的使用"><a href="#②LocalDate、LocalTime、LocalDateTime的使用" class="headerlink" title="②LocalDate、LocalTime、LocalDateTime的使用"></a>②LocalDate、LocalTime、LocalDateTime的使用</h4><p>​A.实例化</p><p>​方式一：调用now()，根据当前时间创建日期对象、时间对象、日期时间对象。该方法是静态方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">LocalDate</span> <span class="variable">localDate</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line"> <span class="type">LocalTime</span> <span class="variable">localTime</span> <span class="operator">=</span> LocalTime.now();</span><br><span class="line"> <span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line"> </span><br><span class="line"> System.out.println(localDate);<span class="comment">//2022-08-15</span></span><br><span class="line"> System.out.println(localTime);<span class="comment">//12:17:21.771</span></span><br><span class="line"> System.out.println(localDateTime);</span><br><span class="line"><span class="comment">//2022-08-15T12:17:21.771</span></span><br></pre></td></tr></table></figure><p>​说明：</p><ul><li>LocalDateTime相较于LocalDate、LocalTime，使用频率要高。</li></ul><p>​方式二：调用of()，返回指定时间的日期对象、时间对象、日期时间对象。该方法是静态方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以LocalDate类举例：</span></span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">localDate</span> <span class="operator">=</span> LocalDate.of(<span class="number">2022</span>, <span class="number">8</span>, <span class="number">10</span>);</span><br><span class="line">System.out.println(localDate);<span class="comment">//2022-08-10</span></span><br></pre></td></tr></table></figure><p>​</p><p>​B.getXxx()</p><p>​通过这三个类的对象进行调用，获取相关的属性。获取的属性值是没有偏移量的，不像Calendar类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以LocalDateTime类为例：</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line"></span><br><span class="line">System.out.println(localDateTime.getDayOfYear());<span class="comment">//227</span></span><br><span class="line">System.out.println(localDateTime.getDayOfMonth());<span class="comment">//15</span></span><br><span class="line">System.out.println(localDateTime.getDayOfWeek());<span class="comment">//MONDAY</span></span><br></pre></td></tr></table></figure><p>​C.withXxx()</p><p>​通过对象来调用，修改对象的属性值。</p><p>​说明：</p><ul><li>修改后，会返回一个修改后的对象，原对象的属性值并没有发生变化。体现了不可变性。</li></ul><p>​D.plusXxxx(要加的值)</p><p>​在属性值上加上某个值。</p><p>​说明：</p><ul><li>该方法通过对象调用。</li><li>该方法返回一个加上值后的对象，原有对象的属性值不变。体现不可变性。</li></ul><p>​E.minusXxx(要减的值)</p><p>​在属性值上减去某个值</p><p>​说明：</p><ul><li>该方法通过对象调用。</li><li>该方法返回一个减去值后的对象，原有对象的属性值不变。体现不可变性。</li></ul><hr><h4 id="③Instant"><a href="#③Instant" class="headerlink" title="③Instant"></a>③Instant</h4><p>​Instant类似于java.util下的Date类</p><p>​A.实例化</p><p>​<strong>方式一：</strong>调用now方法，该方法为静态方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Instant</span> <span class="variable">instant</span> <span class="operator">=</span> Instant.now();</span><br><span class="line">System.out.println(instant);<span class="comment">//2022-08-15T05:34:02.810Z</span></span><br></pre></td></tr></table></figure><p>​<strong>说明：</strong></p><ul><li><p>now()：获取的是本初子午线对应的标准时间</p></li><li><p>需要获取我们现在的时间（东八区），就要这么做：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加时间的偏移量</span></span><br><span class="line"><span class="type">OffsetDateTime</span> <span class="variable">offsetDateTime</span> <span class="operator">=</span> instant.atOffset(ZoneOffset.ofHours(<span class="number">8</span>));</span><br><span class="line">System.out.println(offsetDateTime);</span><br><span class="line"><span class="comment">//2022-08-15T13:34:02.810+08:00</span></span><br></pre></td></tr></table></figure><p>  <strong>方式二：</strong>调用 ofEpochMilli(long epochMilli)</p><p>  <strong>说明：</strong></p><ul><li>属于静态方法。其返回指定毫秒数的Instant类的对象。</li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Instant</span> <span class="variable">instant1</span> <span class="operator">=</span> Instant.toEpochMilli(<span class="number">15550475314878L</span>);</span><br></pre></td></tr></table></figure></li></ul><p>​B.toEpochMilli()</p><p>​<strong>说明：</strong></p><ul><li><p>该方法通过对象调用</p></li><li><p>返回1970-01-01 00:00:00到当前时间的毫秒数，即为时间戳。当前时间是本初子午线的那个时间</p></li><li><p>与Date类中的getTime()方法类似，都是获取时间戳</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Instant</span> <span class="variable">instant</span> <span class="operator">=</span> Instant.now();</span><br><span class="line"><span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> instant.toEpochMilli();</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="④DateTimeFormatter"><a href="#④DateTimeFormatter" class="headerlink" title="④DateTimeFormatter"></a>④DateTimeFormatter</h4><p>​DateTimeFormatter的作用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作为LocalDate、LocalTime、LocalDateTime 与 String 之间转换的桥梁。类似于SimpleDateFormat</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>​A.实例化</p><p>​<strong>方式一、二：</strong>这两种方式少用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://blog.csdn.net/Hhuaahua/article/details/108993426</span><br></pre></td></tr></table></figure><p>​<strong>方式三：</strong>自定义的格式</p><p>​调用ofPattern(你想要的格式)方法，该方法为静态方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">d1</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br></pre></td></tr></table></figure><p>​B.格式化：LocalDate、LocalTime、LocalDateTime –&gt; String</p><p>​调用DateTimeFormatter对象的format(参数)方法，参数为LocalDate、LocalTime、LocalDateTime的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDate</span> <span class="variable">ld</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> d1.format(ld);</span><br><span class="line">System.out.println(s1);<span class="comment">//2022-08-15</span></span><br></pre></td></tr></table></figure><p>​C.解析：String –&gt; 日期类</p><p>​调用DateTimeFormatter对象的parse(String str)方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;2022-12-23&quot;</span>;</span><br><span class="line"><span class="type">TemporalAccessor</span> <span class="variable">accessor</span> <span class="operator">=</span> dateTimeFormatter.parse(s1);</span><br></pre></td></tr></table></figure><p>​<strong>注意：</strong>被解析的字符串要符合你自定义的格式样式，不然会抛出异常</p><hr><h4 id="⑤其他与时间相关的API"><a href="#⑤其他与时间相关的API" class="headerlink" title="⑤其他与时间相关的API"></a>⑤其他与时间相关的API</h4><p><img src="/imgs/image-20220815162943305.png" alt="image-20220815162943305"></p><p>​<strong>应用：</strong></p><p><img src="/imgs/image-20220815163010121.png" alt="image-20220815163010121"></p><p><img src="/imgs/image-20220815163030001.png" alt="image-20220815163030001"></p><p><img src="/imgs/image-20220815163051196.png" alt="image-20220815163051196"></p><p><img src="/imgs/image-20220815163113026.png" alt="image-20220815163113026"></p><hr><h3 id="J-Java比较器"><a href="#J-Java比较器" class="headerlink" title="J.Java比较器"></a>J.Java比较器</h3><h4 id="①引言-2"><a href="#①引言-2" class="headerlink" title="①引言"></a>①引言</h4><p>​Java中的对象，正常情况下，只能进行比较：&#x3D;&#x3D; 或 !&#x3D; 。不能使用 &gt; 或 &lt; ，但是在开发场景中，我们经常会涉及到对象数组的排序问题，言外之意，就需要比较对象的大小。如何实现？使用两个接口中的任何一个：Comparable 或 Comparator</p><h4 id="②Comparable自然排序"><a href="#②Comparable自然排序" class="headerlink" title="②Comparable自然排序"></a>②Comparable自然排序</h4><p>​Comparable接口的使用举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.像String、包装类等实现了 Comparable接口，重写了compareTo(Object obj)方法，给出了比较两个对象大小的方法。</span><br><span class="line">2.像String、包装类等重写的compareTo(Object obj)方法里，进行的是从小到大的排列。</span><br><span class="line">3.重写compareTo(Object obj)的规则：</span><br><span class="line">① 如果当前对象this大于形参对象obj，则返回正整数，</span><br><span class="line">② 如果当前对象this小于形参对象obj，则返回负整数，</span><br><span class="line">③ 如果当前对象this等于形参对象obj，则返回零。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String arr[] = <span class="keyword">new</span> <span class="title class_">String</span>[] &#123;<span class="string">&quot;AA&quot;</span>,<span class="string">&quot;CC&quot;</span>,<span class="string">&quot;KK&quot;</span>,<span class="string">&quot;MM&quot;</span>,<span class="string">&quot;DD&quot;</span>&#125;;</span><br><span class="line">Arrays.sort(arr);<span class="comment">//按照String类中重写的compareTo方法进行排序</span></span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br><span class="line"><span class="comment">//输出结果为：AA,CC,DD,KK,MM</span></span><br></pre></td></tr></table></figure><p>​对于自定义来说，如果需要排序，我们可以让自定义类实现Comparable接口，重写compareTo(Object obj)方法，在compareTo(Object obj)方法中指明如何排序。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Goods)&#123;</span><br><span class="line">        <span class="type">Goods</span> <span class="variable">goods</span> <span class="operator">=</span> (Goods)o;</span><br><span class="line">        <span class="comment">//方式一：</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.price &gt; goods.price)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.price &lt; goods.price)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        方式二：</span></span><br><span class="line"><span class="comment">        return Integer.compare(this.price,goods.price);</span></span><br><span class="line"><span class="comment">        调用包装类中的compare方法</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;不属于商品无法比较&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="③Comparator-定制排序"><a href="#③Comparator-定制排序" class="headerlink" title="③Comparator 定制排序"></a>③Comparator 定制排序</h4><p>​<strong>引言：</strong></p><p>​当元素的类型没有实现java.lang.Comparable接口而又不方便修改代码，或者实现了java.lang.Comparable接口的排序规则不适合当前的操作，那么可以考虑使用 Comparator 的对象来排序。</p><p>​<strong>comparator 接口的使用举例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">重写compare(Object o1,Object o2)方法，比较o1和o2的大小：</span><br><span class="line">如果方法返回正整数，则表示o1大于o2；</span><br><span class="line">如果返回0，表示相等；</span><br><span class="line">返回负整数，表示o1小于o2。</span><br><span class="line">例子：</span><br></pre></td></tr></table></figure><p>​<strong>实现步骤：</strong></p><ol><li><p>调用Arrays的sort()方法</p></li><li><p>往sort()方法传两个参数，一个为要被排序的对象，另一个为实现Comparator接口的实现类对象（由于排序只用到一次，因此就用匿名类的匿名对象了）。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">String[] str = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;a&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;b&quot;</span>&#125;;</span><br><span class="line">Arrays.sort(str, <span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (o1 <span class="keyword">instanceof</span> String &amp;&amp; o2 <span class="keyword">instanceof</span> String)&#123;</span><br><span class="line">         <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> (String)o1;</span><br><span class="line">         <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> (String)o2;</span><br><span class="line">         <span class="keyword">return</span> s1.compareTo(s2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;类型不一致&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//执行完2-12行代码之后，str数组就排好序了</span></span><br><span class="line">System.out.println(Arrays.toString(str));<span class="comment">//[a, b, c]</span></span><br><span class="line"><span class="comment">//上面的输出结果是按照从小到大的方式排序的，如果想从大到小排序，将第八行代改成“return -s1.compareTo(s2)”即可。</span></span><br></pre></td></tr></table></figure><p> compare方法中写你需要的排序方式</p></li></ol><h4 id="④总结"><a href="#④总结" class="headerlink" title="④总结"></a>④总结</h4><ol><li><p>以后只有涉及到对象的排序，就会用到这两个接口。</p></li><li><p>Comparable、Comparator两者的比较</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Comparable接口的方式一旦确定，保证Comparable接口实现类的对象在任何位置都可以比较大小。</span><br><span class="line">comparator 接口属于临时性的比较。下一次比较的时候就得重新编写。</span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="K-System类"><a href="#K-System类" class="headerlink" title="K.System类"></a>K.System类</h3><h4 id="①概述"><a href="#①概述" class="headerlink" title="①概述"></a>①概述</h4><ol><li>该类位于java.lang包。</li><li>由于该类的构造器是private的，所以无法创建该类的对象，但其内部的成员变量和成员方法都是static的，所以也可以很方便的进行调用。</li></ol><h4 id="②成员变量"><a href="#②成员变量" class="headerlink" title="②成员变量"></a>②成员变量</h4><p>​System类内部包含in、out和err三个成员变量，分别代表标准输入流(键盘输入)，标准输出流(显示器)和标准错误输出流(显示器)。</p><h4 id="③成员方法"><a href="#③成员方法" class="headerlink" title="③成员方法"></a>③成员方法</h4><ol><li>native long currentTimeMillis()： 该方法的作用是返回当前的计算机时间，时间的表达格式为当前计算机时间和GMT时间(格林威治时间)1970年1月1号0时0分0秒所差的毫秒数。</li><li>void exit(int status)： 该方法的作用是退出程序。其中status的值为0代表正常退出，非零代表异常退出。使用该方法可以在图形界面编程中实现程序的退出功能等。</li><li>void gc()： 该方法的作用是请求系统进行垃圾回收。至于系统是否立刻回收，则取决于系统中垃圾回收算法的实现以及系统执行时的情况。</li><li>String getProperty(String key)： 该方法的作用是获得系统中属性名为key的属性对应的值。系统中常见的属性名以及属性的作用如下表所示：<img src="/imgs/2020101122461811.png" alt="在这里插入图片描述"><img src="/imgs/image-20220816155849607.png" alt="image-20220816155849607"></li></ol><h3 id="L-Math类"><a href="#L-Math类" class="headerlink" title="L.Math类"></a>L.Math类</h3><p><img src="/imgs/image-20220816160930887.png" alt="image-20220816160930887"></p><h3 id="M-BigInteger与BigDecimal（了解）"><a href="#M-BigInteger与BigDecimal（了解）" class="headerlink" title="M.BigInteger与BigDecimal（了解）"></a>M.BigInteger与BigDecimal（了解）</h3><h4 id="①BigInteger的基本知识"><a href="#①BigInteger的基本知识" class="headerlink" title="①BigInteger的基本知识"></a>①BigInteger的基本知识</h4><ol><li><p>Integer类作为int的包装类，能存储的最大整型值为2^31-1， Long类也是有限的，最大为2^63-1。如果要表示再大的整数，不管是基本数据类型还是他们的包装类都无能为力，更不用说进行运算了。因此我们引入java.math包的BigInteger。</p></li><li><p>BigIntegerr可以表示不可变的任意精度的整数。BigInteger 提供所有 Java 的基本整数操作符的对应物，并提供java.lang.Math 的所有相关方法。另外，BigInteger 还提供以下运算：模算术、GCD 计算、质数测试、素数生成、位操作以及一些其他操作。</p></li><li><p>构造器：BigInteger(String val)：根据字符串构建BigInteger对象</p></li></ol><h4 id="②BigInteger的常用方法"><a href="#②BigInteger的常用方法" class="headerlink" title="②BigInteger的常用方法"></a>②BigInteger的常用方法</h4><p><img src="/imgs/image-20220816161645834.png" alt="image-20220816161645834"></p><h4 id="③BigDecimal的基本知识"><a href="#③BigDecimal的基本知识" class="headerlink" title="③BigDecimal的基本知识"></a>③BigDecimal的基本知识</h4><p>​一般的Float类和Double类可以用来做科学计算或工程计算，但在商业计算中，要求数字精度比较高，故用到java.math.BigDecimal类。BigDecimal类支持不可变的、任意精度的有符号十进制定点数。</p><p>​<strong>构造器：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">BigDecimal</span><span class="params">(<span class="type">double</span> val)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">BigDecimal</span><span class="params">(String val)</span>;</span><br></pre></td></tr></table></figure><h4 id="④BigDecimal的常用方法"><a href="#④BigDecimal的常用方法" class="headerlink" title="④BigDecimal的常用方法"></a>④BigDecimal的常用方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> BigDecimal <span class="title function_">add</span><span class="params">(BigDecimal augend)</span><span class="comment">//加</span></span><br><span class="line"><span class="keyword">public</span> BigDecimal <span class="title function_">subtract</span><span class="params">(BigDecimal subtrahend)</span><span class="comment">//减</span></span><br><span class="line"><span class="keyword">public</span> BigDecimal <span class="title function_">multiply</span><span class="params">(BigDecimal multiplicand)</span><span class="comment">//乘</span></span><br><span class="line"><span class="keyword">public</span> BigDecimal <span class="title function_">divide</span><span class="params">(BigDecimal divisor, <span class="type">int</span> scale, <span class="type">int</span> roundingMode)</span><span class="comment">//除，精度为scale,处理方式为：roundingMode（是四舍五入。。。。。）</span></span><br></pre></td></tr></table></figure><hr><h3 id="N-JDK8之前-amp-JDK8之后时间API的对应关系"><a href="#N-JDK8之前-amp-JDK8之后时间API的对应关系" class="headerlink" title="N.JDK8之前&amp;JDK8之后时间API的对应关系"></a>N.JDK8之前&amp;JDK8之后时间API的对应关系</h3><p><img src="/imgs/image-20220817094820530.png" alt="image-20220817094820530"></p><hr><h2 id="3、枚举类"><a href="#3、枚举类" class="headerlink" title="3、枚举类"></a>3、枚举类</h2><h3 id="A-枚举类的理解"><a href="#A-枚举类的理解" class="headerlink" title="A.枚举类的理解"></a>A.枚举类的理解</h3><ol><li>当类的对象只有有限个，并且每个对象都是确定的，我们称此类为枚举类。</li><li>当需要定义一组常量时，强烈建议使用枚举类。如：如星期：Monday(星期一)、…、Sunday(星期天) ， 性别：Man(男)、Woman(女)。</li><li>若枚举只有一个对象, 则可以作为一种单例模式的实现方式。</li></ol><h3 id="B-如何定义枚举类"><a href="#B-如何定义枚举类" class="headerlink" title="B.如何定义枚举类"></a>B.如何定义枚举类</h3><h4 id="方式一：自定义枚举类（少用）"><a href="#方式一：自定义枚举类（少用）" class="headerlink" title="方式一：自定义枚举类（少用）"></a>方式一：自定义枚举类（少用）</h4><p>​JDK5.0之前需要自定义枚举类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Season</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//1. 对象如果有实例变量，应该声明为private final，并在构造器中初始化</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String SEASONNAME;<span class="comment">//季节的名称</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String SEASONDESC;<span class="comment">//季节的描述</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 私有化类的构造器，保证不能在类的外部创建其对象(否则对象个数不确定）</span></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">Season</span><span class="params">(String seasonName,String seasonDesc)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">this</span>.SEASONNAME = seasonName;</span><br><span class="line"><span class="built_in">this</span>.SEASONDESC = seasonDesc; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 提供当前枚举类的多个对象。声明为：public static final </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SPRING</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;春天&quot;</span>, <span class="string">&quot;春暖花开&quot;</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SUMMER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;夏天&quot;</span>, <span class="string">&quot;夏日炎炎&quot;</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">AUTUMN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;秋天&quot;</span>, <span class="string">&quot;秋高气爽&quot;</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">WINTER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;冬天&quot;</span>, <span class="string">&quot;白雪皑皑&quot;</span>);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//4.其他诉求①：获取枚举类对象的属性</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SEASONNAME;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonDesc</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SEASONDESC;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//4.其他诉求②：提供toString方法，直接alt + shift + s 调用提供的toString方法 </span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​<strong>测试：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Season</span> <span class="variable">season</span> <span class="operator">=</span> Season.AUTUMN;</span><br><span class="line">        System.out.println(season.getSeasonDesc());</span><br><span class="line">        System.out.println(season.getSeasonName());</span><br><span class="line">        System.out.println(season);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方式二：使用enum关键字定义枚举类（常用）"><a href="#方式二：使用enum关键字定义枚举类（常用）" class="headerlink" title="方式二：使用enum关键字定义枚举类（常用）"></a>方式二：使用enum关键字定义枚举类（常用）</h4><p>​JDK5.0之后可以使用enum关键字定义枚举类</p><p>​<strong>实现步骤：</strong>在方式一上按如下步骤进行改造，即可得到enum关键字定义枚举类。</p><ol><li>将class 替换为 enum</li><li>将方式一中声明多个对象的步骤提至最前面，然后把“public static final 枚举类类名” 和 “ &#x3D; new 枚举类类名” 都删掉。</li><li>各对象之间用 “,” 逗号隔开，末尾对象 “;” 结束</li><li>其他部分与方法一相同</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span>  <span class="title class_">Season</span>&#123;</span><br><span class="line"><span class="comment">//1.提供当前枚举类的对象，多个对象之间用&quot;,&quot;隔开，末尾对象&quot;;&quot;结束</span></span><br><span class="line">    SPTING(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;春暖花开&quot;</span>),</span><br><span class="line">    SUMMER(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;夏日炎炎&quot;</span>),</span><br><span class="line">    AUTUMN(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;秋高气爽&quot;</span>),</span><br><span class="line">    WINTER(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;白雪皑皑&quot;</span>);</span><br><span class="line"><span class="comment">//2.对象如果有实例变量，应该声明为private final，并在构造器中初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.私有化类的构造器，保证不能在类的外部创建其对象(否则对象个数不确定）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season</span><span class="params">(String seasonName,String seasonDesc)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.seasonName = seasonName;</span><br><span class="line">        <span class="built_in">this</span>.seasonDesc = seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//4.其他诉求①：获取枚举类对象的属性</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seasonName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​<strong>说明：</strong></p><ol><li><p>对象前面虽然没有了public static final ，但对象还是属于public static final 的。</p></li><li><p>实例变量前的关键字都不可以省略</p></li><li><p>使用enum定义的枚举类默认继承于java.lang.Enum类，因此枚举类中可以不用重写toString方法。如果不重写toString方法，其输出结果为：对象名（即：常量名）。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Season</span> <span class="variable">season</span> <span class="operator">=</span> Season.AUTUMN;</span><br><span class="line">System.out.println(season);<span class="comment">//AUTUMN</span></span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="C-Enum类中的常用方法"><a href="#C-Enum类中的常用方法" class="headerlink" title="C.Enum类中的常用方法"></a>C.Enum类中的常用方法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.values()方法：</span><br><span class="line">通过枚举类的类名来调用，返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值。</span><br><span class="line"></span><br><span class="line">2.valueOf(String str)：</span><br><span class="line">通过枚举类的类名来调用。可以把一个字符串转为对应的枚举类对象。要求字符串必须是枚举类对象的“名字”。如不是，会有运行时异常：IllegalArgumentException。</span><br><span class="line"></span><br><span class="line">3.toString()：</span><br><span class="line">返回当前枚举类对象（即：常量）的名称。</span><br></pre></td></tr></table></figure><h3 id="D-使用enum关键字定义的枚举类实现接口的情况"><a href="#D-使用enum关键字定义的枚举类实现接口的情况" class="headerlink" title="D.使用enum关键字定义的枚举类实现接口的情况"></a>D.使用enum关键字定义的枚举类实现接口的情况</h3><h4 id="情况一"><a href="#情况一" class="headerlink" title="情况一"></a>情况一</h4><p>​实现接口，在enum类中实现抽象方法，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">info</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">enum</span>  <span class="title class_">Season</span> <span class="keyword">implements</span> <span class="title class_">info</span>&#123;</span><br><span class="line">    SPTING,</span><br><span class="line">    SUMMER;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;一年四季&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Season</span> <span class="variable">season</span> <span class="operator">=</span> Season.SPTING;</span><br><span class="line">        <span class="type">Season</span> <span class="variable">season1</span> <span class="operator">=</span> Season.SUMMER;</span><br><span class="line">        season.show();<span class="comment">//一年四季</span></span><br><span class="line">        season1.show();<span class="comment">//一年四季</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​这种实现方式导致每个枚举类对象都是调用同一个show()方法。</p><h4 id="情况二"><a href="#情况二" class="headerlink" title="情况二"></a>情况二</h4><p>​让枚举类的对象分别实现接口中的抽象方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">info</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">enum</span>  <span class="title class_">Season</span> <span class="keyword">implements</span> <span class="title class_">info</span>&#123;</span><br><span class="line">    SPTING&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;这就是春天啊！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    SUMMER&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;夏天到啦！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Season</span> <span class="variable">season</span> <span class="operator">=</span> Season.SPTING;</span><br><span class="line">        <span class="type">Season</span> <span class="variable">season1</span> <span class="operator">=</span> Season.SUMMER;</span><br><span class="line">        season.show();<span class="comment">//这就是春天啊！</span></span><br><span class="line">        season1.show();<span class="comment">//夏天到啦！</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​这种方式就会让不同的对象输出不同的内容。</p><hr><h2 id="4、注解-Annotation"><a href="#4、注解-Annotation" class="headerlink" title="4、注解(Annotation)"></a>4、注解(Annotation)</h2><h3 id="A-概述"><a href="#A-概述" class="headerlink" title="A.概述"></a>A.概述</h3><ol><li>注解是JDK5.0新增的特性。</li><li>Annotation 其实就是代码里的特殊标记, 这些标记可以在编译, 类加载, 运行时被读取, 并执行相应的处理。通过使用 Annotation, 程序员可以在不改变原有逻辑的情况下, 在源文件中嵌入一些补充信息。代码分析工具、开发工具和部署工具可以通过这些补充信息进行验证或者进行部署。</li><li>Annotation 可以像修饰符一样被使用, 可用于修饰包,类, 构造器, 方 法, 成员变量, 参数, 局部变量的声明，这些信息被保存在 Annotation 的 “name&#x3D;value” 对中。</li><li>在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在JavaEE&#x2F;Android中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替JavaEE旧版中所遗留的繁冗代码和XML配置等。</li><li>未来的开发模式都是基于注解的，JPA是基于注解的，Spring2.5以上都是基于注解的，Hibernate3.x以后也是基于注解的，现在的Struts2有一部分也是基于注解的了，注解是一种趋势，一定程度上可以说：<strong>框架 &#x3D; 注解 + 反射 + 设计模式</strong>。</li></ol><h3 id="B-注解的使用示例"><a href="#B-注解的使用示例" class="headerlink" title="B.注解的使用示例"></a>B.注解的使用示例</h3><ol><li><p>生成文档相关的注解，如：@author、@version。。。。。</p></li><li><p>在编译时进行格式检查（JDK内置的三个基本注解）</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">@Override:被修饰的方法会被当作是重写的方法，在编译的时候就会对其进行校验看是否是满足重写的要求，不满足，则报错, 该注解只能用于方法</span></span><br><span class="line"><span class="comment">@Deprecated: 用于表示所修饰的元素(类, 方法等)已过时。通常是因为所修饰的结构危险或存在更好的选择。过时的结构仍可以使用。</span></span><br><span class="line"><span class="comment">@SuppressWarnings: 抑制编译器警告。如：当声明一个变量没使用时，就会出现“变量未使用”的警告，如果你想此警告不出现，可以使用这个注解来抑制该警告的出现。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>跟踪代码依赖性，实现替代配置文件功能</p></li></ol><h3 id="C-如何自定义注解"><a href="#C-如何自定义注解" class="headerlink" title="C.如何自定义注解"></a>C.如何自定义注解</h3><p><img src="/imgs/image-20220818090700252.png" alt="image-20220818090700252"></p><p>一般我们在自定义注解时会指明两个元注解：Retention、Target</p><h3 id="D-JDK中的元注解"><a href="#D-JDK中的元注解" class="headerlink" title="D.JDK中的元注解"></a>D.JDK中的元注解</h3><h4 id="①理解"><a href="#①理解" class="headerlink" title="①理解"></a>①理解</h4><p>​元注解：对现有的注解进行解释说明的注解</p><h4 id="②四个基本元注解—-Retention"><a href="#②四个基本元注解—-Retention" class="headerlink" title="②四个基本元注解—-Retention"></a>②四个基本元注解—-Retention</h4><p>​其只能用于修饰一个 Annotation 定义, 用于指定该 Annotation 的生命周期。</p><p>​格式：@Retention(参数)，使用时必须指明其参数值，下面三个值中选一个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.RetentionPolicy.SOURCE:</span></span><br><span class="line"><span class="comment">表明该注解只在源文件中有效，而在编译时被丢弃</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2.RetentionPolicy.CLASS:</span></span><br><span class="line"><span class="comment">表明该注解编译的时候有，但运行时不加载到内存中。这是默认值，即：某个注解没有被该注解显示修饰时，其默认是被&quot;@Retention(RetentionPolicy.CLASS)&quot;修饰的</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3.RetentionPolicy.RUNTIME:</span></span><br><span class="line"><span class="comment">在运行时有效（即运行时保留），当运行 Java 程序时, JVM 会保留注释。程序可以通过反射获取该注释。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>​<strong>只有声明为RUNTIME生命周期的注解，才能通过反射获取。</strong></p><h4 id="③四个基本元注解—-Target"><a href="#③四个基本元注解—-Target" class="headerlink" title="③四个基本元注解—-Target"></a>③四个基本元注解—-Target</h4><p>​用于修饰 Annotation 定义, 用于指定被修饰的 Annotation 能用于修饰程序中的哪些结构。</p><p>​格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;类型1，类型2，类型3,..&#125;)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">类型可以选择：</span></span><br><span class="line"><span class="comment">TYPE：类、接口、枚举类</span></span><br><span class="line"><span class="comment">FIELD：属性</span></span><br><span class="line"><span class="comment">METHOD：方法</span></span><br><span class="line"><span class="comment">PARAMETER：参数</span></span><br><span class="line"><span class="comment">CONSTRUCTOR：构造器</span></span><br><span class="line"><span class="comment">LOCAL_VARIABLE：局部变量</span></span><br><span class="line"><span class="comment">ANNOTATION_TYPE：注解类型</span></span><br><span class="line"><span class="comment">PACKAGE：包</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>​如果注解没有被该元注解修饰，则表明该注解可以使用在任何地方。</p><p>​以下两个注解在开中2使用频率较低</p><h4 id="④四个基本元注解—-Documented"><a href="#④四个基本元注解—-Documented" class="headerlink" title="④四个基本元注解—-Documented"></a>④四个基本元注解—-Documented</h4><p>​用于指定被该元 Annotation 修饰的 Annotation 类将被javadoc 工具提取成文档。默认情况下，javadoc是不包括注解的。</p><h4 id="⑤四个基本元注解—-Inherited"><a href="#⑤四个基本元注解—-Inherited" class="headerlink" title="⑤四个基本元注解—-Inherited"></a>⑤四个基本元注解—-Inherited</h4><p>​被它修饰的 Annotation 将具有继承性。如果某个类使用了被@Inherited 修饰的 Annotation, 则其子类将自动具有该注解。</p><hr><h3 id="E-通过反射获取注解信息"><a href="#E-通过反射获取注解信息" class="headerlink" title="E.通过反射获取注解信息"></a>E.通过反射获取注解信息</h3><p>​到反射再讲</p><h3 id="F-JDK-8中注解的新特性"><a href="#F-JDK-8中注解的新特性" class="headerlink" title="F.JDK 8中注解的新特性"></a>F.JDK 8中注解的新特性</h3><h4 id="①可重复注解"><a href="#①可重复注解" class="headerlink" title="①可重复注解"></a>①可重复注解</h4><p>​可重复注解：即可以在某个程序结构中声明多个类型相同的注解。如：</p><p><img src="/imgs/image-20230424202349036.png" alt="image-20230424202349036"></p><p>​实现步骤：</p><p>​例子：</p><ol><li>在MyAnnotation上声明@Repeatable，成员值为MyAnnotations.class。</li><li>MyAnnotation的Target和Retention等元注解与MyAnnotations的相同。即MyAnnotation有的元注解，MyAnnotations也得有（除了@Repeatable）并且得一样。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repeatable(MyAnnotations.class)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;TYPE,FIELD,METHOD,PARAMETER,CONSTRUCTOR,LOCAL_VARIABLE&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation</span><br><span class="line">&#123;</span><br><span class="line">String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;TYPE,FIELD,METHOD,PARAMETER,CONSTRUCTOR,LOCAL_VARIABLE&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotations</span><br><span class="line">&#123;</span><br><span class="line">MyAnnotation[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="②类型注解"><a href="#②类型注解" class="headerlink" title="②类型注解"></a>②类型注解</h4><p>​ElementType.TYPE_PARAMETER 表示该注解能写在类型变量的声明语句中（如：用来修饰泛型类型）。<br>​ElementType.TYPE_USE 表示该注解能写在使用类型的任何语句中。</p><p>​上面两个属性属于元注解Target里的，使用时不用加ElementType</p><hr><h2 id="5、Java集合"><a href="#5、Java集合" class="headerlink" title="5、Java集合"></a>5、Java集合</h2><h3 id="A-集合框架的概述"><a href="#A-集合框架的概述" class="headerlink" title="A.集合框架的概述"></a>A.集合框架的概述</h3><ol><li>集合、数组都是对多个数据进行存储操作的结构，简称Java容器。<ul><li>说明：此时的存储，主要指的是内存层面的存储，不涉及到持久化的存储（如：.text，.jpg，.avi，数据库中）。</li></ul></li><li>数组在存储多个数据方面的特点：<ul><li>数组初始化以后，长度就确定了。</li><li>数组一旦定义好，其元素的类型也就确定了。</li></ul></li><li>数组在存储多个数据方面的缺点：<ul><li>一旦初始化以后，其长度就不可修改。</li><li>数组中提供的方法非常有限，对于添加、删除、插入数据等操作，非常不便，同时效率不高。</li><li>获取数组中实际元素的个数的需求，数组没有现成的属性或方法可用。</li><li>数组存储数据的特点：有序、可重复。对于无序、不可重复的需求，不能满足。</li></ul></li></ol><h3 id="B-集合框架"><a href="#B-集合框架" class="headerlink" title="B.集合框架"></a>B.集合框架</h3><p><img src="/imgs/image-20220820174801220.png" alt="image-20220820174801220"></p><p>​key与value是映射关系，key就相当于函数中的自变量，value就相当于因变量。一个key不可以对应多个value，多个key可用对应同一个value值。</p><h3 id="C-Collection接口中的方法"><a href="#C-Collection接口中的方法" class="headerlink" title="C.Collection接口中的方法"></a>C.Collection接口中的方法</h3><p>​<strong>以下方法都是通过对象进行调用。</strong></p><h4 id="①-add-Object-obj"><a href="#①-add-Object-obj" class="headerlink" title="① add(Object obj)"></a>① add(Object obj)</h4><p>​将元素obj添加到当前集合中</p><h4 id="②-addAll-Collection-coll"><a href="#②-addAll-Collection-coll" class="headerlink" title="② addAll(Collection coll)"></a>② addAll(Collection coll)</h4><p>​将coll集合中的所有元素添加到当前的集合中。</p><h4 id="③size"><a href="#③size" class="headerlink" title="③size()"></a>③size()</h4><p>​获取集合中元素的个数</p><h4 id="④clear"><a href="#④clear" class="headerlink" title="④clear()"></a>④clear()</h4><p>​清空当前集合中的元素</p><h4 id="⑤isEmpty"><a href="#⑤isEmpty" class="headerlink" title="⑤isEmpty()"></a>⑤isEmpty()</h4><p>​判断当前集合中是否有元素。有，返回false；没有，返回true。</p><h4 id="⑥contains-Object-obj"><a href="#⑥contains-Object-obj" class="headerlink" title="⑥contains(Object obj)"></a>⑥contains(Object obj)</h4><p>​判断当前集合中是否包含obj，在判断时会调用obj对象所在类的equals()。返回true或false。</p><h4 id="⑦containsAll-Collection-coll1"><a href="#⑦containsAll-Collection-coll1" class="headerlink" title="⑦containsAll(Collection coll1)"></a>⑦containsAll(Collection coll1)</h4><p>​判断形参coll1中的<strong>所有元素是否都存在</strong>于当前集合中。返回true、或false。</p><h4 id="⑧remove-Object-obj"><a href="#⑧remove-Object-obj" class="headerlink" title="⑧remove(Object obj)"></a>⑧remove(Object obj)</h4><p>​从当前集合中移除obj元素。</p><p>​底层的实现方式是：调用obj所在类的equals()方法，看该集合是否包含obj，包含则删除返回true，否则返回false。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    list.add(<span class="number">123</span>);</span><br><span class="line">    list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    list.remove(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    <span class="comment">//list.remove(123); //会报错，因为123会被认为是索引</span></span><br><span class="line">    list.remove(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">123</span>));<span class="comment">//想要删除整数123，就得先把123变成包装类。</span></span><br><span class="line">    System.out.println(list);<span class="comment">//[b]</span></span><br><span class="line">&#125;       </span><br></pre></td></tr></table></figure><h4 id="⑨removeAll-Collection-coll1"><a href="#⑨removeAll-Collection-coll1" class="headerlink" title="⑨removeAll(Collection coll1)"></a>⑨removeAll(Collection coll1)</h4><p>​从当前集合中删除coll1中所有的元素。</p><p>​底层的实现方式是：还是会调用equals()来判断该集合是否含有要删除的元素，有则删除。</p><h4 id="⑩retainAll-Collection-coll1"><a href="#⑩retainAll-Collection-coll1" class="headerlink" title="⑩retainAll(Collection coll1)"></a>⑩retainAll(Collection coll1)</h4><p>​获取当前集合coll和coll1集合的交集，并返回给当前集合coll，即当前集合中的元素变为两集合中的交集的元素。</p><h4 id="11-equals-Object-obj"><a href="#11-equals-Object-obj" class="headerlink" title="11.equals(Object obj)"></a>11.equals(Object obj)</h4><p>​要想返回true，<strong>需要当前集合和形参集合的元素都相同。</strong></p><p>​底层的实现方式：调用obj所在类的equals()方法。</p><h4 id="12-hashCode"><a href="#12-hashCode" class="headerlink" title="12.hashCode()"></a>12.hashCode()</h4><p>​返回当前对象的哈希值。</p><h4 id="13-toArray-、数组集合互转"><a href="#13-toArray-、数组集合互转" class="headerlink" title="13.toArray()、数组集合互转"></a>13.toArray()、数组集合互转</h4><p>​实现的操作：集合 –&gt; 数组。返回Object[ ]。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test6</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    coll.add(<span class="number">123</span>);</span><br><span class="line">    coll.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Object[] array = coll.toArray();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">    System.out.println(array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果：123，aaa</span></span><br></pre></td></tr></table></figure><p>​<strong>补充：</strong></p><p>​数组 —&gt; 集合：调用Arrays类的静态方法asList()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test6</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//可以直接在asList()的参数里写数组元素值</span></span><br><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> Arrays.asList(<span class="number">123</span>,<span class="number">456</span>);<span class="comment">//写其他基本数据类型的数据也行</span></span><br><span class="line">    System.out.println(list);<span class="comment">//[123,456]</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果想在asList()的参数里传一个现有的数组，那就要将该数组转换为对应的包装类的数组（除了String不用转，其他基本数据类型都要转），然后将包装类的数组名传到在asList()里</span></span><br><span class="line">    <span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">123</span>,<span class="number">456</span>&#125;;</span><br><span class="line">    Integer[] arr = <span class="keyword">new</span> <span class="title class_">Integer</span>[a.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> Arrays.asList(arr);</span><br><span class="line">    System.out.println(list);<span class="comment">//[123,456]</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    如果不转换为对应的包装类，而是直接：</span></span><br><span class="line"><span class="comment">    System.out.println(a);</span></span><br><span class="line"><span class="comment">    输出的结果为：[[I@22927a81]</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="14"><a href="#14" class="headerlink" title="14."></a>14.</h4><p>​</p><h4 id="15-iterator"><a href="#15-iterator" class="headerlink" title="15.iterator()"></a>15.iterator()</h4><p>​返回Iterator接口的实例，该实例用于遍历集合Collection中的元素。</p><p>​调用iterator()时，还会生成一个指针，该指针指向集合中第一个元素的前一个位置。</p><p>​Iterator：迭代器。其里面有两个方法：</p><ol><li>hasNext()：判断当前指针的下一个位置上还有没有集合元素，返回布偶值。</li><li>next()：调用该方法时：①指针下移 ②将下移以后集合位置上的元素返回。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test6</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    coll.add(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    coll.add(<span class="number">456</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> coll.iterator();</span><br><span class="line">    <span class="comment">//方法一：不推荐，这种方法也可以将集合中的元素输出</span></span><br><span class="line">    <span class="comment">//System.out.println(iterator.next());</span></span><br><span class="line">    <span class="comment">//System.out.println(iterator.next());</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方式二：推荐，开发中常用</span></span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p><p>​Iterator迭代器里还有一个方法：remove()，可以在遍历的时候，删除集合中的元素。此方法不同于集合直接调用remove()方法。例子：</p><p><img src="/imgs/image-20220820093004056.png" alt="image-20220820093004056"></p><hr><h3 id="D-foreach"><a href="#D-foreach" class="headerlink" title="D.foreach"></a>D.foreach</h3><p>​jdk 5.0新增了foreach循环（又称增强for循环），用于遍历集合和数组。</p><h4 id="①格式"><a href="#①格式" class="headerlink" title="①格式"></a>①格式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">for(集合中元素的类型 变量名 : 集合对象)&#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="②原理"><a href="#②原理" class="headerlink" title="②原理"></a>②原理</h4><p>​每次都从集合对象或数组中取一个元素赋给变量。直到所有元素都取完。</p><h4 id="③例子"><a href="#③例子" class="headerlink" title="③例子"></a>③例子</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test6</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        coll.add(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        coll.add(<span class="number">456</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Object obj : coll)&#123;</span><br><span class="line">            System.out.println(obj);</span><br><span class="line">        &#125;<span class="comment">//123，456</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//for(数组元素类型 变量名 : 数组名)&#123;&#125;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : arr)&#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;<span class="comment">//1，2，3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="E-Collection子接口之一：List接口"><a href="#E-Collection子接口之一：List接口" class="headerlink" title="E.Collection子接口之一：List接口"></a>E.Collection子接口之一：List接口</h3><p>​List接口有三个实现类，分别为：ArrayList、LinkedList、Vector</p><h4 id="①三个实现类的区别"><a href="#①三个实现类的区别" class="headerlink" title="①三个实现类的区别"></a>①三个实现类的区别</h4><ol><li><strong>ArrayList：</strong>作为List接口的主要实现类；线程不安全的，效率高；底层使用Object[ ]  elementData 存储；</li><li><strong>LinkedList：</strong>对于频繁的插入、删除操作，使用此类效率比ArrayList高；底层使用双向链表存储；</li><li><strong>Vector：</strong>作为List接口的古老实现类；线程安全的，效率低；底层使用Object[ ] elementData 存储；此实现类少用。就算ArrayList线程不安全，也不会用Vector。因为还有工具类Collections中有方法可以将ArrayList转换为线程安全的ArrayList。</li><li>三者的相同点：都实现了List接口，存储数据的特点相同——存储有序、可重复的数据</li></ol><h4 id="②底层源码分析之ArrayList"><a href="#②底层源码分析之ArrayList" class="headerlink" title="②底层源码分析之ArrayList"></a>②底层源码分析之ArrayList</h4><p>​<strong>jdk 7情况下的源码分析：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"><span class="comment">//底层创建了一个长度为10的Object[]数组elementData</span></span><br><span class="line">list.add(<span class="number">123</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">每次调用add方法时，都会先判断当前的数据能不能放入elementData数组中，如果放不下就会扩容。默认情况下，扩容为原来容量的1.5倍，同时需要将原有数组中的数据复制到新的数组中。然后再将数据添加到新的数组中。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>​结论：如果开发中知道大概要放多少个数据，那么建议使用带参的构造器：**ArrayList list &#x3D; new ArrayList(int capacity)**。这样可以减少多次扩容，提高效率。底层创建了一个长度为capacity的Object[ ]数组elementData。</p><p>​<strong>jdk 8中ArrayList 的变化：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"><span class="comment">//底层Object[] elementData初始化为&#123;&#125;，并没有创建长度为10的数组</span></span><br><span class="line"></span><br><span class="line">list.add(<span class="number">123</span>);<span class="comment">//第一次调用add()时，底层才创建了长度为10的数组，并将数据123添加到elementData[0]</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">//后续的添加和扩容操作与jdk 7相同</span></span><br></pre></td></tr></table></figure><p>​<strong>小结：</strong></p><p><img src="/imgs/image-20220820125712207.png" alt="image-20220820125712207"></p><hr><h4 id="③底层源码分析之LinkedList"><a href="#③底层源码分析之LinkedList" class="headerlink" title="③底层源码分析之LinkedList"></a>③底层源码分析之LinkedList</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LinkedList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line"><span class="comment">//内部声明了Node类型的first和last属性，分别用于记录链表头和链表尾，默认值都为null</span></span><br><span class="line">list.add(<span class="number">123</span>);<span class="comment">//将123封装到Node，创建Node对象。Node为链表中的结点</span></span><br><span class="line"><span class="comment">//add()的实现方式与数据结构中双向链表的添加结点操作一样</span></span><br></pre></td></tr></table></figure><h4 id="④底层源码分析之Vector"><a href="#④底层源码分析之Vector" class="headerlink" title="④底层源码分析之Vector"></a>④底层源码分析之Vector</h4><p>​jdk7和jdk8中通过Vector()构造器创建对象时，底层都创建了长度为10的数组。</p><p>​在扩容方面，默认扩容为原来的数组长度的2倍。</p><hr><h3 id="F-List接口中的常用方法"><a href="#F-List接口中的常用方法" class="headerlink" title="F.List接口中的常用方法"></a>F.List接口中的常用方法</h3><p>①void <strong>add</strong>(int index, Object ele)：在index位置插入ele元素<br>②boolean <strong>addAll</strong>(int index, Collection eles)：从index位置开始将eles中的所有元素添加进来。eles可以为Collection的任何子类对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        list.add(<span class="number">123</span>);</span><br><span class="line">        list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">ArrayList</span> <span class="variable">list1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        list1.add(<span class="string">&quot;您&quot;</span>);</span><br><span class="line"></span><br><span class="line">        list.addAll(<span class="number">1</span>,list1);</span><br><span class="line">        System.out.println(list);<span class="comment">//[123, 您, a, b]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>③Object <strong>get</strong>(int index):获取指定index位置的元素。</p><p>④int <strong>indexOf</strong>(Object obj):返回obj在集合中首次出现的位置。没有找到该元素，则返回-1。</p><p>⑤int <strong>lastIndexOf</strong>(Object obj):返回obj在当前集合中最后一次出现的位置。没有找到该元素，则返回-1。</p><p>⑥Object <strong>remove</strong>(int index):移除指定index位置的元素，并返回此元素。</p><p>⑦Object <strong>set</strong>(int index, Object ele):设置指定index位置的元素为ele。</p><p>⑧List <strong>subList</strong>(int fromIndex, int toIndex):返回从fromIndex到toIndex（不包括toIndex）位置的子集合。原集合中的元素不变。</p><h6 id="总结：常用方法"><a href="#总结：常用方法" class="headerlink" title="总结：常用方法"></a>总结：常用方法</h6><p>​增：add(Object obj)          —&gt;这里的增是指在末尾添加元素</p><p>​删：remove(int index) \ remove(Object obj)</p><p>​改：set(int index,Object ele)</p><p>​查：get(int index)</p><p>​插：add(int index,Object ele)</p><p>​长度：size()</p><p>​遍历：①Iterator迭代器方式；②增强for循环；③普通for循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用普通for循环遍历</span></span><br><span class="line"><span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">list.add(<span class="number">123</span>);</span><br><span class="line">list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; list.size();i++)&#123;</span><br><span class="line">    System.out.println(list.get(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="G-Collection子接口之二：Set接口"><a href="#G-Collection子接口之二：Set接口" class="headerlink" title="G.Collection子接口之二：Set接口"></a>G.Collection子接口之二：Set接口</h3><h4 id="①概述-1"><a href="#①概述-1" class="headerlink" title="①概述"></a>①概述</h4><p>​Set接口：存储无序的、不可重复的数据 —&gt; 相当于高中讲的“集合”</p><p>​无序性和不可重复性的说明：以HashSet为例进行解释说明</p><ul><li><p><strong>无序性</strong>：不等于随机性。存储的数据在底层数组中并非按照数组索引的顺序添加，而是根据数据的哈希值决定的。</p></li><li><p><strong>不可重复性</strong>：保证添加的元素按照equals()判断时（equals方法要重写），不能返回true。即：相同的元素只能添加一个。</p></li></ul><h4 id="②元素的添加过程"><a href="#②元素的添加过程" class="headerlink" title="②元素的添加过程"></a>②元素的添加过程</h4><p>​以HashSet为例：</p><p>​我们向HashSet中添加元素a，首先调用元素a所在类的hasCode()方法，计算元素a的哈希值，此哈希值接着通过某种算法计算出在HashSet底层数组中的存放位置（即：索引位置），判断数组此位置上是否已经有元素：</p><p>​如果此位置上没有其他元素，则元素a添加成功。 —-&gt; 情况1</p><p>​如果此位置上有其他元素b（或以链表形式存在的多个元素），则比较元素a与元素b等其他元素的哈希值。</p><p>​|——&gt;如果哈希值不同，则元素a添加成功。  —-&gt; 情况2</p><p>​|——&gt;如果哈希值相同，进而想要调用元素a所在类的equals()方法</p><p>​ |—-&gt; equals()返回true，元素a添加失败</p><p>​ |—-&gt; equals()返回false，则元素a添加成功 —-&gt; 情况3</p><p> 对于添加成功的情况2和情况3而言：元素a 与已经存在指定索引位置上数据以链表的方式存储。而jdk7 和jdk8的存储方式又不太一样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jdk 7：元素a 放到数组中，指向原来的元素；</span><br><span class="line">jdk 8：原来的元素在数组中，指向元素 a 。</span><br><span class="line">总结：七上八下</span><br></pre></td></tr></table></figure><p>​补充：hasCode()方法中计算哈希值时，会涉及到属性值。</p><p><strong>HashSet底层：数组+单链表的结构</strong></p><p><img src="/imgs/image-20220824165058008.png" alt="image-20220824165058008"></p><h4 id="③LinkedHashSet的底层结构"><a href="#③LinkedHashSet的底层结构" class="headerlink" title="③LinkedHashSet的底层结构"></a>③LinkedHashSet的底层结构</h4><p>​LinkedHashSet作为HashSet的子类，添加数据的过程一样，但不同的是在添加数据的同时，每个数据还维护了两个引用，记录此数据前一个数据和后一个数据。这使得可以按照添加的顺序遍历输出集合。</p><p><img src="/imgs/image-20220824184932741.png" alt="image-20220824184932741"></p><p><strong>LinkedHashSet底层使用：数组+双向链表进行存储。</strong></p><h4 id="④三个实现类的区别"><a href="#④三个实现类的区别" class="headerlink" title="④三个实现类的区别"></a>④三个实现类的区别</h4><p>​<strong>HashSet</strong>：作为Set接口的主要实现类；线程不安全的；可以存储null值。底层使用数组+单链表进行存储。</p><p>​<strong>LinkedHashSet</strong>：作为HashSet的子类；遍历其内部数据时，可以按照添加的顺序遍历。对于频繁的遍历操作，LinkedHashSet效率高于HashSet。底层使用数组+双向链表进行存储。</p><p>​<strong>TreeSet</strong>：可以按照添加对象的指定属性，进行排序。底层使用红黑树进行存储。向TreeSet中添加的数据，要求是<strong>相同类的对象</strong>。</p><h4 id="⑤TreeSet的两种排序方式"><a href="#⑤TreeSet的两种排序方式" class="headerlink" title="⑤TreeSet的两种排序方式"></a>⑤TreeSet的两种排序方式</h4><ol><li><strong>自然排序</strong>：TreeSet 会调用集合元素的 compareTo(Object obj) 方法来比较元素之间的大小关系，然后将集合元素按升序(默认情况)排列。比较两个对象是否相同的标准为 compareTo( )返回0，而不是equals( )。compareTo( )返回0代表两对象相等，就不能添加到集合中。</li><li><strong>定制排序</strong>：通过Comparator接口来实现。比较两个对象是否相同的标准为 compare( )返回0，而不是equals( )。compare( )返回0代表两对象相等，就不能添加到集合中。</li></ol><p>说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.如果声明TreeSet对象时使用空参的构造器，则代表使用的是自然排序的方式进行排序，此时得在相应的类中继承comparable接口并重写compareTo方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2.如果声明TreeSet对象时使用带参构造器</span></span><br><span class="line"><span class="comment">TreeSet set = new TreeSet(Comparator com);</span></span><br><span class="line"><span class="comment">则代表排序的时候就使用“定制排序”</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="H-List和Set的使用总结"><a href="#H-List和Set的使用总结" class="headerlink" title="H.List和Set的使用总结"></a>H.List和Set的使用总结</h3><p>​向Collection接口的实现类的对象中添加数据obj时，要求obj所在类要重写equals()。</p><h4 id="①List的使用总结"><a href="#①List的使用总结" class="headerlink" title="①List的使用总结"></a>①List的使用总结</h4><h4 id="②Set的使用总结"><a href="#②Set的使用总结" class="headerlink" title="②Set的使用总结"></a>②Set的使用总结</h4><ol><li>Set接口中没有额外定义新的方法，使用的都是Collection中声明过的方法。</li><li>向实现类HashSet、LinkedHashSet中添加的数据，该数据所在的类一定要重写hashCode()和equals()。直接使用：alt + shift + s 调用equals和hashCode即可。</li><li>向TreeSet中添加的数据，该数据所在的类一定要实现自然排序或定制排序。不用重写hashCode()和equals()。向TreeSet中添加的数据，必须是相同类的对象。</li><li>当调用remove(Object obj)时，先计算Obj的哈希值，根据哈希值找到底层数组中对应的索引位置，如果该位置上没有数据则删除失败，如果有数据，则判断哈希值是否相同，相同进而用equals()判断，equals()判断相同则删除该数据，不相同则删除失败；哈希值不一样，也删除失败。</li></ol><h3 id="J-练习"><a href="#J-练习" class="headerlink" title="J.练习"></a>J.练习</h3><h4 id="①在List内去除重复数值值"><a href="#①在List内去除重复数值值" class="headerlink" title="①在List内去除重复数值值"></a>①在List内去除重复数值值</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SetTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List <span class="title function_">toSet</span><span class="params">(List list)</span>&#123;</span><br><span class="line">        <span class="type">TreeSet</span> <span class="variable">treeSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeSet</span>();</span><br><span class="line">        treeSet.addAll(list);<span class="comment">//添加时会调用当前数据所在类的hashCode()和equals()</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>(treeSet);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">2</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">2</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">List</span> <span class="variable">list1</span> <span class="operator">=</span> toSet(list);</span><br><span class="line">        <span class="keyword">for</span> (Object o1 : list1)&#123;</span><br><span class="line">            System.out.println(o1);</span><br><span class="line">        &#125;<span class="comment">//1，2，3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="K-Map接口"><a href="#K-Map接口" class="headerlink" title="K.Map接口"></a>K.Map接口</h3><h4 id="①概述-2"><a href="#①概述-2" class="headerlink" title="①概述"></a>①概述</h4><p>​Map：双列数据，存储key-value对的数据  –&gt; 类似于高中的函数：y&#x3D;f(x)</p><p>​ | — HashMap：作为Map的主要实现类；线程不安全，效率高；可以存储null的key和value。底层：数组+单链表(jdk7.0及之前)，数组+单向链表+红黑树(jdk8)</p><p>​        | — LinkedHashMap：保证在遍历map元素时，可以按照添加的顺序实现遍历。原因：在原有的HashMap底层结构基础上，添加了一对指针，指向前一个和后一个元素。<strong>对于频繁的遍历操作，此类执行效率高于HashMap。</strong>该类是HashMap的子类。</p><p>​| — TreeMap：保证添加的key-value对进行排序，<strong>实现排序遍历</strong>。此时<strong>考虑key的自然排序或定制排序</strong>。底层使用红黑树。</p><p>​| — Hashtable：作为古老的实现类；线程安全的，效率低；不能存储值为null的key和value。</p><p>​| — Properties：是Hashtable的子类。常用来处理配置文件。key和value都是String类型。</p><hr><h4 id="②Map结构的理解"><a href="#②Map结构的理解" class="headerlink" title="②Map结构的理解"></a>②Map结构的理解</h4><p>Map中的key：无序的、不可重复的，使用Set存储所有的key 。</p><p>Map中的value：无序的、可重复的，使用Collection存储所有的value。–&gt; value所在的类要重写equals()</p><p>一个键值对：key-value 构成了一个Entry 对象。key、value为Entry对象的两个属性。</p><p>Map中的entry：无序的、不可重复的，使用Set存储所有的Entry。</p><p><strong>注意：</strong></p><ol><li><p>为保证添加的数据中key的值是不可重复的。我们想要进行如下操作：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">①如果key属于HashMap里的key，则要用HashSet去存储，为保证不可重复性，就要在添加数据所在类里重写equals()和hashCode()。</span></span><br><span class="line"><span class="comment">②如果如果key属于LinkedHashMap里的key，则要用LinkedHashSet去存储，为保证不可重复性，就要在添加数据所在类里重写equals()和hashCode()。</span></span><br><span class="line"><span class="comment">③如果key属于TreeMap里的key，则要用TreeSet去存储，为保证不可重复性，要在添加数据所在类里实现coparable接口或定制排序</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="③HashMap的底层实现原理"><a href="#③HashMap的底层实现原理" class="headerlink" title="③HashMap的底层实现原理"></a>③HashMap的底层实现原理</h4><p>​<strong>以jdk7为例说明：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HashMap</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>()</span><br></pre></td></tr></table></figure><p>在实例化以后，底层创建了长度为16的一维数组Entry[ ] table。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可能已经执行过多次put</span></span><br><span class="line">map.put(key1,value1);</span><br></pre></td></tr></table></figure><p>当执行put时：</p><p>首先，调用key1所在类的hashCode()计算key1哈希值，此哈希值经过某种算法计算以后，得到在Entry数组中的存放位置。</p><p>如果此位置上的数据为空，此时的key1-value1添加成功。– &gt; 情况1</p><p>如果此位置上的数据不为空，（意味着此位置上存在一个或多个数据(以链表形式存在)），比较key1和已经存在的一个或多个数据的key的哈希值：</p><p>|—-如果key1的哈希值与已存在的数据的哈希值都不相同，此时key1-value1添加成功。 – &gt; 情况2</p><p>|—-如果key1的哈希值和已经存在的某一个数据(key2-value2)的哈希值相同。继续比较：调用key1所在类的equals(key2)方法，比较：</p><p>​|—–如果equals()返回false：此时key1-value1添加成功。 —&gt; 情况3</p><p>​|—–如果equals()返回true：使用value1替换value2。</p><p><strong>补充：</strong></p><ol><li>关于情况2和情况3，此时key1-value1和原来的数据以链表的方式存储。</li><li>在不断的添加过程中，会涉及到扩容问题，当超出临界值（且要存放的位置非空）时，扩容。默认的扩容方式：扩容为原来容量的2倍，并将原有的数据复制过来。复制时，要重新计算每个数据的key的哈希值，根据新的哈希值得出该元素在数组中新存放的位置。</li></ol><p>jdk8 相较于jdk7在底层实现方面的不同：</p><ol><li>new HashMap()：底层没有创建一个长度为16的数组。</li><li>jdk 8 底层的数组是 Node[ ]，而非 Entry[ ] 。Node本质上就是Entry[ ]。</li><li>首次调用put（）方法时，底层创建长度为16的数组。</li><li>jdk 7 底层结构只有：数组+链表。jdk 8 中底层结构：数组+链表+红黑树。当数组的某一个索引位置上的元素以链表形式存在的数据个数&gt;8 且当数组的长度&gt;64时，此时此索引位置上的所有数据改为使用红黑树存储。使用红黑树的好处：提高查找效率。如果数组的长度&lt;64，则进行扩容。</li><li>形成链表时，七上八下（jdk7：新的元素指向旧的元素。jdk8：旧的元素指向新的元素）</li></ol><h4 id="④HashMap源码中的重要常量"><a href="#④HashMap源码中的重要常量" class="headerlink" title="④HashMap源码中的重要常量"></a>④HashMap源码中的重要常量</h4><p><strong>DEFAULT_INITIAL_CAPACITY</strong>：HashMap的默认容量，16；<br><strong>DEFAULT_LOAD_FACTOR</strong>：HashMap的默认加载因子：0.75；加载因子影响的是扩容的临界值。如果加载因子太小，数组中的位置还没充分利用就扩容了，如果加载原子太大，就可能会形成许多链表，不利于遍历。<br><strong>threshold</strong>：扩容的临界值，&#x3D;容量 × 加载因子：16 * 0.75&#x3D;12；当要添加当前数据后超过threshold时，先判断要添加的位置上是否有元素，有则需要扩容；没有，则将当前元素放进去该位置。<br><strong>TREEIFY_THRESHOLD</strong>:Bucket中链表长度大于该默认值，转化为红黑树：8；<br><strong>MIN_TREEIFY_CAPACITY</strong>：桶中的Node被树化时最小的hash表容量：64</p><h4 id="⑤LinkedHashMap的底层实现"><a href="#⑤LinkedHashMap的底层实现" class="headerlink" title="⑤LinkedHashMap的底层实现"></a>⑤LinkedHashMap的底层实现</h4><p>​与HashMap的实现原理一样，只是LinkedHashMap中的Entry多了两个属性：before、after,用于记录后一个元素和前一个元素。这样的结构就形成双向链表。</p><h4 id="⑥TreeMap的使用"><a href="#⑥TreeMap的使用" class="headerlink" title="⑥TreeMap的使用"></a>⑥TreeMap的使用</h4><p>​向TreeMap中添加key-value，要求key必须是由同一个类创建的对象。因为要按照key进行排序：自然排序、定制排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当使用空参的构造器声明TreeMap时，意味着使用的是自然排序</span></span><br><span class="line"><span class="type">TreeMap</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeMap</span>();</span><br><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">12</span>);</span><br><span class="line"><span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jerry&quot;</span>,<span class="number">22</span>);</span><br><span class="line">t1.put(p1,<span class="number">100</span>);</span><br><span class="line">t1.put(p2,<span class="number">90</span>);</span><br><span class="line"><span class="comment">//要求key所在类要实现Comparable接口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当使用带参的构造器TreeMap(Comparator com)时，意味着使用的是定制排序</span></span><br><span class="line"><span class="type">Comparator</span> <span class="variable">com</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o1 <span class="keyword">instanceof</span> Person &amp;&amp; o2 <span class="keyword">instanceof</span> Person)&#123;</span><br><span class="line">            <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> (Person)o1;</span><br><span class="line">            <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> (Person)o2;</span><br><span class="line">            <span class="keyword">return</span> Integer.compare(p1.getAge(),p2.getAge());</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;类型不一致&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">TreeMap</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeMap</span>(com);</span><br><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">32</span>);</span><br><span class="line"><span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jerry&quot;</span>,<span class="number">22</span>);</span><br><span class="line">t1.put(p1,<span class="number">100</span>);</span><br><span class="line">t1.put(p2,<span class="number">90</span>);</span><br></pre></td></tr></table></figure><h4 id="⑦Properties的使用"><a href="#⑦Properties的使用" class="headerlink" title="⑦Properties的使用"></a>⑦Properties的使用</h4><p>​Properties里的方法：</p><ul><li>load()：加载流对应的文件</li><li>getProperty(key)：获取配置文件中对应key的value</li></ul><p>实现方式一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Properties</span> <span class="variable">pro</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line"><span class="comment">//如果写相对路径的方式，则文件默认存放在当前module下</span></span><br><span class="line">fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;jdbc.properties&quot;</span>);</span><br><span class="line">pro.load(fis);<span class="comment">//加载流对应的文件</span></span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> pro.getProperty(<span class="string">&quot;name&quot;</span>);</span><br></pre></td></tr></table></figure><p>实现方式二：使用ClassLoader</p><p>ClassLoader属于反射中的知识</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Properties</span> <span class="variable">pro</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line"><span class="comment">//当前类的类名.class.getClassLoader(),获取加载当前类的系统类加载器</span></span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> ClassLoaderTest.clas.getClassLoader();</span><br><span class="line"><span class="comment">//如果以相对路径的方式写（如下），则默认文件存放在当前module的src下</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> classLoader.getResourceAsStream(<span class="string">&quot;jdbc.properties&quot;</span>);</span><br><span class="line">pro.load(is);</span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> pro.getProperty(<span class="string">&quot;name&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：如果配置文件存放在当前module下，当部署到tomcat上时会丢失，所以配置文件要放在当前module的src下</p><h5 id="L-Map中定义的方法"><a href="#L-Map中定义的方法" class="headerlink" title="L.Map中定义的方法"></a>L.Map中定义的方法</h5><h4 id="①添加、删除、修改操作"><a href="#①添加、删除、修改操作" class="headerlink" title="①添加、删除、修改操作"></a>①添加、删除、修改操作</h4><ul><li>Object <strong>put</strong>(Object key,Object value)：将指定key-value添加到(或修改)当前map对象中</li><li>void <strong>putAll</strong>(Map m):将m中的所有key-value对存放到当前map中 </li><li>Object <strong>remove</strong>(Object key)：移除指定key的key-value对，并返回value。找不到要删除的元素，则返回null。</li><li>void <strong>clear</strong>()：清空当前map中的所有数据，与map &#x3D; null 操作不同</li></ul><h4 id="②元素查询的操作"><a href="#②元素查询的操作" class="headerlink" title="②元素查询的操作"></a>②元素查询的操作</h4><ul><li>Object <strong>get</strong>(Object key)：获取指定key对应的value，如果找不到该key，则返回null</li><li>boolean <strong>containsKey</strong>(Object key)：是否包含指定的key</li><li>boolean <strong>containsValue</strong>(Object value)：是否包含指定的value，如果有多个相同的value值，找到第一个后就不再往下找了</li><li>int <strong>size</strong>()：返回map中key-value对的个数</li><li>boolean <strong>isEmpty</strong>()：判断当前map是否为空，即判断当前map中是否没有元素</li><li>boolean <strong>equals</strong>(Object obj)：判断当前map和参数对象obj是否相等。注意：obj必须是map类型，只要元素要一模一样就返回true</li></ul><h4 id="③元视图操作的方法（即遍历Map）"><a href="#③元视图操作的方法（即遍历Map）" class="headerlink" title="③元视图操作的方法（即遍历Map）"></a>③元视图操作的方法（即遍历Map）</h4><ul><li>Set <strong>keySet</strong>()：返回所有key构成的Set集合</li><li>Collection <strong>values</strong>()：返回所有value构成的Collection集合</li><li>Set <strong>entrySet</strong>()：返回所有key-value对构成的Set集合</li></ul><p>map没有iterator方法，遍历时可以用以上方法得到set或者Collection，再用他们的iterator方法，即可实现遍历。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">HashMap</span> <span class="variable">map1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map1.put(<span class="string">&quot;aa&quot;</span>,<span class="number">2</span>);</span><br><span class="line">        map1.put(<span class="string">&quot;cc&quot;</span>,<span class="number">3</span>);</span><br><span class="line">        map1.put(<span class="string">&quot;bb&quot;</span>,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历map1当中的key</span></span><br><span class="line">        <span class="type">Set</span> <span class="variable">keySet</span>  <span class="operator">=</span> map1.keySet();</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> keySet.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历map1当中的value</span></span><br><span class="line">        <span class="type">Collection</span> <span class="variable">collection</span> <span class="operator">=</span> map1.values();</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator1</span> <span class="operator">=</span> collection.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator1.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator1.next());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历map1当中的key-value对，方式一：</span></span><br><span class="line">        <span class="type">Set</span> <span class="variable">entrySet</span> <span class="operator">=</span> map1.entrySet();</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator2</span> <span class="operator">=</span> entrySet.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator2.hasNext())&#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> iterator2.next();</span><br><span class="line">            <span class="comment">//取出来的数据都是Entry类型</span></span><br><span class="line">            Map.Entry entry= (Map.Entry)o;</span><br><span class="line">            System.out.println(entry.getKey() + <span class="string">&quot;--&quot;</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//遍历map1当中的key-value对，方式二：</span></span><br><span class="line">    <span class="type">Set</span> <span class="variable">keySet1</span> <span class="operator">=</span> map1.keySet();</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator3</span> <span class="operator">=</span> keySet1.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator3.hasNext())&#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">key</span> <span class="operator">=</span> iterator3.next();</span><br><span class="line">            <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> map1.get(key);</span><br><span class="line"></span><br><span class="line">            System.out.println(key + <span class="string">&quot;==&quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/imgs/image-20220829170603182-1682331686907.png" alt="image-20220829170603182"></p><p>遍历的应用：将Map中的一条条数据取出来放到数据库中</p><h4 id="④常用方法总结"><a href="#④常用方法总结" class="headerlink" title="④常用方法总结"></a>④常用方法总结</h4><p><img src="/imgs/image-20220829171040578-1682331686908.png" alt="image-20220829171040578"></p><h3 id="M-Collections工具类"><a href="#M-Collections工具类" class="headerlink" title="M.Collections工具类"></a>M.Collections工具类</h3><p>Collections：操作Collection、Map的工具类</p><h4 id="①反转"><a href="#①反转" class="headerlink" title="①反转"></a>①反转</h4><p>**reverse(List)**：反转List中元素的顺序，该方法没有返回值</p><h4 id="②排序"><a href="#②排序" class="headerlink" title="②排序"></a>②排序</h4><ol><li>shuffle(List)：对List集合元素进行随机排序，该方法没有返回值</li><li>sort(List)：调用List元素里的comparTO方法对指定的List集合元素进行自然排序（即按升序排序）。</li><li>sort(List,Comparator)：根据指定的Comparator产生的顺序对List集合元素进行排序</li><li>swap(List,int,int)：将指定 list 集合中的 i 处元素和 j 处元素进行交换</li></ol><h4 id="③求最值"><a href="#③求最值" class="headerlink" title="③求最值"></a>③求最值</h4><ol><li>Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素。自然排序：调用的是集合中元素所在类的compareTo方法。</li><li>Object max(Collection，Comparator)：根据 Comparator 指定的顺序，返回给定集合中的最大元素</li><li>Object min(Collection)：根据元素的自然顺序，返回给定集合中的最小元素。自然排序：调用的是集合中元素所在类的compareTo方法。</li><li>Object min(Collection，Comparator)</li></ol><h4 id="④计算某元素出现的次数"><a href="#④计算某元素出现的次数" class="headerlink" title="④计算某元素出现的次数"></a>④计算某元素出现的次数</h4><p><code>int frequency(Collection，Object)</code>：返回指定集合中指定元素的出现次数</p><h4 id="⑤复制"><a href="#⑤复制" class="headerlink" title="⑤复制"></a>⑤复制</h4><p><code>void copy(List dest,List src)</code>：将src中的内容复制到dest中 </p><p><img src="/imgs/image-20220829204754982-1682331686909.png" alt="image-20220829204754982"></p><h4 id="⑥替换"><a href="#⑥替换" class="headerlink" title="⑥替换"></a>⑥替换</h4><p><code>boolean replaceAll(List list，Object oldVal，Object newVal)</code>：使用新值替换List 对象的所有旧值</p><h4 id="⑦将线程不安全的集合变成线程安全集合"><a href="#⑦将线程不安全的集合变成线程安全集合" class="headerlink" title="⑦将线程不安全的集合变成线程安全集合"></a>⑦将线程不安全的集合变成线程安全集合</h4><p>Collections类中提供了多个synchronizedXxx( )方法，该方法可使将指定集合包装成线程安全的集合，从而可以解决多线程并发访问集合时的线程安全问题，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();<span class="comment">//list存在线程不安全问题</span></span><br><span class="line"><span class="comment">//返回的list1即为线程安全的List</span></span><br><span class="line"><span class="type">List</span> <span class="variable">list1</span> <span class="operator">=</span> Collections.synchronizedList(list);</span><br></pre></td></tr></table></figure><p>当多个线程共同操作list1时，就不再发生线程安全问题。</p><hr><h2 id="6、泛型"><a href="#6、泛型" class="headerlink" title="6、泛型"></a>6、泛型</h2><h3 id="A-引入"><a href="#A-引入" class="headerlink" title="A.引入"></a>A.引入</h3><p>​我们可以往集合中存放任何的数据类型，这其实是集合的一个缺点，就比如：用集合去存储学生的成绩，在添加数据的时候对数据的类型并没有要求，所以可以添加除int以外的类型数据，这并不是我们希望的，因此我们就引入了泛型。其作用是：表明该集合只能存放泛型中声明的数据类型，不能存放其他数据类型。</p><p>​泛型是jdk5.0的新特性。</p><h3 id="B-在集合中使用泛型"><a href="#B-在集合中使用泛型" class="headerlink" title="B.在集合中使用泛型"></a>B.在集合中使用泛型</h3><ol><li><p>集合接口或集合类在jdk5.0时都修改为带泛型的结构。 —&gt;前提。如果没有在定义接口或类时声明为带泛型的结构，那么接口内或类内就不能使用泛型。</p></li><li><p>在实例化集合类时，可以指明具体的泛型类型（只能写类 类型，不能写基本数据类型，要想用基本数据类型—&gt;包装类）</p></li><li><p>指明完以后，在集合类或接口中凡是定义类或接口时，内部结构（如：方法、构造器、属性等）使用到类的泛型的位置，都指定为实例化的泛型类型。如：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">&quot;hhhhh&quot;</span>);<span class="comment">//此时add方法中的参数变为(String s1),不再是(Object obj)</span></span><br></pre></td></tr></table></figure></li><li><p>如果实例化时，没有指明泛型的类型（即没使用泛型时）。默认类型为 Java.lang.Object 类型。</p></li></ol><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ol><li><p>如果集合中使用泛型声明为Integer，则使用add方法时，仍可以这么写：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list1.add(<span class="number">12</span>);<span class="comment">//仍可以写12</span></span><br></pre></td></tr></table></figure></li><li><p>集合、比较器（Comparable、Comparator）都可以使用泛型</p></li><li><p>添加了泛型之后，集合的遍历操作与原来的操作一样，直接调用对应的方法，然后“alt + enter”自动补充即可。生成的代码会有点不同（21行代码）</p></li></ol>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    list.add(<span class="string">&quot;hhhhh&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;123&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//**********************************</span></span><br><span class="line">    HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;Tom&quot;</span>,<span class="number">12</span>);</span><br><span class="line">    map.put(<span class="string">&quot;Jerry&quot;</span>,<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entrySet = map.entrySet();</span><br><span class="line">    Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iterator1 = entrySet.iterator();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (iterator1.hasNext())&#123;</span><br><span class="line">        Map.Entry&lt;String, Integer&gt; entry = iterator1.next();</span><br><span class="line">        <span class="comment">//现在不用将next方法得到的对象强转为Entry类型</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">        System.out.println(key + <span class="string">&quot;---&quot;</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <img src="/imgs/image-20220830170745289-1682331686909.png" alt="image-20220830170745289"></p><h3 id="C-自定义泛型结构–泛型类"><a href="#C-自定义泛型结构–泛型类" class="headerlink" title="C.自定义泛型结构–泛型类"></a>C.自定义泛型结构–泛型类</h3><p>​自定义泛型结构有：泛型类、泛型接口、泛型方法</p><h4 id="①实现方式"><a href="#①实现方式" class="headerlink" title="①实现方式"></a>①实现方式</h4><p>​在类名后面加上”<T>“即可，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&lt;T&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​如果定义了泛型类，实例化没有指明类的泛型，则认为此泛型类型为Object类型。要求：如果定义了类是带泛型的，建议在实例化时要指明类的类型。  </p><h4 id="②继承关系中的泛型"><a href="#②继承关系中的泛型" class="headerlink" title="②继承关系中的泛型"></a>②继承关系中的泛型</h4><p>​如果父类为泛型类，则子类有两种情况：</p><p>​情况1：子类明确父类中泛型的类型，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&lt;T&gt;&#123;</span><br><span class="line">    String name;</span><br><span class="line">    T order;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将父类中的泛型明确为String，此时属性order的类型为String</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Man</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&lt;String&gt;&#123;<span class="comment">//Man就不属于泛型类，那么Man再实例化的时候就不能写泛型，只能像普通的类那样实例化</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​情况2：子类也无法确定父类中的泛型具体是哪种类 类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&lt;T&gt;&#123;</span><br><span class="line">    String name;</span><br><span class="line">    T order;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Man</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Person</span>&lt;T&gt;&#123;<span class="comment">//Man属于泛型类</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Man&lt;String&gt; m = <span class="keyword">new</span> <span class="title class_">Man</span>&lt;&gt;();<span class="comment">//此时order为String类型</span></span><br></pre></td></tr></table></figure><p>​</p><h4 id="③细节说明"><a href="#③细节说明" class="headerlink" title="③细节说明"></a>③细节说明</h4><ol><li><p>泛型类可能有多个参数，此时应将多个参数一起放在尖括号内。比如：&lt;E1,E2,E3&gt;。实例化时应都要指明其具体的泛型类型。</p></li><li><p>泛型类的构造器如下：public GenericClass(){}。而下面是错误的：public GenericClass&lt; E&gt;(){}</p></li><li><p>泛型不同的引用不能相互赋值。</p><p> <img src="/imgs/image-20220831102630840-1682331686909.png" alt="image-20220831102630840"></p><p> 因为赋值之后，list1指向的是list2堆空间中的对象，当调用list1的add方法时添加的是String类型数据，而list2里只能存Integer类型数据，这就发生了冲突，所以不能赋值。</p></li><li><p>在普通的静态方法中不能使用类的泛型。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(T order)</span>&#123;<span class="comment">//报错</span></span><br><span class="line">System.out.println(order);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 因为泛型类型是在创建对象的时候再确定的，而静态方法是在类的加载的时候就加载的，这时候就需要用到这里的泛型数据，而泛型类型没确定，就不行。</p></li><li><p>异常体系结构下的类，不能是泛型类。</p></li><li><p>try-catch，catch后面的小括号里不能使用泛型。</p></li><li><p>如果用泛型造个数组，得这样写：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误:</span></span><br><span class="line">T[] arr1 = <span class="keyword">new</span> <span class="title class_">T</span>[<span class="number">10</span>];</span><br><span class="line"><span class="comment">//正确</span></span><br><span class="line">T[] arr = (T[]) <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">10</span>];<span class="comment">//只能往该数组里存放T或T的子类数据</span></span><br></pre></td></tr></table></figure></li><li><p>继承关系中的泛型详解</p><p> <img src="/imgs/image-20220831105827121-1682331686909.png" alt="image-20220831105827121"></p><p> <img src="/imgs/image-20220831110112288-1682331686909.png" alt="image-20220831110112288"></p><p> <strong>A、B是子类自己的泛型</strong></p></li></ol><h4 id="④应用"><a href="#④应用" class="headerlink" title="④应用"></a>④应用</h4><ol><li>当类中的某个属性的类型不确定时，就可以使用泛型类，如：</li></ol>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&lt;T&gt;&#123;</span><br><span class="line">String name;</span><br><span class="line">    T personT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>对数据库中的表进行操作的类中可以声明为泛型类，因为该类可能操作不同的表，每个表又不同，所以就用泛型，让子类去继承该类时再明确泛型类型（即明确操作的是哪种表）。</p></li><li></li></ol><hr><h3 id="D-自定义泛型结构–泛型接口"><a href="#D-自定义泛型结构–泛型接口" class="headerlink" title="D.自定义泛型结构–泛型接口"></a>D.自定义泛型结构–泛型接口</h3><h4 id="①实现方式-1"><a href="#①实现方式-1" class="headerlink" title="①实现方式"></a>①实现方式</h4><p>​在接口名后面加上“<T>“即可，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Dog</span>&lt;T&gt;&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="E-自定义泛型结构–泛型方法"><a href="#E-自定义泛型结构–泛型方法" class="headerlink" title="E.自定义泛型结构–泛型方法"></a>E.自定义泛型结构–泛型方法</h3><h4 id="①定义"><a href="#①定义" class="headerlink" title="①定义"></a>①定义</h4><p>​泛型方法：在方法中出现了泛型的结构，泛型参数与类的泛型参数没有任何关系。换句话说，泛型方法属于的类是不是泛型类都没有关系。</p><h4 id="②格式"><a href="#②格式" class="headerlink" title="②格式"></a>②格式</h4><p>​在返回值类型前加上“<T>”即可。</p><h4 id="③使用"><a href="#③使用" class="headerlink" title="③使用"></a>③使用</h4><p>​调用泛型方法时，往该泛型方法中传递的参数的类型决定了该泛型方法泛型的类型。</p><h4 id="④注意"><a href="#④注意" class="headerlink" title="④注意"></a>④注意</h4><p>​泛型方法，可以声明为静态的。原因：泛型参数是在调用方法时确实的，并非在实例化时确定。</p><h3 id="F-泛型在继承方面的体现"><a href="#F-泛型在继承方面的体现" class="headerlink" title="F.泛型在继承方面的体现"></a>F.泛型在继承方面的体现</h3><p>①</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//虽然类A是类B的父类，但是G&lt;A&gt; 和 G&lt;B&gt;二者不具备字父类关系，二者是并列关系。G可以是任意的数据类型，如：集合</span></span><br><span class="line">ArrayList&lt;Person&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">ArrayList&lt;Man&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Man&gt;();</span><br><span class="line">list = list1;<span class="comment">//不具备子父类关系，不能相互赋值</span></span><br></pre></td></tr></table></figure><p>②</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类A是类B的父类父接口，A&lt;G&gt; 是 B&lt;G&gt;的父类或父接口，泛型的类型要一样</span></span><br><span class="line">HashSet&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">LinkedHashSet&lt;String&gt; set1 = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">set = set1;<span class="comment">//存在子父类关系，可以赋值</span></span><br></pre></td></tr></table></figure><h3 id="E-通配符的使用"><a href="#E-通配符的使用" class="headerlink" title="E.通配符的使用"></a>E.通配符的使用</h3><h4 id="①定义-1"><a href="#①定义-1" class="headerlink" title="①定义"></a>①定义</h4><p>​通配符：?</p><p>类A是类B的父类，G<A> 和 G<B> 是并列关系，二者共同的父类是：G&lt;?&gt;</p><h4 id="②应用例子"><a href="#②应用例子" class="headerlink" title="②应用例子"></a>②应用例子</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span>&#123;</span><br><span class="line">    ArrayList&lt;Person&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    ArrayList&lt;Man&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">12</span>));</span><br><span class="line">    printList(list);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历集合</span></span><br><span class="line"><span class="comment">//把ArrayList&lt;?&gt;替换为List&lt;?&gt;也行</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printList</span><span class="params">(ArrayList&lt;?&gt; list)</span>&#123;</span><br><span class="line">    Iterator&lt;?&gt; iterator = list.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="③使用-1"><a href="#③使用-1" class="headerlink" title="③使用"></a>③使用</h4><p>A.对于List&lt;?&gt;就不能向其内部添加数据，除了添加null之外。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;?&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list2.add(<span class="string">&quot;sf&quot;</span>);<span class="comment">//报错</span></span><br></pre></td></tr></table></figure><p>B.允许读取List&lt;?&gt;的对象list2中的元素，读取的数据类型为Object类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Person&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">12</span>));</span><br><span class="line">List&lt;?&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list2 = list;</span><br><span class="line">System.out.println(list2.get(<span class="number">0</span>));<span class="comment">//Person&#123;name=&#x27;Tom&#x27;, age=12&#125;</span></span><br></pre></td></tr></table></figure><h4 id="④有限制条件的通配符"><a href="#④有限制条件的通配符" class="headerlink" title="④有限制条件的通配符"></a>④有限制条件的通配符</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有限制条件的通配符：</span></span><br><span class="line">? <span class="keyword">extends</span> <span class="title class_">A</span></span><br><span class="line">? <span class="built_in">super</span> A</span><br></pre></td></tr></table></figure><p>G&lt;? extends A&gt; 可以作为G&lt; A &gt;和G&lt; B &gt;的父类，其中B是A的子类。extends相当于 “&lt;&#x3D;”，G为带泛型的任意一种数据类型，如：集合</p><p>G&lt;? superA&gt; 可以作为G&lt; A &gt;和G&lt; B &gt;的父类，，其中B是A的父类。super相当于 “&gt;&#x3D;”，G为带泛型的任意一种数据类型，如：集合</p><p><strong>A</strong>.对于G&lt;? extends A&gt;声明的对象，我们是可以获取该对象里的数据的，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Person&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">12</span>));</span><br><span class="line">List&lt;? <span class="keyword">extends</span> <span class="title class_">Person</span>&gt; list2 = <span class="literal">null</span>;</span><br><span class="line">list2 = list;</span><br><span class="line">System.out.println(list2.get(<span class="number">0</span>));<span class="comment">//Person&#123;name=&#x27;Tom&#x27;, age=12&#125;</span></span><br></pre></td></tr></table></figure><p>对于G&lt;? superA&gt; 声明的对象也一样可以获取该对象里的数据。</p><p><strong>B</strong>.</p><p>对于**G&lt;? extends A&gt;**声明的对象，我们不能对其进行添加数据操作，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Person&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">12</span>));</span><br><span class="line">List&lt;? <span class="keyword">extends</span> <span class="title class_">Person</span>&gt; list2 = <span class="literal">null</span>;</span><br><span class="line">list2 = list;</span><br><span class="line"><span class="comment">//报错</span></span><br><span class="line">list2.add();<span class="comment">//无论括号里放什么数据都会报错</span></span><br></pre></td></tr></table></figure><p>对于<strong>G&lt;? super A&gt;</strong> 声明的对象，我们可以对其进行添加数据的操作，但只能添加类A或类A的子类的数据，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Person&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;? <span class="built_in">super</span> Person&gt; list3 = <span class="literal">null</span>;</span><br><span class="line">list3 = list;</span><br><span class="line">list3.add(<span class="keyword">new</span> <span class="title class_">Man</span>());</span><br></pre></td></tr></table></figure><h4 id="⑤其他"><a href="#⑤其他" class="headerlink" title="⑤其他"></a>⑤其他</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &lt;T extend Person&gt;&#123;</span><br><span class="line">    T order;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里的T只能取Person类或Person类的子类</span></span><br><span class="line"><span class="comment">//如果Person是一个接口，那T只能是该接口的实现类</span></span><br></pre></td></tr></table></figure><hr><h2 id="7、IO流"><a href="#7、IO流" class="headerlink" title="7、IO流"></a>7、IO流</h2><h3 id="A-File类的使用"><a href="#A-File类的使用" class="headerlink" title="A.File类的使用"></a>A.File类的使用</h3><h4 id="①概述-3"><a href="#①概述-3" class="headerlink" title="①概述"></a>①概述</h4><ul><li>File类的一个对象，代表一个文件或一个文件目录（俗称：文件夹）</li><li>File类声明在java.io包下</li></ul><p>​</p><h4 id="②预备知识"><a href="#②预备知识" class="headerlink" title="②预备知识"></a>②预备知识</h4><p>​<strong>路径</strong>：</p><ul><li><p>相对路径：相较于某个路径下，指明的路径，如：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>绝对路径：包含盘符在内的文件或文件目录的路径</p></li></ul><p>说明：</p><ol><li><p><strong>IDEA</strong>中：如果大家开发使用JUnit中的单元测试方法测试，相对路径即为当前Module下。如果大家使用main()测试，相对路径即为当前的Project下。</p></li><li><p><strong>Eclipse</strong>中：不管使用单元测试方法还是使用mian()测试，相对路径都是当前的Project下。</p></li><li><p>如何准确的写出文件路径？</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.获取当前代码所在路径</span></span><br><span class="line">System.out.println(System.getProperty(<span class="string">&quot;user.dir&quot;</span>));</span><br><span class="line"><span class="comment">//2.打开显示的路径，在此路径下找到要找的文件</span></span><br><span class="line"><span class="comment">//3.复制找到文件的路径，但不包括1中显示的路径。</span></span><br><span class="line"><span class="comment">//4.完成</span></span><br></pre></td></tr></table></figure></li></ol><p>​<strong>路径分隔符和系统的关系</strong></p><ul><li>windows和DOS系统默认使用“ \ ” 来表示</li><li>UNIX和URL使用“ &#x2F; ” 来表示</li><li>补充：Java中路径分隔符用两个 “ \ ” 表示，目的是区分Java中的转译符” \ “</li></ul><h4 id="③如何实例化"><a href="#③如何实例化" class="headerlink" title="③如何实例化"></a>③如何实例化</h4><p>​有以下几种构造器：</p><p>​A.<strong>File(String filePath)</strong></p><p>​filePath：可以是相对路径，也可以是绝对路径</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(hello.txt);</span><br><span class="line"><span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(D:\\hello.txt);</span><br><span class="line"><span class="comment">//此时造了两个File对象，还没涉及到对文件进行操作，所以填入的文件不存在也没事。</span></span><br></pre></td></tr></table></figure><p>​B.<strong>File(String parentPath,String childPath)</strong></p><p>​parentPath：该文件或文件夹的上一级目录</p><p>​childPath：该文件夹名或文件名</p><p>​C.<strong>File(File parentFile,String childPath)</strong></p><p>​parentFile：该文件或文件夹的上一级目录</p><p>​childPath：该文件夹名或文件名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\java\\exer&quot;</span>);</span><br><span class="line"><span class="type">File</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(f1,<span class="string">&quot;file.txt&quot;</span>);</span><br><span class="line"><span class="comment">//该file.txt文件的绝对路径为：D:\java\exer\file.txt</span></span><br></pre></td></tr></table></figure><h3 id="B-File类的常用方法"><a href="#B-File类的常用方法" class="headerlink" title="B.File类的常用方法"></a>B.File类的常用方法</h3><p>​以下方法是内存层面的调用，还没涉及到硬盘层面的调用。</p><h4 id="①获取相应信息"><a href="#①获取相应信息" class="headerlink" title="①获取相应信息"></a>①获取相应信息</h4><ul><li><p>**public String getAbsolutePath()**：获取绝对路径</p></li><li><p><strong>public String getPath()</strong> ：获取路径，显示的是你声明对象时指明的路径</p></li><li><p><strong>public String getName()</strong> ：获取名称</p></li><li><p>**public String getParent()**：获取上层文件目录路径。若无，返回null</p></li><li><p><strong>public long length()</strong> ：获取文件长度（即：字节数）。不能获取目录的长度。 只有真实存在的文件才能获取到长度，不然返回默认值：0。</p></li><li><p><strong>public long lastModified()</strong> ：获取最后一次的修改时间，毫秒值。只有真实存在的文件或文件目录才返回相应的值，否则返回默认值：0。</p><p>  下面两个方法适用于文件目录：（<strong>且指定的目录要真实存在，不然报错</strong>）</p></li><li><p><strong>public String[] list()</strong> ：获取指定目录下的所有文件或者文件目录的名称数组</p></li><li><p><strong>public File[] listFiles()</strong> ：获取指定目录下的所有文件或者文件目录的File数组（绝对路径）</p></li></ul><h4 id="②重命名功能"><a href="#②重命名功能" class="headerlink" title="②重命名功能"></a>②重命名功能</h4><p>​**public boolean renameTo(File dest)**：把文件重命名为指定的文件路径</p><p>​比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"><span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\java\\hi.txt&quot;</span>);</span><br><span class="line">file1.renameTo(file2);</span><br><span class="line"><span class="comment">//要想保证返回true，需要file1在硬盘中是存在的，且file2不能在硬盘中存在</span></span><br></pre></td></tr></table></figure><p>​<strong>说明</strong>：</p><ol><li>file1、file2中的路径是相对路径、还是绝对路径，都没有关系。</li><li>运行的效果是：根据file2的路径在硬盘中创建相应的文件，然后把hello.txt里的内容复制到file2的那个文件里，最后hello.txt文件被删除。</li></ol><h4 id="③判断功能"><a href="#③判断功能" class="headerlink" title="③判断功能"></a>③判断功能</h4><ul><li>**public boolean isDirectory()**：判断是否是文件目录</li><li><strong>public boolean isFile()</strong> ：判断是否是文件</li><li><strong>public boolean exists()</strong> ：判断硬盘上是否存在该文件或文件目录</li><li><strong>public boolean canRead()</strong> ：判断是否可读</li><li><strong>public boolean canWrite()</strong> ：判断是否可写</li><li><strong>public boolean isHidden()</strong> ：判断是否隐藏</li></ul><p>如果在硬盘中没有该文件或文件目录，这些方法都会返回默认值：false</p><h4 id="④在硬盘中创建对应的文件或文件目录"><a href="#④在硬盘中创建对应的文件或文件目录" class="headerlink" title="④在硬盘中创建对应的文件或文件目录"></a>④在硬盘中创建对应的文件或文件目录</h4><ul><li><strong>public boolean createNewFile()</strong> ：创建文件。若文件存在，则不创建，返回false。该方法本身会报异常，我们需要对其进行throws或try-catch-finally</li><li><strong>public boolean mkdir()</strong> ：创建文件目录。如果此文件目录存在，就不创建了。如果此文件目录的上层目录不存在，也不创建。 </li><li><strong>public boolean mkdirs()</strong> ：创建文件目录。如果上层文件目录不存在，一并创建。</li></ul><h4 id="⑤删除硬盘中的文件或文件目录"><a href="#⑤删除硬盘中的文件或文件目录" class="headerlink" title="⑤删除硬盘中的文件或文件目录"></a>⑤删除硬盘中的文件或文件目录</h4><ul><li>**public boolean delete()**：删除文件或者文件夹</li></ul><p>注意：Java中的删除不走回收站。 要删除一个文件目录，请注意该文件目录内不能包含文件或者文件目录。</p><h4 id="⑥总结"><a href="#⑥总结" class="headerlink" title="⑥总结"></a>⑥总结</h4><ol><li>File类中涉及到关于文件或文件目录的创建、删除、重命名、获取修改时间、获取文件大小等方法，并未涉及到写入或读取文件内容的操作。如果需要读取或写入文件内容，必须使用IO流来完成。</li><li>后续File类的对象常作为参数传递到流的构造器中，指明要读取或写入的文件。</li></ol><h3 id="C-IO流原理"><a href="#C-IO流原理" class="headerlink" title="C.IO流原理"></a>C.IO流原理</h3><h4 id="①概述-4"><a href="#①概述-4" class="headerlink" title="①概述"></a>①概述</h4><ul><li><p>I&#x2F;O即：Input&#x2F;Output。数据从一个地方传送到另一个地方，就形成数据流，但我们通常不叫数据流，而是叫I&#x2F;O流。</p></li><li><p>输入：读取外部数据（磁盘、光盘等存储设备的数据）到程序（内存）中。</p><p>  输出：将程序（内存）数据输出到磁盘、光盘等存储设备中。</p></li></ul><h4 id="②流的分类"><a href="#②流的分类" class="headerlink" title="②流的分类"></a>②流的分类</h4><ul><li><p>按操作数据单位不同分为：字节流(8 bit)，字符流(16 bit)。</p><ul><li>字节流：一个字节一个字节地存储数据，存的是二进制数据。适用于：非文本文件，如：照片、视频等。</li><li>字符流：读取的是一个一个字符（char），存的也是一个一个char(字符)，适用于从文本文件中读取数据。</li></ul></li><li><p>按数据流的流向不同分为：输入流，输出流。</p></li><li><p>按流的角色的不同分为：节点流，处理流。</p><ul><li>节点流：直接作用在文件上的流叫节点流，即：可以直接处理File对象的流。</li><li>处理流：作用在已有流基础上的流叫处理流</li></ul><p>  <img src="/imgs/image-20220902142927450-1682331686909.png" alt="image-20220902142927450"></p></li></ul><h4 id="③四个抽象基类"><a href="#③四个抽象基类" class="headerlink" title="③四个抽象基类"></a>③四个抽象基类</h4><p>​Java的IO流共涉及40多个类，这些类都是从如下4个抽象基类派生的。（基类：基础类的意思）。</p><p>​InputStream、OutputStream属于操作字节流的类，Reader、Writer属于操作字符流的类。</p><p><img src="/imgs/image-20220902144531195-1682331686909.png" alt="image-20220902144531195"></p><p>​</p><h4 id="④IO流体系结构"><a href="#④IO流体系结构" class="headerlink" title="④IO流体系结构"></a>④IO流体系结构</h4><p><img src="/imgs/image-20220902153228642-1682331686910.png" alt="image-20220902153228642"></p><p>​注：第二行中的流属于节点流，第二行及以后的流属于处理流。蓝色标注的流属于重点学习和掌握的。</p><p>​简化版：</p><p><img src="/imgs/image-20220902154142103-1682331686910.png" alt="image-20220902154142103"></p><p>​补充：除了RandomAccessFile不是由四个基类派生而来的，其他的流都是由四个派生基类继承来的。</p><h3 id="E-节点流的使用"><a href="#E-节点流的使用" class="headerlink" title="E.节点流的使用"></a>E.节点流的使用</h3><h4 id="①如何从硬盘读入数据"><a href="#①如何从硬盘读入数据" class="headerlink" title="①如何从硬盘读入数据"></a>①如何从硬盘读入数据</h4><p>​<strong>实现步骤：</strong></p><p>​(读数据和写数据的操作步骤都是下面的4步，由于使用的流不一样，步骤2会不同；是读还是写，导致步骤3不一样，其他地方都一样)</p><ol><li><p>造File类的对象，指明要操作的文件。文件一定要存在。</p></li><li><p>根据需要选择具体的流，然后造流的对象，File类的对象作为参数传到流的构造器中。</p></li><li><p>数据的读入，用流的对象取调用read方法。read()：返回读入的一个字符，如果到达文件末尾，返回-1。</p></li><li><p>流的关闭操作。流的对象调用close()方法</p><p> <strong>注意：</strong></p></li></ol><ul><li>造流的对象和调用read方法时，都会抛异常，因此需要用try-catach-finally来处理。用try将这些代码包起来。快捷键：选中需要抱起来的代码   –&gt; alt+shift+z –&gt; try-catch-finally</li><li>调用close()方法时，也会抛异常。首先将关闭流的操作放在finally里（因为流声明完，不再使用时，不关闭会出现内存泄漏，使用<strong>必须关闭</strong>），然后再将close操作用try-catch-finally包起来，最后在close这行代码的上面加上判断语句（判断当前流的对象是否为null）。</li><li>读入的文件一定要存在，否则就会报FileNotFoundException</li></ul><p>​<strong>如何形象理解上面的三个实现步骤：</strong></p><p>​比如我们需要从一个水池里取水，怎么取呢？首先我们得知道水池的位置（即造File对象的步骤），然后我们就要造水管了(即：造流的对象)，但水管具体要安装在哪，我们就需要把File类的对象传到流的构造器中告诉它水管安装在哪，然后就开闸放水（即调用read方法）。</p><h4 id="②读入：read方法"><a href="#②读入：read方法" class="headerlink" title="②读入：read方法"></a>②读入：read方法</h4><ol><li><code>read()</code>：每次读取一个char或一个byte数据，如果到达文件末尾，返回-1。</li><li><code>read(char[] a)</code> \ <code>read(byte[] a)</code>：将文件当中的内容读到数组a当中，每次读的长度为数组的长度，下一次读取时将原有的内容覆盖掉，而不是将数组中原有的内容先清除掉再添加。该方法返回的是，放入数组中字符\字节的个数，当返回-1时，代表读取完毕。<code>数组a的长度一般为1024</code>。如：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(file);</span><br><span class="line"><span class="type">char</span>[] a = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> length;</span><br><span class="line"><span class="keyword">while</span>((length = fr.read(a)) != -<span class="number">1</span>)&#123;<span class="comment">//read会抛异常，需要try-catch-finally，这里省略。</span></span><br><span class="line">    <span class="comment">//方式一：</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; length;i++)&#123;</span><br><span class="line">        System.out.print(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//方式二：</span></span><br><span class="line">    <span class="comment">//String str = new String(a,0,length);//从数组a的0索引处开始取length个数据</span></span><br><span class="line">    <span class="comment">//System.out.print(str);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="③从内存写入数据到硬盘"><a href="#③从内存写入数据到硬盘" class="headerlink" title="③从内存写入数据到硬盘"></a>③从内存写入数据到硬盘</h4><p>​<strong>实现步骤</strong>：</p><ol><li>造File类的对象，指明要写入到的文件</li><li>根据需要选择具体的流，然后造流的对象，File类的对象作为参数传到流的构造器中。</li><li>数据的写入，用流的对象调用write()方法。</li><li>流的关闭操作。流的对象调用close()方法</li></ol><p>​<strong>说明</strong>：</p><ul><li>输出操作，对应的File可以不存在。并不会报异常。File的上级目录一定要存在，不然报错。</li><li>File对应的硬盘中的文件如果不存在，在输出的过程中，会自动创建此文件。</li><li>File对应的硬盘中的文件如果存在：<ul><li>如果流使用的构造器是：FileWriter(file,false) &#x2F; FileWriter(file)：对原有文件的覆盖。 &#x2F;&#x2F;第2个参数是指是否能追加内容</li><li>如果流使用的构造器是：FileWriter(file,true)：不会对原有文件覆盖，而是在原有文件基础上追加内容。</li></ul></li></ul><h4 id="④写出：write方法"><a href="#④写出：write方法" class="headerlink" title="④写出：write方法"></a>④写出：write方法</h4><p>​<code>write(String s)</code>：将字符串s写入到硬盘中</p><p>​<code>write(char[] a,int index,length)</code>：从数组a中索引为index的位置开始取长度为：length的数据写入到硬盘中。</p><h4 id="⑤注意"><a href="#⑤注意" class="headerlink" title="⑤注意"></a>⑤注意</h4><ol><li>对于文本文件（.txt，.java，.c，.cpp），使用字符流（ Reader、Writer）处理。字符流不能处理字节数据。</li><li>）对于非文本文件（.jpg，.mp3，.mp4，.avi，.doc，.ppt，……）使用字节流（InputStream、OutputStream）处理。用字节流去实现文本文件的复制是没问题的，但在复制过程中对内容进行输出就可能出现乱码。</li></ol><h4 id="⑥补充"><a href="#⑥补充" class="headerlink" title="⑥补充"></a>⑥补充</h4><p>​节点流的构造器除了有放File类对象的构造器，还有放String的构造器。</p><p>​放String的构造器，以FileReader为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"><span class="comment">//传的是该文件的相对路径或绝对路径。</span></span><br><span class="line"><span class="comment">//这种声明方式实际上也是造了一个File类的对象，然后将此对象放到FileReader构造器中。</span></span><br></pre></td></tr></table></figure><h3 id="F-缓冲流"><a href="#F-缓冲流" class="headerlink" title="F. 缓冲流"></a>F. 缓冲流</h3><h4 id="①概述-5"><a href="#①概述-5" class="headerlink" title="①概述"></a>①概述</h4><p>​缓冲流属于处理流的一种。处理流：对现有流进行包装的流，其作用在现有流上。</p><p>​缓冲流：提高流的读写效率，开发中常用缓冲流。</p><p><img src="/imgs/image-20220903130413372-1682331738367.png" alt="image-20220903130413372"></p><h4 id="②缓冲流的使用"><a href="#②缓冲流的使用" class="headerlink" title="②缓冲流的使用"></a>②缓冲流的使用</h4><p>​<strong>用缓冲流实现读写操作，实现步骤</strong>：</p><ol><li>造File类对象，指明要读入 (或写入)的文件</li><li>造相应的节点流的对象，把File类的对象作为参数传递到节点流的构造器中</li><li>根据节点流的类型选择对应的缓冲流并造其对象，把上面节点流的对象作为参数传递到缓冲流的构造器中。</li><li>用缓冲流的对象调用read()方法（或write()方法）。</li><li>流的关闭。要求：先关外层的流，再关内层的流。同一层的流，先关哪个都行。<ul><li>说明：关闭外层流的同时，内层流也会自动的进行关闭。关于内层流的关闭，我们可以省略。</li></ul></li></ol><p>​注意：</p><ul><li>造流的对象、调用read()、调用write()都会抛异常，所以要用try-catch-finally来处理。将步骤1-4用try包起来。流的关闭操作放在finally里。</li></ul><p>​<strong>以上实现步骤的形象理解</strong>：</p><p>​我们需要从一个池子中快速地把水抽出来。首先，我们得知道水池的位置（即造File类的对象，指明池子的位置），然后由于缓冲流是作用在现有流的基础上，所以得造节点流的对象（就相当于造了根水管），接着把File类的对象传到节点流的构造器中（即指明水管安装的位置），再接着造缓冲流的对象（相当于弄了台增压水泵），把节点流的对象作为参数传递到缓冲流的构造器中（相当于告诉增压水泵安装到哪根水管）。这些步骤执行完后，用缓冲流的对象调用read()方法（或write()方法）。</p><h4 id="③readLine"><a href="#③readLine" class="headerlink" title="③readLine()"></a>③readLine()</h4><p>​<strong>BufferedReader</strong>中提供了一个**readLine()**方法，该方法每次从文件中读取一行数据，并以String的形式返回。当读到文件末尾时，返回null。</p><p>​注意：</p><ul><li>该方法提高流的对象调用</li><li>该方法返回的内容不包含换行符。如果想换行，可以用流的对象调用newLine()，实现换行操作。</li></ul><h4 id="④为什么缓冲流能提高速度"><a href="#④为什么缓冲流能提高速度" class="headerlink" title="④为什么缓冲流能提高速度"></a>④为什么缓冲流能提高速度</h4><p>​缓冲流内部提供了一个大小为8192个字节（8kb）的缓冲区，每次从文件中读取的数据都会先放在缓冲区中，当存放的容量达到8192时，就会调用flush()方法将缓冲区中的内容写出到另一个文件并清空缓冲区。这样就减少了与文件的交互次数，从而提高了读写效率。</p><h3 id="G-转换流"><a href="#G-转换流" class="headerlink" title="G.转换流"></a>G.转换流</h3><h4 id="①概述-6"><a href="#①概述-6" class="headerlink" title="①概述"></a>①概述</h4><ul><li><p>转换流是处理流中的一种。</p></li><li><p>转换流：提供了在字节流和字符流之间的转换。</p></li><li><p>Java中提供了两个转换流：</p><ul><li>InputStreamReader：将一个字节的输入流转换为字符的输入流</li><li>OutputStreamWriter：将一个字符的输出流转换为字节的输出流</li><li>上面两个流属于字符流</li><li>这两个流<strong>只能操作文本文件。</strong></li></ul></li><li><p>解码：字节、字节数组 —&gt; 字符数组、字符串</p><p>  编码：字符数组、字符串 —&gt; 字节、字节数组</p></li></ul><h4 id="②InputStreamReader"><a href="#②InputStreamReader" class="headerlink" title="②InputStreamReader"></a>②InputStreamReader</h4><p>​InputStreamReader的使用，实现了字节的输入流到字符的输入流的转换</p><p>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;dbcp.txt&quot;</span>);</span><br><span class="line"><span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(fis);<span class="comment">//使用系统默认的字符集</span></span><br><span class="line"><span class="comment">//InputStreamReader isr = new InputStreamReader(fis,&quot;UTF-8&quot;);//参数2指明了字符集，集体使用哪个字符集，取决于文件dbcp.txt保存时使用的字符集</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>[] cbuf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"><span class="keyword">while</span>((len = isr.read(cbuf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(cbuf,<span class="number">0</span>,len);</span><br><span class="line">    System.out.print(str);</span><br><span class="line">&#125;</span><br><span class="line">isr.close();</span><br><span class="line"><span class="comment">//注意：此代码还没有用try-catch-finally进行异常处理</span></span><br></pre></td></tr></table></figure><h4 id="②OutputStreamWriter"><a href="#②OutputStreamWriter" class="headerlink" title="②OutputStreamWriter"></a>②OutputStreamWriter</h4><p><img src="/imgs/image-20220903214413204-1682331738368.png" alt="image-20220903214413204"></p><p>上述过程的代码实现：</p><p><img src="/imgs/image-20220903214048047-1682331738368.png" alt="image-20220903214048047"></p><p>​注意：上面代码并没有用try-catch-finally处理异常，自己写的时候要补上。</p><h3 id="H-字符集"><a href="#H-字符集" class="headerlink" title="H.字符集"></a>H.字符集</h3><h4 id="①编码表"><a href="#①编码表" class="headerlink" title="①编码表"></a>①编码表</h4><p>​计算机只能识别二进制数据，早期由来是电信号。为了方便应用计算机，让它可以识别各个国家的文字。就将各个国家的文字用数字来表示，并一一对应，形成一张表。这就是编码表。</p><h4 id="②常见编码表"><a href="#②常见编码表" class="headerlink" title="②常见编码表"></a>②常见编码表</h4><ul><li>ASCII：美国标准信息交换码。 用一个字节的7位可以表示。</li><li>ISO8859-1：拉丁码表。欧洲码表用一个字节的8位表示。</li><li>GB2312：中国的中文编码表。最多两个字节编码所有字符。兼容了ASCII，因为ASCII用一个字节就可以表示，不用用两个字节表示，这样可以节省空间。<ul><li>那怎么识别是一个字节表示一个字符还是两个字节表示一个字符呢？看字节中最左边的那位，如果是1，则表示它还有一个字节，即两个字节表示一个字符；如果是0，则一个字节表示一个字符。GBK也采用这种方式识别。</li></ul></li><li>GBK：中国的中文编码表升级，融合了更多的中文文字符号。最多两个字节编码。兼容了ASCII。</li><li>Unicode：国际标准码，融合了目前人类使用的所有字符。为每个字符分配唯一的字符码。所有的文字都用两个字节来表示。</li><li>UTF-8：变长的编码方式，可用1-4个字节来表示一个字符。（中文用3个字节存储。）UTF-8是Unicode的一种具体实现。</li></ul><h4 id="③启示"><a href="#③启示" class="headerlink" title="③启示"></a>③启示</h4><p>​客户端、浏览器  &lt;—&gt; 后台 &lt;—-&gt; 数据库</p><p>​为了保证不乱码，这三个部分都要统一字符集。 </p><h3 id="I-标准输入、输出流-了解"><a href="#I-标准输入、输出流-了解" class="headerlink" title="I.标准输入、输出流(了解)"></a>I.标准输入、输出流(了解)</h3><ul><li>标准输入、输出流是处理流中的一种。</li><li>in、out是System里的两个属性。</li><li>System.in和System.out分别代表了系统标准的输入和输出。</li><li>System.in：默认从键盘输入，字节流；System.out：默认从控制台（显示器）输出。</li><li>通过System类的setIn(InputStream is)，setOut(PrintStream ps)方法重新指定输入和输出的流。PrintStream是OutputStream的子类。</li></ul><h3 id="J-打印流-了解"><a href="#J-打印流-了解" class="headerlink" title="J.打印流(了解)"></a>J.打印流(了解)</h3><ul><li>打印流是处理流中的一种。</li><li>实现将基本数据类型的数据格式转化为字符串输出。</li><li>打印流：PrintStream（字节输出流）和PrintWriter（字符输出流）。</li><li>它们提供了一系列重载的print()和println()方法，用于多种数据类型的输出。为什么我们能通过print()就能接收不同类型的数据并输出，是因为调用了PrintStream中重载的print \ println方法。</li><li>System.out返回的是PrintStream的实例</li></ul><h4 id="①把控制台中输出的内容保存到文件"><a href="#①把控制台中输出的内容保存到文件" class="headerlink" title="①把控制台中输出的内容保存到文件"></a>①把控制台中输出的内容保存到文件</h4><p>​步骤：</p><ol><li>创建FileOutputStream的对象，构造器中放File类的对象或直接放文件的路径。（指明要写入的文件）</li><li>因为打印流属于处理流，创建PrintStream类的对象时，将FileOutputStream的对象放进去构造器中。</li><li>用 if 判断打印流的对象是否为null，不为null，则System.setOut(打印流对象);</li><li>接下来写你想写的内容。</li><li>流的关闭操作。</li></ol><p>注意：要用try-catch-finally将1-4包起来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">PrintStream</span> <span class="variable">pw</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;h.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//指明写入到的文件</span></span><br><span class="line">        pw = <span class="keyword">new</span> <span class="title class_">PrintStream</span>(fr,<span class="literal">true</span>);</span><br><span class="line">  <span class="comment">//创建打印输出流，设置为自动刷新模式（写入换行或&#x27;\n&#x27;时都会刷新输出缓冲区）</span></span><br><span class="line">        <span class="keyword">if</span> (pw != <span class="literal">null</span>)&#123;</span><br><span class="line">            System.setOut(pw);</span><br><span class="line">            <span class="comment">//把标准输出流（控制台输出）改成输出到指定文件</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="number">123</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pw != <span class="literal">null</span>)</span><br><span class="line">            pw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="K-数据流-了解"><a href="#K-数据流-了解" class="headerlink" title="K.数据流(了解)"></a>K.数据流(了解)</h3><h4 id="①概述-7"><a href="#①概述-7" class="headerlink" title="①概述"></a>①概述</h4><ul><li>数据流属于处理流的一种。</li><li>数据流：DataInputStream 和 DataOutputStream</li><li>分别“套接”在 InputStream 和 OutputStream 子类的流上。</li><li>数据流的作用：读取或写出基本数据类型的变量或字符串</li></ul><h4 id="②数据流中的方法"><a href="#②数据流中的方法" class="headerlink" title="②数据流中的方法"></a>②数据流中的方法</h4><p><img src="/imgs/image-20220904144442549-1682331738368.png" alt="image-20220904144442549"></p><h4 id="③数据流的使用"><a href="#③数据流的使用" class="headerlink" title="③数据流的使用"></a>③数据流的使用</h4><p>​练习：将内存中的字符串、基本数据类型的变量写出到文件中。</p><p>​注意：下面代码中并没用try-catch-finally对异常进行处理，写的时候要补上。</p><p>​打开写出的数据文件，里面乱码是正常的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//1.创建数据流的对象，DataOutputStream的构造器需要传一个OutputStream子类的对象</span></span><br><span class="line">    <span class="type">DataOutputStream</span> <span class="variable">dis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;data.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.写入操作</span></span><br><span class="line">    dis.writeUTF(<span class="string">&quot;Tom&quot;</span>);<span class="comment">//writeUTF(String s):写入字符串</span></span><br><span class="line">    dis.flush();<span class="comment">//调用flush()将内存中的数据写入到文件中</span></span><br><span class="line">    dis.writeInt(<span class="number">12</span>);</span><br><span class="line">    dis.flush();</span><br><span class="line">    dis.writeBoolean(<span class="literal">true</span>);</span><br><span class="line">    dis.flush();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//流的关闭</span></span><br><span class="line">    dis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p><p>​练习：将文件中存储的基本数据类型变量和字符串读取到内存中，然后再保存在变量中。</p><p>​注意：面代码中并没用try-catch-finally对异常进行处理，写的时候要补上。</p><p>​读数据的时候要与写数据时的顺序一样，不然报异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//1.造数据流的对象，其构造器中需要出入InputStream子类的对象</span></span><br><span class="line">    <span class="type">DataInputStream</span> <span class="variable">dis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;data.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.写数据的操作</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> dis.readUTF();</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> dis.readInt();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">c</span> <span class="operator">=</span> dis.readBoolean();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;name:&quot;</span> + s + <span class="string">&quot;ID:&quot;</span> + i + <span class="string">&quot;是否男&quot;</span> + c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.流的关闭</span></span><br><span class="line">    dis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="L-对象流"><a href="#L-对象流" class="headerlink" title="L.对象流"></a>L.对象流</h3><h4 id="①概述-8"><a href="#①概述-8" class="headerlink" title="①概述"></a>①概述</h4><p>​<strong>对象流</strong>：用于存储和读取<strong>基本数据类型</strong>数据或<strong>对象</strong>的处理流。它的强大之处是可以把Java中的对象写入到数据源（如：文件）中，也能把对象从数据源中还原回来。</p><p>​<strong>序列化</strong>：将内存中的Java对象保存到磁盘中或通过网络传输出去。使用ObjectOutputStream实现</p><p>​<strong>逆序列化</strong>：将磁盘文件中的对象还原为内存中的一个Java对象。使用ObjectInputStream实现</p><p>​<strong>对象流</strong>：<strong>ObjectInputStream</strong>、<strong>ObjectOutputStream</strong>，属于处理流的一种</p><p>​<strong>对象能序列化、逆序列化的前提是其所在类必须是可序列化的。</strong></p><p>​</p><h4 id="②对象序列化机制"><a href="#②对象序列化机制" class="headerlink" title="②对象序列化机制"></a>②对象序列化机制</h4><p>​允许把内存中的Java对象转换成平台无关的二进制流，从而允许把这种二进制流持久地保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点（序列化）。当其它程序获取了这种二进制流，就可以恢复成原来的Java对象（逆序列化）。</p><p>​实际上对象序列化机制就是描述了一下序列化和逆序列化。</p><h4 id="③对象流的使用"><a href="#③对象流的使用" class="headerlink" title="③对象流的使用"></a>③对象流的使用</h4><p>​A.ObjectOutputStream的使用</p><p>​实现步骤：</p><ol><li><p>造ObjectOutputStream对象。</p><p> 但该构造器需要传OutputStream的子类，因此造FileOutputStream的对象放进去。将要写入的文件放到FileOutputStream构造器中。</p></li><li><p>调用writeObject(要写入的对象)，将对象写入文件中</p></li><li><p>流的关闭</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.造ObjectOutputStream对象</span></span><br><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;object.dat&quot;</span>));</span><br><span class="line"><span class="comment">//2.写入数据</span></span><br><span class="line">oos.writeObject(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;123&quot;</span>));</span><br><span class="line">oos.flush();</span><br><span class="line"><span class="comment">//关闭流</span></span><br><span class="line">oos.close();</span><br></pre></td></tr></table></figure><p>注意：上面代码存在异常，需要try-catch-finally进行异常处理</p><p>​B.ObjectInputStream的使用</p><p>​实现步骤：</p><ol><li><p>造ObjectInputStream对象。</p><p> 但该构造器需要传InputStream的子类，因此造FileInputStream的对象放进去。将要读入的文件放到FileInputStream构造器中。</p></li><li><p>调用readObject()，从文件中读取对象</p></li><li><p>流的关闭</p></li></ol><p>​注意：上面代码存在异常，需要try-catch-finally进行异常处理</p><h4 id="④自定义类可序列化"><a href="#④自定义类可序列化" class="headerlink" title="④自定义类可序列化"></a>④自定义类可序列化</h4><p>​要想自定义类能够保存在磁盘或从磁盘读出到内存，该对象所在类必须是可序列化的。具体实现步骤为：</p><ol><li><p>需要实现接口：Serializable</p></li><li><p>当前类提供一个全局常量：serialVersionUID，该常量为Long型，值可以为随意的一个值。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1234567L</span>;</span><br></pre></td></tr></table></figure></li><li><p>除当前类需要实现Serializable接口外，还必须保证其内部所有属性也是可序列化的。（基本数据类型、String：本身就已经是可序列化）</p></li><li><p>补充：ObjectOutputStream和ObjectInputStream不能序列化static和transient修饰的成员变量。即：被这两个关键字修饰的属性其值是不能被保存到文件中的，当我们用ObjectInputStream去读这些属性时，读出来的是默认值。</p></li></ol><p>​为什么需要serialVersionUID？用于表识该对象属于哪个类。如果没有显示使用serialVersionUID，系统会根据类中的细节自动生成一个serialVersionUID，序列化的时候就把当时的serialVersionUID也存到磁盘中了；逆序列化的时候就拿着这个serialVersionUID去比对，如果修改了当前类的内容，类的serialVersionUID就会发生改变，此时对象中的serialVersionUID与类的serialVersionUID就对不上了，就会导致对象还原不回去。因此我们需要显示指明serialVersionUID。</p><hr><h3 id="M-随机存取文件流（了解）"><a href="#M-随机存取文件流（了解）" class="headerlink" title="M.随机存取文件流（了解）"></a>M.随机存取文件流（了解）</h3><h4 id="①概述-9"><a href="#①概述-9" class="headerlink" title="①概述"></a>①概述</h4><ul><li>RandomAccessFile直接继承于Java.lang.Object类，它没有继承那四个抽象基类。</li><li>RandomAccessFile实现了DataInput、DataOutput这两个接口，因此它既可以作为一个输入流，又可以作为一个输出流。</li></ul><h4 id="②RandomAccessFile的使用"><a href="#②RandomAccessFile的使用" class="headerlink" title="②RandomAccessFile的使用"></a>②RandomAccessFile的使用</h4><p>​<strong>构造器</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">RandomAccessFile</span><span class="params">(File file,String mode)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">RandomAccessFile</span><span class="params">(String name,String mode)</span></span><br><span class="line"><span class="comment">//name:指明要写入或读入的文件，可以写文件的相对路径或文件的绝对路径（其本质上还是造了一个File类的对象）</span></span><br><span class="line"><span class="comment">//mode:指定RandomAccessFile的访问模式：见下图，普通的写操作选rw就行</span></span><br></pre></td></tr></table></figure><p><img src="/imgs/image-20220905141403405-1682331826604.png" alt="image-20220905141403405"></p><p>​使用例子：（注：下面代码没有用try-catch-finally对异常进行处理，写的时候要补上）<img src="/imgs/image-20220905142709003-1682331826604.png" alt="image-20220905142709003"></p><p>​虽然此类既可以是输入流，也可以是输出流。对于读写操作，我们还是得造两个对象来分别处理读操作、写操作。</p><h4 id="③说明"><a href="#③说明" class="headerlink" title="③说明"></a>③说明</h4><ul><li>进行写出操作时，如果该文件不存在，就会造一个新的文件。<ul><li>如果文件存在，则会对原有文件内容进行覆盖。（默认情况下，从头覆盖）</li></ul></li><li>write()：该方法实现的效果为对文件内容的覆盖（在文件原本存在的情况下）</li></ul><h4 id="④方法"><a href="#④方法" class="headerlink" title="④方法"></a>④方法</h4><ol><li><p>seek(long pos)：该方法的作用是将指针调到文件中角标为pos的位置，角标从0开始。<img src="/imgs/image-20220905150208025-1682331826604.png" alt="image-20220905150208025"></p><p> 从角标为3的位置开始对文件内容进行覆盖。</p><p> 如果想在文件末尾进行添加数据，则将pos设置为当前文件的大小（调用File类中的length方法即可），再使用write方法。</p></li></ol><h4 id="⑤应用"><a href="#⑤应用" class="headerlink" title="⑤应用"></a>⑤应用</h4><p>​该类可应用于文件的断点续传操作。</p><h3 id="N-NIO-2中Path、Paths、Files类的使用（了解）"><a href="#N-NIO-2中Path、Paths、Files类的使用（了解）" class="headerlink" title="N.NIO.2中Path、Paths、Files类的使用（了解）"></a>N.NIO.2中Path、Paths、Files类的使用（了解）</h3><h4 id="①理解-1"><a href="#①理解-1" class="headerlink" title="①理解"></a>①理解</h4><ul><li>Java NIO (New IO，Non-Blocking IO)是从Java 1.4版本开始引入的一套新的IO API，可以替代标准的Java IO API。NIO与原来的IO有同样的作用和目的，但是使用的方式完全不同，NIO支持面向缓冲区的(IO是面向流的)、基于通道的IO操作。NIO将以更加高效的方式进行文件的读写操作。</li><li>随着 JDK 7 的发布，Java对NIO进行了极大的扩展，增强了对文件处理和文件系统特性的支持，以至于我们称他们为 NIO.2。</li></ul><h4 id="②Path"><a href="#②Path" class="headerlink" title="②Path"></a>②Path</h4><p>​<strong>引入</strong>：</p><p>​早期的Java只提供了一个File类来访问文件系统，但File类的功能比较有限，所提供的方法性能也不高。而且，大多数方法在出错时仅返回失败，并不会提供异常信息。NIO. 2为了弥补这种不足，引入了Path接口。<strong>实际上，Path可以看成是File类的升级版本，实际引用的资源也可以不存在。</strong></p><p><img src="/imgs/image-20220905160945668-1682331826604.png" alt="image-20220905160945668"></p><p>​Path中的常用方法：</p><p><img src="/imgs/image-20220905161408689-1682331826604.png" alt="image-20220905161408689"></p><h4 id="③Paths"><a href="#③Paths" class="headerlink" title="③Paths"></a>③Paths</h4><p>​Paths是一个类，用于创建Path对象的。</p><p>​Paths类提供的静态get()方法用来获取Path对象</p><p><img src="/imgs/image-20220905161318974-1682331826604.png" alt="image-20220905161318974"></p><h4 id="④Files"><a href="#④Files" class="headerlink" title="④Files"></a>④Files</h4><p>​用于操作文件或文件目录的工具类</p><p>​常用方法：</p><p><img src="/imgs/image-20220905161649470-1682331826604.png" alt="image-20220905161649470"><img src="/imgs/image-20220905161705595-1682331826604.png" alt="image-20220905161705595"></p><h3 id="O-ByteArrayOutputStream"><a href="#O-ByteArrayOutputStream" class="headerlink" title="O.ByteArrayOutputStream"></a>O.ByteArrayOutputStream</h3><h4 id="①概述-10"><a href="#①概述-10" class="headerlink" title="①概述"></a>①概述</h4><p>​该流可用于存储字节流数据，并将字符流数据保存到 byte[ ] 数组中。如：</p><h4 id="②toString"><a href="#②toString" class="headerlink" title="②toString()"></a>②toString()</h4><p>​该方法可以将ByteArrayOutputStream底层中的 byte[ ] 转换为字符串</p><h4 id="③getBytes"><a href="#③getBytes" class="headerlink" title="③getBytes()"></a>③getBytes()</h4><p>​该方法属于String类中的方法，可以将字符串转换为一个byte数组</p><h4 id="④例子"><a href="#④例子" class="headerlink" title="④例子"></a>④例子</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//h.txt文件中存放了abc,现在想将此文件中的英文字母全转为大写再输出到文件uph.txt中</span></span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;h.txt&quot;</span>);</span><br><span class="line"><span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line"><span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造器不需要形参</span></span><br><span class="line"><span class="keyword">while</span>((len = fis.read(buffer)) != <span class="literal">null</span>)&#123;</span><br><span class="line">    baos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">toUpperCase</span> <span class="operator">=</span> baos.toString().toUpperCase();</span><br><span class="line"></span><br><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;uph.txt&quot;</span>);</span><br><span class="line"><span class="comment">//因为fos属于字节流，只能向里面添加字节流数据，因此需要将字符串转换为byte数组再写入到文件中</span></span><br><span class="line">fos.write(toUpperCase.getBytes());</span><br></pre></td></tr></table></figure><h2 id="8、网络编程"><a href="#8、网络编程" class="headerlink" title="8、网络编程"></a>8、网络编程</h2><h3 id="①网络编程概述"><a href="#①网络编程概述" class="headerlink" title="①网络编程概述"></a>①网络编程概述</h3><h4 id="A-网络编程的目的"><a href="#A-网络编程的目的" class="headerlink" title="A.网络编程的目的"></a>A.网络编程的目的</h4><ul><li>直接或间接地通过网络协议与其它计算机实现数据交换，进行通讯。</li></ul><h4 id="B-网络编程中有两个主要的问题"><a href="#B-网络编程中有两个主要的问题" class="headerlink" title="B.网络编程中有两个主要的问题"></a>B.网络编程中有两个主要的问题</h4><ol><li><p>如何准确地定位网络上一台或多台主机；定位主机上的特定的应用。</p><ul><li>IP：区分主机。</li><li>端口号：区分一个主机上不同的应用程序。</li></ul></li><li><p>找到主机后如何可靠高效地进行数据传输。</p><p> 一定的规则（即网络通信协议，有两套参考模型）：</p><ul><li>OSI参考模型：模型过于理想化，未能在因特网上广泛推广。</li><li>TCP&#x2F;IP参考模型：事实上的国际标准。</li></ul><p> <img src="/imgs/image-20220905205609057-1682331826604.png" alt="image-20220905205609057"></p><p> 层与层之间是可以进行数据传输的，如：</p></li></ol><p><img src="/imgs/image-20220905205705818-1682331826605.png" alt="image-20220905205705818"></p><p>​</p><h4 id="C-通信要素1–IP和端口号"><a href="#C-通信要素1–IP和端口号" class="headerlink" title="C.通信要素1–IP和端口号"></a>C.通信要素1–IP和端口号</h4><p>​<strong>IP</strong>：</p><ul><li><p>Java中用InetAddress类来表示IP，一个具体的InetAddress对象就是一个具体的IP地址。</p></li><li><p>IP分类：IPV4 和 IPV6；公网地址(万维网使用)和私有地址(局域网使用)</p></li><li><p>域名：如：<code>www.baidu.com</code>、<code>www.vip.com</code>等，本质上对应着一个IP地址。</p><ul><li>当我们在网站中输入一个域名时，先会去找主机host下是否有这个域名存在，没有则发送给域名解析服务器（DNS），让其解析域名并向主机返回该域名对应的IP地址，主机就拿着这个IP地址去访问相应的网站了。</li></ul></li><li><p>本机IP地址：127.0.0.1 ；对应的域名为：Localhost</p></li><li><p>实例化 InetAddress 两个方法：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.getByName（String host）</span></span><br><span class="line"><span class="type">InetAddress</span> <span class="variable">inet</span> <span class="operator">=</span> InetAddress.getByName(String host);<span class="comment">//返回的是对应域名或IP的对象。注意：该方法会抛异常，我们需要try-catch-finally</span></span><br><span class="line"><span class="comment">//host可以是具体的一个IP地址或域名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.getLocalHost（）</span></span><br><span class="line"><span class="type">InetAddress</span> <span class="variable">inet1</span> <span class="operator">=</span> InetAddress.getLocalHost();<span class="comment">//获取本机的IP地址</span></span><br></pre></td></tr></table></figure><p>  两个常用方法：获取域名getHostName()，获取IP地址getHostAddress()</p></li></ul><p>​<strong>端口号</strong>：</p><ul><li>端口号用来标识正在计算机上运行的进程（程序）；不同的进程有不同的端口号。被规定为一个 16 位的整数 0~65535。</li><li>端口号分类（了解）<ul><li>公认端口：0~1023。被预先定义的服务通信占用（如：HTTP占用端口80，FTP占用端口21，Telnet占用端口23）</li><li>注册端口：1024~49151。分配给用户进程或应用程序。（如：Tomcat占用端口8080，MySQL占用端口3306，Oracle占用端口1521等）。</li><li>动态&#x2F;私有端口：49152~65535。</li></ul></li><li>端口号与IP地址的组合得出一个网络套接字：Socket。</li></ul><h4 id="D-通信要素2–网络协议"><a href="#D-通信要素2–网络协议" class="headerlink" title="D.通信要素2–网络协议"></a>D.通信要素2–网络协议</h4><p>​<strong>引入</strong>：我们知道了IP和端口号后，就可以进行数据传输了，但怎么传涉及到了网络协议。</p><p>​<strong>TCP</strong></p><ul><li><p>使用TCP协议前，须先建立TCP连接，形成传输数据通道。</p></li><li><p>传输前，采用“三次握手”方式，点对点通信，是可靠的。</p></li><li><p>TCP协议进行通信的两个应用进程：客户端、服务端。</p></li><li><p>在连接中可进行大数据量的传输。</p></li><li><p>传输完毕，需释放已建立的连接，效率低（相较于UDP）。</p></li><li><p><strong>三次握手</strong></p><p>  <img src="/imgs/20201108194729168.png" alt="在这里插入图片描述"></p><p>  形象理解：<br>  A：你在吗，我是A<br>  B：我在呢，我是B<br>  A：你在就行跟你说个事，我是A</p><ul><li>“<strong>四次挥手</strong>”</li></ul></li></ul><p><img src="/imgs/20201108201307379.png" alt="在这里插入图片描述"></p><p>​“四次挥手”即终止TCP连接。</p><p>​形象理解：像结婚要双方同意才可以。A向B请求断开连接，B反馈。B再向A请求断开连接，A再反馈。两方都断开才是真正的断开。</p><p>​<strong>UDP</strong>：</p><ul><li>将数据、源、目的封装成数据包，<strong>不需要建立连接</strong>。</li><li>每个数据报的大小限制在64K内 。数据比较大时，需要分多个包发送。</li><li>发送不管对方是否准备好，接收方收到也不确认，故是<strong>不可靠</strong>的。</li><li>发送数据结束时无需释放资源，开销小，速度快。</li></ul><h3 id="②TCP网络编程"><a href="#②TCP网络编程" class="headerlink" title="②TCP网络编程"></a>②TCP网络编程</h3><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><ul><li>创建Socket对象，指明服务器端的IP和端口号。</li><li>用Socket对象调用getOutputStream()方法，获取一个输出流。用于给客户端发送信息。</li><li>拿着输出流调用write()进行数据输出操作。</li><li>Socket、流的关闭。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">client</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//1.创建Socket对象，指明服务器端的IP与端口号</span></span><br><span class="line"><span class="type">InetAddress</span> <span class="variable">inet</span> <span class="operator">=</span>InetAddress.getByName(<span class="string">&quot;127.0.0.1);//服务端的IP地址</span></span><br><span class="line"><span class="string">Socket socket=new Socket(inet,8899);//端口号8899</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//2.获取一个输出流，用于输出数据</span></span><br><span class="line"><span class="string">OutputStream os=socket.getOutputStream();</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//3.写出数据</span></span><br><span class="line"><span class="string">os.write(&quot;</span>你好，我是客户端<span class="string">&quot;);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//4.资源关闭</span></span><br><span class="line"><span class="string">os.close();</span></span><br><span class="line"><span class="string">socket.close();</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>​注意：上面代码存在异常，需要用try-catch-finally对其进行异常处理</p><h4 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h4><ul><li>创建服务器端的ServerSocket，指明服务器的端口号。</li><li>用上面创建的对象去调用accept()，接收来自客户端的socket。</li><li>用获取到的socket对象去调用getInputStream()，获取输入流。</li><li>用流的对象去调用read()方法，进行相应的读操作。</li><li>关闭ServerSocket、socket、流</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务端</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">server</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//1.创建Socket对象，指明自己的端口号</span></span><br><span class="line">ServerSocket s=<span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8899</span>);</span><br><span class="line"><span class="comment">//2.调用accept()表示接收来自于客户端的socket</span></span><br><span class="line">Socket socket=s.acept();</span><br><span class="line"><span class="comment">//3.获取输入流</span></span><br><span class="line">InputStream is=socket.getInputStream();</span><br><span class="line"></span><br><span class="line"><span class="comment">//不建议这样写，一个中文3个字节，5太小，两个中文时，第二个字被分开存会出现乱码</span></span><br><span class="line"><span class="comment">/*byte[] buffer=new byte[5];</span></span><br><span class="line"><span class="comment">int len;</span></span><br><span class="line"><span class="comment">while((len=is.read(buffer))!=-1)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">String str=new String(buffer,0,len);</span></span><br><span class="line"><span class="comment">System.out.print(str);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//建议如下写：</span></span><br><span class="line"><span class="comment">//4.读取输入流中的数据</span></span><br><span class="line">ByteArrayOutputStream baos=<span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();<span class="comment">//这时写入的内容在ByteArrayOutputStream的数组里，不会每5个就还原，而是等所有的输完后整体转换，所以不会出现乱码。</span></span><br><span class="line"><span class="type">byte</span>[] buffer=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"><span class="keyword">while</span>((len=is.read(buffer))!=-<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">baos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">&#125;</span><br><span class="line">System.out.print(baos.toString());</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.资源关闭</span></span><br><span class="line">baos.close();</span><br><span class="line">is.close();</span><br><span class="line">socket.close();</span><br><span class="line">ss.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​上面代码会抛异常，我们需要用try把除关闭操作外的代码包起来，将关闭操作的代码放到finally里。</p><h3 id="③UDP网络编程（了解）"><a href="#③UDP网络编程（了解）" class="headerlink" title="③UDP网络编程（了解）"></a>③UDP网络编程（了解）</h3><p>（1）类 DatagramSocket 和 DatagramPacket 实现了基于 UDP 协议网络程序。</p><p>（2）UDP数据报通过数据报套接字 DatagramSocket 发送和接收，系统不保证UDP数据报一定能够安全送到目的地，也不能确定什么时候可以抵达。</p><p>（3）DatagramPacket 对象封装了UDP数据报，在数据报中包含了发送端的IP地址和端口号以及接收端的IP地址和端口号。</p><p>（4）UDP协议中每个数据报都给出了完整的地址信息，因此无须建立发送方和接收方的连接。如同发快递包裹一样。</p><h3 id="④URL编程"><a href="#④URL编程" class="headerlink" title="④URL编程"></a>④URL编程</h3><h4 id="A-URL"><a href="#A-URL" class="headerlink" title="A.URL"></a>A.URL</h4><p>​<strong>URL</strong>：统一资源定位符，它表示 Internet 上某一资源的地址。</p><p>​<strong>URL的基本结构由5部分组成</strong>：&lt;传输协议&gt;:&#x2F;&#x2F;&lt;主机名&gt;:&lt;端口号&gt;&#x2F;&lt;文件名&gt;#片段名?参数列表   </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/examples/beauty.jpg?usernam=Tom</span><br><span class="line">协议   主机名    端口号 资源地址            参数列表 </span><br><span class="line">主机名：相当于IP </span><br></pre></td></tr></table></figure><p>​</p><h4 id="B-实例化URL对象"><a href="#B-实例化URL对象" class="headerlink" title="B.实例化URL对象"></a>B.实例化URL对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://localhost:8080/examples/beauty.jpg?usernam=Tom&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="C-常用方法"><a href="#C-常用方法" class="headerlink" title="C.常用方法"></a>C.常用方法</h4><p><img src="/imgs/image-20220906181630928-1682331826605.png" alt="image-20220906181630928"></p><h4 id="D-用于"><a href="#D-用于" class="headerlink" title="D.用于"></a>D.用于</h4><p>编程实现对网络资源的获取并进行保存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://localhost:8080/examples/beauty.jpg?usernam=Tom&quot;</span>);</span><br><span class="line">        <span class="comment">//下面两行代码获取与服务器的连接</span></span><br><span class="line">        <span class="type">HttpURLConnection</span> <span class="variable">connection</span> <span class="operator">=</span> (HttpURLConnection) url.openConnection();</span><br><span class="line">        connection.connect();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取到连接后就可以将网站中的资源读取进来了</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">stream</span> <span class="operator">=</span> connection.getInputStream();</span><br><span class="line">        <span class="comment">//下面就是对流的读取操作（略）</span></span><br><span class="line">        <span class="comment">//关闭流</span></span><br><span class="line"><span class="comment">//关闭与服务器的连接</span></span><br><span class="line">        connection.disconnection();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​上面代码要用try-catch-finally进行处理</p><h2 id="9、反射"><a href="#9、反射" class="headerlink" title="9、反射"></a>9、反射</h2><p>本节重点：红色字部分+笔记⑤体会反射的动态性+笔记⑦调用运行时类的指定结构+笔记⑥中的重点关注</p><img src="/imgs/image-20230424210400584.png" alt="image-20230424210400584" style="zoom:80%;" /><h3 id="①引入"><a href="#①引入" class="headerlink" title="①引入"></a>①引入</h3><p>​后端运行起来后，当前端发送一个登录操作的URL给后端时，后端就会根据登录来造登录的对象，再通过对象调用相应方法实现登录操作；前端发送注册操作的URL给后端，后端就造注册的对象，再调用相应方法实现注册。我们运行时才知道造哪个类的对象，这就需要用到反射了。</p><h3 id="②反射概述"><a href="#②反射概述" class="headerlink" title="②反射概述"></a>②反射概述</h3><h4 id="A-Java是准动态语言"><a href="#A-Java是准动态语言" class="headerlink" title="A.Java是准动态语言"></a>A.Java是准动态语言</h4><p>​反射具有动态的特性，从而让Java有了一定的动态性，所以Java属于准动态语言。</p><h4 id="B-反射提供的功能"><a href="#B-反射提供的功能" class="headerlink" title="B.反射提供的功能"></a>B.反射提供的功能</h4><ul><li>在运行时判断任意一个对象所属的类</li><li>在运行时构造任意一个类的对象</li><li>在运行时判断任意一个类所具有的成员变量和方法</li><li>在运行时获取泛型信息</li><li>在运行时调用任意一个对象的成员变量和方法</li><li>在运行时处理注解</li><li>生成动态代理</li></ul><h4 id="C-相关主要API"><a href="#C-相关主要API" class="headerlink" title="C.相关主要API"></a>C.相关主要API</h4><ul><li>java.lang.Class:代表一个类</li><li>java.lang.reflect.Method:代表类的方法</li><li>java.lang.reflect.Field:代表类的成员变量</li><li>java.lang.reflect.Constructor:代表类的构造器</li></ul><p>注：如果用到了最后三个API，需要导包</p><h3 id="③关于java-lang-Class类的理解"><a href="#③关于java-lang-Class类的理解" class="headerlink" title="③关于java.lang.Class类的理解"></a>③关于java.lang.Class类的理解</h3><p>​任何的反射操作都要先造Class类的对象，所以Class类被称为反射源。</p><h4 id="A-类的加载过程"><a href="#A-类的加载过程" class="headerlink" title="A.类的加载过程"></a>A.类的加载过程</h4><p>​程序经过javac.exe命令后，会生成一个或多个字节码文件（.class结尾，一个类对应一个字节码文件）。<br>​接着使用java.exe命令对某个字节码文件进行解释运行。相当于将某个字节码文件加载到内存中。此过程就称为<strong>类的加载</strong>。加载到内存中的类，称为<strong>运行时类</strong>，此运行时类，就作为<strong>class的一个实例</strong>。</p><p>​换句话说，<strong>Class的实例就对应着一个运行时类</strong>。</p><h4 id="B-获取Class的实例的方式（前三种方式需要掌握）"><a href="#B-获取Class的实例的方式（前三种方式需要掌握）" class="headerlink" title="B.获取Class的实例的方式（前三种方式需要掌握）"></a>B.获取Class的实例的方式（前三种方式需要掌握）</h4><p>​Class是一个泛型类，在声明时可以指明其泛型类型，指明后就可以在后续操作中不用强转。</p><ol><li><p>方式一：调用运行时类的属性：.class</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz1</span> <span class="operator">=</span> Person.class;</span><br></pre></td></tr></table></figure></li><li><p>方式二：通过运行时类的对象，调用getClass()</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz2</span> <span class="operator">=</span> p1.getClass();</span><br><span class="line"><span class="comment">//getClass()：获取该对象是由哪个类造的</span></span><br></pre></td></tr></table></figure></li><li><p>方式三：调用Class的静态方法：forName(String classPath)</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz3</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.atguigu.java.Person&quot;</span>);</span><br><span class="line"><span class="comment">//该方法会抛异常</span></span><br><span class="line"><span class="comment">//这种创建方式体现了反射的动态性</span></span><br></pre></td></tr></table></figure><p>   classPath：被称为全类名，即：写出该类是属于哪个包下的类</p><p>   这种方式在开发中<strong>使用频率最高</strong>。</p></li><li><p>方式四(了解)：使用类的加载器：ClassLoader</p></li></ol>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">ClassLoader classLoaser = </span></span><br><span class="line"><span class="comment">当前写代码的类的类名.class.getClassLoader();</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz4</span> <span class="operator">=</span> classLoader.loadClass(<span class="string">&quot;要加载的类的全类名&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="C-注意"><a href="#C-注意" class="headerlink" title="C.注意"></a>C.注意</h4><p>​以上四个Class类的对象都是指向同一个运行时类（Person）。</p><h4 id="D-补充（了解）"><a href="#D-补充（了解）" class="headerlink" title="D.补充（了解）"></a>D.补充（了解）</h4><p>​<img src="/imgs/image-20220908121533209-1682331826605.png" alt="image-20220908121533209"></p><p>​例子：</p><p><img src="/imgs/image-20220908121637256-1682331826605.png" alt="image-20220908121637256"></p><h4 id="E-类的加载器"><a href="#E-类的加载器" class="headerlink" title="E.类的加载器"></a>E.类的加载器</h4><p>​类的加载器的作用：将class文件字节码内容加载到内存中，然后在堆中生成一个Class类的实例。</p><p>​<strong>类的加载器的分类</strong>：（了解）</p><ul><li>(Bootstap Classloader)<strong>引导类加载器</strong>：是JVM自带的类加载器，负责Java平台核心库，用来装载核心类库中的类。该加载器无法直接获取。</li><li>(Extension Classloader)<strong>扩展类加载器</strong>：负责jre&#x2F;lib&#x2F;ext目录下的jar包或 –D java.ext.dirs 指定目录下的jar包装入工作库。jar包：将class文件打包</li><li>(System Classloader)<strong>系统类加载器</strong>：负责加载自定义类</li></ul><h3 id="④创建运行时类的对象"><a href="#④创建运行时类的对象" class="headerlink" title="④创建运行时类的对象"></a>④创建运行时类的对象</h3><p>用<strong>Class</strong>类的对象去调用<strong>newIstance()<strong>方法（</strong>该方法会抛异常</strong>），该方法内部调用了运行时类的空参构造器。要想此方法正常的创建运行时类的对象，要求：</p><ul><li>运行时类必须提供空参的构造器</li><li>空参的构造器的权限修饰符要大于private。通常，设置为public。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;<span class="comment">//clazz指向了方法区中的Person类，因此造对象的时候也只能造Person类的对象，不能造其他类的对象。</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> (Person)o;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果在创建Class类的对象时指明泛型类型，就可以省略第3行代码</span></span><br><span class="line">Class&lt;Person&gt; clazz1 = Person.class;</span><br><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> clazz1.newInstance();<span class="comment">//直接返回Person类的对象。</span></span><br></pre></td></tr></table></figure><p>​如果想调用带参数的构造器也是可以的，表不过通常都是调用空参的构造器。</p><h3 id="⑤体会反射的动态性"><a href="#⑤体会反射的动态性" class="headerlink" title="⑤体会反射的动态性"></a>⑤体会反射的动态性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> num=<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">3</span>);</span><br><span class="line">String classPath=<span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">switch</span>(num)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">classPath=<span class="string">&quot;java.util.Date&quot;</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">classPath=<span class="string">&quot;java.lang.Object&quot;</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">classPath=<span class="string">&quot;com.attang.java.Person&quot;</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">Object obj=getInstance(classPath);</span><br><span class="line">System.out.println(obj);</span><br><span class="line"></span><br><span class="line">Public Object <span class="title function_">getInstance</span><span class="params">(String classPath)</span></span><br><span class="line">&#123;</span><br><span class="line">Class clazz=Class.forName(classPath);</span><br><span class="line"><span class="keyword">return</span> class.newInstance();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​<strong>只有在运行时才能确定造的是哪个对象。</strong></p><h3 id="⑥获取运行时类的完整结构（了解）"><a href="#⑥获取运行时类的完整结构（了解）" class="headerlink" title="⑥获取运行时类的完整结构（了解）"></a>⑥获取运行时类的完整结构（了解）</h3><h4 id="A-获取属性结构"><a href="#A-获取属性结构" class="headerlink" title="A.获取属性结构"></a>A.获取属性结构</h4><p>​通过Class类的对象去调用。</p><p>​getFields()：获取当前运行时类及其父类中声明为public访问权限的属性。</p><p>​getDeclaredFields()：获取当前运行时类中声明的所有属性。（不包括父类中声明的属性）</p><p>​拿到一个属性后，我们还可以获取当前属性的数据类型、权限修饰符、属性名等信息。</p><h4 id="B-获取方法结构"><a href="#B-获取方法结构" class="headerlink" title="B.获取方法结构"></a>B.获取方法结构</h4><p>​通过Class类的对象去调用。</p><p>​getMethods()：获取当前运行时类及其所有父类中声明为public权限的方法</p><p>​getDeclaredMethods()：获取当前运行时类中声明的所有方法。（不包含父类中声明的方法）</p><p>​获取到具体的一个方法之后，我们可以接着获取该方法的权限修饰符、返回值类型、方法名、形参列表、注解、抛出异常类型。</p><h4 id="C-获取构造器结构"><a href="#C-获取构造器结构" class="headerlink" title="C.获取构造器结构"></a>C.获取构造器结构</h4><p>​通过Class类的对象去调用。</p><p>​getConstructors()：获取当前运行时类中声明为public的构造器。（不包括父类中的构造器）</p><p>​getDeclaredConstructors()：获取当前运行时类中声明的所有构造器。（不包括父类中的构造器）</p><h4 id="D-获取运行时类的父类"><a href="#D-获取运行时类的父类" class="headerlink" title="D.获取运行时类的父类"></a>D.获取运行时类的父类</h4><p>​通过Class类的对象去调用。</p><p>​getSuperclass()：获取当前运行类的父类</p><p>​getGenericSuperclass()：获取当前运行类的父类（带泛型的父类）</p><h4 id="E-获取当前运行时类的父类的泛型"><a href="#E-获取当前运行时类的父类的泛型" class="headerlink" title="E.获取当前运行时类的父类的泛型"></a>E.获取当前运行时类的父类的泛型</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line"><span class="type">Type</span> <span class="variable">genericSuperclass</span> <span class="operator">=</span> clazz.getGenericSuperclass();</span><br><span class="line"><span class="type">ParameterizedType</span> <span class="variable">paramType</span> <span class="operator">=</span> (ParameterizedType)genericSuperclass;</span><br><span class="line">Type[] actualTypeArguments = paramType.getActualTypeArguments();</span><br><span class="line">System.out.print(actualTypeArguments[<span class="number">0</span>].getTypeName());</span><br></pre></td></tr></table></figure><h4 id="F-获取当前运行时类实现的接口"><a href="#F-获取当前运行时类实现的接口" class="headerlink" title="F.获取当前运行时类实现的接口"></a>F.获取当前运行时类实现的接口</h4><p>​通过Class类的对象去调用。</p><p>​getInterfaces()：获取当前运行时类实现的接口（不包括父类的接口，要想获取父类实现的接口，就先得获取父类，再接着调用getInterfaces()）</p><h4 id="G-获取当前运行时类所在的包"><a href="#G-获取当前运行时类所在的包" class="headerlink" title="G.获取当前运行时类所在的包"></a>G.获取当前运行时类所在的包</h4><p>​通过Class类的对象去调用。</p><p>​getPackage()：获取当前运行时类所在的包</p><h4 id="H-获取运行时类声明的注解"><a href="#H-获取运行时类声明的注解" class="headerlink" title="H.获取运行时类声明的注解"></a>H.获取运行时类声明的注解</h4><p>​通过Class类的对象去调用。</p><p>​getAnnotations()：读取当前运行时类的注解</p><h4 id="需要重点了解的是"><a href="#需要重点了解的是" class="headerlink" title="需要重点了解的是"></a>需要重点了解的是</h4><p>​E、F、H</p><hr><h3 id="⑦调用运行时类的指定结构"><a href="#⑦调用运行时类的指定结构" class="headerlink" title="⑦调用运行时类的指定结构"></a>⑦调用运行时类的指定结构</h3><p>​这里我们重点关注：属性、方法、构造器</p><h4 id="A-如何操作运行时类中指定的属性"><a href="#A-如何操作运行时类中指定的属性" class="headerlink" title="A.如何操作运行时类中指定的属性"></a>A.如何操作运行时类中指定的属性</h4><p>​实现步骤：</p><ol><li>造Class类的对象</li><li>创建运行时类的对象</li><li>用Class类的对象去调用getDeclaredField(String fieldName)，获取运行时类中指定变量名的属性（注意：<strong>获取不了父类中的属性</strong>）</li><li>用获取到的属性调用setAccessible(true)方法，保证当前属性是可访问的（如果不调用该方法，就不能对声明为private的属性进行赋值或获取操作）</li><li>用获取到的属性调用set(Object obj,Object value)实现赋值操作，调用get(Object   obj)实现获取属性值操作。其中：obj为要对哪个对象进行操作，value：属性值要设置多少</li></ol><p>补充：<strong>如果获取的是静态的属性</strong>，则将步骤2去掉，步骤5中的obj写null或“当前运行时类.class”</p><p>​代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="comment">//1.声明Class类的对象</span></span><br><span class="line">    Class&lt;Person&gt; clazz = (Class&lt;Person&gt;) Class.forName(<span class="string">&quot;com.zzc.javatest.Person&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.创建运行时类的对象</span></span><br><span class="line">    <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.获取运行时类中指定变量名的属性</span></span><br><span class="line">    <span class="type">Field</span> <span class="variable">des</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.对获取到的属性进行赋值或获取操作</span></span><br><span class="line">    des.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    des.set(person,<span class="number">1001</span>);</span><br><span class="line">    System.out.println(des.get(person));</span><br><span class="line">    </span><br><span class="line"> <span class="comment">//第三行代码为什么需要强转？因为该forName方法本身返回的是Class&lt;?&gt;类型数据，而clazz是Class&lt;Person&gt;类型，所有就需要强转。Class&lt;?&gt;是Class&lt;Person&gt;的父类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="B-如何操作运行时类中指定的方法"><a href="#B-如何操作运行时类中指定的方法" class="headerlink" title="B.如何操作运行时类中指定的方法"></a>B.如何操作运行时类中指定的方法</h4><p>​<strong>调用非静态的方法</strong>：</p><p>​实现步骤：</p><ol><li>造Class的实例</li><li>造运行时类的对象</li><li>用Class类的对象去调用getDeclareMethod(String methodName,方法的形参列表)，参数1：指明获取的方法的名称，参数2：指明获取的方法的形参列表，没有就不用写，有则这样写：“数据类型.class”</li><li>用获取到的方法调用setAccessible(true)，保证当前方法是可访问的</li><li>调用方法的invoke()：参数1：方法的调用者，参数2：实参，invoke()的返回值即为对应类中调用的方法的返回值。如果没有返回值，则返回的是null。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="comment">//1.</span></span><br><span class="line">    Class&lt;Person&gt; clazz = (Class&lt;Person&gt;) Class.forName(<span class="string">&quot;com.zzc.javatest.Person&quot;</span>);</span><br><span class="line">    <span class="comment">//2.</span></span><br><span class="line">    <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line">    <span class="comment">//3.</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">show</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;show&quot;</span>);</span><br><span class="line">    <span class="comment">//4.</span></span><br><span class="line">    show.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">//5.</span></span><br><span class="line">    show.invoke(person);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​<strong>调用静态的方法</strong>：</p><p>​<strong>实现步骤</strong>：</p><ol><li>造Class的实例</li><li>用Class类的对象去调用getDeclareMethod(String methodName,方法的形参列表)，参数1：指明获取的方法的名称，参数2：指明获取的方法的形参列表，没有就不用写</li><li>用获取到的方法调用setAccessible(true)，保证当前方法是可访问的</li><li>调用方法的invoke()：参数1：null或“当前运行时类.class”，参数2：实参，invoke()的返回值即为对应类中调用的方法的返回值。如果没有返回值，则返回的是null。</li></ol><h4 id="C-如何调用运行时类中指定的构造器"><a href="#C-如何调用运行时类中指定的构造器" class="headerlink" title="C.如何调用运行时类中指定的构造器"></a>C.如何调用运行时类中指定的构造器</h4><p>​<strong>实现步骤</strong>：</p><ol><li>造Class的实例</li><li>用Class的对象去调用getDeclaredConstructor()：参数：指明构造器的参数列表，写参数的时候要这样写：“数据类型.class”。该方法会抛异常。</li><li>用获取到的构造器去调用setAccessible(true)，保证此构造器是可访问的</li><li>调用此构造器创建运行时类的对象，使用newInstance(实参)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="comment">//1.</span></span><br><span class="line">    Class&lt;Person&gt; clazz = (Class&lt;Person&gt;) Class.forName(<span class="string">&quot;com.zzc.javatest.Person&quot;</span>);</span><br><span class="line">    <span class="comment">//2.</span></span><br><span class="line">    Constructor&lt;Person&gt; constructor = clazz.getDeclaredConstructor(String.class, <span class="type">int</span>.class);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.</span></span><br><span class="line">    constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">//4.</span></span><br><span class="line">    <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> constructor.newInstance(<span class="string">&quot;Tom&quot;</span>, <span class="number">12</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="⑧反射应用–动态代理"><a href="#⑧反射应用–动态代理" class="headerlink" title="⑧反射应用–动态代理"></a>⑧反射应用–动态代理</h3><h4 id="①概述-11"><a href="#①概述-11" class="headerlink" title="①概述"></a>①概述</h4><p>​<strong>代理模式</strong>：通过代理类的对象来间接调用被代理类中的方法。</p><p>​<strong>代理模式的具体实现</strong>：代理类和被代理类都实现同一个（堆）接口，然后通过代理类的对象来调用方法，如：show()方法，当调用该方法时，实际上调用的是被代理类里的show()方法。从而实现间接操作被代理中的方法。</p><p>​<strong>动态代理</strong>：接口、被代理类要先造好，而代理类是动态创建。</p><h4 id="②静态代理实现"><a href="#②静态代理实现" class="headerlink" title="②静态代理实现"></a>②静态代理实现</h4><p>​见：笔记12、面向对象中的其他关键字 —&gt; interface –&gt; ⑦</p><h4 id="③动态代理实现"><a href="#③动态代理实现" class="headerlink" title="③动态代理实现"></a>③动态代理实现</h4><p>​基础阶段先了解，到框架部分再深入</p><hr><h2 id="10、Java8的一些新特性"><a href="#10、Java8的一些新特性" class="headerlink" title="10、Java8的一些新特性"></a>10、Java8的一些新特性</h2><h3 id="①概述-12"><a href="#①概述-12" class="headerlink" title="①概述"></a>①概述</h3><p>​java8：</p><ul><li>速度更快</li><li>代码更少(增加了新的语法：Lambda 表达式)</li><li>强大的 Stream API</li><li>便于并行</li><li>最大化减少空指针异常：Optional</li><li>Nashorn引擎，允许在JVM上运行JS应用</li></ul><h3 id="②Lambda表达式"><a href="#②Lambda表达式" class="headerlink" title="②Lambda表达式"></a>②Lambda表达式</h3><h4 id="A-Lambda表达式的举例"><a href="#A-Lambda表达式的举例" class="headerlink" title="A.Lambda表达式的举例"></a>A.Lambda表达式的举例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(o1,o2) -&gt; Integer.compare(o1,o2);</span><br></pre></td></tr></table></figure><h4 id="B-格式"><a href="#B-格式" class="headerlink" title="B.格式"></a>B.格式</h4><p>​-&gt; ：Lambda操作符 或 箭头操作符</p><p>​操作符左边：Lambda形参列表（其实就是接口中的抽象方法的形参列表）</p><p>​操作符右边：Lambda体（其实就是重写的抽象方法的方法体）</p><h4 id="C-Lambda表达式的使用"><a href="#C-Lambda表达式的使用" class="headerlink" title="C.Lambda表达式的使用"></a>C.Lambda表达式的使用</h4><p>​Lambda表达式的本质：函数式接口的匿名实现类的对象。</p><p>​总结：</p><ol><li>操作符左边：Lambda形参列表的参数类型可以省略（类型推断）；如果Lambda形参列表只有一个参数，其一对（）也可以省略。</li><li>操作符右边：Lambda体应该使用一对{ }包裹：如果Lambda体只有一条执行语句（可能是return语句），可以省略这一对{}和return关键字（如果省略{ }，则return必须一起省略）。</li></ol><h4 id="D-注意"><a href="#D-注意" class="headerlink" title="D.注意"></a>D.注意</h4><p>​Lambda表达式使用前提是：只能使用在接口，且该接口只能是函数式接口（即该接口里只有一个抽象方法）</p><h4 id="E-应用场景"><a href="#E-应用场景" class="headerlink" title="E.应用场景"></a>E.应用场景</h4><p>​当函数式接口要创建一个匿名实现类的对象时，我们就可以使用Lambda表达式了。</p><hr><h3 id="③函数式接口"><a href="#③函数式接口" class="headerlink" title="③函数式接口"></a>③函数式接口</h3><h4 id="A-定义"><a href="#A-定义" class="headerlink" title="A.定义"></a>A.定义</h4><p>​接口中只有一个抽象方法的接口，称为函数式接口。</p><p>​我们可以在一个接口上使用 @FunctionalInterface 注解，这样做可以检查它是否是一个函数式接口。</p><h4 id="B-Java内置四大核心函数式接口"><a href="#B-Java内置四大核心函数式接口" class="headerlink" title="B.Java内置四大核心函数式接口"></a>B.Java内置四大核心函数式接口</h4><p><img src="/imgs/image-20220910134838862-1682331876508.png" alt="image-20220910134838862"></p><p><img src="/imgs/image-20220910142024000-1682331876509.png" alt="image-20220910142024000"></p><p>​以后当见到上面的函数式接口时，我们都可以使用Lambda表达式来造函数式接口的实现类对象。</p><h4 id="C-如何使用给定的函数式接口"><a href="#C-如何使用给定的函数式接口" class="headerlink" title="C.如何使用给定的函数式接口"></a>C.如何使用给定的函数式接口</h4><p>​如果我们开发中需要定义一个函数式接口，首先看看在已有的jdk提供的函数式接口是否提供了能满足需求的函数式接口。如果有，则直接调用即可，不需要自己再定义了。</p><hr><h3 id="④方法引用"><a href="#④方法引用" class="headerlink" title="④方法引用"></a>④方法引用</h3><h4 id="A-使用情景"><a href="#A-使用情景" class="headerlink" title="A.使用情景"></a>A.使用情景</h4><p>​当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用。即：当Lambda体中只有一条语句，且这条语句是：通过对象或类调用了某个方法，像这种情况，我们就可以考虑使用方法引用了，具体能不能使用得看方法引用的使用规则。</p><p>​方法引用，本质上就是Lambda表达式，而Lambda表达式作为函数式接口的实例。所以方法引用，也就是函数式接口的实例。</p><h4 id="B-格式-1"><a href="#B-格式-1" class="headerlink" title="B.格式"></a>B.格式</h4><p>​格式：类（或对象） :: 方法名</p><p>​具体可以分成如下三种情况：</p><ol><li><p>对象 :: 非静态方法</p></li><li><p>类 :: 静态方法</p></li><li><p>类 :: 非静态方法</p><p> 以上的方法只写方法名，不用写形参</p></li></ol><h4 id="C-方法引用使用规则"><a href="#C-方法引用使用规则" class="headerlink" title="C.方法引用使用规则"></a>C.方法引用使用规则</h4><ul><li>当Lambda体中调用的方法的形参列表和返回值类型与接口中的抽象方法的形参列表和返回值类型相同时，我们就可以使用格式中情况1或情况2来写方法引用，具体选哪个？<ul><li>当Lambda体中调用的方法为静态方法，则使用格式中的情况2来写方法引用。</li><li>当Lambda体中调用的方法为非静态方法，则使用格式中的情况1来写方法引用。</li></ul></li><li>当Lambda体中调用的方法属于非静态时，选择情况1还是选择情况3呢？<ul><li>当抽象方法中的形参为两个（t1,t2），而Lambda体中调用的方法的形参只有一个（t2）而t1作为方法引用的方法的调用者时，我们选择格式中的情况3。</li><li>当抽象方法中的形参为一个（t1），而Lambda体中调用的方法的形参为0个，而t1作为方法引用的方法的调用者时，我们选择格式中的情况3。</li></ul></li></ul><h4 id="D-具体举例"><a href="#D-具体举例" class="headerlink" title="D.具体举例"></a>D.具体举例</h4><p>​①对象 :: 非静态方法</p><p>​例一：</p><p>​<img src="/imgs/2021011516393733.png" alt="在这里插入图片描述"></p><p>​例二：</p><p><img src="/imgs/20210115165554334.png" alt="在这里插入图片描述"></p><p>​②类::静态方法名</p><p>​例一：</p><p><img src="/imgs/20210115170257876.png" alt="在这里插入图片描述"></p><p>​例二：</p><p><img src="/imgs/20210115170516947.png" alt="在这里插入图片描述"></p><p>​③类::实例方法名</p><p>​第一个参数作为方法的调用者。</p><p>​例一：</p><p><img src="/imgs/20210115171750232.png" alt="在这里插入图片描述"></p><p>​例二：</p><p><img src="/imgs/20210115171858864.png" alt="在这里插入图片描述"></p><p>​最后一句写错了，是pre2</p><p>​例三：</p><p><img src="/imgs/20210115172037108.png" alt="在这里插入图片描述"></p><hr><h3 id="⑤构造器引用"><a href="#⑤构造器引用" class="headerlink" title="⑤构造器引用"></a>⑤构造器引用</h3><h4 id="A-概述-1"><a href="#A-概述-1" class="headerlink" title="A.概述"></a>A.概述</h4><p>​如果Lambda体中只有一条语句且该语句属于创建对象的语句，那么就可以考虑使用构造器引用，具体能不能使用得看看是否符合构造器引用规则。</p><h4 id="B-格式-2"><a href="#B-格式-2" class="headerlink" title="B.格式"></a>B.格式</h4><p>​类名 :: new</p><h4 id="C-构造器引用规则"><a href="#C-构造器引用规则" class="headerlink" title="C.构造器引用规则"></a>C.构造器引用规则</h4><p>​函数式接口的抽象方法的形参列表和构造器的形参列表一致。抽象方法的返回值类型即为构造器所属的类的类型。</p><h4 id="D-例子"><a href="#D-例子" class="headerlink" title="D.例子"></a>D.例子</h4><p>​例一：</p><p><img src="/imgs/20210115172827686.png" alt="在这里插入图片描述"></p><p>​例二：</p><p><img src="/imgs/20210115172800444.png" alt="在这里插入图片描述"></p><p>​例三：</p><p><img src="/imgs/20210115172940482.png" alt="在这里插入图片描述"></p><hr><h3 id="⑥数组引用（？）"><a href="#⑥数组引用（？）" class="headerlink" title="⑥数组引用（？）"></a>⑥数组引用（？）</h3><p>​当Lambda体中只有一条语句且该语句属于创建数组的语句，像这种情况，我们就可以使用数组引用。</p><h4 id="A-格式"><a href="#A-格式" class="headerlink" title="A.格式"></a>A.格式</h4><p>​数组类型[ ] :: new</p><h4 id="B-使用"><a href="#B-使用" class="headerlink" title="B.使用"></a>B.使用</h4><p>​大家可以把数组看做是一个特殊的类，则写法与构造器引用一致。</p><p><img src="/imgs/20210115173412647.png" alt="在这里插入图片描述"></p><hr><h2 id="11、Java8新特性—Stream-API"><a href="#11、Java8新特性—Stream-API" class="headerlink" title="11、Java8新特性—Stream API"></a>11、Java8新特性—Stream API</h2><h3 id="A-概述-2"><a href="#A-概述-2" class="headerlink" title="A.概述"></a>A.概述</h3><ol><li><p>Stream是用来对集合中的数据进行计算操作的API，与CPU打交道</p><p> 集合关注的是数据的存储，与内存打交道</p></li><li><p>为什么需要Stream API？</p><p> 通常像MySQL这些数据库属于强关系数据库，对数据的过滤操作（如：查询大于3的数据）都是在数据库中完成的，而像Radis、MongDB这些弱关系数据库，则需要在Java层面实现数据的过滤操作。</p></li><li><p><strong>注意</strong></p><ul><li>Stream 自己不会存储元素。</li><li>Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。</li><li>Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。</li></ul></li><li><p><strong>Stream执行流程</strong></p><p> ①Stream的实例化</p><p> ②一系列的中间操作（过滤、映射….）</p><p> ③终止操作</p></li><li><p><strong>说明</strong></p><ul><li>中间操作：一个中间操作链，对数据源的数据进行处理</li><li>终止操作(终端操作) ：一旦执行终止操作，就执行中间操作链，并产生结果。之后，<strong>Stram对象就不能再被使用。如果还想执行操作，得重新造Stream对象</strong>。</li></ul></li></ol><h3 id="B-Stream实例化"><a href="#B-Stream实例化" class="headerlink" title="B.Stream实例化"></a>B.Stream实例化</h3><h4 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h4><p>​<strong>通过集合创建</strong></p><p>​<strong>A</strong>.调用集合Collection中默认方法stream()来实例化</p><p>​①先造Collection的实现类的对象</p><p>​②通过上面造的对象调用stream()方法，该方法返回一个顺序流（读取到的数据顺序与集合中存储数据的顺序一样）</p><p>​<strong>B</strong>.调用集合Collection中默认方法parallelStream()来实例化</p><p>​①先造Collection的实现类的对象</p><p>​②通过上面造的对象调用stream()方法，该方法返回一个并行流。（相当于用多个线程同时对集合中的数据进行读取）</p><h4 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h4><p>​<strong>通过数组</strong></p><p>​调用<strong>Arrays</strong>里的静态方法**stream()**，把数组放到方法的形参中，返回一个stream对象</p><h4 id="方式三"><a href="#方式三" class="headerlink" title="方式三"></a>方式三</h4><p>​通过Stream的of()方法，通过显示值创建一个流，它可以接收任意数量任意类型的参数。</p><p>​public static&lt; T &gt; Stream&lt; T &gt; of(T… values) : 返回一个流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream = Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>​该方法适用于：<strong>现造现用</strong>的情况</p><h4 id="方法四（了解）"><a href="#方法四（了解）" class="headerlink" title="方法四（了解）"></a>方法四（了解）</h4><p>​创建无限流</p><p>​可以使用静态方法 Stream.iterate() 和 Stream.generate(), 创建无限流。</p><hr><h3 id="C-中间操作–筛选与切片"><a href="#C-中间操作–筛选与切片" class="headerlink" title="C.中间操作–筛选与切片"></a>C.中间操作–筛选与切片</h3><h4 id="①filter-Predicate-p"><a href="#①filter-Predicate-p" class="headerlink" title="①filter(Predicate p)"></a>①filter(Predicate p)</h4><p>​该方法的作用：从集合中排除某些元素，返回一个新的Stream对象</p><p>​实现：</p><p>​①用Stream的对象去调用filter()方法</p><p>​②在该方法的形参里放Predicate接口的匿名实现类的对象（可以选择用Lambda表达式表示）</p><p>​③在Predicate 接口的抽象方法test里写具体的过滤操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list1.add(<span class="number">1</span>);</span><br><span class="line">    list1.add(<span class="number">2</span>);</span><br><span class="line">    list1.add(<span class="number">3</span>);</span><br><span class="line">    list1.add(<span class="number">4</span>);</span><br><span class="line"><span class="comment">//1.Stream的实例化</span></span><br><span class="line">    Stream&lt;Integer&gt; stream = list1.stream();</span><br><span class="line"><span class="comment">//2.调用filter</span></span><br><span class="line">    stream.filter(<span class="keyword">new</span> <span class="title class_">Predicate</span>&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(Integer integer)</span> &#123;</span><br><span class="line">            <span class="comment">//3.写过滤条件</span></span><br><span class="line">            <span class="keyword">return</span> integer &gt; <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).forEach(System.out::println);</span><br><span class="line">    <span class="comment">//上面的写法可以改成用Lambda表达式写</span></span><br><span class="line"> <span class="comment">//stream.filter(integer -&gt; integer &gt; 2).forEach(System.out::println);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//运行结果为：3 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="②limit-n"><a href="#②limit-n" class="headerlink" title="②limit(n)"></a>②limit(n)</h4><p>​截断流，使其元素不超过给定数量。即：从容器的开始端读取n个数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stream.limit(<span class="number">3</span>).forEach(System.out::println);<span class="comment">//1，2，3</span></span><br></pre></td></tr></table></figure><h4 id="③skip-n"><a href="#③skip-n" class="headerlink" title="③skip(n)"></a>③skip(n)</h4><p>​跳过元素，返回一个扔掉了前n个元素的流。若流中元素不足n个，则返回一个空流。与limit(n)互补。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stream.skip(<span class="number">3</span>).forEach(System.out::println);<span class="comment">//4</span></span><br></pre></td></tr></table></figure><h4 id="④distinct"><a href="#④distinct" class="headerlink" title="④distinct()"></a>④distinct()</h4><p>​筛选，通过流所生成元素的hasCode() 和 equals() 去除重复元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list1.add(<span class="number">1</span>);</span><br><span class="line">list1.add(<span class="number">2</span>);</span><br><span class="line">list1.add(<span class="number">3</span>);</span><br><span class="line">list1.add(<span class="number">4</span>);</span><br><span class="line">list1.add(<span class="number">4</span>);</span><br><span class="line">Stream&lt;Integer&gt; stream = list1.stream();</span><br><span class="line">stream.distinct().forEach(System.out::println);<span class="comment">//1，2，3，4</span></span><br></pre></td></tr></table></figure><h3 id="D-中间操作–映射"><a href="#D-中间操作–映射" class="headerlink" title="D.中间操作–映射"></a>D.中间操作–映射</h3><h4 id="①map-Function-f"><a href="#①map-Function-f" class="headerlink" title="①map(Function f)"></a>①map(Function f)</h4><p>​map(Function f)：依次遍历Stream里的每一个元素，然后按照映射规则对元素进行操作。</p><p>​实现：</p><p>​①Stream对象调用map方法，往map方法的形参中传入实现Function接口的实现类的对象。</p><p>​②在Function接口的抽象方法中写映射的规则</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"> list1.add(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line"> list1.add(<span class="string">&quot;bb&quot;</span>);</span><br><span class="line"> list1.add(<span class="string">&quot;cc&quot;</span>);</span><br><span class="line"> Stream&lt;String&gt; stream = list1.stream();</span><br><span class="line"> stream.map(<span class="keyword">new</span> <span class="title class_">Function</span>&lt;String, Object&gt;() &#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> Object <span class="title function_">apply</span><span class="params">(String string)</span> &#123;</span><br><span class="line">         <span class="comment">//映射规则</span></span><br><span class="line">         <span class="keyword">return</span> string.toUpperCase();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;).forEach(System.out::println);</span><br><span class="line"><span class="comment">//将6-12行代码用Lambda表达式表示</span></span><br><span class="line"><span class="comment">//stream.map(str -&gt; str.toUpperCase()).forEach(System.out::println);</span></span><br><span class="line"><span class="comment">//运行结果：AA,BB,CC</span></span><br></pre></td></tr></table></figure><h4 id="②flatMap-Function-f-不会"><a href="#②flatMap-Function-f-不会" class="headerlink" title="②flatMap(Function f)     不会"></a>②flatMap(Function f)     不会</h4><p>​将流中的每个值都换成另一个流，然后把所有流连接成一个流</p><h3 id="E-中间操作–排序"><a href="#E-中间操作–排序" class="headerlink" title="E.中间操作–排序"></a>E.中间操作–排序</h3><p>​对集合或数组中的元素进行排序操作</p><h4 id="①sorted-自然排序"><a href="#①sorted-自然排序" class="headerlink" title="①sorted()  自然排序"></a>①sorted()  自然排序</h4><p>​使用要求：集合中的元素或数组中的元素所在类要实现Comparable接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    ArrayList&lt;Person&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">12</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jerry&quot;</span>,<span class="number">22</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jack&quot;</span>,<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    list.stream().sorted().forEach(System.out::println);</span><br><span class="line">    <span class="comment">//sorted方法实际上调用的是Person类里的compareTo方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="②sorted-Comparator-com-定制排序"><a href="#②sorted-Comparator-com-定制排序" class="headerlink" title="②sorted(Comparator com)  定制排序"></a>②sorted(Comparator com)  定制排序</h4><p>​参数里放实现了Comparator接口的实现类的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    ArrayList&lt;Person&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">12</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jerry&quot;</span>,<span class="number">22</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jack&quot;</span>,<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//定制排序</span></span><br><span class="line">    list.stream().sorted(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Person&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Person o1, Person o2)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> o1.getName().compareTo(o2.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//如果使用Lambda表达式则这样写：</span></span><br><span class="line"><span class="comment">//list.stream().sorted(((o1, o2) -&gt; o1.getName().compareTo(o2.getName()))).forEach(System.out::println);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="F-终结操作–匹配与查找"><a href="#F-终结操作–匹配与查找" class="headerlink" title="F.终结操作–匹配与查找"></a>F.终结操作–匹配与查找</h3><h4 id="①allMatch-Predicate-p"><a href="#①allMatch-Predicate-p" class="headerlink" title="①allMatch(Predicate p)"></a>①allMatch(Predicate p)</h4><ul><li>判断集合中或数组中的元素是否都满足Predicate接口中抽象方法里的操作，只有都返回true，allMatch才返回true。</li><li>匹配规则写在Predicate接口中的抽象方法里。</li></ul><h4 id="②anyMatch-Predicate-p"><a href="#②anyMatch-Predicate-p" class="headerlink" title="②anyMatch(Predicate p)"></a>②anyMatch(Predicate p)</h4><ul><li>判断集合或数组中的元素是否满足Predicate接口中的抽象方法里的匹配规则，只要有一个元素满足，则返回true。</li><li>匹配规则写在Predicate接口中的抽象方法里。</li></ul><h4 id="③noneMatch-Predicate-p"><a href="#③noneMatch-Predicate-p" class="headerlink" title="③noneMatch(Predicate p)"></a>③noneMatch(Predicate p)</h4><ul><li>检查数组或集合中是否没有匹配的元素，返回布偶值。</li><li>匹配规则写在Predicate接口中的抽象方法里。</li></ul><h4 id="④findFirst"><a href="#④findFirst" class="headerlink" title="④findFirst()"></a>④findFirst()</h4><ul><li>返回当前Stream里的第一个元素。</li></ul><h4 id="⑤findAny"><a href="#⑤findAny" class="headerlink" title="⑤findAny()"></a>⑤findAny()</h4><ul><li>返回当前流中的任意一个元素。</li></ul><h4 id="⑥count"><a href="#⑥count" class="headerlink" title="⑥count()"></a>⑥count()</h4><ul><li>返回流中元素的个数。</li></ul><h4 id="⑦max-Comparator-c"><a href="#⑦max-Comparator-c" class="headerlink" title="⑦max(Comparator c)"></a>⑦max(Comparator c)</h4><ul><li>返回流中最大值，将比较的规则写在Comparator接口里的抽象方法中。</li><li>Comparator属于函数式接口，可以使用Lambda表达式。</li></ul><h4 id="⑧min-Comparator-c"><a href="#⑧min-Comparator-c" class="headerlink" title="⑧min(Comparator c)"></a>⑧min(Comparator c)</h4><ul><li>返回流中最小值，将比较的规则写在Comparator接口里的抽象方法中。</li><li>Comparator属于函数式接口，可以使用Lambda表达式。</li></ul><h4 id="⑨forEach-Consumer-c"><a href="#⑨forEach-Consumer-c" class="headerlink" title="⑨forEach(Consumer c)"></a>⑨forEach(Consumer c)</h4><ul><li><p>内部迭代，通常这样写：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">forEach(System.out::print);<span class="comment">//对流中的元素进行遍历输出</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="G-终结操作–规约"><a href="#G-终结操作–规约" class="headerlink" title="G.终结操作–规约"></a>G.终结操作–规约</h3><p>​规约：即求和操作</p><h4 id="①reduce-T-identity-BinaryOperator"><a href="#①reduce-T-identity-BinaryOperator" class="headerlink" title="①reduce(T identity,BinaryOperator)"></a>①reduce(T identity,BinaryOperator)</h4><p>​将流中的元素反复累加起来，得到一个值。相当于求和操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算1-10的自然数的和</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>);</span><br><span class="line">    <span class="comment">//reduce里的第一个参数为：累加的初始值</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">reduce</span> <span class="operator">=</span> list.stream().reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line">    <span class="comment">//Integer::sum含义：调用Integer里的sum方法</span></span><br><span class="line">    System.out.println(reduce);<span class="comment">//55</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="②reduce-BinaryOperator"><a href="#②reduce-BinaryOperator" class="headerlink" title="②reduce(BinaryOperator)"></a>②reduce(BinaryOperator)</h4><p>​将流中元素反复累加起来，得到一个值，返回Optional<T>。与上面的一样，只是少了一个参数identity来指定累加的初始值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算1-10的自然数的和</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">Integer</span> <span class="variable">reduce</span> <span class="operator">=</span> list.stream().reduce(Integer::sum);</span><br><span class="line">    <span class="comment">//Integer::sum含义：调用Integer里的sum方法</span></span><br><span class="line">    System.out.println(reduce);<span class="comment">//55</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="H-终结操作–收集"><a href="#H-终结操作–收集" class="headerlink" title="H.终结操作–收集"></a>H.终结操作–收集</h3><h4 id="①collect-Collector-c"><a href="#①collect-Collector-c" class="headerlink" title="①collect(Collector c)"></a>①collect(Collector c)</h4><p>​<strong>方法作用</strong>：将Stream里的数据存储到集合（List、Map、set）中，并返回对应集合的对象。</p><p>​Collector是接口，我们使用Collectors中的静态方法来返回一个Collector实现类的对象。</p><p>​如果想将Stream里的数据放到：</p><ul><li>放到List中，将“Collectors.toList()”放到形参中即可</li><li>放到Set中，将“Collectors.toSet()”放到形参中即可</li><li>放到Map中2，将“Collectors.toMap()”放到形参中即可</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>);</span><br><span class="line">    List&lt;Integer&gt; list1 = list.stream().filter(i -&gt; i &gt; <span class="number">5</span>).collect(Collectors.toList());</span><br><span class="line">    System.out.println(list1);<span class="comment">//[6, 7, 8, 9, 10]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="12、Java8新特性—Optional类"><a href="#12、Java8新特性—Optional类" class="headerlink" title="12、Java8新特性—Optional类"></a>12、Java8新特性—Optional类</h2><h3 id="①概述-13"><a href="#①概述-13" class="headerlink" title="①概述"></a>①概述</h3><p>​为了避免出现空指针异常的情况，我们引入了Optional类。 </p><p>​Optional&lt; T t &gt; 类(java.util.Optional) 是一个容器类，它可以将 t 的地址值赋给Optional的属性value，代表这个值存在。或者仅仅保存null，表示这个值不存在。原来用 null 表示一个值不存在，现在 Optional 可以更好的表达这个概念。并且可以避免空指针异常。</p><h3 id="②Optional类的方法"><a href="#②Optional类的方法" class="headerlink" title="②Optional类的方法"></a>②Optional类的方法</h3><h4 id="A-创建Optional类对象的方法"><a href="#A-创建Optional类对象的方法" class="headerlink" title="A.创建Optional类对象的方法"></a>A.创建Optional类对象的方法</h4><p>​→ Optional.of(T t) : 封装数据 t 生成Optional对象，并将数据 t 的地址值赋给Optional内部的value。要求 t 非空，否则报错  </p><p>​→ Optional.empty() : 创建了一个Optional对象，但其内部的value &#x3D; null。</p><p>​→ **Optional.ofNullable(T t)**：封装数据 t 并将数据 t 的地址值赋给Optional内部的value，生成Optional对象。不要求 t 非空。 </p><h4 id="B-常用方法"><a href="#B-常用方法" class="headerlink" title="B.常用方法"></a>B.常用方法</h4><ol><li><p><strong>T orElse(T t1)</strong>      —-&gt; 该方法与ofNullable(T t)搭配使用</p><ul><li>该方法通过Optional类的对象去调用，Optional内部封装的value值或 t1</li><li>如果的当前的Optional对象内部封装的 value 是非空的，则返回此value值 。<ul><li>如果内部的 value 是空的，则返回orElse()方法中的参数 t1 。</li></ul></li></ul></li><li><p>T get()    ——&gt; 该方法与of(T t)搭配使用</p><ul><li>该方法通过Optional类的对象去调用。</li><li>如果Optional封装的数据value为空，则get()报错。否则，value不为空时，返回value。</li></ul> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    Optional&lt;String&gt; optionalS = Optional.ofNullable(s);</span><br><span class="line">    System.out.println(optionalS.get());<span class="comment">//hello</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>boolean isPresent()</p><ul><li>该方法通过Optional类的对象去调用。</li><li>判断当前的Optional对象内部封装的 value 是否有值，有值返回true。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java语法（基础部分）</title>
      <link href="/2023/04/24/Java%E8%AF%AD%E6%B3%95%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/"/>
      <url>/2023/04/24/Java%E8%AF%AD%E6%B3%95%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="1、关键字、保留字、标识符"><a href="#1、关键字、保留字、标识符" class="headerlink" title="1、关键字、保留字、标识符"></a>1、关键字、保留字、标识符</h2><h3 id="A-保留字"><a href="#A-保留字" class="headerlink" title="A.保留字"></a>A.保留字</h3><p>现在不是关键字，将来可能成为关键字的字符串，有：goto、const、null</p><h3 id="B-标识符"><a href="#B-标识符" class="headerlink" title="B.标识符"></a>B.标识符</h3><p>凡是自己可以起名字的地方都叫标识符，如：类名、变量名、方法名、接口名、包名等。标识符的命名规则：</p><p>​①由26个英文字母大小写，0-9，_或$组成。</p><p>​②数字不可以开头。</p><p>​③不可以使用关键字和保留字。</p><p>​④Java中严格区分大小写，如：s1和S1不一样。</p><h2 id="2、Java中的命名规范"><a href="#2、Java中的命名规范" class="headerlink" title="2、Java中的命名规范"></a>2、Java中的命名规范</h2><p>包名：所有字母小写。 </p><p>类名、接口名：所有单词的首字母大写。</p><p>变量名、方法名：第一个单词首字母小写，其余单词的首字母大写。</p><p>常量名：所有字母都大写。多单词时每个单词用下划线连接，如：XXX_YYY_ZZZ</p><h2 id="3、定义变量"><a href="#3、定义变量" class="headerlink" title="3、定义变量"></a>3、定义变量</h2><p>格式：变量类型 变量名 &#x3D; 变量值</p><p>变量的声明和赋值可以不写在一起，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>；</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="type">int</span> i ;</span><br><span class="line">i = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>注意：①使用变量之前要先声明并赋值，不然编译不通过。</p><p>​   ②不可以在同一作用域内定义同名变量。</p><p>​   ③变量的作用域：其定义所在的一对{ }内。变量只有在其作用域内才有效。</p><hr><p><img src="/imgs/image-20220520145505385.png" alt="image-20220520145505385"></p><h3 id="①基本数据类型"><a href="#①基本数据类型" class="headerlink" title="①基本数据类型"></a>①基本数据类型</h3><h4 id="A-整型"><a href="#A-整型" class="headerlink" title="A.整型"></a>A.整型</h4><p><img src="/imgs/image-20220520151836822.png" alt="image-20220520151836822"></p><p>注意：</p><p>​①byte表示的范围是：-128~127，如果赋值时超出了这个范围就会编译不通过。</p><p>​②long类型数据在赋值时要在变量值后面加上“l”或“L”，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">l1</span> <span class="operator">=</span> <span class="number">123l</span>;</span><br><span class="line"><span class="type">long</span> <span class="variable">l2</span> <span class="operator">=</span> <span class="number">12L</span>;</span><br></pre></td></tr></table></figure><h4 id="B-浮点型"><a href="#B-浮点型" class="headerlink" title="B.浮点型"></a>B.浮点型</h4><p>​①float（占4字节）、double（占8字节）。</p><p>​②float表示数值的范围比long还大。</p><p>​③定义float类型变量时，变量要以”f”或”F”结尾。</p><p>​④定义浮点型变量时，常用double型。</p><h4 id="C-字符型"><a href="#C-字符型" class="headerlink" title="C.字符型"></a>C.字符型</h4><p>​①定义char类型变量，通常使用一对单引号，引号内部只能写一个字符。char占两个字节。</p><p>​②可以赋值转义字符给字符型变量，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="string">&#x27;\n&#x27;</span>;<span class="comment">// \n表示换行</span></span><br><span class="line"><span class="type">char</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="string">&#x27;\t&#x27;</span>;<span class="comment">// \t表示制表符即Tab键</span></span><br><span class="line">System.out.print(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;world&quot;</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果为：</span></span><br><span class="line"><span class="comment">helloworld</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">System.out.print(<span class="string">&quot;hello&quot;</span> + c1);</span><br><span class="line">System.out.println(<span class="string">&quot;world&quot;</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果为：</span></span><br><span class="line"><span class="comment">hello</span></span><br><span class="line"><span class="comment">world</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">System.out.print(<span class="string">&quot;hello&quot;</span> + c2);</span><br><span class="line">System.out.println(<span class="string">&quot;world&quot;</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果为：</span></span><br><span class="line"><span class="comment">helloworld</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="D-布偶型"><a href="#D-布偶型" class="headerlink" title="D.布偶型"></a>D.布偶型</h4><p>​①boolean只能取true或false</p><hr><h3 id="②基本数据类型之间的运算"><a href="#②基本数据类型之间的运算" class="headerlink" title="②基本数据类型之间的运算"></a>②基本数据类型之间的运算</h3><p>前提：这里讨论只是7种基本数据类型变量间的运算。不包括boolean类型的。</p><h4 id="A-自动类型转换"><a href="#A-自动类型转换" class="headerlink" title="A.自动类型转换"></a>A.自动类型转换</h4><p>自动转换：小–&gt;大（小、大指数据的表示范围）</p><p>byte、short、char两两间的运算或自己与自己的运算，其结果都为int型。</p><p><img src="/imgs/image-20220520171757481.png" alt="image-20220520171757481"></p><h4 id="B-强制类型转换"><a href="#B-强制类型转换" class="headerlink" title="B.强制类型转换"></a>B.强制类型转换</h4><p>​①需要使用强转符：（）</p><p>​②注意：强制转换可能导致精度损失，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="number">12.9</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> (<span class="type">int</span>)d1;<span class="comment">//输出结果为：12。浮点型转整型时结果取整数</span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">l1</span> <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line"><span class="type">short</span> <span class="variable">s2</span> <span class="operator">=</span> (<span class="type">short</span>)l1;<span class="comment">//输出结果还是123，没有精度损失</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> (<span class="type">byte</span>)i2;<span class="comment">//输出结果为-128，有精度损失</span></span><br></pre></td></tr></table></figure><h4 id="C-注意"><a href="#C-注意" class="headerlink" title="C.注意"></a>C.注意</h4><p>​整型常量，默认类型为int型。浮点型常量，默认类型为double型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">1232213</span>;</span><br><span class="line"><span class="comment">//123213后面没加L或l编译也能通过，因为整型常量默认为int型，int转换成long型属于自动类型转换，所以编译没有报错。</span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="number">12.3</span>;</span><br><span class="line"><span class="comment">//12.3后面没加F或f，编译会报错，因为浮点型常量默认为double型，double转float需要强制转换，所以编译报错。</span></span><br><span class="line"></span><br><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">12</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">b1</span> <span class="operator">=</span> b + <span class="number">1</span>；<span class="comment">//此行会编译报错，因为1属于整型常量，所以为int型，(b + 1)结果为int型数据，int型转byte需要强制转换。</span></span><br></pre></td></tr></table></figure><p>总结：long类型和float类型数据记得加（L或l）、（F或f）</p><hr><h3 id="③引用数据类型"><a href="#③引用数据类型" class="headerlink" title="③引用数据类型"></a>③引用数据类型</h3><h4 id="A-String-字符串"><a href="#A-String-字符串" class="headerlink" title="A. String(字符串)"></a>A. String(字符串)</h4><p>​①声明String类型变量时，使用””（双引号）。</p><p>​②赋给字符串的值，可以是单个字符，可以多个字符，也可以没有。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;as&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="type">char</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="string">&#x27;&#x27;</span>;<span class="comment">//编译不通过，因为char类型不能不赋值。</span></span><br></pre></td></tr></table></figure><p>​③String可以和8种基本数据类型变量做运算，且只能做连接运算（即 “+” ），其运算结果为String类型。</p><p>例子：</p><p><img src="/imgs/image-20220521004644430.png" alt="image-20220521004644430"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;**&quot;</span>);<span class="comment">//结果为**</span></span><br><span class="line">System.out.println(<span class="string">&#x27;*&#x27;</span> + <span class="string">&#x27;\t&#x27;</span> + <span class="string">&#x27;*&#x27;</span>);<span class="comment">//结果为93</span></span><br><span class="line">System.out.println(<span class="string">&#x27;*&#x27;</span> + <span class="string">&quot;\t&quot;</span> + <span class="string">&#x27;*&#x27;</span>);<span class="comment">//结果为**</span></span><br><span class="line">System.out.println(<span class="string">&#x27;*&#x27;</span> + <span class="string">&#x27;\t&#x27;</span> + <span class="string">&quot;*&quot;</span>);<span class="comment">//结果为51*</span></span><br><span class="line">System.out.println(<span class="string">&#x27;*&#x27;</span> + (<span class="string">&#x27;\t&#x27;</span> + <span class="string">&quot;*&quot;</span>));<span class="comment">//结果为**</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// *的ASCII码为42，&quot;\t&quot;的ASCII码为9</span></span><br><span class="line"><span class="comment">//总结：当+为连接运算时，\t是Tab键；为加号时，\t变成整型</span></span><br></pre></td></tr></table></figure><hr><h3 id="④进制与进制间的转换（了解）"><a href="#④进制与进制间的转换（了解）" class="headerlink" title="④进制与进制间的转换（了解）"></a>④进制与进制间的转换（了解）</h3><h4 id="A-进制"><a href="#A-进制" class="headerlink" title="A.进制"></a>A.进制</h4><p>对于整数，有四种表示方式：</p><p><img src="/imgs/image-20220521112750208.png" alt="image-20220521112750208"></p><p>上面的0b、0B、0x、0X都是数字零。</p><p>例子：</p><p><img src="/imgs/image-20230424174734908.png" alt="image-20230424174734908"></p><p>输出结果为：</p><p><img src="/imgs/image-20220521114116121.png" alt="image-20220521114116121"></p><h4 id="B-二进制与十进制（了解）"><a href="#B-二进制与十进制（了解）" class="headerlink" title="B.二进制与十进制（了解）"></a>B.二进制与十进制（了解）</h4><p><code>计算机底层都以补码的方式来存储数值！</code></p><p>正数的补码、反码、原码一样；负数的反码为：在原码基础上，除符号位（即最高位）外所有位都取反。负数的补码：在反码的基础上加1。</p><p>符号位上：0代表正数，1代表负数。</p><h4 id="C-其他进制之间的转换"><a href="#C-其他进制之间的转换" class="headerlink" title="C.其他进制之间的转换"></a>C.其他进制之间的转换</h4><ol><li><p>二进制转八进制：只需将二进制中从低位开始，每三个合成一个数即可。</p><p> <img src="/imgs/image-20220521155645209.png" alt="image-20220521155645209"></p></li><li><p>二进制转十六进制：只需将二进制中从低位开始，每四个合成一个数即可。</p><p> <img src="/imgs/image-20220521155841060.png" alt="image-20220521155841060"></p></li><li><p>八进制转二进制：将八进制中的一个数变成三位，然后将这些合起来即可。</p><p> <img src="/imgs/image-20230424174945501.png" alt="image-20230424174945501"></p></li><li><p>十六进制转二进制：将十六进制中的一个数变成四位，然后将这些合起来即可。</p><p> <img src="/imgs/image-20230424174951559.png" alt="image-20230424174951559"></p></li></ol><h4 id="D-总结"><a href="#D-总结" class="headerlink" title="D.总结"></a>D.总结</h4><p>实际开发中，很少用到进制转换知识，我们只需知识其转换的思想即可，如果开发中用到进制转换，我们会调用方法来解决，如·下图。<img src="/imgs/image-20220521160741394.png" alt="image-20220521160741394"></p><hr><h2 id="4、运算符"><a href="#4、运算符" class="headerlink" title="4、运算符"></a>4、运算符</h2><h3 id="A-算术运算符"><a href="#A-算术运算符" class="headerlink" title="A.算术运算符"></a>A.算术运算符</h3><p><img src="/imgs/image-20220521203102936.png" alt="image-20220521203102936"></p><p>注意：当容量小的数据类型的变量与容量大的数据类型的变量做算术运算时，结果自动提升为大容量的数据类型。</p><h4 id="1-除运算（-x2F-）"><a href="#1-除运算（-x2F-）" class="headerlink" title="1.除运算（  &#x2F;  ）"></a>1.除运算（  &#x2F;  ）</h4><p>如果除数和被除数都是整数，而想让结果变成浮点数，可以像下面那样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">12</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">result</span> <span class="operator">=</span> num1*<span class="number">1.0</span> / num2;<span class="comment">//结果为2.4，注意结果的数据类型为double型，如果用float类型数据去接收结果需要强制转换。</span></span><br></pre></td></tr></table></figure><h4 id="2-取余运算（-）"><a href="#2-取余运算（-）" class="headerlink" title="2.取余运算（%）"></a>2.取余运算（%）</h4><p>结果的符号与被模数（即下面例子中的m变量）的符号相同。</p><p><img src="/imgs/image-20220521211911300.png" alt="image-20220521211911300"></p><p><img src="/imgs/image-20220521212033055.png" alt="image-20220521212033055"></p><h4 id="3-自增、自减运算"><a href="#3-自增、自减运算" class="headerlink" title="3.自增、自减运算"></a>3.自增、自减运算</h4><p>前（++），如：++a。先自加1，后运算。</p><p>后（++），如：a++。先运算，后自加1。</p><p>a–及–a同理</p><h3 id="B-赋值运算符"><a href="#B-赋值运算符" class="headerlink" title="B.赋值运算符"></a>B.赋值运算符</h3><h4 id="1-连续赋值"><a href="#1-连续赋值" class="headerlink" title="1.连续赋值"></a>1.连续赋值</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i1,i2;</span><br><span class="line">i1 = i2 = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//***************************</span></span><br><span class="line"><span class="type">int</span> <span class="variable">j1</span> <span class="operator">=</span> <span class="number">20</span>,j2 = <span class="number">30</span>;</span><br></pre></td></tr></table></figure><h4 id="2-x3D-、-x3D-、-x3D-、-x3D-、-x2F-x3D"><a href="#2-x3D-、-x3D-、-x3D-、-x3D-、-x2F-x3D" class="headerlink" title="2.+&#x3D;、-&#x3D;、*&#x3D;、%&#x3D;、&#x2F;&#x3D;"></a>2.+&#x3D;、-&#x3D;、*&#x3D;、%&#x3D;、&#x2F;&#x3D;</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">num1 += <span class="number">2</span>;<span class="comment">//相当于num1 = num1 + 2，结果为12</span></span><br><span class="line"><span class="comment">//-=、*=、%=、/=也类似</span></span><br></pre></td></tr></table></figure><p>注意：+&#x3D;、-&#x3D;、*&#x3D;、%&#x3D;、&#x2F;&#x3D;不会改变变量本身的数据类型。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例一：</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>；</span><br><span class="line">i *= <span class="number">0.1</span>;<span class="comment">//执行完此行代码后，变量i的数据类型还是int型，因此i=0</span></span><br><span class="line">System.out.println(i);</span><br><span class="line">i++;</span><br><span class="line">System.out.println(i);<span class="comment">//i=1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//例二：</span></span><br><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">n *= m++;<span class="comment">//等价于：n = n * m++;即n = 3 * 2 </span></span><br><span class="line">System.out.println(m);<span class="comment">//3</span></span><br><span class="line">System.out.println(n);<span class="comment">//6</span></span><br></pre></td></tr></table></figure><p>补充：</p><p><img src="/imgs/image-20220522160339925.png" alt="image-20220522160339925"></p><p><img src="/imgs/image-20220524115825798.png" alt="image-20220524115825798"></p><h3 id="C-比较运算符"><a href="#C-比较运算符" class="headerlink" title="C.比较运算符"></a>C.比较运算符</h3><p><img src="/imgs/image-20220522163900491.png" alt="image-20220522163900491"></p><p>说明：</p><p>​①比较运算符的结果都是boolean型，也即是true或false</p><p>​② &gt;  、&lt; 、  &gt;&#x3D; 、 &lt;&#x3D; ：只能使用在数值型的数据之间。</p><p>​③ !&#x3D;、&#x3D;&#x3D;：可以使用在数值型数据之间，还可以使用在其他引用类型变量之间。（存在自动类型转换）如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">10.0</span>;</span><br><span class="line">System.out.println(i == j);<span class="comment">//true</span></span><br><span class="line"><span class="type">char</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">System.out.println(i == k);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><h3 id="D-逻辑运算符"><a href="#D-逻辑运算符" class="headerlink" title="D.逻辑运算符"></a>D.逻辑运算符</h3><p><img src="/imgs/image-20220522171429018.png" alt="image-20220522171429018"></p><p>说明：逻辑运算符操作的都是boolean类型的变量。其运算结果也是boolean类型数据。</p><h4 id="1-amp-与-amp-amp"><a href="#1-amp-与-amp-amp" class="headerlink" title="1.&amp; 与 &amp;&amp;"></a>1.&amp; 与 &amp;&amp;</h4><p>​运算规则：两个为真，结果才为真。</p><p>​相同点：</p><p>​①&amp; 与 &amp;&amp; 的运算结果相同。</p><p>​②当符号左边是true时，二者都会执行符号右边的运算。</p><p>​不同点：当符号左边是false时，&amp;继续执行符号右边的运算。&amp;&amp;不再执行符号右边的运算。</p><p>​写代码时推荐使用：&amp;&amp;。</p><h4 id="2-与"><a href="#2-与" class="headerlink" title="2.  |  与   ||"></a>2.  |  与   ||</h4><p>​运算规则：其中一个为真，结果为真。</p><p>​相同点：</p><p>​① |  与 || 的运算结果相同。</p><p>​②当符号左边是false时，二者都会执行符号右边的运算。</p><p>​不同点：当符号左边是true时， |  继续执行符号右边的运算，而 || 不再执行符号右边的运算。</p><p>​写代码时推荐使用：|| 。</p><h4 id="3-异或运算（-）"><a href="#3-异或运算（-）" class="headerlink" title="3.异或运算（^）"></a>3.异或运算（^）</h4><p>​运算规则：相同为false，不相同为true。</p><h3 id="E-位运算符（了解）"><a href="#E-位运算符（了解）" class="headerlink" title="E.位运算符（了解）"></a>E.位运算符（了解）</h3><p><img src="/imgs/image-20220522211834252.png" alt="image-20220522211834252"></p><p>​①操作对象：整型数据；其运算结果：整型数据。</p><p>​②左移运算符（&lt;&lt;）和右移运算符(&gt;&gt;)</p><p>​&lt;&lt; ：在一定范围内，每向左移1位，相当于 * 2。</p><p>​&gt;&gt; ：在一定范围内，每向右移1位，相当于 &#x2F; 2。</p><h3 id="F-三元运算符"><a href="#F-三元运算符" class="headerlink" title="F.三元运算符"></a>F.三元运算符</h3><p>​①格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//(条件表达式)? 表达式1 : 表达式2;</span></span><br></pre></td></tr></table></figure><p>​②说明：</p><p>​       A.条件表达式的运算结果必须是boolean型。</p><p>​   B.三元运算符的运算结果是返回表达式1或表达式2。如：</p><p><img src="/imgs/image-20220523115005452.png" alt="image-20220523115005452"></p><p>​   C.如果条件表达式为true，执行表达式1；如果表达式为false，执行表达式2。</p><p>​   D.表达式1和表达式2的数据类型可以不一样，但接收三元表达式结果的变量的数据类型要能接收这两个表达式的数据类型。如：</p><p><img src="/imgs/image-20230424175138753.png" alt="image-20230424175138753"></p><p>​  E.三元运算符可以嵌套使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> (m &gt; n)? <span class="string">&quot;m大&quot;</span> : ((m == n)? <span class="string">&quot;m = n&quot;</span> : <span class="string">&quot;n大&quot;</span>);</span><br></pre></td></tr></table></figure><p>​  F.凡是可以使用三元运算符的地方，都可以改写成 if-else语句。当程序既可以使用三元运算符，又可以使用if-else结构，那么优先选择三元运算符。原因是：简洁、执行效率高。</p><p>练习：如何获取三个数中的最大值？</p><p><img src="/imgs/image-20220523121959562.png" alt="image-20220523121959562"></p><hr><h2 id="5、流程控制"><a href="#5、流程控制" class="headerlink" title="5、流程控制"></a>5、流程控制</h2><h3 id="A-分支结构"><a href="#A-分支结构" class="headerlink" title="A.分支结构"></a>A.分支结构</h3><h4 id="①if…-else"><a href="#①if…-else" class="headerlink" title="①if….else"></a>①if….else</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 条件判断语句的三种结构</span></span><br><span class="line"><span class="comment">1、</span></span><br><span class="line"><span class="comment">if(条件表达式)&#123;</span></span><br><span class="line"><span class="comment">代码块；</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">2、</span></span><br><span class="line"><span class="comment">if（条件表达式）&#123;</span></span><br><span class="line"><span class="comment">代码块1；</span></span><br><span class="line"><span class="comment">&#125;else&#123;</span></span><br><span class="line"><span class="comment">代码块2；</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">3、</span></span><br><span class="line"><span class="comment">if(条件表达式)&#123;</span></span><br><span class="line"><span class="comment">代码块1；</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">else if（条件表达式2）&#123;</span></span><br><span class="line"><span class="comment">代码块2；</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">......</span></span><br><span class="line"><span class="comment">else&#123;  //此行的else结构是可选项，即可有可无。</span></span><br><span class="line"><span class="comment">代码块n;//如果上面的条件表达式都不为true，则执行代码块n</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><img src="/imgs/image-20220526163007386.png" alt="image-20220526163007386"></p><h4 id="②switch-case"><a href="#②switch-case" class="headerlink" title="②switch-case"></a>②switch-case</h4><p>​A.switch-case的结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">switch(表达式)&#123;  //表达式：一般为一个变量</span></span><br><span class="line"><span class="comment">case 常量1:</span></span><br><span class="line"><span class="comment">语句1; //可以是多个语句</span></span><br><span class="line"><span class="comment">break;</span></span><br><span class="line"><span class="comment">case 常量2:</span></span><br><span class="line"><span class="comment">语句2;</span></span><br><span class="line"><span class="comment">break;</span></span><br><span class="line"><span class="comment">.....</span></span><br><span class="line"><span class="comment">    case 常量N:</span></span><br><span class="line"><span class="comment">语句N;</span></span><br><span class="line"><span class="comment">break;</span></span><br><span class="line"><span class="comment">default: //当上面的case都不满足时，执行default。</span></span><br><span class="line"><span class="comment">语句;</span></span><br><span class="line"><span class="comment">break;//此行的break可写可不写</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">//default结构为可选项。每个case里的break也是可选项，不过一般都写上。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>​B.说明</p><p>​①根据switch表达式中的值，依次匹配各个case中的常量。一旦匹配成功，则进入相应case结构中，调用其执行语句。当调用完执行语句以后，则仍然继续向下执行其他case结构中的执行语句（<code>向下执行过程中不再进行case的判断</code>），直到遇到break关键字或switch-case结构末尾结束为止。</p><p>​②switch结构中的表达式，只能是如下的6种数据类型之一：byte、short、char、int、枚举类型（jdk5.0新增）、String类型（jdk7.0新增）。</p><p>​③case之后只能声明常量，不能声明范围。如下面的情况，编译会报错。</p><p><img src="/imgs/image-20230424175215001.png" alt="image-20230424175215001"></p><p>​C.补充</p><p>​①如果switch-case结构中的多个case的执行语句相同，则可以考虑进行合并。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> <span class="number">78</span>;</span><br><span class="line"><span class="keyword">switch</span>(score / <span class="number">10</span>)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;不及格&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;不及格&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;及格&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以合并成：</span></span><br><span class="line"><span class="keyword">switch</span>(score / <span class="number">10</span>)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;不及格&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;及格&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​②当switch的参数为一个枚举类对象时，case 后面直接写枚举类的对象名即可。<img src="/imgs/image-20220817183943637.png" alt="image-20220817183943637"></p><p>​throw可以代替break。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="/imgs/image-20220525203549438.png" alt="image-20220525203549438"></p><hr><h3 id="B-循环结构"><a href="#B-循环结构" class="headerlink" title="B.循环结构"></a>B.循环结构</h3><h4 id="①for"><a href="#①for" class="headerlink" title="①for"></a>①for</h4><p>​a.for循环的结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//①初始化条件  ②循环条件(是boolean类型) ③循环体 ④迭代条件</span></span><br><span class="line"><span class="keyword">for</span>(①;②;④)&#123;</span><br><span class="line">    ③</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//初始化条件中定义的变量只在for循环中有效。</span></span><br><span class="line"><span class="comment">//当初始化条件当中有多个时，请使用“,”将各个部分隔开。如：</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>,k = <span class="number">2</span>;j &lt;= <span class="number">5</span>;j++)&#123;</span><br><span class="line">    k++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果初始化条件放在了for循环的外面，则①的位置就不用写东西了，如：</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(;i &lt; <span class="number">10</span>;i++)&#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这样写，出来了for循环后i还可以继续使用</span></span><br></pre></td></tr></table></figure><h4 id="②while"><a href="#②while" class="headerlink" title="②while"></a>②while</h4><p>​a.while循环的结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//①初始化条件  ②循环条件(是boolean类型) ③循环体 ④迭代条件</span></span><br><span class="line"><span class="comment">/*while循环的结构：</span></span><br><span class="line"><span class="comment">①;</span></span><br><span class="line"><span class="comment">while(②)&#123;</span></span><br><span class="line"><span class="comment">    ③;</span></span><br><span class="line"><span class="comment">    ④;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>​b.声明</p><p>​①写while循环千万小心不要丢了迭代条件。一旦丢了，就可能导致死循环！</p><p>​②for循环和while循环是可以相互转换的！for循环和while循环的区别：初始化条件部分的作用范围不同。（for循环中的初始化条件变量只能在for循环里使用，出来for循环就没有了；而while循环的初始化条件变量出了while循环后还可以使用）</p><h4 id="③do…-while"><a href="#③do…-while" class="headerlink" title="③do….while"></a>③do….while</h4><p>​a.do….while循环的结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//①初始化条件  ②循环条件(是boolean类型) ③循环体 ④迭代条件</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">①；</span></span><br><span class="line"><span class="comment">do&#123;</span></span><br><span class="line"><span class="comment">   ③；</span></span><br><span class="line"><span class="comment">   ④；</span></span><br><span class="line"><span class="comment">&#125;while(②);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">执行顺序：① - ③ - ④ - ② - ③ - ④ - .... - ② </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>​b.说明</p><p>​①do-while循环至少执行一次循环体。</p><p>​②当do-while循环中的循环体执行多次时，其与while循环、for循环的执行结果是一样的。<u>日常开发中常用for循环和while循环。</u></p><h3 id="C-练习"><a href="#C-练习" class="headerlink" title="C.练习"></a>C.练习</h3><h4 id="补充说明："><a href="#补充说明：" class="headerlink" title="补充说明："></a>补充说明：</h4><p>​①当要求输入某个特定值时才可以终止循环时，就需要用到下面的结构：while(true)或for(;;)，再根据实际条件在循环内加上break即可。如：下面的练习一。</p><p>​②结束循环的两种方式：</p><p>​A.不再满足循环条件。</p><p>​B.在循环体中，执行break。</p><hr><p>​ 练习一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题目：</span></span><br><span class="line"><span class="comment">从键盘读入个数不确定的整数，并判断读入的正数和负数的个数，输入为0时结束程序。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="variable">positiveNumber</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//记录正数的个数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">negativeNumber</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//记录负数的个数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123; <span class="comment">//while(true)这个结构等价于for(;;)</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">    <span class="keyword">if</span>(number &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        positiveNumber++；</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(number &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        negativeNumber++;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​练习二：求100以内的质数。（质数：只能能被1和自身整除的数，最小的质数为2。）</p><p><img src="/imgs/image-20220527135839433.png" alt="image-20220527135839433"></p><p>​为什么要重置isFlag？如果前一个数的isFlag是false，而接下来的一个数就算是质数，那么也不会被输出。</p><hr><h4 id="嵌套循环："><a href="#嵌套循环：" class="headerlink" title="嵌套循环："></a>嵌套循环：</h4><p>​当为两层循环时，可以将嵌套循环看成是一个表格，内层循环相当于列，外层循环相当于行。</p><hr><h3 id="D-break、continue"><a href="#D-break、continue" class="headerlink" title="D.break、continue"></a>D.break、continue</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">            使用范围       循环中使用的作用      相同点</span></span><br><span class="line"><span class="comment">break；     switch-case       </span></span><br><span class="line"><span class="comment">   循环结构中      结束当前循环      关键字后面不能</span></span><br><span class="line"><span class="comment">                                            紧接着声明执行</span></span><br><span class="line"><span class="comment">continue：  循环结构中      结束当次循环      语句</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>补充：<br>    ①当break，continue用于多重循环结构时，break是默认跳出最近的一层循环；continue是默认结束最近一层循环的当前循环。<br>    ②如果想用break结束指定某一层的for循环，则在那层的for循环前加上个“标签”（标签名可以随便起），然后再break + “标签”即可，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">label:<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= <span class="number">4</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j &lt;= <span class="number">10</span>;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(j % <span class="number">4</span> == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">break</span> label;<span class="comment">//结束的是外层的for循环</span></span><br><span class="line">&#125;</span><br><span class="line">System.out.print(j);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">  &#125; <span class="comment">//输出结果为：123</span></span><br></pre></td></tr></table></figure><p>​③如果想用continue结束指定某一层的for循环当前循环，则在那层的for循环前加上个“标签”（标签名可以随便起），然后再continue+ “标签”即可，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">label:<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= <span class="number">4</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j &lt;= <span class="number">10</span>;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(j % <span class="number">4</span> == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">continue</span> label;<span class="comment">//结束的是外层的for循环</span></span><br><span class="line">&#125;</span><br><span class="line">System.out.print(j);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">  &#125; <span class="comment">//输出结果为：123123123123</span></span><br></pre></td></tr></table></figure><p>​④当循环结构里面有个switch-case，而你想当执行到某个case时就结束循环，可以在循环前面加个“标签”，然后在break+“标签”，即可。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">label:<span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">    <span class="keyword">switch</span> (number) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            System.out.print(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">//结束的是switch-case</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            System.out.print(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">//结束的是switch-case</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            System.out.print(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span> label;<span class="comment">//结束的是while循环</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;已退出while循环&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​练习：求2-100000以内的所有质数并计算质数的总数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;2-100000的质数有：&quot;</span>);</span><br><span class="line">label:<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>;i &lt;= <span class="number">100000</span>;i++)&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span>;j &lt;= Math.sqrt(i);j++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i % j == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span> label;</span><br><span class="line">       &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  count++;</span><br><span class="line">   System.out.println(i);</span><br><span class="line">  &#125;</span><br><span class="line">System.out.println(<span class="string">&quot;2-100000的质数个数为&quot;</span> + count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="6、Scanner-获取输入"><a href="#6、Scanner-获取输入" class="headerlink" title="6、Scanner(获取输入)"></a>6、Scanner(获取输入)</h2><h3 id="A-实现步骤"><a href="#A-实现步骤" class="headerlink" title="A.实现步骤"></a>A.实现步骤</h3><p>​①导包：import java.util.Scanner；&#x2F;&#x2F;需写在程序的开头</p><p>​②Scanner的实例化：Scanner 变量名 &#x3D; new Scanner(System.in);</p><p>​③调用Scanner类的相关方法：</p><p>​A.如果想获取int、byte、short、long、float、double类型的数据，则：变量名.nextXxx()，如：变量名.nextInt等。</p><p>​B.如果想获取字符串，则：变量名.next()。</p><p>​C.Scanner没有提供获取char类型变量的方法，如果想获取char类型变量，可以先获取String类型变量，再利用String类的方法来转换成char类型变量。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> scan.next();</span><br><span class="line"><span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s1.charAt(<span class="number">0</span>);<span class="comment">//0代表：获取s1字符串的第一个字符。如果是1：代表获取s1字符串的第二个字符。</span></span><br></pre></td></tr></table></figure><h3 id="B-注意"><a href="#B-注意" class="headerlink" title="B.注意"></a>B.注意</h3><pre><code> 需要根据相应的方法，来输入指定类型的值。如果输入的数据类型与要求的类型不匹配时，会报异常：InputMisMatchExcpetion，导致程序终止。</code></pre><hr><h2 id="7、生成随机数"><a href="#7、生成随机数" class="headerlink" title="7、生成随机数"></a>7、生成随机数</h2><p>​想在[a,b]这个范围内，生成一个随机整数，如何做呢？</p><h4 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h4><p>​(int)(Math.random() * (b - a + 1) + a)</p><p>​注：a,b都为整数</p><p>​补充：Math.random()产生的是[0.0,1.0)的随机数（产生的随机数为double型）</p><p>如：在[10,99]生成一个随机数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> (<span class="type">int</span>)(Math.random() * (<span class="number">99</span> - <span class="number">10</span> + <span class="number">1</span>) + <span class="number">10</span>);</span><br></pre></td></tr></table></figure><h2 id="8、数组"><a href="#8、数组" class="headerlink" title="8、数组"></a>8、数组</h2><h3 id="①数组的概述"><a href="#①数组的概述" class="headerlink" title="①数组的概述"></a>①数组的概述</h3><p>​数组实际上是一种特殊的类，其继承于Object类，因此也可以调用Object类中的方法。例子：int arr[]，则其属于一维数组int类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> b[] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">b.equals(obj);</span><br></pre></td></tr></table></figure><h4 id="A-数组相关的概念"><a href="#A-数组相关的概念" class="headerlink" title="A.数组相关的概念"></a>A.数组相关的概念</h4><p>​&gt; 数组名 </p><p>​&gt; 元素</p><p>​&gt; 角标、下标、索引（三者其实是同一个概念）</p><p>​&gt; 数组的长度：即元素的个数</p><h4 id="B-数组的特点"><a href="#B-数组的特点" class="headerlink" title="B.数组的特点"></a>B.数组的特点</h4><p><img src="/imgs/image-20220529122018882.png" alt="image-20220529122018882"></p><h4 id="C-数组的分类"><a href="#C-数组的分类" class="headerlink" title="C.数组的分类"></a>C.数组的分类</h4><p><img src="/imgs/image-20220529122202348.png" alt="image-20220529122202348"></p><h3 id="②一维数组"><a href="#②一维数组" class="headerlink" title="②一维数组"></a>②一维数组</h3><h4 id="A-一维数组声明和初始化"><a href="#A-一维数组声明和初始化" class="headerlink" title="A.一维数组声明和初始化"></a>A.一维数组声明和初始化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">静态初始化：(数组的初始化和数组元素的赋值操作同时进行)</span></span><br><span class="line"><span class="comment">int[] ids = new int[]&#123;1,2,3,4,5&#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">动态初始化：(数组的初始化和数组元素的赋值操作分开进行)</span></span><br><span class="line"><span class="comment">String[] names = new String[5]; </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">声明和初始化可以分开，如：</span></span><br><span class="line"><span class="comment">int[] number;</span></span><br><span class="line"><span class="comment">number = new int[]&#123;2,3,4,5&#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">String[] address;</span></span><br><span class="line"><span class="comment">address = new String[5];</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注意：数组的正确声明和初始化方式只有以上四种</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>​总结：数组一旦初始化完成，其长度就确定了。数组长度一旦确定   了，就不可以修改。</p><h4 id="B-数组元素的使用"><a href="#B-数组元素的使用" class="headerlink" title="B.数组元素的使用"></a>B.数组元素的使用</h4><pre><code> 通过索引（即下标）的方式调用，格式为： 数组名[索引]  ，如：</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String[] names = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">3</span>];</span><br><span class="line">names[<span class="number">0</span>] = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">names[<span class="number">1</span>] = <span class="string">&quot;def&quot;</span>;</span><br><span class="line">names[<span class="number">2</span>] = <span class="string">&quot;ghi&quot;</span>;</span><br><span class="line">System.out.println(names[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><h4 id="C-获取数组的长度"><a href="#C-获取数组的长度" class="headerlink" title="C.获取数组的长度"></a>C.获取数组的长度</h4><p>​  格式为：数组名.length，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] names = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;def&quot;</span>,<span class="string">&quot;ghi&quot;</span>&#125;;</span><br><span class="line">System.out.println(names.length);<span class="comment">//为3</span></span><br></pre></td></tr></table></figure><h4 id="D-遍历数组"><a href="#D-遍历数组" class="headerlink" title="D.遍历数组"></a>D.遍历数组</h4><p><img src="/imgs/image-20230424175327311.png" alt="image-20230424175327311"></p><h4 id="E-数组元素的默认初始化值"><a href="#E-数组元素的默认初始化值" class="headerlink" title="E.数组元素的默认初始化值"></a>E.数组元素的默认初始化值</h4><p>​数组元素是整型：默认为：0</p><p>​数组元素是浮点型：默认为：0.0</p><p>​数组元素是char型：默认为：ASCII为零的那个字符</p><p>​数组元素是boolean型：默认为：false</p><p>​数组元素是String型：默认为：null</p><h4 id="F-数组的内存分析"><a href="#F-数组的内存分析" class="headerlink" title="F.数组的内存分析"></a>F.数组的内存分析</h4><p>​内存的主要结构有：</p><p><img src="/imgs/image-20220529233240226.png" alt="image-20220529233240226"></p><p>​局部变量：在方法中定义的变量。</p><p>​常量池：存放字符串。</p><p><img src="/imgs/image-20220530090904730.png" alt="image-20220530090904730"></p><h3 id="③二维数组"><a href="#③二维数组" class="headerlink" title="③二维数组"></a>③二维数组</h3><p>​二维数组：设实际上是一维数组里的元素是一个一维数组。</p><p><img src="/imgs/image-20220530111835839.png" alt="image-20220530111835839"></p><h4 id="A-二维数组声明和初始化"><a href="#A-二维数组声明和初始化" class="headerlink" title="A.二维数组声明和初始化"></a>A.二维数组声明和初始化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">静态初始化：</span></span><br><span class="line"><span class="comment">int[][] arr1 = new int[][]&#123;&#123;1,3,4&#125;,&#123;2,6,7&#125;,&#123;5,8&#125;&#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">动态初始化1：</span></span><br><span class="line"><span class="comment">String[][] arr2 = new String[3][2];//3行2列</span></span><br><span class="line"><span class="comment">动态初始化2：</span></span><br><span class="line"><span class="comment">String[][] arr3 = new String[3][];</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">以上写法是正确的写法。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>​总结：</p><p>​二维数组就像一张表，第一个“[ ]”，就相当于表中的行，第二个“[ ] ”就相当于表中的列。</p><h4 id="B-数组元素的使用-1"><a href="#B-数组元素的使用-1" class="headerlink" title="B.数组元素的使用"></a>B.数组元素的使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] arr1 = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">2</span>,<span class="number">6</span>,<span class="number">7</span>&#125;,&#123;<span class="number">5</span>,<span class="number">8</span>&#125;&#125;;</span><br><span class="line">System.out.println(arr1[<span class="number">0</span>][<span class="number">0</span>]);<span class="comment">//输出结果为：1</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果想输出第n行，第n列的元素，其格式为：数组名[n-1][n-1];</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">String[][] arr3 = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">3</span>][];</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果使用了上面的方式声明和初始化数组，想要输出数组第二行某列的元素，则先要指定该行有多少列：</span></span><br><span class="line"><span class="comment">arr3[1] = new String[4];//第二行有四列</span></span><br><span class="line"><span class="comment">然后才可以输出第二行某列的元素。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">String[][] arr2 = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">3</span>][<span class="number">2</span>];</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果使用了上面的声明和初始化方式，想要输出数组的第n行第n列的元素，其格式为：数组名[n-1][n-1];</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>​</p><h4 id="C-获取数组的长度-1"><a href="#C-获取数组的长度-1" class="headerlink" title="C.获取数组的长度"></a>C.获取数组的长度</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">数组名.length;//结果为此数组的行数</span></span><br><span class="line"><span class="comment">数组名[n].length;//结果为第n-1行的列数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">//联想一下二维数在内存中的存储形式就能理解上面的知识</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="D-遍历数组-1"><a href="#D-遍历数组-1" class="headerlink" title="D.遍历数组"></a>D.遍历数组</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] arr1 = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">7</span>,<span class="number">8</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; arr1.length;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; arr1[i].length;j++)&#123;</span><br><span class="line">        System.out.print(arr1[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行结果为：</span></span><br><span class="line"><span class="comment">1 2 4 </span></span><br><span class="line"><span class="comment">4 5 </span></span><br><span class="line"><span class="comment">7 8 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="E-数组元素的默认初始化值-1"><a href="#E-数组元素的默认初始化值-1" class="headerlink" title="E.数组元素的默认初始化值"></a>E.数组元素的默认初始化值</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">规定：二维数组分为外层数组的元素，内层数组的元素</span></span><br><span class="line"><span class="comment">int[][] arr = new int[3][4];</span></span><br><span class="line"><span class="comment">外层元素：arr[0]、arr[1]等</span></span><br><span class="line"><span class="comment">内存元素：arr[0][0]、arr[1][1]等</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">① 数组元素的默认初始化值</span></span><br><span class="line"><span class="comment">针对初始化方式一：比如：int[][] arr = new int[3][4];</span></span><br><span class="line"><span class="comment">外层元素的初始化值为：地址值</span></span><br><span class="line"><span class="comment">内存元素的初始化值为：与一维数组初始化情况相同，如果数组类    型为int型，则为0;为float型，则为0.0;String型，则为null；Boolean 型，则为false。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">针对初始化方式二：比如：int[][] arr = new int[3][];</span></span><br><span class="line"><span class="comment">外层元素的初始化值为：null（因为外层元素都是存放一维数  组--&gt; 而一维数组是引用类型--&gt; 引用  类型数据默认初始化值为null --&gt; 所以  这里为null）</span></span><br><span class="line"><span class="comment">内存元素的初始化值为：不能调用，否则会报错</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>​</p><h4 id="F-数组的内存分析-1"><a href="#F-数组的内存分析-1" class="headerlink" title="F.数组的内存分析"></a>F.数组的内存分析</h4><p><img src="/imgs/image-20220531093430105.png" alt="image-20220531093430105"></p><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p>​引用数据类型变量的值要么是null，要么是一个地址值。</p><h3 id="④数组练习"><a href="#④数组练习" class="headerlink" title="④数组练习"></a>④数组练习</h3><h4 id="练习一"><a href="#练习一" class="headerlink" title="练习一"></a>练习一</h4><p><img src="/imgs/image-20220531120947255.png" alt="image-20220531120947255"></p><p>​解释：</p><p>​x是一维数组，y是二维数组。进行赋值时，要么两个变量的类型一样，要么满足自动转换或进行强制转换。</p><p>​a) y是一维数组，x[0]是一个int型数据，两者类型不一样，不能进行赋值。</p><p>​b) x是一维数组，y[0]也是一维数组，所以可以赋值。</p><p>​c) x是一维数组，y【0】【0】是int型数据，两者类型不一样，不能进行赋值。</p><p>​d) x是一维数组，不存在x【0】【0】</p><p>​e) x[0]是int型数据，y【0】【0】也是int型数据，两者类型一样，可以赋值。</p><p>​f) x是一维数组，y是二维数组，两者类型不一样，不可以赋值。</p><h3 id="⑤数组中涉及的常见算法"><a href="#⑤数组中涉及的常见算法" class="headerlink" title="⑤数组中涉及的常见算法"></a>⑤数组中涉及的常见算法</h3><h4 id="A-数组元素的赋值（会在面试中以手写的形式考察）"><a href="#A-数组元素的赋值（会在面试中以手写的形式考察）" class="headerlink" title="A.数组元素的赋值（会在面试中以手写的形式考察）"></a>A.数组元素的赋值（会在面试中以手写的形式考察）</h4><p>​a.杨辉三角</p><p><img src="/imgs/image-20220531151342121.png" alt="image-20220531151342121"></p><p>​代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//先把数组的框搭建起来</span></span><br><span class="line">    <span class="type">int</span>[][] yanghui = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>][];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; yanghui.length;i++) &#123;</span><br><span class="line">        yanghui[i] = <span class="keyword">new</span> <span class="title class_">int</span>[i+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//为数组里的每个元素赋值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; yanghui.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; yanghui[i].length;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">0</span> || j == (yanghui[i].length-<span class="number">1</span>)) &#123;</span><br><span class="line">                yanghui[i][j] = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                yanghui[i][j] = (yanghui[i-<span class="number">1</span>][j] +                                           yanghui[i-<span class="number">1</span>][j-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历输出数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; yanghui.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; yanghui[i].length;j++) &#123;</span><br><span class="line">            System.out.print(yanghui[i][j] + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p><p>​b.回形数</p><h4 id="B-求数值型数组中元素的最大值、最小值、平均数、总和等"><a href="#B-求数值型数组中元素的最大值、最小值、平均数、总和等" class="headerlink" title="B.求数值型数组中元素的最大值、最小值、平均数、总和等"></a>B.求数值型数组中元素的最大值、最小值、平均数、总和等</h4><p>​题目要求：定义一个int型的一维数组，包含10个元素，分别赋一些随机整数，然后求出所有元素的最大值，最小值，和值，平均值，并输出出来。所有随机数都是两位数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; arr.length;i++) &#123;</span><br><span class="line">        arr[i] = (<span class="type">int</span>)(Math.random() * <span class="number">90</span> + <span class="number">10</span>);</span><br><span class="line">        System.out.print(arr[i] + <span class="string">&quot; &quot;</span>);<span class="comment">//输出该数组</span></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">    <span class="comment">//求数组里的最大值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; max) &#123;</span><br><span class="line">            max = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;该数组的最大值为：&quot;</span> + max);</span><br><span class="line">    <span class="comment">//求数组里的最小值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; min) &#123;</span><br><span class="line">            min = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;该数组的最小值为：&quot;</span> + min);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//求数组的总和</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        sum += arr[i]; </span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;该数组的总和为：&quot;</span> + sum);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//求数组的平均数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">avg</span> <span class="operator">=</span> sum / arr.length;</span><br><span class="line">    System.out.println(<span class="string">&quot;该数组的平均数为：&quot;</span> + avg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="C-数组的复制、反转、查找（线性查找、二分法查找（会在面试中考察））"><a href="#C-数组的复制、反转、查找（线性查找、二分法查找（会在面试中考察））" class="headerlink" title="C.数组的复制、反转、查找（线性查找、二分法查找（会在面试中考察））"></a>C.数组的复制、反转、查找（线性查找、二分法查找（会在面试中考察））</h4><p>​<strong>复制</strong>：</p><p>​将arr1数组复制到arr2数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr1 = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span>[] arr2;</span><br><span class="line">arr2 = arr1;<span class="comment">//这种操作不能称作数组的“复制”。因为arr2指向的是arr1数组。</span></span><br><span class="line"><span class="comment">//数组的复制：</span></span><br><span class="line">arr2 = <span class="keyword">new</span> <span class="title class_">int</span>[arr1.length];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; arr2.length;i++)&#123;</span><br><span class="line">    arr2[i] = arr1[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p><p>​<strong>反转</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr1 = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//中间变量</span></span><br><span class="line">    <span class="comment">//对数组进行反转</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr1.length / <span class="number">2</span>; i++) &#123;</span><br><span class="line">        temp = arr1[i];</span><br><span class="line">        arr1[i] = arr1[arr1.length - <span class="number">1</span> - i];</span><br><span class="line">        arr1[arr1.length - <span class="number">1</span> - i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对反转后的数组进行输出</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr1.length; i++) &#123;</span><br><span class="line">        System.out.print(arr1[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;<span class="comment">//结果为：6 5 4 3 2 1 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​<strong>查找</strong>：(两种基本的查找方式：线性查找、二分查找(此方法常用))</p><p>​①线性查找：(即：从前往后一个一个进行查找)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">String[] arr = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;aa&quot;</span>,<span class="string">&quot;bb&quot;</span>,<span class="string">&quot;cc&quot;</span>&#125;;</span><br><span class="line"><span class="type">String</span> <span class="variable">dest</span> <span class="operator">=</span> <span class="string">&quot;bb&quot;</span>;<span class="comment">//查找对象</span></span><br><span class="line"><span class="comment">//从前往后遍历数组，看是否找到查找对象</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; arr.length;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(dest.equals(arr[i]))&#123;</span><br><span class="line">        <span class="comment">//dest.equals(字符串A)的作用是判断dest字符串是否与字符串A相等，如果相等返回true，不相等返回false。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;找到了指定的元素，位置为：&quot;</span>+i);</span><br><span class="line">        <span class="keyword">break</span>;<span class="comment">//找到之后就退出for循环       </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i == arr.length - <span class="number">1</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;找不到指定的元素&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​总结：</p><p>​如果想比较两个字符串是否相等，可以使用字符串变量里的equals方法，如果相等，则返回true，不相等，则返回false。</p><hr><p>​②二分法查找：(即：折半查找)</p><p>​前提：<strong>所要查找的数组必须要有序。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">24</span>,<span class="number">56</span>,<span class="number">77</span>&#125;;</span><br><span class="line">    <span class="type">int</span> <span class="variable">dest</span> <span class="operator">=</span> <span class="number">12</span>;<span class="comment">//查找目标</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">head</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//初始的首索引</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> arr.length - <span class="number">1</span>;<span class="comment">//初始的尾索引</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isFlag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//二分查找</span></span><br><span class="line">    <span class="keyword">while</span>(head &lt;= end) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> (head + end) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (dest == arr[middle]) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;找到了指定的元素，位置为：&quot;</span> + middle);</span><br><span class="line">            isFlag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dest &gt; arr[middle]) &#123;</span><br><span class="line">            head = middle + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            end = middle - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isFlag) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;找不到指定的元素&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p><h4 id="D-数组元素的排序算法（会在面试中考察）"><a href="#D-数组元素的排序算法（会在面试中考察）" class="headerlink" title="D.数组元素的排序算法（会在面试中考察）"></a>D.数组元素的排序算法（会在面试中考察）</h4><p>​排序不仅出现在整型、浮点型数据中，还可以出现在字符串、字符、对象(根据对象的某个属性进行排序)中。</p><p><img src="/imgs/image-20220601104231814.png" alt="image-20220601104231814"></p><p>​说明：红色字体：要求会手写；黄色字体：要求知道其算法思想。其他了解。</p><p>​①冒泡排序（时间复杂度为：o(n^2)）</p><p>​算法思想：如果想得到一个升序数组。从下标为0的元素开始比较，如果左边的数比右边的数大，则交换，经过一轮后得到一个最大值，然后进行进行下一轮比较，以此类推。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">1</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//中间变量</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">比较轮数 i = 元素个数-1</span></span><br><span class="line"><span class="comment">如果 i 的初始值为1，j的初始值为0，则：</span></span><br><span class="line"><span class="comment">每轮的比较次数 j = 元素个数 - 当前轮数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="comment">//冒泡排序(求升序)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt; arr.length;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; arr.length - i;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//循环输出数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        System.out.print(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​②快速排序（面试前再看）</p><p>​时间复杂度为：</p><p><img src="/imgs/image-20220601181008081.png" alt="image-20220601181008081"></p><p>​算法思想：以求升序为例。每次选数组的第一个元素作为基准，比基准小的数放到右边，比基准大的数放左边，此轮结束后，就会形成两个分区，再分别对这两个分区进行以上操作，直到分区中只有一个元素为止。如：</p><p><img src="/imgs/image-20220601175408022.png" alt="image-20220601175408022"></p><p>​③堆排序（面试前再看，问思想）</p><p>​④归并排序（面试前再看，问思想）</p><h4 id="E-算法学习网址"><a href="#E-算法学习网址" class="headerlink" title="E.算法学习网址"></a>E.算法学习网址</h4><p><a href="https://visualgo.net/zh/sorting">https://visualgo.net/zh/sorting</a></p><hr><h3 id="⑥数组工具类的使用"><a href="#⑥数组工具类的使用" class="headerlink" title="⑥数组工具类的使用"></a>⑥数组工具类的使用</h3><p>​使用下列方法之前要先写：java.util.Arrays;<img src="/imgs/image-20220601203908582.png" alt="image-20220601203908582"></p><h4 id="A-判断两个数组是否相等"><a href="#A-判断两个数组是否相等" class="headerlink" title="A.判断两个数组是否相等"></a>A.判断两个数组是否相等</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法为：Arrays.equals(数组名1,数组名2);</span></span><br><span class="line"><span class="comment">//例子：</span></span><br><span class="line"><span class="type">int</span> <span class="variable">arr1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="variable">arr2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isEquals</span> <span class="operator">=</span> Arrays.equals(arr1,arr2);</span><br><span class="line"><span class="comment">//如果两个数相等，则返回true，不相等，则返回false。</span></span><br></pre></td></tr></table></figure><h4 id="B-输出数组信息"><a href="#B-输出数组信息" class="headerlink" title="B.输出数组信息"></a>B.输出数组信息</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法为：Arrays.toString(数组名);</span></span><br><span class="line"><span class="comment">//例子：</span></span><br><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">1</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>&#125;;</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br><span class="line"><span class="comment">//注意：Arrays.toString(arr)要放在System.out.println()里不然输出不了结果</span></span><br></pre></td></tr></table></figure><p>​输出结果为：</p><p><img src="/imgs/image-20230424175428237.png" alt="image-20230424175428237"></p><h4 id="C-将数组里的值全替换成某个数"><a href="#C-将数组里的值全替换成某个数" class="headerlink" title="C.将数组里的值全替换成某个数"></a>C.将数组里的值全替换成某个数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法为：Arrays.fill(数组名, 替换成的值);</span></span><br><span class="line"><span class="comment">//例子：</span></span><br><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">1</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>&#125;;</span><br><span class="line">System.out.println(<span class="string">&quot;原来的结果为：&quot;</span> + Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line"><span class="comment">//替换操作：</span></span><br><span class="line">Arrays.fill(arr, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;替换后的结果为：&quot;</span>+Arrays.toString(arr));</span><br></pre></td></tr></table></figure><p>​运行结果为：</p><p><img src="/imgs/image-20230424175515300.png" alt="image-20230424175515300"></p><h4 id="D-对数组进行升序排序"><a href="#D-对数组进行升序排序" class="headerlink" title="D.对数组进行升序排序"></a>D.对数组进行升序排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法为：Arrays.sort(数组名);</span></span><br><span class="line"><span class="comment">//例子：</span></span><br><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">1</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>&#125;;</span><br><span class="line">System.out.println(<span class="string">&quot;排序前：&quot;</span> + Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">Arrays.sort(arr);<span class="comment">//其用的是快速排序</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;排序后：&quot;</span> + Arrays.toString(arr));</span><br></pre></td></tr></table></figure><p>​运行结果为：</p><p><img src="/imgs/image-20230424175526483.png" alt="image-20230424175526483"></p><h4 id="E-二分法查找指定的值"><a href="#E-二分法查找指定的值" class="headerlink" title="E.二分法查找指定的值"></a>E.二分法查找指定的值</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法为：Arrays.binarySearch(数组名, 查找值);</span></span><br><span class="line"><span class="comment">//注意：使用该方法前数组一定要是有序的。</span></span><br><span class="line"><span class="comment">//例子：</span></span><br><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Arrays.binarySearch(arr, <span class="number">5</span>);</span><br><span class="line"><span class="comment">//如果找不到该指定值，则返回一个负数；找到该指定值，则返回该值的索引</span></span><br><span class="line">System.out.println(index);<span class="comment">//结果为：4</span></span><br></pre></td></tr></table></figure><h3 id="⑦数组使用中的常见异常"><a href="#⑦数组使用中的常见异常" class="headerlink" title="⑦数组使用中的常见异常"></a>⑦数组使用中的常见异常</h3><p>​一旦程序出现异常，未处理时，程序就终止执行。</p><h4 id="A-数组角标越界的异常"><a href="#A-数组角标越界的异常" class="headerlink" title="A.数组角标越界的异常"></a>A.数组角标越界的异常</h4><p>​报错为：<strong>ArrayIndexOutOfBoundsException</strong></p><p>​只要超出了数组的下标范围，都算越界。如：</p><p><img src="/imgs/image-20220601213934234.png" alt="image-20220601213934234"></p><h4 id="B-空指针异常"><a href="#B-空指针异常" class="headerlink" title="B.空指针异常"></a>B.空指针异常</h4><p>​报错为：<strong>NullPointerException</strong></p><p>​<strong>什么为空指针异常：</strong>如：A.方法或A.其他东西，A为null时，就会出现空指针异常。</p><p>​情况一：arr没有指向内存中的数组，此时还去调用数组中元素时就会报空指针异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">arr = <span class="literal">null</span>;</span><br><span class="line">System.out.println(arr[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><p>​情况二：arr[]没有指向内存中的数组，此时还去调用数组中元素时就会报空指针异常。<img src="/imgs/image-20220601220925018.png" alt="image-20220601220925018"></p><p>​情况三：引用类型变量的值为null时，还去调用该变量对应的方法，就会报空指针异常。</p><h3 id="⑧补充"><a href="#⑧补充" class="headerlink" title="⑧补充"></a>⑧补充</h3><p>A.数组还可以这么写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line"><span class="type">int</span>[][] b = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>&#125;&#125;;</span><br></pre></td></tr></table></figure><p>B.如果某个方法的参数为Objecct[ ] 类型的，那么传递的参数可以是Objecct[ ] 的子类，如：String[ ] 。因为String[ ] 里每个元素为String类型，Object[ ] 里每个元素为Object类型，String 是 Object 的子类，所以String[ ] 就是Objecct[ ] 的子类。</p><hr><h2 id="9、面向对象"><a href="#9、面向对象" class="headerlink" title="9、面向对象"></a>9、面向对象</h2><h3 id="①面向过程与面向对象的解释"><a href="#①面向过程与面向对象的解释" class="headerlink" title="①面向过程与面向对象的解释"></a>①面向过程与面向对象的解释</h3><p>​      <strong>面向过程</strong>，强调的是功能行为，以函数为最小单位，<strong>考虑怎么做</strong>。</p><p>​  <strong>面向对象</strong>，将功能封装进对象，强调具备了功能的对象，以类&#x2F;对象为最小单位，<strong>考虑谁来做</strong>。</p><h3 id="②类与对象"><a href="#②类与对象" class="headerlink" title="②类与对象"></a>②类与对象</h3><h4 id="A-引言"><a href="#A-引言" class="headerlink" title="A.引言"></a>A.引言</h4><p>​设计类，其实就是设计类的成员。类的成员主要包括：属性和方法。</p><p>​属性 &#x3D; 成员变量 &#x3D; field &#x3D; 域、字段</p><p>​方法 &#x3D; 成员方法 &#x3D; 函数 &#x3D; method</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">补充：</span></span><br><span class="line"><span class="comment">成员变量：</span></span><br><span class="line"><span class="comment">位置:定义在类里方法外</span></span><br><span class="line"><span class="comment">注意:不用初始化,也会自动被初始化成默认值</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">局部变量：</span></span><br><span class="line"><span class="comment">位置:定义在方法里或者方法的声明上</span></span><br><span class="line"><span class="comment">注意:必须手动初始化来分配内存.如:int i = 5;或者int i;i = 5;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="B-类与对象的使用"><a href="#B-类与对象的使用" class="headerlink" title="B.类与对象的使用"></a>B.类与对象的使用</h4><p>​<strong>创建对象的格式：</strong></p><p>​类名 对象名 &#x3D; new 类名();</p><p>​<strong>使用对象的方法、属性的格式：</strong></p><p>​对象名.属性;</p><p>​对象名.方法;</p><p>​<strong>补充：</strong></p><p>如果创建了一个类的多个对象，则每个对象都独立的拥有一套类的属性和方法。（这里说的属性是非static的）。这意味着：如果我们修改一个对象的属性a，则不影响另外一个对象属性a的值。</p><h4 id="C-对象的内存解析"><a href="#C-对象的内存解析" class="headerlink" title="C.对象的内存解析"></a>C.对象的内存解析</h4><p>​下图是jvm里真实的内存结构：</p><img src="/imgs/image-20230424175831095.png" alt="image-20230424175831095" style="zoom:67%;" /><p>​<strong>方法区</strong>：存放类信息、常量、静态变量（又称静态域）等</p><p>​<strong>虚拟机栈</strong>：即平时我们认识中的栈。其用于存放局部变量。</p><p>​<strong>堆</strong>：存放new结构的东西。</p><p>​<strong>补充：</strong></p><p>​方法中定义的变量都是局部变量，局部变量存放在虚拟机栈中。成员变量存放在堆空间里的对象实体中。例子：</p><img src="/imgs/image-20230424175842925.png" alt="image-20230424175842925" style="zoom:67%;" /><h4 id="D-属性与局部变量的对比"><a href="#D-属性与局部变量的对比" class="headerlink" title="D.属性与局部变量的对比"></a>D.属性与局部变量的对比</h4><p>​<strong>相同点：</strong></p><p>​①格式相同：数据类型 变量名 &#x3D; 变量值</p><p>​②都要先声明，后使用</p><p>​③都有其对应的作用域</p><p>​<strong>不同点：</strong></p><p>​<strong>A. 在类中声明的位置不同</strong></p><p>​①属性（即：成员变量）定义在类里，方法外面。</p><p>​②局部变量：定义在方法内、方法形参、代码块内、构造器形参、构造器内部的变量</p><p>​<strong>B. 权限修饰符不同</strong></p><p>​①属性：可以在声明属性时，指明其权限，在数据类型前添加权限修饰符。</p><p>​常用的权限修饰符有：private、public、缺省（即不添加权限修饰符的情况）、protected等。</p><p>​权限修饰符的作用：说明变量的作用域（到封装的时会详细说明权限修饰符）。</p><p>​</p><p>​②局部变量：不可以使用权限修饰符。</p><p>​<strong>C. 默认初始化值的情况</strong></p><p>​<strong>属性：</strong></p><p>​都有默认初始化值（与一维数组的默认初始化值情况是一样的）。</p><p>​整型（byte、short、int、long）: 0</p><p>​浮点型（float、double）: 0.0</p><p>​字符型（char）: ASCII为零的字符</p><p>​布尔型（boolean）: false</p><p>​引用数据类型（类、数组、接口）：null</p><p>​<strong>局部变量</strong>：没有默认初始化值。</p><p>​这意味着，我们在调用局部变量之前，一定要显式赋值。</p><p>​特别地：形参在调用时，我们赋值即可。</p><p>​<strong>D. 在内存中存放的位置不同</strong></p><p>​<strong>属性：</strong>存放到堆空间里的对象实体中（注意：这里的属性是非静态的（即非static））</p><p>​<strong>局部变量：</strong>存放在栈空间中。</p><h4 id="E-类中方法的声明和使用"><a href="#E-类中方法的声明和使用" class="headerlink" title="E.类中方法的声明和使用"></a>E.类中方法的声明和使用</h4><p>​<strong>①方法的声明：</strong></p><p>​<strong>格式：</strong>权限修饰符 返回值类型 方法名 (形参列表){</p><p>​方法体</p><p>​}</p><p>​<strong>注意：</strong>方法一定会有上面的几个部分。，部分方法除了有上面几个部分外还会有关键字：static、final、abstract来修饰，而这些关键字的修饰，后面再讲。</p><p>​<strong>说明：</strong></p><p>​<strong>A. 关于权限修饰符</strong></p><p>​Java规定的4种权限修饰符：private、public、缺省、protected –&gt; 关于权限修饰符的使用，在封装性再细讲。</p><p>​<strong>B. 关于返回值类型</strong></p><p>​<strong>①如果有返回值</strong>，则必须在方法声明时，指定返回值的类型。同时，方法中，使用return关键字来<strong>返回指定类型</strong>的变量或常量。注意：if(age &gt; 18){return name;};这种情况会报错，因为当age &lt;&#x3D; 18时，没有返回值。</p><p>​<strong>②如果没有返回值</strong>，在方法声明时使用void来表示。一般不使用return，如果使用的话只能是 “ return;”，表示结束此方法。</p><p>​<strong>补充：</strong></p><p>​我们定义方法该不该有返回值？</p><p>​①看题目要求</p><p>​②凭经验：具体问题具体分析</p><p>​<strong>C. 关于参数列表</strong></p><p>​形参列表中<strong>可以声明0个，1个，或多个形参。</strong></p><p>​<strong>格式：</strong>数据类型1 形参1，数据类型2 形参2，…..</p><p>​<strong>注意：</strong>不能对形参进行赋值</p><p>​<strong>什么时候需要参数列表呢？</strong>当该方法需要外界传递东西时，就要定义形参。</p><p>​<strong>②return关键字的使用：</strong></p><p>​<strong>A.使用范围：</strong>使用在方法体中</p><p>​<strong>B.作用：</strong>①结束方法</p><p>​  ②针对有返回值的方法，返回对应数据。</p><p>​<strong>C.注意：</strong>return后不能声明执行语句。</p><p>​<strong>③补充：</strong></p><p>​A.方法的使用中，可以调用当前类的属性或方法。</p><p>​方法A和B在同一个类里，当静态方法A想调用非静态方法B时，就要在方法A中声明一个对象，然后通过对象调用B方法。其他情况则可以直接调用。</p><p>​B.方法中不可以定义方法。</p><p>​C.对象.方法或方法里调方法都是按就近原则调用。</p><h4 id="F-练习"><a href="#F-练习" class="headerlink" title="F.练习"></a>F.练习</h4><p>​<strong>练习一：</strong></p><p><img src="/imgs/image-20220606212906530.png" alt="image-20220606212906530"></p><p><img src="/imgs/image-20220606212853259.png" alt="image-20220606212853259"></p><p>​运行结果为：</p><p><img src="/imgs/image-20220606213505702.png" alt="image-20220606213505702"></p><p>​<strong>总结：</strong>当执行到s1.study()时，study方法里又使用了name属性，那这个name是谁的呢？是s1调用了study方法，所以这个name是s1的name。</p><p>​<strong>练习二</strong>：</p><p>​<strong>题目：</strong><img src="/imgs/image-20220607192023640.png" alt="image-20220607192023640"></p><p>​<strong>代码实现：</strong></p><p><img src="/imgs/image-20220607195654949.png" alt="image-20220607195654949"></p><p><img src="/imgs/image-20220607195331972.png" alt="image-20220607195331972"></p><p>​要求1：打印出3年级的学生信息。</p><p><img src="/imgs/image-20220607193726589.png" alt="image-20220607193726589"></p><p>​要求2：使用冒泡排序按学生成绩排序，并遍历所有学生信息。</p><p><img src="/imgs/image-20220607194116215.png" alt="image-20220607194116215"></p><p>​<strong>内存解析：</strong></p><p><img src="/imgs/image-20220607201514107.png" alt="image-20220607201514107"></p><p>​<strong>总结：</strong></p><p>​当要求创建多个对象时，这样做：</p><p>​①创建该类的数组，如上图第10行代码</p><p>​②创建对象，即让数组元素指向对象实体。如上图第11、12行代码</p><p>​③数组元素.属性或数组元素.方法。如：上图第13-15行代码</p><p>​<strong>练习三</strong>：</p><p>​将功能封装到方法中，可用使main方法中的代码更简洁，同时可用提高代码的复用性（即可以在其他任意一个类中使用该类的方法）。</p><hr><h3 id="③理解”万事万物皆对象“"><a href="#③理解”万事万物皆对象“" class="headerlink" title="③理解”万事万物皆对象“"></a>③理解”万事万物皆对象“</h3><ul><li><p>在Java语言范畴中，我们都将功能（即方法）、结构（即属性）等封装到类中，通过类的实例化，来调用具体的功能结构。</p></li><li><p>涉及到Java 语言与前端HTML、后端的数据库交互时，前后端的结构在Java层面交互时，都体现为类、对象。</p></li></ul><h3 id="④匿名对象的使用"><a href="#④匿名对象的使用" class="headerlink" title="④匿名对象的使用"></a>④匿名对象的使用</h3><p>​A.理解：我们创建的对象，没有显示的赋给一个变量。即为匿名对象。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">people</span>();<span class="comment">//这就是使用了匿名对象</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">people</span>().eat();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">people</span>().age = <span class="number">10</span>;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">people</span>().age);<span class="comment">//此行代码在堆空间中又新建了一个对象实体，所以不是10而是0。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">people</span>&#123;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">char</span> sex;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;吃饭啦&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​运行结果：</p><p><img src="/imgs/image-20220609195708147.png" alt="image-20220609195708147"></p><p>​</p><p>​在实际开发中会像下面那样使用匿名对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">PhoneMall</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PhoneMall</span>();</span><br><span class="line">        p1.show(<span class="keyword">new</span> <span class="title class_">Phone</span>());<span class="comment">//使用匿名对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PhoneMall</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(Phone phone)</span> &#123;</span><br><span class="line">        phone.sendEmail();</span><br><span class="line">        phone.playGame();</span><br><span class="line">        <span class="comment">//这时候上面两个方法使用的对象都是同一个对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span>&#123;</span><br><span class="line">    <span class="type">double</span> price;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;发送邮件&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">playGame</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;玩游戏&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="⑤方法的重载"><a href="#⑤方法的重载" class="headerlink" title="⑤方法的重载"></a>⑤方法的重载</h3><h4 id="A-定义"><a href="#A-定义" class="headerlink" title="A.定义"></a>A.定义</h4><p>​在<strong>同一个类</strong>中，允许存在一个以上的<strong>同名方法</strong>，只要它们的<strong>参数个数、参数顺序或者参数类型不同即可</strong>。（不满足定义那就不属于重载）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">顺口溜：</span><br><span class="line">   两同一不同：同一个类、同一个方法名</span><br><span class="line">   数列表不同：参数个数不同，参数类型不同，参数顺序不同</span><br></pre></td></tr></table></figure><p>​如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="comment">//以才两个方法构成了重载</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">char</span>[] arr)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//以才两个方法构成了重载</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">char</span>[] arr1，<span class="type">int</span>[] arr2)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] arr1，<span class="type">char</span>[] arr2)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="B-判断是否是重载"><a href="#B-判断是否是重载" class="headerlink" title="B.判断是否是重载"></a>B.判断是否是重载</h4><p>​跟方法的权限修饰符、返回值类型、形参变量名、方法体都没有关系。</p><h3 id="⑥可变参数个数的方法"><a href="#⑥可变参数个数的方法" class="headerlink" title="⑥可变参数个数的方法"></a>⑥可变参数个数的方法</h3><h4 id="A-格式"><a href="#A-格式" class="headerlink" title="A.格式"></a>A.格式</h4><p>​数据类型 … 形参名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">    <span class="comment">//使用了可变参数个数的方法：</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">(<span class="type">int</span> ... a)</span> &#123;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="B-使用"><a href="#B-使用" class="headerlink" title="B.使用"></a>B.使用</h4><p>​其实“int … a”就像一个一维数组，int 为数组的类型，a就是数组名。因此可变参数个数的使用方法就像使用数组一样，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line">        p1.tset(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tset</span><span class="params">(<span class="type">int</span> ... a)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; a.length;i++) &#123;</span><br><span class="line">            System.out.println(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​运行结果：</p><p><img src="/imgs/image-20220610094333302.png" alt="image-20220610094333302"></p><h4 id="C-说明"><a href="#C-说明" class="headerlink" title="C.说明"></a>C.说明</h4><p>​①当调用可变个数形参的方法时，<strong>传入的参数个可以是0个、1个、2个</strong>。。。。</p><p>​②可变个数形参的方法与本类中方法名相同，形参不同的方法之间构成重载。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">    <span class="comment">//使用了可变参数个数的方法：</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">(<span class="type">int</span> ... a)</span> &#123;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">(<span class="type">int</span> a)</span> &#123;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​③在jdk5.0之前，想使用可变个数形参的方法得像下面一样做：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="type">Phone</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>();</span><br><span class="line">       </span><br><span class="line">       p1.sendEmail(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line">    <span class="comment">//jdk5.0之前使用可变参数个数的方法：</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">(<span class="type">int</span>[] a)</span> &#123;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//jdk5.0之后使用可变参数个数的方法：</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendEmail</span><span class="params">(<span class="type">int</span> ... a)</span> &#123;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​所以jdk5.0之前的可变参数个数方法与jdk5.0之后的可变参数个数方法（也就是A中的格式）之间不构成重载。换句话说，也就是它俩不能同时出现。</p><p>​④可变参数只能放在参数列表的末尾。</p><p>​⑤参数列表中只能有一个可变参数。</p><hr><h3 id="⑦方法参数的值传递机制"><a href="#⑦方法参数的值传递机制" class="headerlink" title="⑦方法参数的值传递机制"></a>⑦方法参数的值传递机制</h3><h4 id="A-形参与实参"><a href="#A-形参与实参" class="headerlink" title="A.形参与实参"></a>A.形参与实参</h4><p>​<strong>形参</strong>：方法定义时，声明的小括号内的参数。</p><p>​<strong>实参</strong>：方法调用时，实际传递给形参的数据。</p><h4 id="B-值传递机制"><a href="#B-值传递机制" class="headerlink" title="B.值传递机制"></a>B.值传递机制</h4><p>​如果参数是<strong>基本数据类型</strong>，此时实参赋给形参的是实参真实存储的<strong>数据值</strong>。</p><p>​如果参数是<strong>引用数据类型</strong>，此时实参赋给形参的是实参存储数据的<strong>地址值</strong>。</p><h4 id="C-练习-1"><a href="#C-练习-1" class="headerlink" title="C.练习"></a>C.练习</h4><p>​练习一：见如下网址中的“2.关于方法形参的传递机制：值传递”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://blog.csdn.net/Hhuaahua/article/details/108149332</span><br></pre></td></tr></table></figure><p>​总结：</p><p>​方法A想通过调用方法B来交换方法A中两个变量i、j的值。如果i、j为基本数据类型，那是无法通过方法B进行交换的；如果i、j为引用数据类型变量，那方法B可以通过接收这两个变量的地址，进而交换这两个变量的值。</p><p>​练习二：见如下网址中的“2.关于方法形参的传递机制：值传递”下面的例题</p><hr><h3 id="⑧递归方法"><a href="#⑧递归方法" class="headerlink" title="⑧递归方法"></a>⑧递归方法</h3><p>​    <strong>定义：</strong>一个方法体内调用它自身。</p><p>​递归就像循环，它会重复执行某行代码，但这种重复执行无须循环控制。<strong>递归一定要向已知方向递归</strong>（即要向递归出口方向递归），否则这种递归就变成无穷递归，类似于死循环。</p><p>​    <strong>例子：</strong>求1-n自然数的和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Hello</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hello</span>();</span><br><span class="line">        System.out.println(test.getSum(<span class="number">100</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//求1-n自然数的和</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> n + getSum(n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果为5050</span></span><br></pre></td></tr></table></figure><hr><h3 id="⑨构造器-或构造方法"><a href="#⑨构造器-或构造方法" class="headerlink" title="⑨构造器(或构造方法)"></a>⑨构造器(或构造方法)</h3><h4 id="A-构造器的作用"><a href="#A-构造器的作用" class="headerlink" title="A.构造器的作用"></a>A.构造器的作用</h4><p>​①创建对象</p><p>​Person p &#x3D; new <u>Person()</u>，横线部分就是构造器。</p><p>​②初始化对象的属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">ublic <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">People</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">People</span>(<span class="number">10</span>,<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        <span class="type">People</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">People</span>();</span><br><span class="line">        </span><br><span class="line">        System.out.println(p1.age + <span class="string">&quot; &quot;</span> + p1.name);</span><br><span class="line">        <span class="comment">//结果：10 Tom</span></span><br><span class="line">        System.out.println(p2.age + <span class="string">&quot; &quot;</span> + p2.name);</span><br><span class="line">        <span class="comment">//结果：18 null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>&#123;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器：</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">People</span><span class="params">(<span class="type">int</span> n,String s)</span> &#123;</span><br><span class="line">        age = n;</span><br><span class="line">        name = s;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">People</span><span class="params">()</span> &#123;</span><br><span class="line">        age = <span class="number">18</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="B-说明"><a href="#B-说明" class="headerlink" title="B.说明"></a>B.说明</h4><p>​①如果没有显示定义类的构造器的话， 则系统默认提供一个空参的构造器，而<strong>构造器的权限与类的权限相同</strong>。</p><p>​②定义<strong>构造器</strong>的<strong>格式：</strong><code>权限修饰符 类名(形参列表) &#123; &#125;</code> ，如：public Person() {}</p><p>​③一个类中可以定义多个构造器，彼此构成重载。</p><p>​④一个类中，至少会有一个构造器。</p><h4 id="C-注意-1"><a href="#C-注意-1" class="headerlink" title="C.注意"></a>C.注意</h4><p>​①一旦显式的定义了类的构造器之后，系统就不再提供默认的空参构造器。</p><p>​②<strong>只要造对象，就一定会用构造器。</strong></p><h3 id="⑩属性赋值的先后顺序"><a href="#⑩属性赋值的先后顺序" class="headerlink" title="⑩属性赋值的先后顺序"></a>⑩属性赋值的先后顺序</h3><ul><li>赋值的位置：<br>  ① 默认初始化<br>  ② 显式初始化 &#x2F; ⑤ 在代码块中赋值<br>  ③ 构造器中初始化<br>  ④ 通过“对象.属性“或“对象.方法”的方式赋值</li><li>赋值的先后顺序：<br>  ① - ② &#x2F; ⑤ - ③ - ④<br>  ②和⑤取决于在声明的先后顺序，值取后面的。</li></ul><h3 id="11-、JavaBean"><a href="#11-、JavaBean" class="headerlink" title="(11)、JavaBean"></a>(11)、JavaBean</h3><h4 id="A-定义-1"><a href="#A-定义-1" class="headerlink" title="A.定义"></a>A.定义</h4><p>​JavaBean是一种Java语言写成的可重用组件。</p><h4 id="B-组成"><a href="#B-组成" class="headerlink" title="B.组成"></a>B.组成</h4><p>​满足以下要求的类都叫JavaBean</p><ul><li>类是公共的</li><li>有一个<u>无参</u>的<u>公共</u>的构造器</li><li>有属性，且有对应的get、set方法</li></ul><p>​</p><h3 id="12-、关键字"><a href="#12-、关键字" class="headerlink" title="(12)、关键字"></a>(12)、关键字</h3><h4 id="A-this关键字"><a href="#A-this关键字" class="headerlink" title="A.this关键字"></a>A.this关键字</h4><p>​①引入：当方法中形参名与属性名同名时，为了区分它俩，我们需要在<strong>属性前加this关键字。</strong></p><p>​<strong>②格式</strong>：<strong>this.属性</strong>或<strong>this.方法</strong></p><p>​<strong>③this关键字可以修饰属性、方法。</strong></p><p>​A.在类的方法中，我们使用this关键字修饰属性或方法时：</p><p>​this关键字可以理解为：当前对象的</p><p>​B.在类的构造器中，我们使用this关键字修饰属性或方法时：</p><p>​this关键字可以理解为：当前创建的对象</p><p>​<strong>④this关键字可以修饰构造器</strong></p><p>​<strong>this关键字调用构造器的意义：</strong></p><p>​当构造器B与构造器A中存在相同的代码时，为了减少冗余，我们可以使用“this(形参列表)”方式来调用构造器A。</p><p>​<strong>A.<strong>我们在类的构造器中，可以显示的使用“this(形参列表)”方式，来调用本类中指定的</strong>其他</strong>构造器。</p><p>​**B.**构造器中不能通过“this(形参列表)”方式调用自己。</p><p>​**C.**构造器A调用了构造器B，那么构造器B就不能调用构造器A，不然会出现死循环。</p><p><img src="/imgs/image-20220615103209747.png" alt="image-20220615103209747"></p><p>​**D.**规定：</p><p>​①“this(形参列表)”必须声明在当前构造器的首行。</p><p>​②构造器内部，<strong>最多只能声明一个“this(形参列表)”</strong>，用来调用其他的构造器。</p><p>​⑤补充：当单独使用“this”时（如：27行代码），其代表：当前对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Boy</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Boy</span>();</span><br><span class="line">        b1.name = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Girl</span> <span class="variable">g1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Girl</span>();</span><br><span class="line">        g1.name = <span class="string">&quot;Jelly&quot;</span>;</span><br><span class="line"></span><br><span class="line">        b1.shout(g1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shout</span><span class="params">(Boy boy)</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;也喜欢&quot;</span> + boy.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Boy</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shout</span><span class="params">(Girl girl)</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;喜欢&quot;</span> + girl.name);</span><br><span class="line">        <span class="comment">//下面的“this”代表当前对象，即：谁调用当前shout方法，那这个对象就是谁</span></span><br><span class="line">        girl.shout(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​运行结果：</p><p><img src="/imgs/image-20230424175953797.png" alt="image-20230424175953797"></p><p>​⑥练习：当类中的属性为自定义类类型时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        p1.name = <span class="string">&quot;x&quot;</span>;</span><br><span class="line">        p1.car = <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br><span class="line">        p1.car.setColour(<span class="string">&quot;白色&quot;</span>);</span><br><span class="line">        p1.car.setCarBrand(<span class="string">&quot;BMW&quot;</span>);</span><br><span class="line">        p1.car.setPlateNumber(<span class="string">&quot;xxxxxx&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;恭喜&quot;</span> + p1.name + <span class="string">&quot;先生喜提一辆车牌为&quot;</span> + p1.car.getPlateNumber() + p1.car.getColour() + p1.car.getCarBrand());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    Car car;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String colour;<span class="comment">//颜色</span></span><br><span class="line">    <span class="keyword">private</span> String plateNumber;<span class="comment">//车牌</span></span><br><span class="line">    <span class="keyword">private</span> String carBrand;<span class="comment">//车的品牌</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setColour</span><span class="params">(String colour)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.colour = colour;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getColour</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> colour;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPlateNumber</span><span class="params">(String plateNumber)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.plateNumber = plateNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPlateNumber</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> plateNumber;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCarBrand</span><span class="params">(String carBrand)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.carBrand = carBrand;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCarBrand</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> carBrand;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​运行结果为：</p><img src="/imgs/image-20230424180253252.png" alt="image-20230424180253252" style="zoom:80%;" /><p>​该程序的内存图为：</p><img src="/imgs/image-20230424180454832.png" alt="image-20230424180454832" style="zoom:80%;" /><hr><h4 id="B-package关键字"><a href="#B-package关键字" class="headerlink" title="B.package关键字"></a>B.package关键字</h4><p>​①引入</p><p>​为了更好的实现项目中类的管理，提供了包的概念。</p><p>​②package的使用</p><p>​A.使用packet 声明类或接口所属的包，声明在源文件的首行。</p><p>​B.每“.”一次，就代表一层文件目录。如：</p><img src="/imgs/image-20230424180526015.png" alt="image-20230424180526015" style="zoom:80%;" /><p>​C.同一个包下，不能命名同名的接口、类。不同的包可以。</p><p>​D.JDK中主要的包介绍：</p><p><img src="/imgs/image-20220617102357409.png" alt="image-20220617102357409"></p><hr><h4 id="C-import关键字"><a href="#C-import关键字" class="headerlink" title="C.import关键字"></a>C.import关键字</h4><p>​①在源文件中使用import显式的导入指定包下的类或接口。</p><p>​②声明在包的声明和类的声明之间。</p><p>​③如果需要导入多个类或接口，那么就并列显式多个import语句即可。</p><p>​④举例：可以使用java.util.*的方式，一次性导入util包下所有的类或接口。</p><p>​⑤如果使用的类或接口是java.lang包下定义的，则可以省略import结构。</p><p>​⑥使用同一包下的类或接口时，就不用导入包下的类或接口；而使用其他包下的类或接口时，就需要导入指定包下的类或接口（是否需要导入，与权限修饰符无关）。</p><p>​⑦如果在源文件中，使用了不同包下的同名的类，则必须至少有一个类需要以全类名的方式显示。如：</p><p><img src="/imgs/image-20220617144515659.png" alt="image-20220617144515659"></p><p>​⑧使用“xxx.*”方式表明可以调用xxx包下爱的所有结构。但是如果使用的是xxx子包下的结构，则仍需显式导入。</p><hr><h3 id="13-、面向对象综合练习"><a href="#13-、面向对象综合练习" class="headerlink" title="(13)、面向对象综合练习"></a>(13)、面向对象综合练习</h3><h4 id="综合练习一的总结"><a href="#综合练习一的总结" class="headerlink" title="综合练习一的总结"></a>综合练习一的总结</h4><p>1、当类中的属性为数组时，一定要在使用该数组属性前初始化该数组，可通过对象.属性或构造器的方式声明该数组，如：</p><p><img src="file:///C:\Users\橙子\AppData\Local\Temp\ksohtml244844\wps1.jpg" alt="img"> </p><p>2、删除数组元素的操作：</p><p><img src="/imgs/image-20220625154001373.png" alt="image-20220625154001373"></p><h3 id="14-、类的成员之四：代码块-或初始化块"><a href="#14-、类的成员之四：代码块-或初始化块" class="headerlink" title="(14)、类的成员之四：代码块(或初始化块)"></a>(14)、类的成员之四：代码块(或初始化块)</h3><h4 id="A-引入"><a href="#A-引入" class="headerlink" title="A.引入"></a>A.引入</h4><p>​<strong>格式：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态代码块</span></span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">    <span class="comment">//代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非静态代码块</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​<strong>作用：</strong><u>用来初始化类、对象</u></p><p>​<strong>修饰符：</strong>如果有修饰符的话，只能使用static</p><p>​<strong>分类：</strong>静态代码块、非静态代码块</p><h4 id="B-静态代码块"><a href="#B-静态代码块" class="headerlink" title="B.静态代码块"></a>B.静态代码块</h4><p>​①内部可以有输出语句</p><p>​②随着类的加载而执行，而且只执行一次（补充：使用类的时候就会加载类）</p><p>​③作用：初始化类的信息</p><p>​④如果一个类中定义了多个静态代码块，则按照声明的先后顺序执行</p><p>​⑤静态代码块的执行要优先于非静态代码块的执行</p><p>​⑥静态代码块只能调用静态的属性、静态的方法，不能调用非静态的属性、方法</p><h4 id="C-非静态代码块"><a href="#C-非静态代码块" class="headerlink" title="C.非静态代码块"></a>C.非静态代码块</h4><p>​①内部可以有输出语句</p><p>​②随着对象的创建而执行</p><p>​③每创建一个对象，就执行一次非静态代码块</p><p>​④作用：可以创建对象时，对对象的属性等进行初始化</p><p>​⑤如果一个类中定义了多个非静态代码块，则按照声明的先后顺序执行</p><p>​⑥非静态代码块内可以调用静态的属性、静态的方法、或非静态的属性、或非静态的方法</p><h4 id="D-静态代码块、非静态代码块及构造器三者的执行顺序"><a href="#D-静态代码块、非静态代码块及构造器三者的执行顺序" class="headerlink" title="D.静态代码块、非静态代码块及构造器三者的执行顺序"></a>D.静态代码块、非静态代码块及构造器三者的执行顺序</h4><p>​由父及子，先执行静态代码块，静态代码块执行完后，回到父类，先执行非静态代码块再执行构造器，然后到子类，也是先执行子类的非静态代码块，再执行子类的构造器，直到最后一个子类的非静态代码块和构造器执行完。</p><hr><h3 id="15-类的成员之五：内部类-了解"><a href="#15-类的成员之五：内部类-了解" class="headerlink" title="(15)类的成员之五：内部类(了解)"></a>(15)类的成员之五：内部类(了解)</h3><h4 id="A-引入-1"><a href="#A-引入-1" class="headerlink" title="A.引入"></a>A.引入</h4><p>​如类A中需声明一个结构，但这结构用属性来刻画会不完整，因此就得造个类B来描述这个结构，但只有类A调用类B其他类不会去调用，所以就将类B放到类A中变成一个内部类。类A称为外部类。</p><p>​<strong>分类：</strong>成员内部类（静态的、非静态的）、局部内部类（声明在方法内、构造器内、代码块内）</p><h4 id="B-成员内部类"><a href="#B-成员内部类" class="headerlink" title="B.成员内部类"></a>B.成员内部类</h4><p>​①一方面，作为外部类的成员：</p><ul><li>调用外部类的结构，如：属性、方法、构造器等。</li><li>可以被static修饰。被static修饰之后只能调用静态的结构了。</li><li>可以被4种不同的权限修饰（public、缺省、protected、private）</li></ul><p>​②另一方面，作为一个类：</p><ul><li>可以在内部定义属性、方法、构造器等结构；</li><li>可以声明为abstract类 ，表明该类不能造对象</li><li>可以声明为final的，不被继承。不声明为final则，可以被继承</li></ul><p>​</p><h4 id="C-开发中局部内部类的使用"><a href="#C-开发中局部内部类的使用" class="headerlink" title="C.开发中局部内部类的使用"></a>C.开发中局部内部类的使用</h4><p>​局部内部类最常见的用法：返回一个实现某个接口的类的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line"><span class="comment">//返回一个实现Comparable接口的类的对象</span></span><br><span class="line"><span class="keyword">public</span> Comparable <span class="title function_">getComparable</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyComparable</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyComparable</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p><p>​注意点：</p><p>​在局部内部类的方法中（如：show方法）如果调用局部内部类所声明的方法（比如：method方法）中的局部变量（比如：num）的话，要求此局部变量声明为final的。jdk 7及之前版本：要求此局部变量显示的声明为final的；jdk 8及之后的版本：可以省略final的声明，但实际上还是存在final。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//局部变量</span></span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(num);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="D-如何实例化成员内部类的对"><a href="#D-如何实例化成员内部类的对" class="headerlink" title="D.如何实例化成员内部类的对"></a>D.如何实例化成员内部类的对</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//创建Dog实例（静态的成员内部类）</span></span><br><span class="line">InnerClass.<span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InnerClass</span>.Dog();</span><br><span class="line">dog.method1();</span><br><span class="line"><span class="comment">//创建Bird实例（非静态的成员内部类）</span></span><br><span class="line"><span class="type">InnerClass</span> <span class="variable">innerClass</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InnerClass</span>();</span><br><span class="line">InnerClass.<span class="type">Bird</span> <span class="variable">bird</span> <span class="operator">=</span> innerClass.<span class="keyword">new</span> <span class="title class_">Bird</span>();</span><br><span class="line">bird.method();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InnerClass</span>&#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;小鸟唱歌&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Dog</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;汪汪汪&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p><h4 id="E-如何在成员内部类中区分调用外部类的结构（没重名可以直接调用这些结构。如果重名见下面代码）"><a href="#E-如何在成员内部类中区分调用外部类的结构（没重名可以直接调用这些结构。如果重名见下面代码）" class="headerlink" title="E.如何在成员内部类中区分调用外部类的结构（没重名可以直接调用这些结构。如果重名见下面代码）"></a>E.如何在成员内部类中区分调用外部类的结构（没重名可以直接调用这些结构。如果重名见下面代码）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Outer</span> <span class="variable">outer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">Outer.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> outer.<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">inner.mb(<span class="number">333</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">111</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">222</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mb</span><span class="params">(<span class="type">int</span> s)</span> &#123;</span><br><span class="line">System.out.println(s); <span class="comment">//方法形参s</span></span><br><span class="line">System.out.println(<span class="built_in">this</span>.s); <span class="comment">// 内部类的属性s</span></span><br><span class="line">System.out.println(Outer.<span class="built_in">this</span>.s); <span class="comment">//外部类属性s</span></span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="10、面向对象三大特性"><a href="#10、面向对象三大特性" class="headerlink" title="10、面向对象三大特性"></a>10、面向对象三大特性</h2><h3 id="①封装与隐藏"><a href="#①封装与隐藏" class="headerlink" title="①封装与隐藏"></a>①封装与隐藏</h3><h4 id="A-问题的引入"><a href="#A-问题的引入" class="headerlink" title="A.问题的引入"></a>A.问题的引入</h4><p>​当我们创建一个类的对象以后，我们可以通过“对象.属性”的方式，对对象的属性进行赋值。这里，赋值操作要受到属性的数据类型和存储范围的制约。除此之外，没有其他制约条件。但是，在实际问题中，我们往往需要给属性赋值加入额外的限制条件。这个条件就不能在属性声明时体现，我们只能通过方法进行限制条件的添加（比如：setAge()）。同时，我们需要避免用户再使用“对象.属性”的方式对属性进行赋值。则需要将属性声明为私有的（即：private）。–&gt; 上面对属性的操作就体现了封装性。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">People</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">People</span>();</span><br><span class="line">        p1.setAge(<span class="number">10</span>);</span><br><span class="line">        System.out.println(p1.getAge());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> temp)</span> &#123;</span><br><span class="line">        age = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="B-封装性的体现"><a href="#B-封装性的体现" class="headerlink" title="B.封装性的体现"></a>B.封装性的体现</h4><p>​我们将类的属性xxx私有化（private），同时，提供公共的（public）方法来获取（getXxx）和设置（setXxx）此属性的值。如：上面第10-18行代码。</p><p>​<strong>注意：</strong>这只是封装性的一种体现，并不等同于封装性。封装性的体现还包括：不对外暴露的私有方法，单例模式等等。</p><p>​<strong>补充：</strong>属性被私有化后，该类内的方法还是可以直接使用该私有属性的。</p><h4 id="C-四种权限修饰符"><a href="#C-四种权限修饰符" class="headerlink" title="C.四种权限修饰符"></a>C.四种权限修饰符</h4><p>​<strong>引入：</strong>封装性的体现，需要权限修饰符来配合。</p><p>​<strong>Java规定的4种权限（从小到大排列）</strong></p><p>​private、缺省、protected、public</p><p><img src="/imgs/image-20220613105013420.png" alt="image-20220613105013420"></p><h4 id="D-四种权限的使用"><a href="#D-四种权限的使用" class="headerlink" title="D.四种权限的使用"></a>D.四种权限的使用</h4><p>​①4种权限<strong>可以用来修饰类及类的内部结构</strong>：<strong>属性、方法、构造器、内部类</strong>（<strong>注意：</strong>不能修饰代码块）</p><p>​②具体的，4种权限都可以用来修饰类的内部结构：<strong>属性、方法、构造器、内部类</strong></p><p>​<strong>修饰类</strong>的话，<strong>只能</strong>使用：<strong>缺省、public</strong></p><p>​③Java权限修饰符置于类的成员定义前，用来限定对象对该类成员的访问权限。</p><h4 id="E-总结封装性"><a href="#E-总结封装性" class="headerlink" title="E.总结封装性"></a>E.总结封装性</h4><p>​Java提供了4种权限修饰符来修饰类及类的内部结构，体现类及类的内部结构在被调用时的可见性的大小</p><p>​①<strong>属性</strong>及<strong>方法</strong>被各权限修饰符修饰时：</p><table><thead><tr><th align="center">权限</th><th align="center">类内</th><th align="center">同一个包内的类</th><th align="center">不同包内的子类</th><th align="center">同一个工程的类</th></tr></thead><tbody><tr><td align="center">private</td><td align="center">直接使用</td><td align="center">不可以调用</td><td align="center">不可以调用</td><td align="center">不可以调用</td></tr><tr><td align="center">缺省</td><td align="center">直接使用</td><td align="center">可以通过对象调用</td><td align="center">不可以调用</td><td align="center">不可以调用</td></tr><tr><td align="center">protected</td><td align="center">直接使用</td><td align="center">可以通过对象调用</td><td align="center">可以通过对象调用</td><td align="center">不可以调用</td></tr><tr><td align="center">public</td><td align="center">直接使用</td><td align="center">可以通过对象调用</td><td align="center">可以通过对象调用</td><td align="center">可以通过对象调用</td></tr></tbody></table><p>​注意:</p><p>​被protect修饰的属性和方法，此时想调用这些结构的类A与这些结构所在的类B处于不同包下，此时如果类A是类B的子类，则可以调用类B中被protect修饰的属性和方法；否则，不能调用被protect修饰的属性和方法。如果类A与类B在同一个包下，类A是不是类B的子类都可以使用这些结构。</p><p>​②当<strong>类被public修饰</strong>时：代表该类在此项目内可以。</p><p>​当<strong>类被缺省修饰</strong>时：代表该类只能在当前包内使用。</p><h4 id="F-补充"><a href="#F-补充" class="headerlink" title="F.补充"></a>F.补充</h4><p>​同一个包内不可以定义同名类，不同包下可以定义同名类。</p><hr><h3 id="②继承性"><a href="#②继承性" class="headerlink" title="②继承性"></a>②继承性</h3><h4 id="A-问题的引入-1"><a href="#A-问题的引入-1" class="headerlink" title="A.问题的引入"></a>A.问题的引入</h4><p>​现在有类A，类A中有一些方</p><p>法和属性，准备创建一个类B，类B中有些方法和属性与类A的一样，这时我们就可以使用继承性，让类B继承类A，这样类B就不用再写这些相同的方法和属性了。</p><h4 id="B-继承性的好处"><a href="#B-继承性的好处" class="headerlink" title="B.继承性的好处"></a>B.继承性的好处</h4><ul><li>减少了代码的冗余，提高了代码的复用性。</li><li>便于功能的扩展。(后期需在子类中添加相同的功能时，只需在父类添加即可，不用在每个子类中添加)</li><li>为之后多态性的使用提供了前提。</li></ul><h4 id="C-继承性的格式"><a href="#C-继承性的格式" class="headerlink" title="C.继承性的格式"></a>C.继承性的格式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">B</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​其中：A被称为子类、派生类、subclass；B被称为父类、超类、基类、superclass</p><h4 id="D-说明"><a href="#D-说明" class="headerlink" title="D.说明"></a>D.说明</h4><p>​①一旦子类A继承父类B以后，子类A就获取了父类B中声明的所有的属性和方法。特别的，父类中声明为private的属性或方法，子类继承父类后，仍然认为获取了父类中的私有结构。只是因为封装性影响，使得子类不能直接调用父类的结构而已（但可通过父类中的get、set方法来使用）。</p><p>​②子类继承父类之后，还可以声明自己特有的属性或方法，实现功能扩展。</p><p>​③extends的含义：延展、扩展</p><p>​④子类继承了父类的属性后，在堆空间中，子类的对象实体中会有父类的属性（父类的private属性也在里面）。</p><p>​⑤子类继承父类的属性和方法后，子类就拥有了这些属性和方法，但子类能不能用呢？还得看父类中这些属性和方法的权限大小。</p><h4 id="E-继承性的规则"><a href="#E-继承性的规则" class="headerlink" title="E.继承性的规则"></a>E.继承性的规则</h4><p>​①一个类可以被多个子类继承。</p><p>​②Java中类的单继承性：一个类只能有一个父类。</p><p>​③子父类是相对的概念。</p><p>​④子类直接继承的父类，称为：直接父类。间接继承的父类成为：间接父类。</p><p>​⑤子类继承父类以后，就获取了直接父类以及所有间接父类中声明的属性和方法。</p><h4 id="F-继承练习"><a href="#F-继承练习" class="headerlink" title="F.继承练习"></a>F.继承练习</h4><p>​子类继承了父类，那么就可以在子类里使用父类的属性和方法了，但如果使用父类中的私有属性，只能通过get、set方法调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Cylinder</span> <span class="variable">cylinder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cylinder</span>();</span><br><span class="line">        <span class="type">double</span> <span class="variable">findVolume</span> <span class="operator">=</span> cylinder.findVolume();</span><br><span class="line">        System.out.println(<span class="string">&quot;圆柱的面积为：&quot;</span> + findVolume);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findArea</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3.14</span> * a * a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Cylinder：圆柱</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cylinder</span> <span class="keyword">extends</span> <span class="title class_">Circle</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//计算圆柱体积</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findVolume</span><span class="params">()</span>&#123;</span><br><span class="line">        a = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">return</span> findArea() * length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​运行结果为：</p><p><img src="/imgs/image-20220704170523651.png" alt="image-20220704170523651"></p><h4 id="G-重写"><a href="#G-重写" class="headerlink" title="G.重写"></a>G.重写</h4><p>​重写实际上就是将父类中被重写的方法覆盖掉。</p><p>​<strong>引入：</strong></p><p>​当子类继承父类后，发现需要对父类中的某个方法进行修改，此时我们就可以在子类中使用重写的方式将父类中的同名同参方法<strong>覆盖</strong>掉。</p><p>​<strong>运用：</strong></p><p>​①子类重写父类的方法A后，通过子类调用方法A时，执行的是子类中重写的方法。</p><p>​②在实际开发中，子类重写的方法的声明与父类被重写的方法的声明一样。（即：直接将父类中被重写的方法的声明复制到子类中）</p><p>​<strong>规则：</strong></p><p>​①子类重写的方法的方法名和形参列表与父类被重写的方法的方法名和形参列表相同。</p><p>​②子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符。</p><p>​特别的：子类<strong>不能重写</strong>父类中声明为<strong>private权限的方法。</strong></p><p>​    ③返回值类型：</p><p>​A.父类被重写的方法的返回值类型是void，则子类重写的方法的返回值类型只能是void。</p><p>​B.父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是A类或A类的子类。</p><p>​补充：①.方法的返回值类型可以是基本数据类型，可以是 类 类型（return写的是该类的实例对象）。</p><p>​   ②.如果父类中被重写的方法的返回值类型为：Object类 类型，则子类重写的方法的返回值类型可以是Object类 类型也可以是Object类 类型的子类，如：String类型等。</p><p>​C.父类被重写的方法的返回值类型是基本数据类型，则子类重写的方法的返回值类型必须是相同的基本数据类型。</p><p>​④子类重写的方法抛出的异常不能大于父类被重写的方法抛出的异常类型，最小的异常是没有异常，因此子类重写的方法中也可以不写“throws+异常类型”。（在异常处理的时候补充）</p><p>​</p><p>​<strong>额外说明：</strong></p><p>​子类与父类中的同名同参数的方法要么都声明为非static的(考虑重写)，要么都声明为static的（不是重写）。</p><p>​被static修饰的方法不能被重写。</p><hr><h4 id="H-Super关键字"><a href="#H-Super关键字" class="headerlink" title="H.Super关键字"></a>H.Super关键字</h4><p>​<strong>引言：</strong></p><p>​子类重写了父类的方法，此时父类的方法就被覆盖掉了，如果子类中还想调用父类中被重写的方法，那就得使用Super关键字了。</p><p>​<strong>Super关键字的使用：调用属性和方法</strong></p><p>​A.super理解为：父类的…….</p><p>​B.super可以用来调用：属性、方法、构造器</p><p>​C.super的使用</p><p>​①当子父类出现同名属性时，可以用super表明调用的是父类中的属性（super.属性）。</p><p>​②子类中想调用父类中被重写的方法，可以使用”super.方法”的方式调用。</p><p>​<strong>Super的使用：调用构造器</strong></p><p>​A.我们可以在子类的构造器中显式的使用”super(形参列表)”的方式，调用父类中声明的指定的构造器。</p><p>​B.”super(形参列表)”必须声明在子类构造器的首行！</p><p>​C.我们在类的构造器中，针对于”this(形参列表)”或”super(形参列表)”只能二选一，不能同时出现。（因为他们都得放在首行）</p><p>​D.在子类构造器的首行，没有显式的声明“this（形参列表）”或“super（形参列表）”，则默认调用的是父类中空参的构造器super()。若父类中又没有无参的构造器，则编译出错。</p><p>​E.如果有n个构造器，则最多有n-1个构造器使用this关键字调用其他构造器，至少有一个构造器使用super关键字调用父类的构造器。</p><p>​<strong>补充注意：</strong>没有<strong>super.super</strong>。类C直接父类为类B，间接父类为类A，类B重写了类A中的toString方法，而类C想调用间接父类中的toString方法，此时不能通过super来调用了，只能在间接父类中再声明一个方法（将重写的toString方法的内容写在这里，然后toString方法调用该方法），然后类C调用直接父类中的该方法即可。</p><hr><h4 id="I-子类对象实例化的全过程"><a href="#I-子类对象实例化的全过程" class="headerlink" title="I.子类对象实例化的全过程"></a>I.子类对象实例化的全过程</h4><p>​①从结果上看（继承性）</p><p>​子类继承父类以后，就获取了父类中声明的属性或方法。创建子类的对象，在堆空间中，就会加载所有父类中声明的属性。</p><p>​②从过程上看</p><p>​当我们通过子类的构造器创建子类对象时，我们一定会直接或间接的调用其父类的构造器，进而调用父类的父类构造器……直到调用了java.lang.Object类中的空参构造器为止。<strong>正因为加载过所有的父类的结构，所以才可以看到内存中有父类中的结构</strong>，子类对象才可以考虑进行调用。</p><hr><h4 id="J-Object类"><a href="#J-Object类" class="headerlink" title="J.Object类"></a>J.Object类</h4><p>​<strong>引入：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如果没有显式的声明一个类的父类的话，则此类继承于Java.lang.Object类。</span><br><span class="line">所有类（除Java.lang.Object类之外）都继承于Java.lang.Object类。这意味着，所有的Java类具有Java.lang.Object类声明的功能。</span><br></pre></td></tr></table></figure><p>​<strong>Object类是所有类的根父类</strong></p><p>​<strong>说明：</strong></p><p>​Objecct类里没有声明属性，声明了一个空参构造器，声明了一些方法。</p><p>​<strong>Object类中常用的方法：</strong></p><p>​<strong>①equals()</strong></p><p>​equals()和&#x3D;&#x3D;的区别：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">==的使用：</span><br><span class="line">①可以使用在基本数据类型变量和引用数据类型变量中</span><br><span class="line">②如果比较的是基本数据类型变量，比较两个变量保存的数据是否相等（不一定类型相同）</span><br><span class="line">如果比较的是引用数据类型变量，比较两个对象的地址值是否相等，即两个引用是否指向同一个对象实体</span><br><span class="line"></span><br><span class="line">补充：==符号使用时。必须保证符号左右两边的变量类型一致。</span><br><span class="line"></span><br><span class="line">equals()方法的使用：</span><br><span class="line">①其是一个方法，而非运算符。所以只能适用于引用数据类型</span><br><span class="line">②Object类中定义的equals()和==的作用相同，比较两个对象的地址值是否相同，即两个引用是否指向同一个对象实体。</span><br><span class="line">③像String、Date、File、包装类等都重写了Object类中的equals()方法。重写以后，比较的不是两个引用的地址是否相同，而是比较两个对象的“实体内容”是否相同。</span><br><span class="line">④通常情况下，我们自定义的类如果使用equals()的话，也通常是比较两个对象的“实体”内容是否相同（通常比较两个对象的属性值是否相等）。那么，我们就需要对Object类中的equals()进行重写。</span><br><span class="line"></span><br><span class="line">总结：</span><br><span class="line">涉及到基本数据类型用“==”，引用数据类型用“equals()”</span><br></pre></td></tr></table></figure><p>​如果想重新Object类中的equals()方法，我们通常调用现成的equals()方法。步骤为：Source–&gt;生成hashCode()和equals()–&gt;选择需要比较的属性–&gt;点击OK即可。</p><p>​如果手写（不推荐，因为逻辑上不够严谨），其格式大概为：（主要目的：熟悉一下格式，为后续的集合做准备）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;<span class="comment">//自定义一个类</span></span><br><span class="line">    <span class="type">int</span> orderId;</span><br><span class="line">    String orderName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> <span class="comment">//重写equals方法</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span> == obj)  <span class="comment">//1.比较两者地址是否相同</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> Order) <span class="comment">//2.若地址不同，判断两者是否同一类型</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> (Order)obj; <span class="comment">//3.向下转型，为了调用子类的属性和方法</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//正确的：</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.orderId == order.orderId &amp;&amp; </span><br><span class="line">                <span class="built_in">this</span>.orderName.equals(order.orderName); <span class="comment">//4.比较子类的属性的“内容”而不是地址</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//错误的：</span></span><br><span class="line">            <span class="comment">//return this.orderId == order.orderId &amp;&amp;</span></span><br><span class="line">            <span class="comment">//this.orderName == order.orderName;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​<strong>equals()练习：</strong></p><p>​练习1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">System.out.println(s1.equals(s2));<span class="comment">//true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​练习2：如果类A中的属性有自定义类 类型，那么比较两个类A的对象是否相等是，要这样做：</p><p><img src="/imgs/image-20220712130432093.png" alt="image-20220712130432093"></p><p>​<strong>②toString()</strong></p><p>​1.<strong>当我们输出一个对象的引用时，实际上就是调用当前对象的toString()方法。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">System.out.println(p1);</span><br><span class="line">System.out.println(p1.toString);</span><br><span class="line"><span class="comment">//第3、4行代码输出的内容是一样的，因此它们实际上是等价的</span></span><br></pre></td></tr></table></figure><p>​2.Object类中toString()方法输出的是该对象的地址值（地址值中包含对象的类型和虚拟地址）</p><p>​3.像 File、String、Date及包装类（Wrapper Class）等来说，重写了toString()方法，使得调用toString()方法时输出不是地址值而是“实体内容”信息（即输出对象的属性）。</p><p>​4.自定义类也可以重写toString()方法，当调用此方法时，返回对象的“实体内容”。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Source--&gt; 生成toString()--&gt; 选择要输出的属性--&gt; 点击OK即可重写toString()方法</span><br><span class="line">注：使用系统提供重写的toString()方法，只能输出其类所拥有的属性（不包括静态变量）</span><br></pre></td></tr></table></figure><h4 id="K-继承中的this关键字"><a href="#K-继承中的this关键字" class="headerlink" title="K.继承中的this关键字"></a>K.继承中的this关键字</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getA</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Man</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getA</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Man</span> <span class="variable">m1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Man</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> m1.getA();</span><br><span class="line">        System.out.println(a);</span><br><span class="line">        <span class="comment">//输出2；如果没有第八行，则输出结果为1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​总结：在继承关系中，子类使用”this.属性”或”this.方法”，都会先观察子类中是否有该属性、方法。如果有，则使用这些属性和方法；如果没有，则执行父类中的属性和方法。</p><hr><h3 id="③多态性-属于运行时行为）"><a href="#③多态性-属于运行时行为）" class="headerlink" title="③多态性(属于运行时行为）"></a>③多态性(属于运行时行为）</h3><h4 id="A-何为多态性"><a href="#A-何为多态性" class="headerlink" title="A.何为多态性"></a>A.何为多态性</h4><p>​对象的多态性：父类的引用指向子类的对象。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Man</span>();</span><br><span class="line"><span class="comment">//Man为子类，Person为父类</span></span><br></pre></td></tr></table></figure><h4 id="B-多态性的使用"><a href="#B-多态性的使用" class="headerlink" title="B.多态性的使用"></a>B.多态性的使用</h4><p>​虚拟方法调用</p><p>​有了对象的多态性以后，我们在编译期，只能调用父类中声明的方法，但在运行期，我们实际<strong>执行的是子类重写父类的方法。</strong></p><p>​总结：编译看左边；运行，看右边。</p><h4 id="C-多态性的使用前提"><a href="#C-多态性的使用前提" class="headerlink" title="C.多态性的使用前提"></a>C.多态性的使用前提</h4><p>​①有类的继承关系</p><p>​②方法的重写</p><h4 id="D-多态性的好处"><a href="#D-多态性的好处" class="headerlink" title="D.多态性的好处"></a>D.多态性的好处</h4><p>​实现代码的通用性</p><h4 id="E-注意"><a href="#E-注意" class="headerlink" title="E.注意"></a>E.注意</h4><p>​<strong>对象的多态性，只适用于方法，</strong>不适用于属性（编译和运行都看左边）</p><h4 id="F-多态的内存解析"><a href="#F-多态的内存解析" class="headerlink" title="F.多态的内存解析"></a>F.多态的内存解析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Man</span>();</span><br></pre></td></tr></table></figure><p>​堆空间中创建了一个对象实体，该对象实体中有父类的属性，也有子类的属性。方法区当中有父类的方法，也有子类的方法。但由于变量声明为父类类型，导致编译时，只能调用父类中声明的属性和方法。子类特有的属性和方法不能调用。</p><h4 id="G-instanceof-操作符"><a href="#G-instanceof-操作符" class="headerlink" title="G.instanceof 操作符"></a>G.instanceof 操作符</h4><p>​<strong>①引入：</strong>如何才能调用子类特有的方法和属性？</p><p>​<strong>方法：</strong>向下转型，使用强制类型转换符。</p><p><img src="/imgs/image-20220708163545220.png" alt="image-20220708163545220"></p><p>​</p><p>​<strong>使用强转时的内存解析：</strong></p><p><img src="file:///C:\Users\橙子\AppData\Local\Temp\ksohtml249328\wps1.jpg" alt="img"></p><p>​强转后，m1只能使用子类中声明的属性和方法。</p><p>​<strong>instanceof使用情景：</strong></p><p>​使用强转时，可能出现ClassCastException的异常。为了避免出现这种错误，我们引入instanceof关键字，在强转前进行判断。</p><p>​<strong>②instanceof的格式</strong></p><p>​a intanceof  A ：判断父类的引用a是否是类A的实例，是返回true，否则返回false。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Man</span>();</span><br><span class="line"><span class="keyword">if</span>(p1 <span class="keyword">instanceof</span> Man)&#123;<span class="comment">//返回true</span></span><br><span class="line">    <span class="type">Man</span> <span class="variable">m1</span> <span class="operator">=</span> (Man)p1;<span class="comment">//当为true时，就可以进行强</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">为什么返回true？</span></span><br><span class="line"><span class="comment">因为声明多态时，p1指向的是子类Man的对象，所以返回true</span></span><br><span class="line"><span class="comment">p1 instanceof Woman ，返回false</span></span><br><span class="line"><span class="comment">因为声明多态时，p1指向的是子类Man的对象，不是子类Woman的对象所以返回false</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>​如果a instanceof A返回true，则a intanceof B也返回true。其中类B是类A的父类。</p><p>​<strong>③补充：</strong></p><p>​A.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Objecct</span> <span class="variable">ob1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Man</span>();</span><br><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> (Person)ob1;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">强转时，不仅可以转为Man,也可以转为Man的父类Person</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>​Object类、Person类、Man类三者的继承关系：</p><img src="C:\Users\橙子\AppData\Roaming\Typora\typora-user-images\image-20220709110852956.png" alt="image-20220709110852956" style="zoom:50%;" /><p>​B.instanceof的其他含义：</p><p>​a instanceof B，判断a是否是B类 类型，如：c1 instanceof Person，其含义为：判断c1是否是Person类型。</p><p>​C.如何判断a instanceof B是true还是false。</p><p>​已知：对象a属于Person类型。我们拿着Person和B进行对比，如果B也是Person类型或是Person类的父类，则返回true；如果B是Person类的子类，则返回false。</p><p>​D.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="type">Man</span> <span class="variable">m1</span> <span class="operator">=</span> (Man)p1; <span class="comment">//ClassCastException，强转只发生在多态中，第一行代码的声明方式并不属于多态。</span></span><br></pre></td></tr></table></figure><hr><h2 id="11、包装类的使用"><a href="#11、包装类的使用" class="headerlink" title="11、包装类的使用"></a>11、包装类的使用</h2><h3 id="A-JUnit单元测试"><a href="#A-JUnit单元测试" class="headerlink" title="A.JUnit单元测试"></a>A.JUnit单元测试</h3><h4 id="①什么是单元测试"><a href="#①什么是单元测试" class="headerlink" title="①什么是单元测试"></a>①什么是单元测试</h4><p>​对某一部分代码进行测试</p><h4 id="②单元测试的步骤"><a href="#②单元测试的步骤" class="headerlink" title="②单元测试的步骤"></a>②单元测试的步骤</h4><p>​<strong>复杂型：</strong></p><p>​A.选中当前工程，右键选择：build path—add libraries—JUnit 4 —下一步 。</p><p>​B.创建Java 类，进行单元测试。此时的Java类要求：①此类是public的；②此类提供公共的无参构造器。</p><p>​C.此类中声明单元测试方法，方法的权限是public，没有返回值，没有形参。</p><p>​D.此单元测试方法上需要声明注解：@Test，并在单元测试类中导入：import org.junit.Test;</p><p>​E.将需要测试的代码写在单元测试方法里。</p><p>​F.写好代码后，左键双击单元测试方法名，右键 run as — JUnit Test 。</p><p>​G.在JUnit视图中看看结果，执行结果没有任何异常：绿条，反之红条（在红条的下方可以看到异常的原因）。</p><p>​<strong>简单型：</strong></p><p>​    A.创建一个public类</p><p>​B.声明一个测试方法。该方法权限为public，没有返回值，没有形参列表。</p><p>​C.在声明的测试方法上面加上@Test，然后将鼠标放在@Test上，导入相关东西。</p><p>​D.左键双击单元测试方法名，右键 run as — JUnit Test 。</p><h4 id="③说明"><a href="#③说明" class="headerlink" title="③说明"></a>③说明</h4><p>​A.可以在该类中声明多个单元测试方法</p><p>​B.也可以声明属性、其他的方法</p><p>​C.单元测试里如果使用到了Scanner从键盘获取用户输入，用户从键盘是输入不了数据的。输入不了的原因不是代码造成的。如果想输入，只能换成main方法。</p><hr><h3 id="B-包装类"><a href="#B-包装类" class="headerlink" title="B.包装类"></a>B.包装类</h3><h4 id="①引入"><a href="#①引入" class="headerlink" title="①引入"></a>①引入</h4><p>​基本数据类型的功能比较单薄，不可以通过基本数据类型变量来调用方法，因此为了使基本数据类型变量也可以调用对应的方法，我们就将基本数据类型封装到一个类中，这些类就叫：包装类。</p><h4 id="②基本数据类型对应的包装类"><a href="#②基本数据类型对应的包装类" class="headerlink" title="②基本数据类型对应的包装类"></a>②基本数据类型对应的包装类<img src="/imgs/20200826203112117.png" alt="在这里插入图片描述"></h4><p>​注意：数值型的包装类都继承了父类：Number</p><h4 id="③基本数据类型、包装类、String三者之间的相互转换"><a href="#③基本数据类型、包装类、String三者之间的相互转换" class="headerlink" title="③基本数据类型、包装类、String三者之间的相互转换"></a>③基本数据类型、包装类、String三者之间的相互转换</h4><p>​A.基本数据类型–&gt; 包装类，调用包装类的构造器即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">10</span>);</span><br><span class="line">System.out.println(integer.toString);<span class="comment">//10</span></span><br><span class="line"><span class="comment">//System.out.println(integer);       与第二行代码等价</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">System.out.println(integer.toString);<span class="comment">//数字：123</span></span><br></pre></td></tr></table></figure><p>​调用包装类的构造器时，也可以选择形参为String类型的构造器，但要注意引号内只能填纯数字（数值型包装类）。布偶类型的包装类如果选了String形参的构造器，其双引号内写true（不区分大小写），则值为true，写其他的内容，则值为false。</p><p>​应用：当调用方法A，但该方的形参为Object类型，我们又需要把基本数据类型传进去方法中，此时就需要将基本数据类型转换为包装类。</p><p>​B.包装类–&gt; 基本数据类型，调用包装类Xxx的xxxValue()方法</p><p>​如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">10</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> integer.intValue();</span><br></pre></td></tr></table></figure><p>​应用：当需要做基本运算时，就要把包装类转换为基本数据类型</p><p>​</p><p>​C.JFK5.0新特性：：自动装箱与自动拆箱</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自动装箱：基本数据类型--&gt; 包装类的对象，如：</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="comment">//以后基本数据类型--&gt; 包装类，这样写就行，不用像上面那样</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//自动拆箱：包装类--&gt; 基本数据类型，如：</span></span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> integer;</span><br><span class="line"><span class="comment">//以后包装类--&gt; 基本数据类型，这样写就行，不用像上面那样</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> a;</span><br></pre></td></tr></table></figure><p>​</p><p>​D.基本数据类型、包装类–&gt; String类型，调用String重载的valueOf(Xxx xxx)方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> String.valueOf(<span class="number">10</span>);<span class="comment">//&quot;10&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> String.valueOf(integer);<span class="comment">//&quot;10&quot;</span></span><br></pre></td></tr></table></figure><p>​E.String类型–&gt; 基本数据类型、包装类，调用包装类的parseXxx(String s)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> Integer.parseInt(s3);<span class="comment">//数字：123</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;12.6&quot;</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">k</span> <span class="operator">=</span> Double.parseDouble(s4);</span><br><span class="line"><span class="comment">//转换时，要注意字符串要满足转换目标类型的要求，如：</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;123a&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> Integer.parseInt(s1);<span class="comment">//报错：NumberFormatException</span></span><br></pre></td></tr></table></figure><p>​</p><h4 id="④练习"><a href="#④练习" class="headerlink" title="④练习"></a>④练习</h4><p>​练习一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">j</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line">System.out.println(i == j); <span class="comment">//false，“==”比较两个地址是否相同</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">System.out.println(m == n);<span class="comment">//true,</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">System.out.println(x == y);<span class="comment">//false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">第二、三个运行结果为什么是这样？</span></span><br><span class="line"><span class="comment">这是因为，Integer 内部定义了IntegerCache结构，IntegerCache 中定义了数组Integer[ ]，保存了-128~127 范围的整数。如果我们使用自动装箱的方式，给Integer 赋值的范围在-128 ~ 127范围内时，可以直接使用Integer[ ] 中的元素，不必再去new；如果超出了-128~127，则需要new</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">① 在上述第二段代码中，m 和 n 都在-128 ~ 127范围内，且第一次定义m时用了数组元素，用完后不会销毁，所以在定义n时，仍用的是数组里相同的元素，两者地址值相等，所以结果true 。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">② 而在上述第三段代码中，x 和 y 都不在-128 ~ 127范围内，要再new 一个对象，于是分别new 了两个对象，两者地址值不相等，所以结果false 。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>​</p><p>​练习二：</p><p>​有了自动装箱和自动拆箱后，Object类、包装类、基本数据类型类型之间的关系为：</p><img src="C:\Users\橙子\AppData\Roaming\Typora\typora-user-images\image-20220713122621592.png" alt="image-20220713122621592" style="zoom:43%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">Vector</span> <span class="variable">v</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vector</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//v.elementAt()方法接收的是Object类型的形参</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> v.elementAt(i);<span class="comment">//自动转换</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> (<span class="type">int</span>)object;<span class="comment">//强制转换</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    v.addElement(s1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="12、面向对象中的其他关键字"><a href="#12、面向对象中的其他关键字" class="headerlink" title="12、面向对象中的其他关键字"></a>12、面向对象中的其他关键字</h2><h3 id="A-static"><a href="#A-static" class="headerlink" title="A.static"></a>A.static</h3><h4 id="①引入-1"><a href="#①引入-1" class="headerlink" title="①引入"></a>①引入</h4><p>​static：静态的</p><p>​static可以修饰<strong>属性、方法、代码块、内部类</strong>，不能修饰外部类</p><h4 id="②使用static修饰属性：静态变量（又称类变量）"><a href="#②使用static修饰属性：静态变量（又称类变量）" class="headerlink" title="②使用static修饰属性：静态变量（又称类变量）"></a>②使用static修饰属性：静态变量（又称类变量）</h4><p>​**A.**属性按照是否使用 static 修饰，又分为：静态属性（类变量）和非静态属性（实例变量）。</p><p>​<strong>实例变量：</strong><br>​我们创建了类的多个对象，每个对象都独立的拥有一套类中的非静态变量。当修改其中一个对象的非静态属性时，不会导致其他对象中同样的属性值的修改。</p><p>​<strong>静态变量：</strong><br>​我们创建了类的多个对象，多个对象共享一个静态变量。当通过某一个对象修改静态变量时，会导致其他对象调用此静态变量时，是修改过了的。</p><p>​<strong>B.static修饰属性的其他说明</strong></p><p>​①静态变量随着类的加载而加载。可以通过“类.静态变量”的方式进行调用。</p><p>​②静态变量的加载要早于对象的创建。因此也可以通过“对象.静态变量”的方式进行调用。</p><p>​③由于类只会加载一次，则静态变量在内存中也只会存在一份，存在方法区的静态域中。</p><p>​④</p><table><thead><tr><th align="center"></th><th align="center">类变量</th><th align="center">实例变量</th></tr></thead><tbody><tr><td align="center">类</td><td align="center">类.类变量</td><td align="center">不可调用</td></tr><tr><td align="center">对象</td><td align="center">对象.类变量</td><td align="center">对象.实例变量</td></tr></tbody></table><p>​</p><p>​<strong>C.类变量与实例变量内存解析</strong></p><p><img src="/imgs/image-20220714161530481.png" alt="image-20220714161530481"></p><p>​</p><h4 id="③使用static修饰方法：静态方法"><a href="#③使用static修饰方法：静态方法" class="headerlink" title="③使用static修饰方法：静态方法"></a><strong>③使用static修饰方法：静态方法</strong></h4><p>​<strong>A.</strong></p><p>​随着类的加载而加载但不执行，可以通过“类.静态方法”的方式调用</p><p>​<strong>B.</strong></p><table><thead><tr><th align="center"></th><th align="center">静态方法</th><th align="center">非静态方法</th></tr></thead><tbody><tr><td align="center">类</td><td align="center">类名.静态方法</td><td align="center">不可调用</td></tr><tr><td align="center">对象</td><td align="center">对象.静态方法</td><td align="center">对象.非静态方法</td></tr></tbody></table><p>​<strong>C.</strong></p><p>​静态方法中，只能调用静态的方法或属性。如果想调用非静态的属性或方法，只能先创建对象，然后通过对象来调用。</p><p>​非静态方法中，既可以调用非静态的方法或属性，也可以调用静态的方法或属性。</p><h4 id="④static注意点"><a href="#④static注意点" class="headerlink" title="④static注意点"></a><strong>④static注意点</strong></h4><p>​A.在静态方法内，不能使用this 、super 关键字。（此时还没有对象）</p><p>​B.关于静态属性和静态方法的使用，可以从类和对象的生命周期的角度去理解。</p><p>​C.通常类变量都不会放在构造器里。</p><h4 id="⑤如何确定是否使用-static"><a href="#⑤如何确定是否使用-static" class="headerlink" title="⑤如何确定是否使用 static"></a><strong>⑤如何确定是否使用 static</strong></h4><p>​属性：</p><ul><li>属性是可以被多个对象共享的，不会随着对象的不同而不同的。</li><li>类中的常量也常常声明为static。是常量但不加static修饰的情况：每个人的身份证号，不能改但没个人的身份证号又不一样，因此不能加static。</li></ul><p>​方法：</p><ul><li>操作静态属性的方法，通常设置为 static 的。</li><li>工具类中的方法，习惯声明为 static 的。</li></ul><hr><h3 id="B-Static关键字的应用–单例设计模式"><a href="#B-Static关键字的应用–单例设计模式" class="headerlink" title="B.  Static关键字的应用–单例设计模式"></a>B.  Static关键字的应用–单例设计模式</h3><h4 id="①定义"><a href="#①定义" class="headerlink" title="①定义"></a>①定义</h4><p>​<strong>设计模式：</strong></p><p>​是在大量的实践中总结和理论化之后优选的代码结构、编程风格、以及解决问题的思考方式。即：<strong>解决问题的套路</strong></p><p>​<strong>单列设计模式：</strong></p><p>​就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法。</p><p>​<strong>单例设计模式设计思想</strong></p><p>​如果我们要让类在一个虚拟机中只能产生一个对象，我们首先必须将类的构造器的访问权限设置为private，这样，就不能用new操作符在类的外部产生类的对象了，但在类内部仍可以产生该类的对象。因为在类的外部开始还无法得到类的对象，只能调用该类的某个静态方法以返回类内部创建的对象，静态方法只能访问类中的静态成员变量，所以，指向类内部产生的该类对象的变量也必须定义成静态的。</p><h4 id="②实现-饿汉式-amp-懒汉式"><a href="#②实现-饿汉式-amp-懒汉式" class="headerlink" title="②实现(饿汉式&amp;懒汉式)"></a>②实现(饿汉式&amp;懒汉式)</h4><p>​<strong>饿汉式：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bank</span> &#123;   </span><br><span class="line">    <span class="comment">// 1.私有化构造器</span></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">Bank</span><span class="params">()</span>   &#123;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.内部提供一个当前类的实例  </span></span><br><span class="line">    <span class="comment">//4.此实例也必须静态化</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Bank</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bank</span>(); </span><br><span class="line">    </span><br><span class="line">     <span class="comment">// 3.提供公共的静态的方法，返回当前类的对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​<strong>懒汉式：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bank</span>&#123;</span><br><span class="line">    <span class="comment">//1.私有化构造器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Bank</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.声明当前类的对象，没有初始化</span></span><br><span class="line">    <span class="comment">//4.此对象也必须声明为static</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Bank</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.声明public、static的返回当前类对象的方法。效率稍高</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Bank.class)&#123;</span><br><span class="line">            <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">                instance = <span class="keyword">new</span> <span class="title class_">Bank</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    方式一：但效率稍差</span></span><br><span class="line"><span class="comment">    public static synchronized Bank getInstance()&#123;</span></span><br><span class="line"><span class="comment">        if(instance == null)&#123;</span></span><br><span class="line"><span class="comment">            instance = new Bank();</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return instance;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    方式二：但效率稍差</span></span><br><span class="line"><span class="comment">    public static Bank getInstance()&#123;</span></span><br><span class="line"><span class="comment">        synchronized(Bank.class)&#123;</span></span><br><span class="line"><span class="comment">            if(instance == null)&#123;</span></span><br><span class="line"><span class="comment">                instance = new Bank();</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        return instance;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="③饿汉式与懒汉式比较"><a href="#③饿汉式与懒汉式比较" class="headerlink" title="③饿汉式与懒汉式比较"></a>③饿汉式与懒汉式比较</h4><table><thead><tr><th align="center"></th><th align="center">好处</th><th align="center">坏处</th></tr></thead><tbody><tr><td align="center">饿汉式</td><td align="center">线程安全</td><td align="center">对象加载时间过长</td></tr><tr><td align="center">懒汉式</td><td align="center">延迟对象的创建</td><td align="center">无</td></tr></tbody></table><h4 id="④单例模式应用场景-了解"><a href="#④单例模式应用场景-了解" class="headerlink" title="④单例模式应用场景(了解)"></a>④单例模式应用场景(了解)</h4><ul><li><strong>网站的计数器</strong> ，一般也是单例模式实现，否则难以同步。</li><li><strong>应用程序的日志应用</strong> ，一般都使用单例模式实现，这一般是由于共享的日志文件一直处于打开状态，因为只能有一个实例去操作，否则内容不好追加。</li><li><strong>数据库连接池</strong> 的设计一般也是采用单例模式，因为数据库连接是一种数据库资源。</li><li>项目中， <strong>读取配置文件的类</strong> ，一般也只有一个对象。没有必要每次使用配置文件数据，都生成一个对象去读取。</li><li><strong>Application</strong> 也是单例的典型应用。</li><li><strong>Windows的Task Manager (任务管理器)</strong> 就是很典型的单例模式。</li><li><strong>Windows的Recycle Bin (回收站)</strong> 也是典型的单例应用。在整个系统运行过程中，回收站一直维护着仅有的一个实例。</li></ul><hr><h3 id="C-mian-方法的语法-了解"><a href="#C-mian-方法的语法-了解" class="headerlink" title="C.mian()方法的语法(了解)"></a>C.mian()方法的语法(了解)</h3><p>​①作为程序入口</p><p>​②每个类里都可以写main()方法</p><p>​③main()方法也可以看作一个普通的静态方法</p><p>​④当一个源文件里有多个main()方法，当运行时其会让你选择执行哪个main()方法。</p><p>​⑤main()方法可以作为我们与控制台交互的方式。（了解）</p><hr><h3 id="D-final"><a href="#D-final" class="headerlink" title="D.final"></a>D.final</h3><h4 id="①引入-2"><a href="#①引入-2" class="headerlink" title="①引入"></a>①引入</h4><p>​final可以用来修饰的结构：类、方法、变量</p><h4 id="②final-用来修饰一个类（了解）"><a href="#②final-用来修饰一个类（了解）" class="headerlink" title="②final 用来修饰一个类（了解）"></a>②final 用来修饰一个类（了解）</h4><p>​表明此类不能被其它类所继承</p><h4 id="③final-用来修饰方法（了解）"><a href="#③final-用来修饰方法（了解）" class="headerlink" title="③final 用来修饰方法（了解）"></a>③final 用来修饰方法（了解）</h4><p>​表明此方法不能被重写</p><h4 id="④final-用来修饰变量"><a href="#④final-用来修饰变量" class="headerlink" title="④final 用来修饰变量"></a>④final 用来修饰变量</h4><p>​final用来修饰变量，此时“变量”就是一个常量，一但赋值就不能被修改。</p><p>​A.final修饰属性：可以考虑赋值的位置有：显式初始化、代码块中初始化、构造器中初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FinalTest</span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//显示初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> b;</span><br><span class="line">    &#123;</span><br><span class="line">        b=<span class="number">1</span>;</span><br><span class="line">    &#125;<span class="comment">//代码块中初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> c;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FinalTest</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        c=<span class="number">2</span>;</span><br><span class="line">    &#125;<span class="comment">//构造器中初始化</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">那三种情况都可以给常量赋值，在什么情况选哪种赋值情况比较好？</span></span><br><span class="line"><span class="comment">​ 当多个对象的常量值都一样时，可以显式初始化、代码块初始化。</span></span><br><span class="line"><span class="comment">​ 当需要将某个方法的返回值，赋给一个常量时，可以使用代码块初始化、构造器初始化。</span></span><br><span class="line"><span class="comment">​ 当每个对象的常量值都不一样时，可以使用构造器初始化。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>​B.final修饰局部变量：</p><p>​尤其是修饰形参时，表明此形参是一个常量。当我们调用此方法时，给常量形参赋一个实参。一旦赋值以后，就只能在方法体内使用此形参，但不能重新赋值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FinalTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="comment">//a = 20;  会报错，一旦赋值就不能修改其值</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> b)</span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//b = 20;  会报错，一旦赋值就不能修改其值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p><h4 id="⑤static-final"><a href="#⑤static-final" class="headerlink" title="⑤static final"></a>⑤static final</h4><p>​static final 只能用来修饰属性和方法，但用来修饰方法的情况少见。</p><p>​static final 用来修饰属性：全局常量</p><h3 id="E-abstract"><a href="#E-abstract" class="headerlink" title="E.abstract"></a>E.abstract</h3><h4 id="①-引入"><a href="#①-引入" class="headerlink" title="①.引入"></a>①.引入</h4><p>​当父类被多个子类继承时，就很少再通过造父类的对象来调用父类的方法了，因为子类继承了父类的属性和方法。因此可以用<strong>abstract</strong>关键字来修饰父类，表明父类<strong>不可以创建对象了。</strong></p><p>​abstract：抽象的</p><p>​abstract可以用来修饰的结构：类、方法</p><p>​abstract修饰类：抽象类，abstract修饰方法：抽象方法</p><h4 id="②-抽象类"><a href="#②-抽象类" class="headerlink" title="②.抽象类"></a>②.抽象类</h4><p>​①抽象类不能实例化</p><p>​②抽象类中一定有构造器，便于子类的构造器调用父类的构造器。</p><p>​③开发中，都会提供抽象类的子类，让子类实例化，完成相关的操作。</p><h4 id="③-抽象方法"><a href="#③-抽象方法" class="headerlink" title="③.抽象方法"></a>③.抽象方法</h4><p>​A.抽象方法只有方法的声明，没有方法体。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//只有上面的格式才为抽象方法</span></span><br></pre></td></tr></table></figure><p>​B.抽象方法不能被调用。</p><p>​C.包含抽象方法的类，一定是一个抽象类。反之，抽象类中可以没有抽象方法。</p><p>​D.若继承的父类中有抽象方法，则子类要不重写父类（直接父类、间接父类）中所有的抽象方法，此时子类可以实例化；要不不重写父类中抽象的方法，此时子类要声明为abstract的，并不能造子类的对象。</p><h4 id="④-抽象方法的应用"><a href="#④-抽象方法的应用" class="headerlink" title="④.抽象方法的应用"></a>④.抽象方法的应用</h4><p>​如父类中有一个方法A，而子类会重写该方法A，并且不同的子类重写的内容也不一样，父类中的方法A就无法确定其方法体的内容，因此就可以将方法A声明为抽象方法。</p><h4 id="⑤-abstract使用上的注意点"><a href="#⑤-abstract使用上的注意点" class="headerlink" title="⑤.abstract使用上的注意点"></a>⑤.abstract使用上的注意点</h4><p>​A.abstract只能用来修饰类和方法</p><p>​B.abstract不能用来修饰私有方法、静态方法、final的方法、final的类</p><h4 id="⑥-匿名类（看得懂就行）"><a href="#⑥-匿名类（看得懂就行）" class="headerlink" title="⑥.匿名类（看得懂就行）"></a>⑥.匿名类（看得懂就行）</h4><p>​由于抽象类不能实例化，假设 Person 是一个抽象类，那么 Person p&#x3D; new Person (); 是错误的写法，但是 Person p&#x3D; new Person () { }; { }内重写 Person 的抽象方法，此时是不报错的。这时new Person( ){ } 就说创建了一个匿名子类的对象p。（此时类的种类不清楚，但是是 Person 的子类，没有子类名）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">method(s1);</span><br><span class="line"></span><br><span class="line"><span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>() &#123;</span><br><span class="line"><span class="comment">//匿名子类（new Person()&#123;&#125;）。父类引用指向匿名子类的对象 --&gt;多态</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">walk</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;高一（9）班走路&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">method(p2);<span class="comment">//属于多态，因此执行子类中重写的方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Person p)</span> &#123;</span><br><span class="line">p.walk();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">walk</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">walk</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;学生走路&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/imgs/image-20220720162420195.png" alt="image-20220720162420195"></p><p>​实际上，代码3-4和25-29行代码与6-14行代码是等价的。这就体现了匿名子类的意义：不用创建抽象类的子类（25–29行代码）。</p><p>​注意：</p><p>​①使用匿名子类的前提：父类是抽象类</p><p>​②匿名子类如果赋给了一个对象，则可以多次使用该对象，如果没有赋给一个对象，则该匿名子类只能使用一次。</p><p>​补充：（看得懂就行）</p><p><img src="/imgs/image-20220720163742547.png" alt="image-20220720163742547"></p><p>​也可以将匿名子类直接放到方法实参处，这就是匿名子类的匿名对象</p><hr><h4 id="⑦-应用–模板方法设计模式（了解）"><a href="#⑦-应用–模板方法设计模式（了解）" class="headerlink" title="⑦.应用–模板方法设计模式（了解）"></a>⑦.应用–模板方法设计模式（了解）</h4><ul><li>当功能内部一部分实现是确定的，一部分实现是不确定的。这时可以把不确定的部分暴露出去，让子类去实现。</li><li>换句话说，在软件开发中实现一个算法时，整体步骤很固定、通用，这些步骤已经在父类中写好了。但是某些部分易变，易变部分可以抽象出来，供不同子类实现。这就是一种模板模式。</li></ul><h3 id="G-interface-接口"><a href="#G-interface-接口" class="headerlink" title="G.interface(接口)"></a>G.interface(接口)</h3><h4 id="①引入-3"><a href="#①引入-3" class="headerlink" title="①引入"></a>①引入</h4><p>​Java里类只能单继承，但想继承多个类，只能引入接口的概念，有了接口，就可以得到多重继承的效果。</p><p>​有时必须从几个类中抽取一些共同的行为特征，而它们之间又没有is-a关系（即继承关系），仅仅是具有相同的行为特征而已。如：手机、键盘等，它们支持USB连接，手机和USB之间不是继承关系，所以因将USB声明为接口。</p><h4 id="②接口的格式"><a href="#②接口的格式" class="headerlink" title="②接口的格式"></a>②接口的格式</h4><p>​接口使用interface来定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Fly</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">①类与接口之间属于并列关系，一个类可以实现多个接口，实现了某个接口后，类就拥有了接口的功能。实现了接口的类就叫实现类。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">②接口中静态的结构也可以通过接口名调用</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="③-接口定义"><a href="#③-接口定义" class="headerlink" title="③.接口定义"></a>③.接口定义</h4><p>​如何定义接口，定义接口中的成员</p><p>​①JDK7及以前：<strong>只能定义全局常量和抽象方法</strong></p><p>​全局常量：public static final 的，但书写时，可以省略不写。声明时要赋值，不然报错。</p><p>​抽象方法：public abstract的，书写时也可省略不写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Fly</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_SPEED</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">MAX_SPEED</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">    <span class="comment">//public static final可以不写，但实际上还是有的</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>;<span class="comment">//public abstract可以不写，但实际上还是有的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​②JDK8及以后：除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法</p><p>​<strong>静态方法：</strong>接口中定义的静态方法，<strong>只能通过接口名来调用</strong>，其他的调用方式都不行。实现类中继承不了接口中定义的静态方法。</p><p>​<strong>默认方法：</strong>只能<strong>通过实现类的对象来调用</strong>默认方法。默认方法可以在实现类中重写（重写时，default就不用写了），调用时，仍然调用的是重写以后的方法。</p><p>​<strong>其他说明：</strong></p><p>​①类优先原则：如果子类（或实现类）继承的父类和实现的接口中声明了同名同参数的默认方法，那么在子类没有重写此方法的情况下，默认调用的是父类中的同名同参数的方法。—–&gt;类优先原则（只针对方法）</p><p>​②若一个接口中定义了一个默认方法，而另外一个接口中也定义了一个同名同参数的默认方法，在实现类同时实现了这两个接口且没有重写方法时，会出现：<strong>接口冲突</strong>。要想不冲突，只能在实现类中重写此方法。重写之后想调用某个接口的同名同参默认方法，则可以通过“接口名.super.默认方法名”调用</p><p>​③静态方法和默认方法都有方法体</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Fly</span>&#123;</span><br><span class="line">    <span class="comment">//静态方法，public可以省略但实际上还是有的</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>&#123;<span class="comment">//与第3行代码一样</span></span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认方法，default要写出来，public可以省略但实际上还是有的</span></span><br><span class="line"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;<span class="comment">//与11行代码一样</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="④接口的使用"><a href="#④接口的使用" class="headerlink" title="④接口的使用"></a>④接口的使用</h4><p>​A.Java中，<strong>类与接口是并列的两个结构</strong></p><p>​B.接口中不能定义构造器！这意味着接口不可以实例化</p><p>​C.Java开发中，类通过实现（<strong>implements</strong>）的方式使用接口</p><p>​类实现了接口后，就拥有了接口中的所有结构了。</p><p>​①如果实现类（实现接口的类叫实现类）实现了接口中的所有抽象方法，则此实现类就可以造对象</p><p>​②如果实现类没有实现接口中所有的抽象方法，则此实现类仍为一个抽象方法。</p><p>​D.Java中，类可以实现多个接口 –&gt; 弥补了Java单继承性的局限性</p><p>​继承多个接口，接口之间用逗号隔开</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Plane</span> <span class="keyword">implements</span> <span class="title class_">Fly</span>, Attack&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​E.当类中既有继承，又实现了接口，那其格式为：先写继承后写接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Plane</span> <span class="keyword">extends</span> <span class="title class_">TranSport</span> <span class="keyword">implements</span> <span class="title class_">Flyable</span>, Attack&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​F.接口与接口之间为继承关系，而且可以多继承</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">AA</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">BB</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">CC</span> <span class="keyword">extends</span> <span class="title class_">AA</span>, BB&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​补充：类与类之间是继承关系（extends）；类与接口之间是实现关系（implements）；接口与接口之间是继承关系（extends）</p><h4 id="⑤其他"><a href="#⑤其他" class="headerlink" title="⑤其他"></a>⑤其他</h4><p>​A.接口的具体使用，体现多态性</p><p>​例如一个方法的形参是接口类型，由于接口不能实例化，所以只能提供其实现类的对象，即体现了多态性。</p><p>​B.接口，实际上可以看做是一种规范</p><p>​要想让实现类造对象，实现类就必须重写接口中的抽象方法，这就体现了接口的规范性。</p><p>​C.开发中，面向接口编程（体会）</p><p>​我们在应用程序中，调用的结构都是JDBC中定义的接口，不会出现具体某个数据库厂商的API。</p><h4 id="⑥匿名实现类"><a href="#⑥匿名实现类" class="headerlink" title="⑥匿名实现类"></a>⑥匿名实现类</h4><p>​与匿名子类一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Fly</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">speed</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Fly</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Fly</span>()&#123;<span class="comment">//匿名实现类的非匿名对象</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">speed</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;飞机加速&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/imgs/image-20220721222732965.png" alt="image-20220721222732965"></p><h4 id="⑦应用–代理模式-amp-工厂模式"><a href="#⑦应用–代理模式-amp-工厂模式" class="headerlink" title="⑦应用–代理模式&amp;工厂模式"></a>⑦应用–代理模式&amp;工厂模式</h4><p>​A.代理模式</p><p>​定义：类B不想操作某个接口里的方法，因此让类A去帮类B操作实现这些方法，这就是代理模式，其中类B称为被代理类，类A称为代理类。</p><p>​分类：静态代理、动态代理</p><p>​B.工厂模式</p><p>​定义：“工厂”用来创建对象的，达到让对象的创建与对象的使用分开的目的</p><p>​分类：简单工厂模式、工厂方法模式、抽象工厂模式</p><p>​简单工厂模式：一般使用静态方法，通过接收的参数的不同返回不同的实例对象。缺点：对于增加新产品，不修改代码的话，是无法扩展的。从而产生工厂方法模式。</p><p>​工厂方法模式：将工厂变成一个接口，再创建一些具体工厂实现类，让实现类去返回实例对象。</p><p>​抽象工厂模式：在对象的创建上比工厂方法模式的创建复杂些。（了解，后面再讲）</p><hr><h2 id="13、异常处理"><a href="#13、异常处理" class="headerlink" title="13、异常处理"></a>13、异常处理</h2><h3 id="A-定义-2"><a href="#A-定义-2" class="headerlink" title="A.定义"></a>A.定义</h3><p>​在Java语言中，将程序执行中发生的不正常情况称为“异常”。 (开发过程中的<strong>语法错误和逻辑错误不是异常</strong>)</p><h3 id="B-分类"><a href="#B-分类" class="headerlink" title="B.分类"></a>B.分类</h3><p>​Exception和Error的顶级父类为Throwable</p><h4 id="①Error"><a href="#①Error" class="headerlink" title="①Error"></a>①Error</h4><p>​Java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等严重情况。<strong>一般不编写针对性的代码进行处理。因此需要对报错的代码进行修改</strong></p><p>​比如：StackOverflowError（栈溢出）和OOM(OutOfMemoryError，堆溢出)。</p><h4 id="②Exception"><a href="#②Exception" class="headerlink" title="②Exception"></a>②Exception</h4><p>​Exception: 其它因编程错误或偶然的外在因素导致的一般性问题，<strong>可以使用针对性的代码进行处理</strong>。例如：</p><ul><li>空指针访问</li><li>试图读取不存在的文件</li><li>网络连接中断</li><li>数组角标越界</li></ul><p>​Exception又可以分为运行时异常（unchecked）和编译时异常（checked）</p><h4 id="③异常的体系结构图"><a href="#③异常的体系结构图" class="headerlink" title="③异常的体系结构图"></a>③异常的体系结构图</h4><p><img src="/imgs/image-20220727110208618.png" alt="image-20220727110208618"></p><h4 id="④常见的运行时异常"><a href="#④常见的运行时异常" class="headerlink" title="④常见的运行时异常"></a>④常见的运行时异常</h4><p>​NullPointerException：空指针异常（如：该对象为Null，但调用了其方法）</p><p>​ArryIndexOutOfBoundsException：数组下标越界异常</p><p>​classCastException：强制转换异常（如：父类强制转换为不正确的子类时）</p><p>​NumberFormatException：(如：出现在包装类转基本数据类型时)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span>  <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Integer.parseInt(str);<span class="comment">//因为abc不是int类型，所以出现NumberFormatException</span></span><br></pre></td></tr></table></figure><p>​InputMismatchException：输入异常（用scanner时，获取的是int型，但输入的是字符型）</p><p>​ArithmeticException：运算异常（如：除数为0）</p><hr><h3 id="C-异常处理"><a href="#C-异常处理" class="headerlink" title="C.异常处理"></a>C.异常处理</h3><p>​<strong>Java中有异常处理的机制：抓抛模型</strong></p><p>​<strong>过程一：“抛”：</strong>程序在正常执行的过程中，一旦出现异常，就会在异常代码处生成一个异常类的对象，并对此对象抛出。一旦抛出对象以后，其后的代码就不再执行。</p><p>​<strong>过程二：“抓”：</strong>过程一抛出对象后，需要对对象进行抓取，即：对异常进行处理，处理方式就是①try-catch-finally ②throws</p><p>​</p><h3 id="D-异常处理机制一：try-catch-finally"><a href="#D-异常处理机制一：try-catch-finally" class="headerlink" title="D.异常处理机制一：try-catch-finally"></a>D.异常处理机制一：try-catch-finally</h3><p>​try-catch-finally是处理异常，即把异常解决掉。在方法体内使用。</p><h4 id="①格式"><a href="#①格式" class="headerlink" title="①格式"></a>①格式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//可能出现异常的代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">1</span> 变量名<span class="number">1</span>)&#123;<span class="comment">//变量名只在第一个catch的&#123;&#125;里有效</span></span><br><span class="line">    <span class="comment">//异常处理的方式1</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">2</span> 变量名<span class="number">2</span>)&#123;</span><br><span class="line">    <span class="comment">//异常处理的方式2</span></span><br><span class="line">&#125;</span><br><span class="line">.....</span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">//一定会执行的代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可以抓取多种类型的异常，即可以有多个catch</span></span><br></pre></td></tr></table></figure><h4 id="②说明一"><a href="#②说明一" class="headerlink" title="②说明一"></a>②说明一</h4><ul><li>finally是可选的</li><li>使用try将可能出现异常的代码包装起来，在执行过程中，一旦出现异常，就会生成一个对应异常类的对象，且try里剩下的代码也不会继续执行。然后就根据此对象的类型，去catch中进行匹配。</li><li>一旦try中的异常对象匹配到某一个catch时，就进入catch中进行异常的处理。一旦处理完成，就跳出当前的try-catch结构（此时没有finally）,继续执行其后的代码。（只会进入一个catch，与case类似）</li><li>catch中的异常类型如果满足子父类关系，则要求子类一定声明在父类的上面，否则报错。如果不是子父类关系，则无先后顺序要求。</li><li>catch的{ }里常用的异常对象处理方式： ① String getMessage（）获取异常信息，返回字符串 ② printStackTrace（）获取异常类类名和异常信息，以及异常出现在程序中的位置。返回值void。</li><li>在try结构中声明的变量，在出了try结构以后，就不能再被调用</li><li>try-catch-finally 可以嵌套。</li></ul><h4 id="③说明二"><a href="#③说明二" class="headerlink" title="③说明二"></a>③说明二</h4><p>​<strong>try-catch-finally中finally的使用</strong></p><p>​A.finally是可选的</p><p>​B.finally中声明的是一定会被执行的代码。即使catch中又出现异常了，try中有return语句，catch中有return语句，try中没有异常等情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> order.method();</span><br><span class="line">System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">int</span>[] b = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1</span>];</span><br><span class="line">System.out.println(b[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">catch</span> (ArrayIndexOutOfBoundsException e) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;数组下标越界&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;一定会执行的代码&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/imgs/image-20220727211813611.png" alt="image-20220727211813611"></p><p>​C.像数据库连接、输入输出流、网络编程Socket等资源，JVM是不能自动回收的，需要自己手动进行资源释放。此时的资源释放就需要声明在finally中。</p><h4 id="④体会"><a href="#④体会" class="headerlink" title="④体会"></a>④体会</h4><p>​A.使用try-catch-finally处理编译时异常，使得程序在编译时不再报错，但是运行时仍可能报错。相当于将一个编译时可能出现的异常，延迟到运行时出现。</p><p>​B.开发中，由于<strong>运行时异常</strong>比较常见，所以我们通常<strong>就不</strong>针对运行时异常<strong>编写try-catch-finally</strong>了。针对于<strong>编译时异常</strong>，我们一<strong>定要考虑异常的处理。</strong></p><h3 id="E-异常处理机制二：throws-异常类型"><a href="#E-异常处理机制二：throws-异常类型" class="headerlink" title="E.异常处理机制二：throws+异常类型"></a>E.异常处理机制二：throws+异常类型</h3><ul><li>throws是把异常往上一级抛，throws也不处理运行时异常，谁调用就把异常抛给谁。</li><li>“throws + 异常类型” 写在方法的声明处，指明此方法执行时，可能会抛出异常类型。一旦当方法体执行时，出现异常，仍会在异常代码处生成一个异常类的对象，此对象满足throws后异常类型时，就会被抛出（不满足时程序报错终止）。异常代码后续的代码就不再执行。</li><li>出现了异常类型A，那么throws的时候可以写其父类的异常类型。如：出现了RuntimeException，则可以写throws Exception。</li></ul><h4 id="①体会"><a href="#①体会" class="headerlink" title="①体会"></a>①体会</h4><p>​try-catch-finally 真正将异常处理掉了，但是throws 的方法只是将异常抛给了方法的调用者，并没有真正将异常处理掉。</p><h3 id="F-开发中如何选择异常处理的方式"><a href="#F-开发中如何选择异常处理的方式" class="headerlink" title="F.开发中如何选择异常处理的方式"></a>F.开发中如何选择异常处理的方式</h3><ol><li>父类中被重写的方法没有throws方式处理异常，则子类重写的方法也不能使用throws。意味着若子类重写的方法中有异常，必须使用try-catch-finally 方式处理。</li><li>执行的方法a 中，先后又调用了另外的几个方法，这几个方法是递进关系执行的。我们建议在这几个方法的声明里使用throws的方式进行处理。而执行的方法a可以考虑使用try-catch-finally 方式将这几个方法包起来。</li><li>当该方法A会被其他方法调用，而该方法A又会出现异常时，通常不会在方法A中对异常进行try-catch-finally，而是throws</li></ol><h3 id="G-补充"><a href="#G-补充" class="headerlink" title="G.补充"></a>G.补充</h3><p>​出现运行时异常，只能去修改出错的代码了</p><h3 id="H-手动抛出异常"><a href="#H-手动抛出异常" class="headerlink" title="H.手动抛出异常"></a>H.手动抛出异常</h3><p>​声明在方法里</p><h4 id="①格式：throw-new-异常类型（）"><a href="#①格式：throw-new-异常类型（）" class="headerlink" title="①格式：throw new 异常类型（）;"></a>①格式：<strong>throw new 异常类型（）;</strong></h4><p>​抛出异常的类型：Excception、RuntimeException（从这两种异常类型中选）</p><ul><li>如果抛出的异常类型为：Excception，则必须对异常做出处理，不然报错。Exception可以选择不带参数的，或带参数的（String message，将想要输出的语句写进去，然后在处理该异常时可以调用getMessage方法来将该语句输出）</li><li>如果抛出的异常类型为：RuntimeException（运行时异常），则可以不用对异常进行处理。RuntimeException也可以选择带参数为String message的。</li></ul><h4 id="②应用"><a href="#②应用" class="headerlink" title="②应用"></a>②应用</h4><p>​A.当方法需要返回某个类型的值或对象，但又需要通过报错来提醒用户时，可以使用throw。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(a &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> a++;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;a不能小于0&quot;</span>);</span><br><span class="line">        <span class="comment">//可以代替return......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​B.根据需要手动抛出异常来提醒用户</p><p>​快速生成try-catch-finaly的方法：选中可能出现异常的代码 –&gt; 右击 –&gt; surround with –&gt; try &#x2F; catch 块</p><h3 id="I-用户自定义异常类"><a href="#I-用户自定义异常类" class="headerlink" title="I.用户自定义异常类"></a>I.用户自定义异常类</h3><h4 id="①如何自定义异常类"><a href="#①如何自定义异常类" class="headerlink" title="①如何自定义异常类"></a>①如何自定义异常类</h4><ul><li><p>继承于现有的异常结构：RuntimeException、 Exception</p></li><li><p>提供全局常量：serialVersionUID （随便赋一个值即可，其用于唯一标识该类）</p></li><li><p>提供重载的构造器，如：（一般会加上如下的构造器）</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">(String message)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="②补充"><a href="#②补充" class="headerlink" title="②补充"></a>②补充</h4><ul><li>如果继承的是Exception，当抛出该自定义异常类时，需要对此进行异常处理，否则报错。</li><li>如果继承的是RuntimeException，当抛出该自定义异常类时，可以不对此进行异常处理</li></ul><h2 id="14、项目三中收获的知识"><a href="#14、项目三中收获的知识" class="headerlink" title="14、项目三中收获的知识"></a>14、项目三中收获的知识</h2><ol><li><p>枚举</p><p> 一个类只能有有限个对象，且这些对象都是确定的。</p></li><li><p>构造器：一般提供一个带参的构造器和一个空参的构造器</p></li><li><p>如果方法有返回值，且方法里有switch-case，而又需要在switch-case里“return 值”，此时可以将switch-case里的break删掉（不然报错）<img src="/imgs/image-20220730203228674.png" alt="image-20220730203228674"></p></li><li><p><img src="/imgs/image-20220731185334039.png" alt="image-20220731185334039"></p><p> “BUSY.equals()”这样写可以减少空指针异常的情况，因为BUSY是确实的。</p><p> equalsIgnoreCase该方法可以忽略大小写来比较是否相等</p></li><li><pre><code class="java"> int i = 0,j = 1;</code></pre></li><li><p>MVC，M：放一些基础的类；V：放与用户交互的页面操作；C：放一些逻辑处理</p></li><li><p><img src="/imgs/image-20220801123010138.png" alt="image-20220801123010138"></p><p> 有时候，调用别的方法其返回的数组值为NULL，为了避免空指针异常，所以加个判断</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA</title>
      <link href="/2023/04/24/IDEA%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/04/24/IDEA%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="一、IDEA下载及安装教程"><a href="#一、IDEA下载及安装教程" class="headerlink" title="一、IDEA下载及安装教程"></a>一、IDEA下载及安装教程</h3><p><a href="https://mp.weixin.qq.com/s/1ftYaMM5rHek1oEBN8CR2Q">IntelliJ IDEA 2017 软件安装教程 (qq.com)</a></p><h4 id="①JDK1-8-0-131存放位置"><a href="#①JDK1-8-0-131存放位置" class="headerlink" title="①JDK1.8.0_131存放位置"></a>①JDK1.8.0_131存放位置</h4><p>​C:\Program Files\Java\jdk1.8.0_131</p><p>​如何查看JDK存放位置：cmd - - &gt; java -verbose</p><h3 id="二、IDEA包含的文件"><a href="#二、IDEA包含的文件" class="headerlink" title="二、IDEA包含的文件"></a>二、IDEA包含的文件</h3><p>config文件：保存对IDEA配置的文件，每个工作空间都共用这个配置文件，这意味着新开的工作空间的配置与原来的工作空间的配置一样。</p><p>system文件：保存了一些缓存文件，用于加快IDEA的运行</p><p><img src="/imgs/image-20220802171106985.png" alt="image-20220802171106985"></p><h3 id="三、IDEA初次使用设置"><a href="#三、IDEA初次使用设置" class="headerlink" title="三、IDEA初次使用设置"></a>三、IDEA初次使用设置</h3><h4 id="①IDEA插件官方下载地址"><a href="#①IDEA插件官方下载地址" class="headerlink" title="①IDEA插件官方下载地址"></a>①IDEA插件官方下载地址</h4><p>​<a href="http://plugins.jetbrains.com/idea">http://plugins.jetbrains.com/idea</a></p><h4 id="②"><a href="#②" class="headerlink" title="②"></a>②</h4><h4 id=""><a href="#" class="headerlink" title=""></a><img src="/imgs/image-20220802173824581.png" alt="image-20220802173824581"></h4><h4 id="③其他设置"><a href="#③其他设置" class="headerlink" title="③其他设置"></a>③其他设置</h4><p><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=412&spm_id_from=pageDriver&vd_source=9c398663599ac78b625d463b4ffc1ff5">尚硅谷Java入门视频教程(在线答疑+Java面试真题)_哔哩哔哩_bilibili</a></p><h3 id="四、IDEA的使用"><a href="#四、IDEA的使用" class="headerlink" title="四、IDEA的使用"></a>四、IDEA的使用</h3><h4 id="①创建一个新的基本JAVA项目"><a href="#①创建一个新的基本JAVA项目" class="headerlink" title="①创建一个新的基本JAVA项目"></a>①创建一个新的基本JAVA项目</h4><p>​A.     </p><img src="/imgs/image-20230424165424869.png" alt="image-20230424165424869" style="zoom:67%;" /><p>​B.选择JDK安装的路径 – &gt; NEXT – &gt; NEXT</p><p><img src="/imgs/image-20220802172530154.png" alt="image-20220802172530154"></p><p>​C.填好以下信息后点击NEXT —&gt; OK<img src="/imgs/image-20220802172800011.png" alt="image-20220802172800011"></p><p>​D.Project名–&gt; 右击，新建一个Module – &gt; 新建一个包 – &gt; 在该包下新建一个类</p><h4 id="②如何删除一个Moduel"><a href="#②如何删除一个Moduel" class="headerlink" title="②如何删除一个Moduel"></a>②如何删除一个Moduel</h4><p>​选中要删除的Moduel – &gt; Remove Module – &gt;OK –&gt; 然后再对该Module 右键 –&gt; delete</p><h3 id="五、IDEA中的Module-amp-Project"><a href="#五、IDEA中的Module-amp-Project" class="headerlink" title="五、IDEA中的Module&amp;Project"></a>五、IDEA中的Module&amp;Project</h3><p><img src="/imgs/image-20220803114312511.png" alt="image-20220803114312511"></p><h3 id="六、IDEA快捷键"><a href="#六、IDEA快捷键" class="headerlink" title="六、IDEA快捷键"></a>六、IDEA快捷键</h3><p><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=413&spm_id_from=pageDriver&vd_source=9c398663599ac78b625d463b4ffc1ff5">尚硅谷Java入门视频教程(在线答疑+Java面试真题)_哔哩哔哩_bilibili</a></p><h3 id="七、模板设置"><a href="#七、模板设置" class="headerlink" title="七、模板设置"></a>七、模板设置</h3><p><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=414&spm_id_from=pageDriver&vd_source=9c398663599ac78b625d463b4ffc1ff5">尚硅谷Java入门视频教程(在线答疑+Java面试真题)_哔哩哔哩_bilibili</a></p><h3 id="八、Debug调试"><a href="#八、Debug调试" class="headerlink" title="八、Debug调试"></a>八、Debug调试</h3><p>设置断点 – &gt; 右击运行Debug</p><p><img src="/imgs/image-20220813100137404.png" alt="image-20220813100137404"></p><h3 id="九、如何导入一个Module"><a href="#九、如何导入一个Module" class="headerlink" title="九、如何导入一个Module"></a>九、如何导入一个Module</h3><ol><li>将Module复制到你想存放的工程下（即：workspace）</li><li><img src="/imgs/image-20220815164720095.png" alt="image-20220815164720095"></li><li><img src="/imgs/image-20220815164749843.png" alt="image-20220815164749843"></li><li><img src="/imgs/image-20220815164833214.png" alt="image-20220815164833214"></li><li>找到该Module存放的位置（即：硬盘中该工程下Module的位置）–&gt; 点击ok<img src="/imgs/image-20220815165207250.png" alt="image-20220815165207250"></li><li>如果该Module是存在某个软件下，就选第二个，否则选第一个</li></ol><p><img src="/imgs/image-20220815165415010.png" alt="image-20220815165415010"></p><p>一直点Next –&gt; Overwrite –&gt; Finsh –&gt; </p><p><img src="/imgs/image-20220815165901909.png" alt="image-20220815165901909"></p><h3 id="十、如何将Eclipse中的项目导入到IDEA中"><a href="#十、如何将Eclipse中的项目导入到IDEA中" class="headerlink" title="十、如何将Eclipse中的项目导入到IDEA中"></a>十、如何将Eclipse中的项目导入到IDEA中</h3><p>①在Eclipse中对你要导入的项目进行右击 - - &gt; Properties - - &gt; <img src="/imgs/image-20220817174941870.png" alt="image-20220817174941870"></p><p>查看该项目的位置 - - &gt; 将该项目复制</p><p>②在IDEA中选择该导入项目要存放的位置，比如：我想将此导入项目（“项目”相当于IDEA中Module），放到IDEA中的一个Project(相当于workspace)下，那就对此Project右击，选择”show in Explorer” - - &gt; 双击文件 - - &gt; 将刚才复制的文件放到该文件下</p><p>③按照“九、如何导入一个Module”做，做到第6步时，选择第二个选项“Import module from external model” - - &gt; 选择Eclipse - - &gt; 点击Next，直到点击finish - - &gt; 点击ok</p><p>④选择该项目的Module SDK为Java1.8 - - &gt; 点击ok</p><p><img src="/imgs/image-20220817181248081.png" alt="image-20220817181248081"></p><p>⑤导入完成</p><h3 id="十一、如何打开现有的workspace"><a href="#十一、如何打开现有的workspace" class="headerlink" title="十一、如何打开现有的workspace"></a>十一、如何打开现有的workspace</h3><p>​点击file - - &gt;  Open - - &gt; 找到workspcae_idea1文件，并打开 - - &gt; 选中你要打开的workspace - - &gt; 点击OK，完事。</p><h3 id="十二、修改包名"><a href="#十二、修改包名" class="headerlink" title="十二、修改包名"></a>十二、修改包名</h3><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://blog.csdn.net/hanyunlong1989/article/details/125442359</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDEA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Eclipse</title>
      <link href="/2023/04/24/eclipse%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/04/24/eclipse%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="1、eclipse首次启动的设置"><a href="#1、eclipse首次启动的设置" class="headerlink" title="1、eclipse首次启动的设置"></a>1、eclipse首次启动的设置</h2><p><a href="https://www.bilibili.com/video/BV1Kb411W75N?p=136&spm_id_from=pageDriver">尚硅谷Java入门视频教程(在线答疑+Java面试真题)_哔哩哔哩_bilibili</a></p><p>​第136P</p><h2 id="2、如何创建一个Java程序"><a href="#2、如何创建一个Java程序" class="headerlink" title="2、如何创建一个Java程序"></a>2、如何创建一个Java程序</h2><p>在左边的栏目里选择Package Explorer - - &gt; 右击 - - &gt; new  Java project - - &gt; 输入Project name - - &gt; 点击next - - &gt; Finish - - &gt; 对src右击(src是存放源代码)新建一个包 - - &gt; 输入包名(通常为com.②.③,其中“com.②”为域名的倒写，③可以写包名。如：com.baidu.包名) - - &gt; Finish - - &gt; 对刚才新建的包进行右击，新建一个类 - - &gt; 输入类名 - - &gt; Finish </p><h2 id="3、如何导入已有的工程"><a href="#3、如何导入已有的工程" class="headerlink" title="3、如何导入已有的工程"></a>3、如何导入已有的工程</h2><p>File - - &gt; Import - - &gt;  General - - &gt; Existing Projects into Workspace - - &gt; Next  - - &gt; 浏览(Browse….)，选择工程现在的位置 - - &gt; 然后按下图勾上对应的选项 - - &gt; 最后点击Finish - - &gt; 至此导入完成。</p><p><img src="/imgs/image-20230424163724108.png" alt="image-20230424163724108"></p><p>​注意：如果没有勾上“Copy projects into workspace”，删除了该工程，那么就打不开该工程了。</p><h2 id="4、如何改现有工程的名字"><a href="#4、如何改现有工程的名字" class="headerlink" title="4、如何改现有工程的名字"></a>4、如何改现有工程的名字</h2><h3 id="①、改eclipse里的工程名字"><a href="#①、改eclipse里的工程名字" class="headerlink" title="①、改eclipse里的工程名字"></a>①、改eclipse里的工程名字</h3><p>​选择需要改的工程 –&gt; 右击 –&gt; Refactor(即：重构) –&gt; Rename</p><h3 id="②、改准备导入eclipse的工程名字"><a href="#②、改准备导入eclipse的工程名字" class="headerlink" title="②、改准备导入eclipse的工程名字"></a>②、改准备导入eclipse的工程名字</h3><p>​改不了</p><h2 id="5、如何导入已有的源文件"><a href="#5、如何导入已有的源文件" class="headerlink" title="5、如何导入已有的源文件"></a>5、如何导入已有的源文件</h2><p>​直接复制（ctrl + c）此源文件，直接在指定的<strong>工程包</strong>下粘贴（ctrl + v）即可。</p><h2 id="6、如果导入源文件后打开是乱码"><a href="#6、如果导入源文件后打开是乱码" class="headerlink" title="6、如果导入源文件后打开是乱码"></a>6、如果导入源文件后打开是乱码</h2><p>​将要导入的源文件复制到桌面上，用eclipse打开然后将其另存为UTF-8的编码形式。然后再将此文件复制（ctrl + c）到指定的<strong>工程包</strong>下粘贴（ctrl + v）即可。如果导入后还是报错，那看看此源程序的开头是否有加“Package 包名;”。最后刷新一下即可。</p><h2 id="7、如何在Eclispe中查看Java类库源代码"><a href="#7、如何在Eclispe中查看Java类库源代码" class="headerlink" title="7、如何在Eclispe中查看Java类库源代码"></a>7、如何在Eclispe中查看Java类库源代码</h2><p>​在代码中按住“ctrl”键，移动鼠标到想看的代码出，然后点击即可。如果想查找此源代码的某个内容，如：想看一下String类里的chartAt()方法，直接使用“ctrl + o”，最后再输入chartAt()，即可。</p><h2 id="8、如何在编写的代码中显示此程序的相关信息"><a href="#8、如何在编写的代码中显示此程序的相关信息" class="headerlink" title="8、如何在编写的代码中显示此程序的相关信息"></a>8、如何在编写的代码中显示此程序的相关信息</h2><p><img src="/imgs/image-20220529113343294.png" alt="image-20220529113343294"></p><p><img src="/imgs/image-20220529113526167.png" alt="image-20220529113526167"></p><p>​设置完后，当想在代码中使用这些信息，只需要输出“&#x2F;** *&#x2F;”然后再回车即可。</p><h3 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h3><p>​1、新建的workspace与原有的workspace的设置是不一样的，因为两者的”.metadata”文件不一样。</p><h2 id="9、Debug调试"><a href="#9、Debug调试" class="headerlink" title="9、Debug调试"></a>9、Debug调试</h2><h3 id="①断点"><a href="#①断点" class="headerlink" title="①断点"></a>①断点</h3><p>​对你想查看的内容打上断点，当程序执行到该断点时，就会暂时暂停。</p><h3 id="②如何运行Debug？"><a href="#②如何运行Debug？" class="headerlink" title="②如何运行Debug？"></a>②如何运行Debug？</h3><p>右击选择Debug as Java application即可。</p><p><img src="/imgs/image-20220704174951502.png" alt="image-20220704174951502"></p><h3 id="③Eclipse中常用的调试按键"><a href="#③Eclipse中常用的调试按键" class="headerlink" title="③Eclipse中常用的调试按键"></a>③Eclipse中常用的调试按键</h3><p><img src="/imgs/20201208201536259.png" alt="img"></p><table><thead><tr><th align="center">操作</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">step into 跳入(f5)</td><td align="center">进入当前行所调用的方法中</td></tr><tr><td align="center">step over 跳过(f6)</td><td align="center">执行完当前行的语句，进入下一行</td></tr><tr><td align="center">step return 跳回(f7)</td><td align="center">退出当前行所调用的方法</td></tr><tr><td align="center">resume 恢复</td><td align="center">进入下一个断点，如果没有就结束</td></tr><tr><td align="center">Terminate 终止</td><td align="center">停止调试</td></tr><tr><td align="center">drop to frame</td><td align="center">回到当前行所在方法的第一行</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 编程软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Eclipse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目补充知识</title>
      <link href="/2023/04/24/%E5%81%9A%E9%A1%B9%E7%9B%AE%E6%97%B6%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86/"/>
      <url>/2023/04/24/%E5%81%9A%E9%A1%B9%E7%9B%AE%E6%97%B6%E8%A1%A5%E5%85%85%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<ol><li><p>Vue对象里可以写</p> <img src="/imgs/image-20230424155505954.png" alt="image-20230424155505954" style="zoom:67%;" /> </li><li><p>下面引入的代码写在html的body标签的开头即可</p><p> <img src="/imgs/image-20221202220013403-1682322858044.png" alt="image-20221202220013403"></p><p> 上面的路径别写错，不然会识别不了部分代码。<code>要写资源相对于该页面的位置。</code>  </p></li><li><p>如何获取表单里一行数据中的某个值：</p><p> <img src="/imgs/image-20221204225611772-1682322858045.png" alt="image-20221204225611772"></p></li><li><p>要想使用Vue对象里的模型或方法，必须先有Vue对象。除了axios请求中的then里的this是指window对象，在Vue对象里的其它位置使用this，this都是指Vue对象。</p></li><li><p>当点击前端页面中的新增按钮、修改按钮时，弹出的是对话框，不是消息提醒之类的弹框。</p></li><li><p>写添加数据的SQL语句时，要注意别写错关键字</p><p> <img src="/imgs/image-20221205144746602-1682322858046.png" alt="image-20221205144746602"></p></li><li><p>当编写的SQL关键字不是粗体字的话，就可能是识别不了此关键字，需进行相应的设置。</p><p> <img src="/imgs/image-20221206205326825-1682322858046.png" alt="image-20221206205326825"></p></li><li><p>如果发现运行tomcat时出现以下情况，就很有可能在调用对应SQL语句的方法时出错了。找到对应的位置修改即可。</p><p> <img src="/imgs/image-20221206205514876-1682322858046.png" alt="image-20221206205514876"></p></li><li><p>这种情况下就不能直接写username</p><p> <img src="/imgs/image-20230424161857087.png" alt="image-20230424161857087"></p></li><li><p>在浏览器中如何查看表单post提交的数据</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://blog.csdn.net/hkhl_235/article/details/103444085</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 项目开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目补充知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零搭建Web项目</title>
      <link href="/2023/04/24/%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BAweb%E9%A1%B9%E7%9B%AE/"/>
      <url>/2023/04/24/%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BAweb%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<p>实现步骤：</p><ol><li><p>建一个 maven web 项目（见Web服务器-Tomcat –&gt; IDEA中创建maven web项目–实现），然后在pom.xml文件中导入依赖：mybatis、mysql、jsp、servlet、jstl、Tomcat、Fastjson。</p></li><li><p>在webapp下建一个文件命名为：js，用于存放js文件。</p><ol><li>将axios-0.18.0.js文件放到该文件下。（Axios框架需要用到此文件）</li><li>将vue.js文件放到该文件下。</li></ol><p> 注：上面两个文件在电脑D：&#x2F;web开发所需资料。Element ui文件也在。</p></li><li><p>将Element ui文件复制到webapp下。</p></li><li><p>创建三层架构的包结构。创建三层架构的包结构。在Java文件下建com.zzc.web、com.zzc.service、com.zzc.mapper，另外还建com.zzc.pojo（放Javabean），com.zzc.utils（放自定义的工具类）。</p><ol><li>在com.zzc.web包下再建一个文件servlet。<ul><li>在servlet文件下先建一个baseServlet，其内容详见servlet代码优化。以后写的servlet类都继承于baseServle。</li></ul></li><li>在com.zzc.service包下建一个impl文件。<ul><li>先定义一个service相关的接口，如：brandService接口，然后在这里面写对brand表操作的相关方法。</li><li>在impl文件里实现brandService接口，类命名为：brandServiceImpl。</li></ul></li></ol></li><li><p>在数据库中创建需要的表，如：tb_brand表。</p></li><li><p>在com.zzc.pojo包下建数据库表对应的实体类。</p></li><li><p>Mybatis基础环境搭建：</p><ol><li>Mybatis-config.xml</li><li>BrandMapper.xml</li><li>BrandMapper接口</li></ol></li><li><p>在编写前端页面之前都要引入如下三个东西：</p><ol><li><p>引入axios的js文件</p><p> <img src="/imgs/image-20221202171825016-1682322503285.png" alt="image-20221202171825016"></p></li><li><p>引入Element的css、js文件</p><p> <img src="/imgs/image-20221202202141339-1682322503286.png" alt="image-20221202202141339"></p></li><li><p>引入Vue.js文件</p><p> <img src="/imgs/image-20221202172033846-1682322503286.png" alt="image-20221202172033846"></p></li><li><p>在编写页面时参考Element官网，再根据自己需要修改。</p> <figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://element.eleme.cn/#/zh-CN/component/table</span><br></pre></td></tr></table></figure></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web核心（下）</title>
      <link href="/2023/04/24/web%E6%A0%B8%E5%BF%83%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
      <url>/2023/04/24/web%E6%A0%B8%E5%BF%83%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="13-AJAX"><a href="#13-AJAX" class="headerlink" title="13.AJAX"></a>13.AJAX</h2><h3 id="A-概述"><a href="#A-概述" class="headerlink" title="A.概述"></a>A.概述</h3><p><img src="/imgs/image-20230424150618783.png" alt="image-20230424150618783"></p><p><img src="/imgs/image-20230424150627689.png" alt="image-20230424150627689"></p><p><img src="/imgs/image-20230424150637989.png" alt="image-20230424150637989"></p><hr><h3 id="B-AJAX快速入门"><a href="#B-AJAX快速入门" class="headerlink" title="B.AJAX快速入门"></a>B.AJAX快速入门</h3><p>​这下面的开发步骤了解即可，因为这种开发步骤比较繁琐，将来会用Axiox异步框架来代替这种旧的开发方式。</p><p><img src="/imgs/image-20230424150748050.png" alt="image-20230424150748050"></p><p>​具体实现：</p><p>​新建一个HTML页面，使用&lt; script &gt;标签，在里面写Ajax代码。</p><p><img src="/imgs/image-20230424150818807.png" alt="image-20230424150818807"></p><p><img src="/imgs/image-20230424150827232.png" alt="image-20230424150827232"></p><p>说明：</p><ol><li><p>全路径：<a href="http://localhost:8080/%E8%AF%A5%E9%A1%B9%E7%9B%AE%E7%9A%84%E8%AE%BF%E9%97%AE%E8%B7%AF%E5%BE%84/%E8%A2%AB%E8%AE%BF%E9%97%AE%E8%B5%84%E6%BA%90%E7%9A%84%E8%B7%AF%E5%BE%84">http://localhost:8080/该项目的访问路径/被访问资源的路径</a></p></li><li><p>发送请求中的open方法里还有第三个参数，用于设置该请求是异步请求还是同步请求，true就是异步请求，false就是同步请求。该参数默认是：true，所以也可以不写。</p></li><li><p>获取响应中的涉及到的知识见：</p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.w3school.com.cn/js/js_ajax_http_response.asp</span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="C-案例"><a href="#C-案例" class="headerlink" title="C.案例"></a>C.案例</h3><p><img src="/imgs/image-20230424151018672.png" alt="image-20230424151018672"></p><p>​实现步骤：</p><ol><li><p>先编写SelectUserServlet</p><p> <img src="/imgs/image-20221125180554640-1682320230969.png" alt="image-20221125180554640"></p></li><li><p>在注册页面register.html编写Ajax。</p><p> <img src="/imgs/image-20221125181936629-1682320230972.png" alt="image-20221125181936629"></p><p> <img src="/imgs/image-20221125182729372-1682320230973.png" alt="image-20221125182729372"></p></li></ol><p>补充：表单中用户名输入框处的HTML代码：</p><p><img src="/imgs/image-20221125182628316-1682320230973.png" alt="image-20221125182628316"></p><hr><h3 id="D-Axios异步框架"><a href="#D-Axios异步框架" class="headerlink" title="D.Axios异步框架"></a>D.Axios异步框架</h3><h4 id="①概述"><a href="#①概述" class="headerlink" title="①概述"></a>①概述</h4><ul><li>Axios：对原生的AJAX进行封装，简化书写。</li><li>官网：<a href="http://www.axios-http.cn/">http://www.axios-http.cn</a></li></ul><h4 id="②Axios快速入门"><a href="#②Axios快速入门" class="headerlink" title="②Axios快速入门"></a>②Axios快速入门</h4><p>​在IDEA中webapp目录下建一个js目录，用于存放JS文件。</p><p>​在引入axios的js文件前，先将电脑D盘中的”web开发需要资料“中的axios-0.18.0.js文件拉到刚才建的JS文件中。</p><p>​创建HTML文件，在里面写如下代码：</p><p><img src="/imgs/image-20221125210635180-1682320310941.png" alt="image-20221125210635180"></p><p>​说明：</p><ol><li>then前面的部分属于发送请求，then后面部分属于获取响应。</li><li>then后面的部分被称为回调函数，当收到响应后会自动执行回调函数的代码。</li><li>resp.data：data中存储的就是响应数据。</li><li>url：写全路径：<a href="http://localhost:8080/%E8%AF%A5%E9%A1%B9%E7%9B%AE%E7%9A%84%E8%AE%BF%E9%97%AE%E8%B7%AF%E5%BE%84/%E8%A2%AB%E8%AE%BF%E9%97%AE%E8%B5%84%E6%BA%90%E7%9A%84%E8%B7%AF%E5%BE%84%E3%80%82">http://localhost:8080/该项目的访问路径/被访问资源的路径。</a></li><li>Axios中post请求和get请求的不同：就是参数存放的位置不一样。</li><li>date：date中放的数据都是JSON数据，将来这些数据都会放到HTTP协议的请求体中发送给服务器。</li></ol><h4 id="③Axios请求方式别名"><a href="#③Axios请求方式别名" class="headerlink" title="③Axios请求方式别名"></a>③Axios请求方式别名</h4><p>​为进一步简化书写，Axios对所有支持的请求方法进行了封装，封装为对应的方法。</p><p><img src="/imgs/image-20221125211934363-1682320310941.png" alt="image-20221125211934363"></p><p>​</p><p>​例子：</p><p><img src="/imgs/image-20221125211949144-1682320310942.png" alt="image-20221125211949144"></p><hr><h2 id="14-JSON"><a href="#14-JSON" class="headerlink" title="14.JSON"></a>14.JSON</h2><h3 id="A-概述-1"><a href="#A-概述-1" class="headerlink" title="A.概述"></a>A.概述</h3><p>​JSON现常作为浏览器和服务器之间数据载体，在网络中进行数据传输。最终会将JSON中的数据变成字符串存储到HTTP中。</p><h3 id="B-JSON语法"><a href="#B-JSON语法" class="headerlink" title="B.JSON语法"></a>B.JSON语法</h3><p><img src="/imgs/image-20221126174831803-1682320388475.png" alt="image-20221126174831803"></p><p>​注意：以上代码都写在HTML中的&lt; script &gt;标签中</p><hr><h3 id="C-JSON数据和Java对象转换"><a href="#C-JSON数据和Java对象转换" class="headerlink" title="C.JSON数据和Java对象转换"></a>C.JSON数据和Java对象转换</h3><h4 id="①概述-1"><a href="#①概述-1" class="headerlink" title="①概述"></a>①概述</h4><p>​JSON作为数据载体将来会通过异步（AJAX）方式在网络中传输数据，服务器收到JSON数据后需要将其转换为Java对象，而发送数据给浏览器时，需要将Java对象转换为JSON字符串。</p><p>​总结：</p><ul><li>请求数据：JSON字符串转为Java对象</li><li>响应数据：Java对象转为JSON字符串</li></ul><h4 id="②使用"><a href="#②使用" class="headerlink" title="②使用"></a>②使用</h4><p><img src="/imgs/image-20221126202948982-1682320388473.png" alt="image-20221126202948982"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.62<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="D-案例"><a href="#D-案例" class="headerlink" title="D.案例"></a>D.案例</h3><p>​使用Axios和JSON来完成之前做的查询品牌数据和添加品牌数据的案例。</p><ul><li><p><strong>查询所有品牌数据</strong></p><p>  <img src="/imgs/image-20221126211754656-1682320388474.png" alt="image-20221126211754656"></p><p>  补充：<strong>List集合转换为JSON后变成了字符串数组。</strong></p><p>  实现：</p><p>  brand.html：</p><p>  <img src="/imgs/image-20221126221126050-1682320388475.png" alt="image-20221126221126050"></p><p>  <img src="/imgs/image-20221126221555239-1682320388475.png" alt="image-20221126221555239"></p><p>  SelectAllServlet：</p><p>  <img src="/imgs/image-20221126213520686-1682320388475.png" alt="image-20221126213520686"></p><p>  至此，展示所有品牌数据的功能就完成了。</p></li><li><p><strong>添加品牌数据</strong></p><p>  需求：点击 “新增” 按钮，弹出添加数据的表单，点击提交数据后，返回提交结果信息，最后展示现在所有品牌的信息。</p><p>  <img src="/imgs/image-20221127161835465-1682320388475.png" alt="image-20221127161835465"></p><p>  实现：</p><p>  addBrand.html：（前端的代码了解一下就可以，因为后面会学一些框架来简化开发步骤）</p><p>  <img src="/imgs/image-20221127163316571-1682320388475.png" alt="image-20221127163316571"></p><p>  <img src="/imgs/image-20221127172321160-1682320388475.png" alt="image-20221127172321160"></p><p>  <img src="/imgs/image-20221127172647446-1682320388475.png" alt="image-20221127172647446"></p><p>  <img src="/imgs/image-20221127173421868-1682320388476.png" alt="image-20221127173421868"></p><p>  <img src="/imgs/image-20221127174851659-1682320388476.png" alt="image-20221127174851659"></p><p>  AddServlet：</p><p>  <img src="/imgs/image-20221127171103397-1682320388476.png" alt="image-20221127171103397"></p></li></ul><p>补充：</p><p>​为什么不能使用request.getParameter？因为getParameter方法底层是根据and和 ‘ &#x3D; ‘ 来切割数据、获取数据的，而JSON数据存储到HTTP请求行中后其数据的格式是“键名：值”的形式，所以getParameter方法就无法获取到JSON数据。要想获取到JSON数据只能，先从请求体中读取数据（上图中26、27行代码）再将获取到的JSON数据转为Java对象。</p>]]></content>
      
      
      <categories>
          
          <category> Java Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web核心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web核心（中）</title>
      <link href="/2023/04/24/web%E6%A0%B8%E5%BF%83%EF%BC%88%E4%B8%AD%EF%BC%89/"/>
      <url>/2023/04/24/web%E6%A0%B8%E5%BF%83%EF%BC%88%E4%B8%AD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="⑨案例"><a href="#⑨案例" class="headerlink" title="⑨案例"></a>⑨案例</h2><p><img src="/imgs/image-20230424151759217.png" alt="image-20230424151759217"></p><h3 id="A-环境准备"><a href="#A-环境准备" class="headerlink" title="A.环境准备"></a>A.环境准备</h3><ol><li>建一个 maven web 项目（见Web服务器-Tomcat –&gt; IDEA中创建maven web项目），然后在pom.xml文件中导入依赖：mybatis、mysql、jsp、servlet、jstl、Tomcat。</li><li>创建三层架构的包结构。在Java文件下建com.zzc.web、com.zzc.service、com.zzc.mapper，另外还建com.zzc.pojo（放Javabean），com.zzc.utils（放自定义的工具类）。</li><li>在数据库中创建tb_brand表。</li><li>在com.zzc.pojo包下建实体类Brand。</li><li>Mbatis基础环境：<ol><li>Mybatis-config.xml</li><li>BrandMapper.xml</li><li>BrandMapper接口</li></ol></li></ol><h3 id="B-查询所有"><a href="#B-查询所有" class="headerlink" title="B.查询所有"></a>B.查询所有</h3><p><img src="/../imgs/image-20221119160426733-1682310001087.png" alt="image-20221119160426733"></p><p>​</p><ol><li><p>DAO层：在BrandMapper接口里定义selectAll方法。</p></li><li><p>在com.zzc.service包下建个BrandService类，专门用来放一些从数据库的Brand表中获取数据的方法。</p></li><li><p>在webapp下建一个index.html页面。注意：如果将来在浏览器访问时不输入任何的访问资源，浏览器就会默认访问命名为index的html页面。</p></li><li><p>在com.zzc.web下建一个命名为SelectAllServlet的Servlet。</p><ol><li>调用BrandService类中的selectAll方法。</li><li>将数据存入request对象。</li><li>转发到brand.jsp。</li></ol></li><li><p>在webapp目录下建一个命名为brand的jsp页面。</p><ol><li><p>引入JSTL标签库</p> <figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%<span class="meta">@taglib</span> prefix=<span class="string">&quot;c&quot;</span> uri=<span class="string">&quot;http://java.sun.com/jsp/jstl/core&quot;</span> %&gt;</span><br></pre></td></tr></table></figure></li><li><p>使用JSTL标签中的foreach标签遍历数据。</p></li></ol></li><li><p>完成。</p></li></ol><hr><h3 id="C-添加数据"><a href="#C-添加数据" class="headerlink" title="C.添加数据"></a>C.添加数据</h3><p><img src="/../imgs/image-20221119200120310-1682310001087.png" alt="image-20221119200120310"></p><p>​</p><ol><li><p>在BrandMapper接口中提交add方法。</p><p> <img src="/../imgs/image-20221119200302253-1682310001087.png" alt="image-20221119200302253"></p></li><li><p>在BrandService类中声明add方法，add方法里先获取数据连接，再调用BrandMapper接口中的add方法，然后<strong>提交事务</strong>，关闭资源。</p><p> <img src="/../imgs/image-20221119200752666-1682310001087.png" alt="image-20221119200752666"></p></li><li><p>为 “新增” 按钮添加单击事件，用到JavaScript，JavaScript要写在script标签里。</p><p> <img src="/../imgs/image-20221119201531297-1682310001087.png" alt="image-20221119201531297"></p><p> <img src="/../imgs/image-20221119202106701-1682310001087.png" alt="image-20221119202106701"></p></li><li><p>用jsp来编写添加数据页面。</p><p> <img src="/../imgs/image-20221119202524160-1682310001088.png" alt="image-20221119202524160"></p></li><li><p>在com.zzc.web下新建一个Servlet，命名为：AddServlet。</p><ol><li>设置字符输入流的编码集为HTML页面的编码集。不然获取到的中文数据就会乱码。（请求参数中文乱码–POST解决方案）</li><li>在servlet里获取请求数据，将数据封装到brand对象里。</li><li>调用BrandService类中的add方法。（此时数据已经存到数据库了）</li><li>使用请求转发，跳转到SelectServlet。展现添加完成后的所有数据。</li></ol></li></ol><p>​补充：如果出现了404，则访问路径写错了。</p><p>​</p><hr><h3 id="D-修改数据"><a href="#D-修改数据" class="headerlink" title="D.修改数据"></a>D.修改数据</h3><p>​修改数据之前，先回显之前的数据，然后再在这些数据上修改，最后提交修改。</p><p><img src="/../imgs/image-20221119212740338-1682310001088.png" alt="image-20221119212740338"></p><h4 id="①回显数据"><a href="#①回显数据" class="headerlink" title="①回显数据"></a>①回显数据</h4><p><img src="/../imgs/image-20221119212910939-1682310001088.png" alt="image-20221119212910939"></p><p>​</p><ol><li><p>在BrandMapper接口中声明selectById方法。</p></li><li><p>在BrandService类中声明slectById方法。</p><ol><li>获取数据库连接。</li><li>调用BrandMapper接口中的selectById方法，返回brand对象。</li><li>关闭资源。</li></ol></li><li><p>编写 “ 修改 ”  的超链接地址。</p><p> <img src="/../imgs/image-20221119214220754-1682310001088.png" alt="image-20221119214220754"></p><p> 如果不再后面加上 “ ?id&#x3D;${brand.id} ”，到时候使用request对象是获取不到该数据的id值的，所以得加上。 </p></li><li><p>在com.zzc.web下建一个Servler命名为SelectByIdServlet。</p><ol><li>使用request对象来获取id值。</li><li>调用BrandService类中的selectById方法。</li><li>将获取到的brand对象存储到request对象中。</li><li>请求转发。转发到update.jsp。</li></ol></li><li><p>编写update.jsp。</p></li></ol><p>  想将数据回显到表单中。</p><p>  <img src="/../imgs/image-20221120103622795-1682310001088.png" alt="image-20221120103622795"></p><p>  <img src="/../imgs/image-20221120104414569-1682310001088.png" alt="image-20221120104414569"></p><ol start="6"><li>数据回显完成。</li></ol><h4 id="②修改数据"><a href="#②修改数据" class="headerlink" title="②修改数据"></a>②修改数据</h4><p><img src="/../imgs/image-20221120105137616-1682310001088.png" alt="image-20221120105137616"></p><p>​</p><ol><li><p>在BrandMapper接口中声明update方法。</p></li><li><p>在BrandService类中声明update方法。</p></li><li><p>修改update.jsp。</p><p> 因为修改数据的SQL语句中需要用到 id ，但这个 id 不希望用户看到，所以我们得：</p><p> <img src="/../imgs/image-20221120111737938-1682310001088.png" alt="image-20221120111737938"></p></li><li></li></ol><hr><h3 id="E-删除数据"><a href="#E-删除数据" class="headerlink" title="E.删除数据"></a>E.删除数据</h3><ol><li>BrandMapper接口中声明DeleteById方法。</li><li>BrandService类中声明DeleteById方法。<ol><li>获取数据库连接。</li><li>调用BrandMapper接口中的DeleteById方法。记得提交事务和关闭sqlsession资源。</li></ol></li><li>修改 “ 删除 ” 的超链接地址为要访问的Servlet地址，再拼上 “?id&#x3D;${brand.id}”。</li><li>编写DeleteByIdServlet。<ol><li>获取请求数据中的id值。</li><li>调用BrandService类中的DeleteById方法。</li><li>请求转发，跳转到查询所有数据的Servlet，将现在的数据都展现出来。</li></ol></li><li>完成。</li></ol><hr><h3 id="F-补充知识"><a href="#F-补充知识" class="headerlink" title="F.补充知识"></a>F.补充知识</h3><ol><li>将来所有的Servler都放在com.zzc.web包下，而JSP、HTML都放在webapp下。</li><li>在表单提交数据时，其提交的内容就是你表单里的内容，表单里没有的内容，提交的数据里也没有。如：表单里没有 id 这个数据，那么提交的数据中也没有 id 这个数据。</li></ol><hr><h2 id="⑩会话跟踪技术"><a href="#⑩会话跟踪技术" class="headerlink" title="⑩会话跟踪技术"></a>⑩会话跟踪技术</h2><h3 id="A-概述"><a href="#A-概述" class="headerlink" title="A.概述"></a>A.概述</h3><p><img src="/../imgs/image-20221120124846464-1682310001088.png" alt="image-20221120124846464"></p><ul><li><p>上图中一共有三个会话</p></li><li><p>Cookie和Session的区别：存放数据的地方不一样</p><ol><li>Cookie：数据存放在客户端。</li><li>Session：数据存放在服务器端。</li></ol></li><li><p>总结：会话跟踪技术就是来解决一次会话中多次请求间共享数据的问题。</p></li></ul><hr><h3 id="B-Cookie"><a href="#B-Cookie" class="headerlink" title="B.Cookie"></a>B.Cookie</h3><h4 id="①概述"><a href="#①概述" class="headerlink" title="①概述"></a>①概述</h4><ul><li><p>Cookie：客户端会话技术，将数据保存到客户端，以后每次请求都携带Cookie数据访问。</p></li><li><p>Cookie的流程：</p>  <img src="/imgs/image-20230424151926317.png" alt="image-20230424151926317" style="zoom:80%;" /><p>  ​当中间的浏览器访问服务器中的A serlvet时，A servlet会创建一个Cookie对象，然后将Cookie对象随着响应发给浏览器。浏览器收到Cookie对象之后就将Cookie里的数据保存到浏览器内存中。以后的每次请求都会携带所有的Cookie一起访问服务器资源，此时服务器资源就可以获取Cookie中的数据了。</p></li><li><p>作为后端程序员，我们只需要知道如何发送Cookie和获取Cookie即可。</p></li></ul><h4 id="②基本使用"><a href="#②基本使用" class="headerlink" title="②基本使用"></a>②基本使用</h4><p>​<img src="/imgs/image-20230424151940370.png" alt="image-20230424151940370" style="zoom: 67%;" /></p><p>​</p><p>​获取Cookie的例子：</p><img src="/imgs/image-20230424151956442.png" alt="image-20230424151956442" style="zoom:67%;" /><hr><h4 id="③原理"><a href="#③原理" class="headerlink" title="③原理"></a>③原理</h4><p>​服务器与客户端之间都是基于Http协议进行数据传输的，所以Cookie的实现也是基于Http协议的。</p><ol><li>当在服务器发送Cookie时，Cookie中的数据就会存到响应头中（响应头存的都是键值对），其中键名为：Set-cookie，值为Cookie中的数据值。然后就随着Http响应数据发送到客户端了。</li><li>当客户端发送请求给服务器时，会携带所有的Cookie数据访问，这些数据是存放在请求头中（请求头中也是以键值对存储数据）的。键名为：cookie，值为：所有Cookie数据，每个数据之间用分号隔开。</li></ol><hr><h4 id="④使用细节–Cookie存活时间"><a href="#④使用细节–Cookie存活时间" class="headerlink" title="④使用细节–Cookie存活时间"></a>④使用细节–Cookie存活时间</h4><p>​<img src="/../imgs/image-20221121182911003-1682310001088.png" alt="image-20221121182911003"></p><p>​</p><hr><h4 id="⑤使用细节–Cookie存储中文"><a href="#⑤使用细节–Cookie存储中文" class="headerlink" title="⑤使用细节–Cookie存储中文"></a>⑤使用细节–Cookie存储中文</h4><ul><li><p>Cookie不能直接存储中文，不然会报错。</p></li><li><p>如需要存储，则需要进行转码：使用URL编码的方式转码。</p></li><li><p>实现：</p><ul><li><p>使用URLEncoder.encode对数据进行URL编码</p>  <img src="/imgs/image-20230424152023008.png" alt="image-20230424152023008" style="zoom:67%;" /></li><li><p>使用URLDecoder.decode对获取到的数据进行URL解码</p>  <img src="/imgs/image-20230424152031193.png" alt="image-20230424152031193" style="zoom:67%;" /></li></ul></li></ul><p>​</p><hr><h3 id="C-Session"><a href="#C-Session" class="headerlink" title="C.Session"></a>C.Session</h3><h4 id="①引入"><a href="#①引入" class="headerlink" title="①引入"></a>①引入</h4><p>​会话跟踪技术中的Cookie是将数据保存到浏览器内存中的，然后每次请求都会携带着这些Cookie去访问资源，着些资源在网络上传输很容易被获取到，所以我们就引入了会话跟踪技术中的第二个技术：Session。Session是将数据保存到服务端的。</p><h4 id="②概述"><a href="#②概述" class="headerlink" title="②概述"></a>②概述</h4><p>​JavaEE提供HttpSession接口，来实现一次会话的多次请求间数据共享功能。</p><h4 id="③基本使用"><a href="#③基本使用" class="headerlink" title="③基本使用"></a>③基本使用</h4><p>​<img src="/../imgs/image-20221121205808627-1682310001088.png" alt="image-20221121205808627"></p><p>​注意：每次调用Session对象里的方法时，都得先获取Session对象。每次获取到的Session对象都是内存当中的同一个Session对象。</p><hr><h4 id="④原理"><a href="#④原理" class="headerlink" title="④原理"></a>④原理</h4><p>​Session是基于Cookie实现的。</p><p><img src="/../imgs/image-20221122105547870-1682310001088.png" alt="image-20221122105547870"></p><p>​Session里有一个唯一标识：id，用于标识此Session对象。当第一次创建Session对象时，由于浏览器中并没有session的id值，因此会在服务器的内存中创建一个session对象，此时其id值就确定了，然后这个id值会随着这次请求的响应，一起发送给客户端浏览器，而客户端与服务器之间数据传输靠的是Http协议，所以 id 会放在请求头中的键名为set-cookie里。浏览器收到这个 id 后会保存在浏览器内存中，随后的每一次请求都会携带着这个 id 一起访问服务器。当第二次获取session对象时，就从请求头中键名为cookie中获取到了此session的 id 值，然后根据此 id 值来找内存中是否有对应的session对象，如果没有则创建一个新的seesion对象；如果有，则直接获取该session对象。</p><p>​总结：</p><p>​获取session时，先去看浏览器中是否有保存session对象的id。</p><p>​①如果有，那就根据此id值，在服务器的内存中找对应的session对象，如果找不到就创建一个session对象。</p><p>​②如果没有，则直接在服务器的内存中创建一个session对象，然后响应时将session对象的id一起发送到浏览器中，然后浏览器保存在浏览器的内存中。</p><hr><h4 id="⑤使用细节–Session钝化、活化（了解）"><a href="#⑤使用细节–Session钝化、活化（了解）" class="headerlink" title="⑤使用细节–Session钝化、活化（了解）"></a>⑤使用细节–Session钝化、活化（了解）</h4><p>​服务器正常重启后，Session中的数据是否还在？</p><ul><li>钝化：在服务器正常关闭后，Tomcat会自动将Session数据写入硬盘的文件中。</li><li>活化：再次启动服务器后，从文件中加载数据到Session中。</li></ul><p>​什么才算服务器正常关闭？就是通过命令行去关闭服务器。</p><p>​①先在命令行启动该项目</p><img src="/imgs/image-20230424152041417.png" alt="image-20230424152041417" style="zoom:67%;" /><p>​②然后在命令行输入 ctrl + c –&gt; yes –&gt; 正常关闭。</p><img src="/imgs/image-20230424152050178.png" alt="image-20230424152050178" style="zoom:67%;" /><p>​</p><p>​                           <img src="/imgs/image-20230424152059397.png" alt="image-20230424152059397"></p><p>​如果点击上图的按钮进行重启，那么这个 “重启” 属于不正常重启。</p><hr><h4 id="⑥使用细节–Session销毁"><a href="#⑥使用细节–Session销毁" class="headerlink" title="⑥使用细节–Session销毁"></a>⑥使用细节–Session销毁</h4><ul><li><p>默认情况下，无操作，30分钟自动销毁。</p><ul><li><p>当然我们可以在web.xml文件中配置其自动销毁的时间。</p><p>  <img src="/../imgs/image-20221122135131562-1682310001088.png" alt="image-20221122135131562"></p></li></ul></li><li><p>调用Session对象的invalidate()方法。</p><ul><li>应用：将来用户登录的数据都会放在Session对象中，那么退出登录的时候就需要用到Session对象的invalidate()方法了。</li></ul></li></ul><hr><h4 id="⑦补充"><a href="#⑦补充" class="headerlink" title="⑦补充"></a>⑦补充</h4><p>​<img src="/imgs/image-20230424152107298.png" alt="image-20230424152107298" style="zoom:67%;" /></p><p>​当浏览器发送请求1给A Servlet时，在A Servlet获取Session对象，然后关闭浏览器，重新开一个浏览器访问B Servlet，在B Servlet里获取Session对象，此时A Servlet中获取到的Session对象 与 B Servlet中获取到的Session对象不是同一个内存对象。</p><p>​这是因为关闭浏览器后，浏览器内存中存储的session对象的 id 就没了，当B servlet再次获取session对象时，发现浏览器中并没有存储session对象的 id 值，因此就直接在服务器内存中新建了一个Session对象，因此就不是同一个对象了。</p><hr><h3 id="D-Cookie-amp-Session的比较"><a href="#D-Cookie-amp-Session的比较" class="headerlink" title="D.Cookie &amp; Session的比较"></a>D.Cookie &amp; Session的比较</h3><p>​<img src="/imgs/image-20230424152116094.png" alt="image-20230424152116094" style="zoom:67%;" /></p><p>​总结：</p><ol><li><p>Cookie一般用于用户未登录时进行身份验证的，而Session用来存储用户登录之后的数据的。</p></li><li><p>如果想让数据在关闭浏览器之后，下次打开浏览器时还存在，那么就只能使用Cookie。</p><p> 因为在浏览器关闭之后，保存到客户端的Session id 就会被销毁，下次打开浏览器再获取Session对象就不是同一个了。</p></li></ol><hr><h3 id="E-登录注册案例"><a href="#E-登录注册案例" class="headerlink" title="E.登录注册案例"></a>E.登录注册案例</h3><p><img src="/../imgs/image-20221122161512961-1682310001088.png" alt="image-20221122161512961"></p><h4 id="①用户登录"><a href="#①用户登录" class="headerlink" title="①用户登录"></a>①用户登录</h4><p><img src="/../imgs/image-20221122162023281-1682310001088.png" alt="image-20221122162023281"></p><p>​实现步骤：</p><ol><li><p>先写Dao层，再写Service层。</p></li><li><p>写登录页面 login.jsp。</p><p> 因为将来登录失败之后，需要动态获取数据来显示错误的提示信息，如果使用HTML就实现不了这个功能，所以得使用JSP。</p></li><li><p>编写LoginServlet。</p><ol><li><p>如果登录成功，则需要跳转到查询所有数据的Servlet去。可以使用请求转发或请求重定向来实现转发。这里使用请求重定向，因为想用一下Session对象。</p><ol><li>转发之前，先获取Session对象，调用设置参数的方法，将user对象存储到Session对象里。</li><li>在查询所有数据的JSP里，使用EL表达式获取user对象中的username。</li></ol></li><li><p>如果登录失败，则重新跳回到login.jsp。我们可以使用请求转发来实现跳转，跳转前先将提示信息 “用户名或密码错误”存储到request对象中。</p><ol><li><p>login.jsp页面中添加</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;提示信息对应的request对象中的键名&#125;</span><br></pre></td></tr></table></figure><p> 当request对象中没有该键名时，这行代码在页面中就什么也不会显示，当用户输入错误，就可以获取到其值，然后将 “用户名或密码错误”显示到页面。</p></li></ol></li></ol></li><li><p>完成。</p></li></ol><hr><h4 id="②记住用户"><a href="#②记住用户" class="headerlink" title="②记住用户"></a>②记住用户</h4><p>​<img src="/imgs/image-20230424152127444.png" alt="image-20230424152127444" style="zoom:67%;" /></p><p>​</p><p>​实现步骤：</p><ol><li><p>在页面login.jsp中的复选框里添加一个value属性 “value&#x3D;1”，当此复选框被勾选时value就会随着请求一起发送到服务器，我们就可以通过request对象来获取此value值，然后判断是否等于1，等于则说明复选框被勾选。</p></li><li><p>修改login.jsp，当登录成功并且复选框被选中，就将用户名和密码存储到Cookie对象中，设置存活数据，发送Cookie。</p><p> <img src="/../imgs/image-20221123105055644-1682310001088.png" alt="image-20221123105055644"></p></li><li><p>在login.jsp页面获取Cookie数据后，设置到用户名和密码框中。</p><p> 如何在JSP页面中获取Cookie数据呢？</p><p> 使用**${cookie.key.value}** &#x2F;&#x2F;其中key指存储在Cookie中的键名称，例子：${cookie.username.value} </p><p> <img src="/../imgs/image-20221123111359565-1682310001088.png" alt="image-20221123111359565"></p></li><li><p>完成</p></li></ol><hr><h4 id="③用户注册"><a href="#③用户注册" class="headerlink" title="③用户注册"></a>③用户注册</h4><p>​<img src="/../imgs/image-20221123114556845-1682310001088.png" alt="image-20221123114556845"></p><p>​</p><p>​实现步骤：</p><ol><li><p>在UserMapper接口中编写两个方法。</p></li><li><p>在UserService类中写注册方法。</p> <img src="/imgs/image-20230424152137911.png" alt="image-20230424152137911" style="zoom:67%;" /></li><li><p>编写注册页面register.jsp。因为将来要动态显示信息，所以得用JSP。</p></li><li><p>编写RegisterServlet。</p><p> <img src="/../imgs/image-20221123120456027-1682310001088.png" alt="image-20221123120456027"></p><p> <img src="/../imgs/image-20221123120431574-1682310001088.png" alt="image-20221123120431574"></p></li><li><p>在login.jsp和register.jsp对应的位置获取数据即可。</p></li><li><p>完成。</p></li></ol><hr><h4 id="④验证码–展示验证码"><a href="#④验证码–展示验证码" class="headerlink" title="④验证码–展示验证码"></a>④验证码–展示验证码</h4><p>​验证码其实就是由Java生成的一张图片。</p><p>​功能要求：</p><p>​展示验证码图片，并可以点击切换。</p><p>​实现步骤：</p><ol><li><p>修改验证码图片的访问路径。</p><p> <img src="/../imgs/image-20221123161817117-1682310001088.png" alt="image-20221123161817117"></p></li><li><p>编写checkCodeServlet，专门用来生成验证码和验证码图片。</p><p> <img src="/../imgs/image-20221123160616951-1682310001088.png" alt="image-20221123160616951"></p></li><li><p>为 “看不清” 按钮添加单击事件，实现换验证码图片的功能。</p><p> <img src="/../imgs/image-20221123162255170-1682310001088.png" alt="image-20221123162255170"></p><p> 如果不加 “new Date().getMillliseconds()” ，就会导致点击一次 “看不清”后再点击就换不了图片，原因是scr的那个路径被缓存了，所以得让这个src路径变化且唯一，因此在后面加上当前的时间即可。</p></li></ol><hr><h4 id="⑤验证码–校验验证码"><a href="#⑤验证码–校验验证码" class="headerlink" title="⑤验证码–校验验证码"></a>⑤验证码–校验验证码</h4><p>​验证码图片访问和提交注册表单是两次请求，所以要将程序生成的验证码存入Session中。</p><img src="/imgs/image-20230424152148060.png" alt="image-20230424152148060" style="zoom:67%;" /><p>​实现步骤：</p><ol><li><p>在CheckCodeServlet中将验证码存入session。</p><p> <img src="/../imgs/image-20221123164008334-1682310001089.png" alt="image-20221123164008334"></p></li><li><p>在regiserServlet里获取用户输入的验证码数据，获取程序生成的验证码。</p><p> <img src="/../imgs/image-20221123164406790-1682310001089.png" alt="image-20221123164406790"></p></li><li><p>比对验证码信息。比对操作要写在注册操作的前面，不然注册了再进行比对就没有意义了。</p><p> <img src="/../imgs/image-20221123165517995-1682310001089.png" alt="image-20221123165517995"></p></li><li><p>在register.jsp页面中补充一段代码，用于验证码输入错误时出现提示信息。</p> <figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h6&gt;$&#123;register_msg&#125;&lt;/h6&gt;</span><br></pre></td></tr></table></figure></li><li><p>完成。</p></li></ol><hr><h2 id="11、Filter"><a href="#11、Filter" class="headerlink" title="11、Filter"></a>11、Filter</h2><h3 id="A-概述-1"><a href="#A-概述-1" class="headerlink" title="A.概述"></a>A.概述</h3><p>​<img src="/imgs/image-20230424152155797.png" alt="image-20230424152155797" style="zoom:67%;" /></p><p>​资源中一些通用的操作可以放到Filter过滤器中，这样可以节省代码量。</p><h3 id="B-Filter快速入门"><a href="#B-Filter快速入门" class="headerlink" title="B.Filter快速入门"></a>B.Filter快速入门</h3><p><img src="/../imgs/image-20221123182453927-1682310001089.png" alt="image-20221123182453927"></p><p>​</p><hr><h3 id="C-Filter执行流程"><a href="#C-Filter执行流程" class="headerlink" title="C.Filter执行流程"></a>C.Filter执行流程</h3><p>​<img src="/imgs/image-20230424152204323.png" alt="image-20230424152204323" style="zoom:67%;" /></p><p>​</p><ul><li><p>Filter执行流程：<img src="/imgs/image-20230424152244187.png" alt="image-20230424152244187"></p></li><li><p>一般，放行前，对request对象中的数据进行处理；放行后，对response数据进行处理。</p><p>  因为放行前request对象中就已经有数据了（服务器会自动地将请求数据放到request对象中），而response对象中还没有数据，所以放行前对equest对象中的数据进行处理。放行后，就会去访问服务器的资源，然后回到Filter中执行放行后的代码，因此放行后会对response数据进行处理。</p></li></ul><hr><h3 id="D-Filter使用细节"><a href="#D-Filter使用细节" class="headerlink" title="D.Filter使用细节"></a>D.Filter使用细节</h3><h4 id="①Filter-拦截路径配置"><a href="#①Filter-拦截路径配置" class="headerlink" title="①Filter 拦截路径配置"></a>①Filter 拦截路径配置</h4><p>​<img src="/imgs/image-20230424152252945.png" alt="image-20230424152252945" style="zoom:67%;" /></p><h4 id="②过滤器链"><a href="#②过滤器链" class="headerlink" title="②过滤器链"></a>②过滤器链</h4><p>​<img src="/imgs/image-20230424152301823.png" alt="image-20230424152301823" style="zoom:67%;" /></p><ul><li><p>按照上图，Filter的执行流程是：Filter1 –&gt; 放行前逻辑 –&gt; 放行 –&gt; Filter2的放行前逻辑 –&gt; 放行 –&gt; web资源 –&gt; Filter2中的放行后逻辑 –&gt; Filter1中的放行后逻辑。</p></li><li><p>如果有多个过滤器，那先执行哪个过滤器呢？</p><p>  注解配置的Filter，过滤器的执行顺序是按照 过滤器类名的升序排序的，即对类名中的每个字母按照字母顺序进行比较，小的就先执行。</p><p>  如：过滤器1的类名为：filterDemo，过滤器2的类名为：filterDemo2，过滤器3的类名为：AFilter。</p><p>  ​其执行顺序是：</p><p>  ​AFilter –&gt; filterDemo –&gt; filterDemo2</p><p>  ​因为A排在F的前面，因此比较小先执行；filterDemo 和 filterDemo2前面都一样，而filterDemo的 “o” 后面没有东西，所以比较小。</p></li></ul><hr><h3 id="E-案例"><a href="#E-案例" class="headerlink" title="E.案例"></a>E.案例</h3><p>​引入：</p><p>​我们希望服务器中任何资源被访问前都先登录然后再访问。如果每个资源中都写判断是否登录的代码，那就会有很多重复的代码，所以就不妨把判断是否登录的代码放在过滤器中，这样就可以节省代码量。</p><p>​<img src="/../imgs/image-20221124215854668-1682310001089.png" alt="image-20221124215854668"></p><p>​</p><p>​实现：</p><p><img src="/../imgs/image-20221124220505631-1682310001089.png" alt="image-20221124220505631"></p><p><img src="/../imgs/image-20221124220522055-1682310001089.png" alt="image-20221124220522055"></p><p><img src="/../imgs/image-20221124220542999-1682310001089.png" alt="image-20221124220542999"></p><hr><h2 id="12、Listener"><a href="#12、Listener" class="headerlink" title="12、Listener"></a>12、Listener</h2><h3 id="A-概述-2"><a href="#A-概述-2" class="headerlink" title="A.概述"></a>A.概述</h3><p><img src="/../imgs/image-20221125154415677-1682310001089.png" alt="image-20221125154415677"></p><p>​在这个8个监听器中最重要的就是ServletContextListener监听器，其代表着整个web项目。（当web应用发布成功时，就会自动创建ServletContextListener对象，调用其里面的contextInitialized方法；当web项目被卸载时，就会调用其里面的contextDestroyed方法进行销毁）</p><h3 id="B-ServletContextListener使用"><a href="#B-ServletContextListener使用" class="headerlink" title="B.ServletContextListener使用"></a>B.ServletContextListener使用</h3><ol><li>写一个类，该类继承ServletContextListener接口，复写接口中所有的方法。</li><li>在该类上面写上@WebListener注解。</li></ol><p>补充：</p><ol><li>一般在contextInitialized()方法里进行资源的加载操作，在contextDestroyed()里释放资源。</li><li>现在先不用管其里面需要加载哪些资源，到时候讲到Spring时，Spring里面就是用ServletContextListener监听器中的contextInitialized()方法来加载Spring所需要的资源的。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web核心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ElementUI</title>
      <link href="/2023/04/24/ElementUI/"/>
      <url>/2023/04/24/ElementUI/</url>
      
        <content type="html"><![CDATA[<h2 id="①概述"><a href="#①概述" class="headerlink" title="①概述"></a>①概述</h2><ul><li><p>Element：是饿了么公司前端开发团队提供的一套基于 Vue 的网站组件库，用于快速构建网页。</p></li><li><p>组件：组成网页的部件，例如 超链接、按钮、图片、表等等~。</p></li><li><p>Element官网：</p>  <figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://element.eleme.cn/#/zh-CN/component/carousel</span><br></pre></td></tr></table></figure></li></ul><h2 id="②Element快速入门"><a href="#②Element快速入门" class="headerlink" title="②Element快速入门"></a>②Element快速入门</h2><ol><li><p>将Element ui文件复制到webapp下（Element ui文件在电脑 D:\web开发所需资料）</p></li><li><p>创建一个HTML。引入Element的css、js文件和 Vue.js。注意：文件路径从webapp下开始写</p><p> <img src="/imgs/image-20230312180602805-1682321984281.png" alt="image-20230312180602805"></p></li><li><p>创建div标签，设置其id值为app。以后从官网复制过来的代码都放在div标签包裹的范围里。如果涉及到CSS代码，则将CSS代码（style标签里包裹的代码就是CSS代码）放到HTML页面中的head标签里。</p></li><li><p>创建Vue核心对象</p><p> <img src="/imgs/image-20221128210855663-1682321984283.png" alt="image-20221128210855663"></p></li><li><p>官网复制Element组件代码</p></li></ol><p>​说明：不用看懂从官网复制的代码，你也看不懂，因为这是用Element定义的，不是HTML标签。实在不知道其意思，就试试将一部分代码删掉，再还原，此时就清楚其意思了。 </p><hr><h2 id="③Element布局"><a href="#③Element布局" class="headerlink" title="③Element布局"></a>③Element布局</h2><p>Element中有两种布局的方式：</p><ol><li><p>Layout布局：按行进行布局，一行里有24个格子。</p><p> <img src="/imgs/image-20221128214114256-1682321984283.png" alt="image-20221128214114256"></p><p> 如果想让这一行里只有两个格子，则让每个格子占12个格子的宽度。如：</p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-row</span>&gt;</span>   <span class="comment">&lt;!-- row代表行 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">el-col</span> <span class="attr">:span</span>=<span class="string">&quot;12&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;grid-content bg-purple&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">el-col</span>&gt;</span>   <span class="comment">&lt;!-- col代列 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">el-col</span> <span class="attr">:span</span>=<span class="string">&quot;12&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;grid-content bg-purple-light&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">el-col</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-row</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- 这里一共有一行，两个格子 --&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>Container布局容器：带侧边导航栏的布局方式。</p><p> <img src="/imgs/image-20221128213747606-1682321984283.png" alt="image-20221128213747606"></p></li></ol><hr><h2 id="④Element组件"><a href="#④Element组件" class="headerlink" title="④Element组件"></a>④Element组件</h2><p>​具体使用见Element官网。将官网中的代码复制过来，然后根据实际情况修改即可。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://element.eleme.cn/#/zh-CN/component/card</span><br></pre></td></tr></table></figure><hr><h2 id="⑤案例"><a href="#⑤案例" class="headerlink" title="⑤案例"></a>⑤案例</h2><h3 id="A-查询所有"><a href="#A-查询所有" class="headerlink" title="A.查询所有"></a>A.查询所有</h3><p><img src="/imgs/image-20221129170413333-1682321984283.png" alt="image-20221129170413333"></p><p>​</p><p>​实现：</p><ol><li><p>编写BrandMapper</p><ol><li><p>如果brand对象中的属性名和brand表中的字段名不一致，那就要像下面那样做映射。</p><p> <img src="/imgs/image-20221129170908576-1682321984284.png" alt="image-20221129170908576"></p></li><li><p>编写SQL语句</p><p> <img src="/imgs/image-20221129171111240-1682321984283.png" alt="image-20221129171111240"></p></li></ol></li><li><p>在Java下的service包下建对应service的接口，其实现类就放在impl文件下即可。（impl文件是放service文件下的）</p><p> 这样做的目的是降低web层和service层代码的耦合性（即关联程度）。</p><p> <img src="/imgs/image-20221129172310701-1682321984284.png" alt="image-20221129172310701"></p> <img src="/imgs/image-20230424154158092.png" alt="image-20230424154158092" style="zoom:67%;" /> </li><li><p>编写SelectAllServlet</p><p> <img src="/imgs/image-20221129173234909-1682321984284.png" alt="image-20221129173234909"></p></li><li><p>后台代码写完，对其进行测试看是否有出错。打开浏览器访问SelectAllServlet，如果页面中返回了JSON中的数据，则代表后台代码编写没有问题。</p></li><li><p>编写brand.html页面</p><ol><li><p>数据展示部分的代码可以抄Element官网中的表格，然后根据实际情况修改即可。</p></li><li><p>实现模型的双向绑定</p><p> <img src="/imgs/image-20221129174403466-1682321984286.png" alt="image-20221129174403466"></p><p> <img src="/imgs/image-20221129174331722-1682321984286.png" alt="image-20221129174331722"></p></li></ol></li><li><p>完成</p></li></ol><hr><h3 id="B-新增品牌"><a href="#B-新增品牌" class="headerlink" title="B.新增品牌"></a>B.新增品牌</h3><p><img src="/imgs/image-20221129183620359-1682321984286.png" alt="image-20221129183620359"></p><p>实现：</p><ol><li><p>编写BrandMapper</p><p> <img src="/imgs/image-20221129184045280-1682321984286.png" alt="image-20221129184045280"></p></li><li><p>在brandService接口中写上add方法，然后在刚才的brandService实现类中重写add方法</p><ol><li><p>brandService接口：</p><p> <img src="/imgs/image-20221129184449915-1682321984286.png" alt="image-20221129184449915"></p></li><li><p>brandService实现类：</p><p> <img src="/imgs/image-20221129184709296-1682321984287.png" alt="image-20221129184709296"></p></li></ol></li><li><p>编写AddServlet</p><p> <img src="/imgs/image-20221129185319861-1682321984287.png" alt="image-20221129185319861"></p></li><li><p>编写brand.html</p><p> <img src="/imgs/image-20221129210925084-1682321984287.png" alt="image-20221129210925084"></p><p> <img src="/imgs/image-20221129210742216-1682321984287.png" alt="image-20221129210742216"></p><p> <img src="/imgs/image-20221129205408131-1682321984287.png" alt="image-20221129205408131"></p><p> 补充：</p><p> <img src="/imgs/image-20221129205550233-1682321984287.png" alt="image-20221129205550233"></p></li></ol><hr><h3 id="C-Servlet代码优化"><a href="#C-Servlet代码优化" class="headerlink" title="C.Servlet代码优化"></a>C.Servlet代码优化</h3><h4 id="①引入"><a href="#①引入" class="headerlink" title="①引入"></a>①引入</h4><p>​以前我们每写一个功能就写对应的Servlet，随着功能不断丰富Servlet个数也越来越多，就不利于管理和编写，因此我们得对Servlet进行归类，对同一个实体的操作方法，写到一个Servlet中。比如：BrandServlet、UserServlet。</p><h4 id="②原理"><a href="#②原理" class="headerlink" title="②原理"></a>②原理</h4><p>​当我们访问BrandServlet时，其就会自动调用BaseServlet里的service方法，service方法就会根据请求路径的最后一段路径（我们约定这段路径写方法名），来调用对应Servlet中的方法。方法里再写些获取请求参数等操作。</p><p>​这就实现了Servlet代码优化。</p><h4 id="③实现步骤"><a href="#③实现步骤" class="headerlink" title="③实现步骤"></a>③实现步骤</h4><ol><li>先造一个基础的Servlet，命名为：BaseServlet。让其继承HttpServlet，重写service方法（重写内容如下：）</li></ol><p>  <img src="/imgs/image-20221130134703517-1682321984287.png" alt="image-20221130134703517"></p><p>  <img src="/imgs/image-20221130124052643-1682321984287.png" alt="image-20221130124052643"></p><p>  补充：</p><ul><li>上图中的this代表：BaseServlet的子类，如：BrandServlet、UserServlet等。</li><li>上图第40行代码中的getMehod方法：第一个参数是方法名，剩下的参数是：被获取方法的参数。该方法会抛异常，因此需要try-catch。</li><li>上图第42行代码中invoke方法：用于执行对应方法。实参req、resp：为第18行代码中的req、resp。该方法也会抛异常，因此也需要try-catch。</li></ul><ol start="2"><li><p>编写BrandServlet（以后对Brand进行操作的Servlet都放在这），让其继承刚才写的BaseServlet。</p><p> BrandServlet的访问路径得改成：&#x2F;brand&#x2F;*</p><p> <img src="/imgs/image-20221130130159491-1682321984287.png" alt="image-20221130130159491"></p><p> 例子：</p><p> <img src="/imgs/image-20221130140102546-1682321984288.png" alt="image-20221130140102546"></p></li></ol><hr><h3 id="D-批量删除"><a href="#D-批量删除" class="headerlink" title="D.批量删除"></a>D.批量删除</h3><p><img src="/imgs/image-20221130162304255-1682321984288.png" alt="image-20221130162304255"></p><p>实现：</p><ol><li><p>编写BrandMapper</p><p> <img src="/imgs/image-20221130162855157-1682321984288.png" alt="image-20221130162855157"></p><p> 由于此SQL语句比较复杂，就不使用注解开发，我们在对应的xml文件中写SQL语句。</p><p> <img src="/imgs/image-20221130170724498-1682321984288.png" alt="image-20221130170724498"></p><p> 如果忘记了如何写SQL语句，可以看笔记：MyBatis练习 –&gt; 删除–批量删除</p></li><li><p>编写BrandService。先在BrandService接口中声明deleteByIds方法，再去BrandService类中实现该方法。</p><p> <img src="/imgs/image-20221130163428292-1682321984288.png" alt="image-20221130163428292"></p></li><li><p>在BrandServlet里写deleteByIds方法。</p><p> <img src="/imgs/image-20221130163957050-1682321984289.png" alt="image-20221130163957050"></p></li><li><p>为批量删除按钮绑定事件，发送异步请求。</p><p> <img src="/imgs/image-20221130164534622-1682321984289.png" alt="image-20221130164534622"></p><p> 在Vue对象里的data部分创建一个selectedIds模型，用于存放被选中的id。</p><p> <img src="/imgs/image-20221130165924711-1682321984289.png" alt="image-20221130165924711"></p><p> 编写deleteByIds方法</p><p> <img src="/imgs/image-20221130170255771-1682321984289.png" alt="image-20221130170255771"></p><p> <img src="/imgs/image-20221130171235331-1682321984289.png" alt="image-20221130171235331"></p><p> <img src="/imgs/image-20221130174320989-1682321984289.png" alt="image-20221130174320989"></p><p> <img src="/imgs/image-20221130171530066-1682321984289.png" alt="image-20221130171530066"></p></li><li><p>完成</p></li></ol><hr><h3 id="E-分页查询"><a href="#E-分页查询" class="headerlink" title="E.分页查询"></a>E.分页查询</h3><h4 id="①复习"><a href="#①复习" class="headerlink" title="①复习"></a>①复习</h4><p>​之前我们在学习SQL的时候有学到分页查询，其用到的关键字为LIMIT </p><p><img src="/imgs/image-20230424154343007.png" alt="image-20230424154343007"></p><p><img src="/imgs/image-20221130180200634-1682321984289.png" alt="image-20221130180200634"></p><h4 id="②分析"><a href="#②分析" class="headerlink" title="②分析"></a>②分析</h4><p><img src="/imgs/image-20221130180822799-1682321984289.png" alt="image-20221130180822799"></p><p>如何才能一次性将后台数据List和totalCount发送给前端呢？将这两个数据封装到一个对象里，然后将对象传递过去进行。</p><h4 id="③实现"><a href="#③实现" class="headerlink" title="③实现"></a>③实现</h4><p><img src="/imgs/image-20221130183614827-1682321984290.png" alt="image-20221130183614827"></p><ol><li>编写BrandMapper</li></ol><p>  分页功能的实现需要后端传：分页结果、总记录数</p><p>  <img src="/imgs/image-20221130184101837-1682321984290.png" alt="image-20221130184101837"></p><ol start="2"><li><p>编写BrandService</p><p> 在BrandService里调用上面的两个SQL，因为这两个结果都需要返回给前端，所以就将数据封装到一个pageBean对象里。</p><p> 在pojo包下编写pageBean</p><p> <img src="/imgs/image-20221130182539066-1682321984290.png" alt="image-20221130182539066"></p><p> 先在BrandService接口中声明selectByPage方法。</p><p> <img src="/imgs/image-20221130184456247-1682321984290.png" alt="image-20221130184456247"></p><p> 在BrandService类中实现该方法</p><p> <img src="/imgs/image-20221130185614307-1682321984290.png" alt="image-20221130185614307"></p><p> <img src="/imgs/image-20221130185737858-1682321984290.png" alt="image-20221130185737858"></p></li><li><p>编写BrandServlet</p></li></ol><pre><code>获取前端发来的分页数据，并进行处理</code></pre><p><img src="/imgs/image-20221130201717396-1682321984290.png" alt="image-20221130201717396"></p><p>​</p><pre><code>3. 后端代码编写完成</code></pre><ol start="3"><li><p>编写前端代码</p><p> <img src="/imgs/image-20221130202431316-1682321984290.png" alt="image-20221130202431316"></p><ol><li><p>对分页工具条进行改造</p><p> <img src="/imgs/image-20221130205610788-1682321984291.png" alt="image-20221130205610788"></p><p> <img src="/imgs/image-20221130205655494-1682321984291.png" alt="image-20221130205655494"></p><p> ​改造Vue对象中的handleSizeChange方法及handleCurrentChange方法</p><p> <img src="/imgs/image-20221130210341041-1682321984291.png" alt="image-20221130210341041"></p></li><li><p>对Vue对象中的selectAll方法进行改造，改成分页查询的代码</p><p> <img src="/imgs/image-20221130204604741-1682321984291.png" alt="image-20221130204604741"></p></li></ol></li><li><p>完成</p></li></ol><hr><h3 id="F-条件查询"><a href="#F-条件查询" class="headerlink" title="F.条件查询"></a>F.条件查询</h3><p><img src="/imgs/image-20221201172950909-1682321984291.png" alt="image-20221201172950909"></p><p><img src="/imgs/image-20221201173535266-1682321984291.png" alt="image-20221201173535266"></p><p>实现：</p><ol><li><p>编写BrandMapper</p><p> <img src="/imgs/image-20221201174444242-1682321984291.png" alt="image-20221201174444242"></p><p> 在对应的xml文件中编写SQL语句：</p><p> <img src="/imgs/image-20221201175615596-1682321984291.png" alt="image-20221201175615596"></p><p> <img src="/imgs/image-20221201180222808-1682321984291.png" alt="image-20221201180222808"></p></li><li><p>编写BrandService</p><ol><li><p>在BrandService接口中编写selectByPageAndCondition方法</p><p> <img src="/imgs/image-20221201180505349-1682321984292.png" alt="image-20221201180505349"></p></li><li><p>在BrandService类中实现该方法</p><p> <img src="/imgs/image-20221201182138878-1682321984292.png" alt="image-20221201182138878"></p><p> <img src="/imgs/image-20221201182016734-1682321984292.png" alt="image-20221201182016734"></p><p> <img src="/imgs/image-20221201182118420-1682321984292.png" alt="image-20221201182118420"></p></li></ol></li><li><p>在brandServlet中编写selectByPageAndCondition方法，在方法里写获取数据、调用service中方法等操作</p><p> <img src="/imgs/image-20221201183858823-1682321984292.png" alt="image-20221201183858823"></p><p> <img src="/imgs/image-20221201182813902-1682321984292.png" alt="image-20221201182813902"></p></li><li><p>后端代码编写完成</p></li></ol><p>​前端代码编写：</p><p><img src="/imgs/image-20221201210322239-1682321984292.png" alt="image-20221201210322239"></p><ol><li><p>为查询按钮绑定单击事件</p><p> <img src="/imgs/image-20221201210416941-1682321984292.png" alt="image-20221201210416941"></p></li><li><p>详见视频</p> <figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.bilibili.com/video/BV1Qf4y1T7Hx/?p=162&amp;spm_id_from=pageDriver&amp;vd_source=9c398663599ac78b625d463b4ffc1ff5</span><br></pre></td></tr></table></figure></li></ol><h2 id="⑥补充"><a href="#⑥补充" class="headerlink" title="⑥补充"></a>⑥补充</h2><ol><li><p><img src="/imgs/image-20221201212936677-1682321984292.png" alt="image-20221201212936677"></p></li><li><p>es6之后我们引入了箭头表达式，可以简化Axios中then部分代码的书写</p><p> es6之前的写法：</p><p> <img src="/imgs/image-20221201212359565-1682321984293.png" alt="image-20221201212359565"></p><p> ​es6之后的写法：（此时then中的this就指的是Vue对象）</p><p> <img src="/imgs/image-20221201212111220-1682321984293.png" alt="image-20221201212111220"></p><p> ​</p></li></ol><p></p>]]></content>
      
      
      <categories>
          
          <category> Java Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ElementUI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue</title>
      <link href="/2023/04/24/vue/"/>
      <url>/2023/04/24/vue/</url>
      
        <content type="html"><![CDATA[<h2 id="①概述"><a href="#①概述" class="headerlink" title="①概述"></a>①概述</h2><p><img src="/imgs/image-20221127192947272-1682321667875.png" alt="image-20221127192947272"></p><p>​双向绑定之后，Model中的数据发生变化View中的数据也会跟着发生变化；View中的数据发生变化，model中的数据也会跟着变化，这些变化都是自动完成的。</p><p>​View即HTML等，Model即数据。</p><hr><h2 id="②Vue快速入门"><a href="#②Vue快速入门" class="headerlink" title="②Vue快速入门"></a>②Vue快速入门</h2><ol><li><p>在webapp下建一个js目录，在vue官网下载vue.js文件，并将其放到刚才创建的js目录下。</p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://v2.cn.vuejs.org/v2/guide/installation.html</span><br></pre></td></tr></table></figure><p> <img src="/imgs/image-20221128092019798-1682321667877.png" alt="image-20221128092019798"></p></li><li><p>在webapp下新建HTML页面，写相关代码。</p><ol><li>引入Vue.js文件。</li></ol><p>   <img src="/imgs/image-20221128221027634-1682321667877.png" alt="image-20221128221027634"></p><ol start="2"><li>在script标签里创建Vue核心对象，进行数据绑定。</li></ol><p>   <img src="/imgs/image-20221128155708651-1682321667877.png" alt="image-20221128155708651"></p>   <img src="C:\Users\橙子\AppData\Roaming\Typora\typora-user-images\image-20221128152323193.png" alt="image-20221128152323193" style="zoom:67%;" /><p>  补充：</p><p> el属性的值一般为div标签中的id属性值，即：“#div标签的id值”。</p></li></ol><hr><h2 id="③Vue常用指令"><a href="#③Vue常用指令" class="headerlink" title="③Vue常用指令"></a>③Vue常用指令</h2><ul><li><p>指令：HTML标签上带有v-前缀的特殊属性。</p></li><li><p><img src="/imgs/image-20221128153146940-1682321667877.png" alt="image-20221128153146940"></p></li><li><p><img src="/imgs/image-20221128154515335-1682321667877.png" alt="image-20221128154515335"></p></li><li><p><img src="/imgs/image-20221128155524056-1682321667878.png" alt="image-20221128155524056"></p></li><li><p><img src="/imgs/image-20221128165940492-1682321667878.png" alt="image-20221128165940492"></p></li><li><p>sf1</p><p>  <img src="/imgs/image-20221128170906672-1682321667878.png" alt="image-20221128170906672"></p><p>  ​例子：</p><p>  <img src="/imgs/image-20221128170808623-1682321667878.png" alt="image-20221128170808623"></p><p>  <img src="/imgs/image-20221128171037620-1682321667878.png" alt="image-20221128171037620"></p><p>  <img src="/imgs/image-20221128170728942-1682321667878.png" alt="image-20221128170728942"></p></li></ul><hr><h2 id="④Vue生命周期"><a href="#④Vue生命周期" class="headerlink" title="④Vue生命周期"></a>④Vue生命周期</h2><p><img src="/imgs/image-20221128172227637-1682321667878.png" alt="image-20221128172227637"></p><p>​上面八个阶段中，我们重点关注挂载完成阶段mounted。因为挂载完成后，Vue初始化成功，HTML页面渲染成功，此时我们就会发生异步请求，加载数据。</p><p><img src="/imgs/image-20230424153528754.png" alt="image-20230424153528754"></p><hr><h2 id="⑤案例"><a href="#⑤案例" class="headerlink" title="⑤案例"></a>⑤案例</h2><p>​需求：使用Vue简化品牌列表数据查询和添加功能</p><ul><li><p>查询所有数据</p><p>  <img src="/imgs/image-20221128174544367-1682321667878.png" alt="image-20221128174544367"></p><p>  brand.html：</p><p>  <img src="/imgs/image-20221128181329131-1682321667879.png" alt="image-20221128181329131"></p><p>  <img src="/imgs/image-20221128180953473-1682321667879.png" alt="image-20221128180953473"></p><p>  ​说明：</p><ol><li><p>在Axios的then里使用this（this代表的是window对象），如果在Vue里Axios外面使用this（this代表当前Vue对象）。要想获取Vue里的模型数据，则要在如果在Vue里Axios外面使用this。</p></li><li><p>SelectAllServlet</p><p> 与JSON中案例一样做法。</p></li></ol></li><li><p>新增品牌</p><p>  <img src="/imgs/image-20221128183226881-1682321667879.png" alt="image-20221128183226881"></p><p>  实现：</p><p>  addBrand.html：</p><p>  <img src="/imgs/image-20221128184315288-1682321667879.png" alt="image-20221128184315288"></p><p>  <img src="/imgs/image-20221128184143087-1682321667879.png" alt="image-20221128184143087"></p></li></ul><p>​AddServlet：</p><p>​与JOSN中的案例一样做法。</p>]]></content>
      
      
      <categories>
          
          <category> Java Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web核心（上）</title>
      <link href="/2023/04/24/web%E6%A0%B8%E5%BF%83/"/>
      <url>/2023/04/24/web%E6%A0%B8%E5%BF%83/</url>
      
        <content type="html"><![CDATA[<h2 id="①概述"><a href="#①概述" class="headerlink" title="①概述"></a>①概述</h2><h3 id="A-B-x2F-S架构"><a href="#A-B-x2F-S架构" class="headerlink" title="A.B&#x2F;S架构"></a>A.B&#x2F;S架构</h3><p><img src="/../imgs/image-20221101095153149-1682310001084.png" alt="image-20221101095153149"></p><h3 id="B-浏览器如何访问到数据"><a href="#B-浏览器如何访问到数据" class="headerlink" title="B.浏览器如何访问到数据"></a>B.浏览器如何访问到数据</h3><p><img src="/../imgs/image-20221101095514293-1682310001085.png" alt="image-20221101095514293"></p><p>​浏览器通过数据传输协议HTTP发生请求给web服务器，web服务器收到请求后对HTTP协议进行解析，然后解析请求数据（服务器中存放了两种资源：静态资源、动态资源，动态资源负责逻辑处理和访问数据库，然后将动态资源发生给静态资源进行页面处理），并发送响应数据。</p><hr><h2 id="②HTTP"><a href="#②HTTP" class="headerlink" title="②HTTP"></a>②HTTP</h2><h3 id="A-概述"><a href="#A-概述" class="headerlink" title="A.概述"></a>A.概述</h3><h4 id="①概念"><a href="#①概念" class="headerlink" title="①概念"></a>①概念</h4><p><img src="/../imgs/image-20221101115959217-1682310001085.png" alt="image-20221101115959217"></p><h4 id="②HTTP特点"><a href="#②HTTP特点" class="headerlink" title="②HTTP特点"></a>②HTTP特点</h4><ol><li>基于TCP协议：面向连接，安全（在建立三次握手后再进行数据传输）。</li><li>基于请求-响应模型的：一次请求对应一次响应。</li><li>HTTP协议是无状态的协议：对于事务处理没有记忆能力。即：这次 “请求-响应”数据 并不会记录上一次的 “请求-响应” 的数据。<ul><li>缺点：多次请求间不能共享数据。Java中使用会话技术（Cookie、Session）来解决这个问题。<ul><li>例子：如果在网购时，选择某件商品将其加入购物车（这就完成了一次 “请求-响应” ），然后再点击购物车来查看购买的商品（这又是一次 “请求-响应” ），按照HTTP的无状态的特点，当我们点击购物车时是看不见购物车里有商品的，问了解决这个问题，所以我们就得使用Java中的会话技术来解决这个问题。</li></ul></li><li>优点：速度块。</li></ul></li></ol><h3 id="B-HTTP请求"><a href="#B-HTTP请求" class="headerlink" title="B.HTTP请求"></a>B.HTTP请求</h3><h4 id="①-请求数据格式"><a href="#①-请求数据格式" class="headerlink" title="①.请求数据格式"></a>①.请求数据格式</h4><ul><li><p>请求数据分为3部分：</p><ol><li><p>请求行：请求数据的第一行。其中GET表示请求方式(一共有7种请求方式)， &#x2F; ：表示请求资源路径(url)，HTTP&#x2F;1.1表示协议版本。</p></li><li><p>请求头：第二行开始，格式为key:value形式。</p> <img src="/imgs/image-20230424143722914.png" alt="image-20230424143722914" style="zoom: 67%;" /></li><li><p>请求体：POST请求特有，其位于POST请求的最后一部分，POST请求体与POST请求行之间是有空行隔开的。</p></li></ol></li></ul><h4 id="②-post请求和get请求区别"><a href="#②-post请求和get请求区别" class="headerlink" title="②.post请求和get请求区别"></a>②.post请求和get请求区别</h4><p>​<img src="/imgs/image-20230424143749954.png" alt="image-20230424143749954"></p><ol><li>GET请求请求参数在请求行的请求资源路径中，没有请求体。POST请求请求参数在请求体中。</li><li>由于GET请求请求参数存放在请求资源路径（即url）中，所以请求参数大小有限制。POST请求的请求参数大小没有限制。</li></ol><h3 id="C-HTTP响应"><a href="#C-HTTP响应" class="headerlink" title="C.HTTP响应"></a>C.HTTP响应</h3><h4 id="①响应数据格式"><a href="#①响应数据格式" class="headerlink" title="①响应数据格式"></a>①响应数据格式</h4><p>​<img src="/imgs/image-20230424143803097.png" alt="image-20230424143803097" style="zoom:67%;" /></p><p>​<img src="/imgs/image-20230424143813467.png" alt="image-20230424143813467" style="zoom:67%;" /></p><p>​</p><h4 id="②常见的HTTP响应头"><a href="#②常见的HTTP响应头" class="headerlink" title="②常见的HTTP响应头"></a>②常见的HTTP响应头</h4><p>​<img src="/imgs/image-20230424143825619.png" alt="image-20230424143825619" style="zoom:80%;" /></p><p>​补充：</p><ol><li>Content-Type的作用：告诉浏览器响要用 html 还是 image 去解析响应内容。</li><li>Cache-Control：在缓存时间内可以直接在本地上访问该页面，不用再发送请求，节省时间。</li></ol><h4 id="③响应状态码"><a href="#③响应状态码" class="headerlink" title="③响应状态码"></a>③响应状态码</h4><p><img src="/../imgs/image-20221101160303264-1682310001085.png" alt="image-20221101160303264"></p><p>​常见状态响应码</p><table><thead><tr><th align="center">状态码</th><th align="center">英文描述</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">200</td><td align="center">OK</td><td align="center">请求、响应成功，客户端正常访问到资源</td></tr><tr><td align="center">404</td><td align="center">Not Found</td><td align="center">请求资源不存在，一般是URL输入有误，或者网站资源被删除</td></tr><tr><td align="center">500</td><td align="center">Internal Server Error</td><td align="center">服务器发生不可预期的错误，服务器出现异常了，去看Java代码哪里出错了</td></tr></tbody></table><p>​其它状态响应码见：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://cloud.tencent.com/developer/chapter/13553</span><br></pre></td></tr></table></figure><hr><h2 id="③Web服务器-Tomcat"><a href="#③Web服务器-Tomcat" class="headerlink" title="③Web服务器-Tomcat"></a>③Web服务器-Tomcat</h2><h3 id="A-引入"><a href="#A-引入" class="headerlink" title="A.引入"></a>A.引入</h3><p>​原本我们需要去解析浏览器发给我们的HTTP请求并向浏览器发送响应，但现在不用了，web服务器就可以帮我们完成这些事。</p><h3 id="B-概念"><a href="#B-概念" class="headerlink" title="B.概念"></a>B.概念</h3><ol><li>Web服务器是一个应用软件，对HTTP协议的操作进行封装，使得程序员不必直接对协议进行操作，让Web开发更加便捷。Web服务器的主要功能是 “ 提供网上信息浏览服务 “。</li><li>Web服务器有：jetty:&#x2F;&#x2F; 、WebLogic、WebSphere、Tomcat</li></ol><p>​<strong>总结</strong>：</p><p>​Web服务器作用：</p><ol><li>封装HTTP协议操作，简化开发。</li><li>可以将web项目部署到服务器中，对外提供网上浏览服务。</li></ol><p>​</p><h3 id="C-Tomcat基本使用"><a href="#C-Tomcat基本使用" class="headerlink" title="C.Tomcat基本使用"></a>C.Tomcat基本使用</h3><h4 id="①下载、安装、卸载"><a href="#①下载、安装、卸载" class="headerlink" title="①下载、安装、卸载"></a>①下载、安装、卸载</h4><ul><li><p>下载</p><p>  直接在官网下载即可</p>  <figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://tomcat.apache.org/</span><br></pre></td></tr></table></figure><p>  选哪个版本下载？</p><p>  <img src="/../imgs/image-20221101210234025-1682310001085.png" alt="image-20221101210234025"></p></li><li><p>安装</p><p>  直接解压即可</p></li><li><p>卸载</p><p>  直接将整个tomcat目录删除即可</p></li></ul><h4 id="②Tomcat文件"><a href="#②Tomcat文件" class="headerlink" title="②Tomcat文件"></a>②Tomcat文件</h4><p>​<img src="/imgs/image-20230424143840531.png" alt="image-20230424143840531" style="zoom:80%;" /></p><ul><li>bin：存放可执行文件，其中 “.bat” 后缀的文件属于window的可执行文件， “.sh” 后缀的文件属于Linux的可执行文件。<ul><li>可以执行文件：点击之后直接运行的文件。</li></ul></li><li>conf：存放tomcat的配置文件。</li><li>lib：存放tomcat依赖的jar包。</li><li>logs：日志文件，如果以后web出现了错误，可以在日志文件中找到出错原因。</li><li>temp：存放临时文件。</li><li>webapps：将来将项目放到此目录下就实现了对项目的部署。</li><li>work：工作目录。</li></ul><h4 id="③启动、关闭"><a href="#③启动、关闭" class="headerlink" title="③启动、关闭"></a>③启动、关闭</h4><ul><li><p>启动</p><p>  <img src="/../imgs/image-20221102094759347-1682310001085.png" alt="image-20221102094759347"></p></li><li><p>关闭</p><ol><li>直接 x 掉运行窗口：强制关闭，不使用这种方式，因为会导致数据丢失。</li><li>bin\shutdown.bat：正常关闭</li><li>在运行窗口里输入：ctrl + c。正常关闭 —&gt; 推荐使用</li></ol><p>  在正常关闭的情况下，我们可以释放资源，而强制关闭则不能释放资源。</p></li></ul><h4 id="④配置"><a href="#④配置" class="headerlink" title="④配置"></a>④配置</h4><img src="/imgs/image-20230424143850052.png" alt="image-20230424143850052" style="zoom:80%;" /><p>​<strong>补充</strong>：启动窗口一闪而过，还有一个原因就是没有配置CATALINA_HOME环境变量</p><p>​<img src="/imgs/image-20230424143858259.png" alt="image-20230424143858259" style="zoom:67%;" /></p><p>​解决办法：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.cnblogs.com/wangkang0320/p/7404110.html</span><br></pre></td></tr></table></figure><h4 id="⑤部署"><a href="#⑤部署" class="headerlink" title="⑤部署"></a>⑤部署</h4><ul><li><p>Tomcat项目部署</p><ul><li><p>将项目放到Tomcat文件下的webapps目录下，即部署完成。</p><p>  如果项目比较大，直接将其复制过去会比较慢，所以推荐使用下面将项目打包的方式。</p></li></ul></li><li><p>一般JavaWeb项目会被打成war包，然后将war包放到webapps目录下，Tomcat会自动解压war文件。</p><ul><li>而IDEA中可以使用插件来完成对javaweb项目的打包操作。</li></ul></li></ul><h3 id="D-IDEA中创建maven-web项目"><a href="#D-IDEA中创建maven-web项目" class="headerlink" title="D.IDEA中创建maven web项目"></a>D.IDEA中创建maven web项目</h3><h4 id="①引入"><a href="#①引入" class="headerlink" title="①引入"></a>①引入</h4><p>​部署到tomcat服务器上的项目一般为Java web项目，用IDEA里的maven web就可以帮我们快速创建一个Java web项目了。</p><h4 id="②maven-web项目结构"><a href="#②maven-web项目结构" class="headerlink" title="②maven web项目结构"></a>②maven web项目结构</h4><img src="/imgs/image-20230424143907282.png" alt="image-20230424143907282" style="zoom:80%;" /><ul><li><p>开发中的Maven Web项目与普通的Maven Java项目的区别：</p><ol><li><p>Maven Web项目多了个webapp文件夹（用于存放web资源，如：css、HTML等）。</p></li><li><p>Maven Web项目中的pom.xml文件里需指定项目的打包方式为war。</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure><p> 注意：</p><p> 一个javaweb项目里必须要有webapp这个文件夹，该文件夹里必须要有WEB-INF这个文件，WEB-INF这个文件里又必须有web.xml这个文件。</p></li></ol></li><li><p>部署的Javaweb项目：</p><ol><li><p>如何得到？在IDEA中对项目右键 –&gt; run maven –&gt; package 。生成的打包内容放在该项目的target目录中。</p> <img src="/imgs/image-20230424143916006.png" alt="image-20230424143916006" style="zoom:80%;" /></li><li><p>部署的Java项目结构其实就是开发中的maven web项目结构中的webapp文件夹里的内容，不过WEB-INF文件夹中会有classes文件和lib文件。</p><ul><li>classes文件：存放编译后的Java字节码文件和resources的资源文件。</li><li>lib文件：存放pom.xml中依赖的jar包。</li></ul></li><li><p>将打包好的项目放到tomcat文件夹下的webapps文件里即可完成项目部署，然后就可以通过浏览器来访问了。</p></li></ol></li><li><p>补充：</p><p>  <img src="/../imgs/image-20221102154056588-1682310001085.png" alt="image-20221102154056588"></p></li></ul><p>​</p><h3 id="E-IDEA中创建Maven-Web项目–实现"><a href="#E-IDEA中创建Maven-Web项目–实现" class="headerlink" title="E.IDEA中创建Maven Web项目–实现"></a>E.IDEA中创建Maven Web项目–实现</h3><p>​</p><p>​<img src="/imgs/image-20230424143952502.png" alt="image-20230424143952502"></p><p><img src="/imgs/image-20230424144004559.png" alt="image-20230424144004559"></p><p><img src="/imgs/image-20230424144055434.png" alt="image-20230424144055434"></p><p><img src="/imgs/image-20230424144123015.png" alt="image-20230424144123015"></p><p>最后点击finish即可</p><ol start="5"><li><p>将新建好项目里的pom.xml文件中没用的插件删除掉。删剩如下内容即可：</p><p> <img src="/../imgs/image-20221102171618535-1682310001085.png" alt="image-20221102171618535"></p></li><li><p>补齐缺失的目录结构。在mai目录下建Java目录、resources目录。然后右键mask as 标记成相应的颜色。</p><p> <img src="/../imgs/image-20221102171935911-1682310001085.png" alt="image-20221102171935911"></p><p> <img src="/../imgs/image-20230220103104722-1682310001085.png" alt="image-20230220103104722"></p></li></ol><hr><h3 id="F-IDEA中使用Tomcat"><a href="#F-IDEA中使用Tomcat" class="headerlink" title="F.IDEA中使用Tomcat"></a>F.IDEA中使用Tomcat</h3><h4 id="①引入-1"><a href="#①引入-1" class="headerlink" title="①引入"></a>①引入</h4><p>​在编写web项目的过程中我们需要不停地运行网站进行测试，测试之前我们要先将web项目打包成war包，将war包放到tomcat目录下的webapp文件下，然后再运行网页，每次测试如果都这么做将会非常繁琐，使用我们就得在IDEA中使用Tomcat。</p><h4 id="②集成本地Tomcat"><a href="#②集成本地Tomcat" class="headerlink" title="②集成本地Tomcat"></a>②集成本地Tomcat</h4><ol><li><p>首先将本地Tomcat集成到Idea中</p></li><li><p><img src="/../imgs/image-20221102221348083-1682310001085.png" alt="image-20221102221348083"></p></li><li><p><img src="/imgs/image-20230424144213650.png" alt="image-20230424144213650"></p></li><li><p><img src="/imgs/image-20230424144305124.png" alt="image-20230424144305124"></p></li><li><p>进行项目部署</p><p> <img src="/imgs/image-20230424144316096.png" alt="image-20230424144316096"></p><p> 最后点击apply –&gt; ok即可</p></li><li><p>部署完成后，点击运行符号即可启动项目。</p></li></ol><h4 id="③Tomcat-maven插件"><a href="#③Tomcat-maven插件" class="headerlink" title="③Tomcat maven插件"></a>③Tomcat maven插件</h4><ol><li><p>安装maven helper插件，安装完之后在那里点击“restart idea”。</p> <img src="/imgs/image-20230424144325633.png" alt="image-20230424144325633" style="zoom:50%;" /> </li><li><p>在项目的pom.xml文件里导入tomcat插件</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--tomcat插件--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--注意只支持tomcat7及以下的版本--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--配置访问tomcat时的端口号,默认为8080--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">port</span>&gt;</span>80<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--配置访问该项目的路径，如果不配置会使用默认值--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">path</span>&gt;</span>/<span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>右击项目名 –&gt; run maven –&gt; tomcat7:run  –&gt; 点击如下链接即可访问</p><p> <img src="/../imgs/image-20221103150640685-1682310001085.png" alt="image-20221103150640685"></p></li></ol><hr><h2 id="④Servlet"><a href="#④Servlet" class="headerlink" title="④Servlet"></a>④Servlet</h2><h3 id="A-概述-1"><a href="#A-概述-1" class="headerlink" title="A.概述"></a>A.概述</h3><p>​<img src="/imgs/image-20230424144339044.png" alt="image-20230424144339044"></p><ol><li>Servlet是Java提供的一门动态web资源开发技术。</li><li>Servlet其实就是一个接口，将来我们需要定义servlet接口的实现类，并由web服务器运行servlet。</li></ol><h3 id="B-快速入门"><a href="#B-快速入门" class="headerlink" title="B.快速入门"></a>B.快速入门</h3><h4 id="①Servlet编写"><a href="#①Servlet编写" class="headerlink" title="①Servlet编写"></a>①Servlet编写</h4><p><img src="/../imgs/image-20221103171322067-1682310001086.png" alt="image-20221103171322067"></p><p>​<img src="/imgs/image-20230424144347746.png" alt="image-20230424144347746"></p><p>​上面的访问路径仅作参考</p><p>​<strong>补充</strong>：</p><p>​servlet的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="②说明"><a href="#②说明" class="headerlink" title="②说明"></a>②说明</h4><ol><li>Servlet依赖中的<scope>标签是用于规定依赖范围的，provided表示该依赖只能在编译和测试时使用。为什么要规定这个范围呢？这是因为Tomcat中也包含了Servlet，如果我们项目运行中也使用servlet就会造成冲突。所以得这样做。</li><li>Servlet接口中的service方法是自动执行的，当我们访问Servlet时，Servlet就会自动调用service方法。<ul><li>service方法是Servlet接口中最重要的方法。</li></ul></li></ol><h3 id="C-Servlet执行流程"><a href="#C-Servlet执行流程" class="headerlink" title="C.Servlet执行流程"></a>C.Servlet执行流程</h3><p><img src="/../imgs/image-20221103195232838-1682310001085.png" alt="image-20221103195232838"></p><ol><li><p>我们编写好Servlet后启动Tomcat服务器输入URL就能够访问到Servlet。而访问Servlet的URL由三部分组成：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/web-demo/demo1    各部分对应的内容：</span><br><span class="line">http://localhost:8080 --&gt; 主机上端口为8080的软件，即Tomcat（Tomcat的默认端口号为8080）</span><br><span class="line">web-demo --&gt; 该web项目的访问地址</span><br><span class="line">demo1 --&gt; 该Servlet的访问地址</span><br></pre></td></tr></table></figure></li><li><p>为什么我们访问Servlet时，就能自动访问Servlet接口中的service方法？而我们并没有创建Servlet对象，调用service方法</p><p> 因为Tomcat会帮我们创建Servlet对象并调用service方法。</p></li><li><p>服务器怎么知道Servlet中一定有service方法？</p><p> 因为我们自定义的Servlet实现类，必须实现Servlet接口并复写其方法，而Servlet接口中有service方法。</p></li></ol><hr><h3 id="D-Servlet生命周期"><a href="#D-Servlet生命周期" class="headerlink" title="D.Servlet生命周期"></a>D.Servlet生命周期</h3><h4 id="①概述-1"><a href="#①概述-1" class="headerlink" title="①概述"></a>①概述</h4><p>​对象的生命周期是指一个对象从被创建到被销毁的整个过程。</p><h4 id="②生命周期"><a href="#②生命周期" class="headerlink" title="②生命周期"></a>②生命周期</h4><p>​Servlet运行在Servlet容器中（即web服务器）中，其生命周期由容器来管理，分为4个阶段：</p><ol><li>加载和实例化：默认情况下，当servlet第一次被访问时，由容器创建Servlet对象。</li></ol><ul><li><p>不是默认情况：</p><p><img src="/imgs/image-20230424144407135.png" alt="image-20230424144407135"></p><p>当Servlet需要加载比较多的资源时，我们可以将其设置为服务器启动时创建，这样就可以节省加载时间。</p></li></ul><ol start="2"><li>初始化：在Servlet实例化之后，容器将调用Servlet的<strong>init()<strong>方法初始化这个对象，完成一些如：加载配置文件、创建连接等初始化的工作。</strong>该方法只调用一次。</strong></li><li>请求请求处理：每次请求Servlet时，Servlet容器都会调用Servlet的service()方法对请求进行处理。</li><li>服务终止：当需要释放内存或者容器关闭时，容器就会调用Servlet实例的destroy()方法释放init()方法中申请的资源。在destroy()方法调用之后，容器会释放这个Servelt实例，该实例随后会被Java的垃圾收集器所回收。</li></ol><h3 id="E-Servlet方法"><a href="#E-Servlet方法" class="headerlink" title="E.Servlet方法"></a>E.Servlet方法</h3><img src="/imgs/image-20230424144432101.png" alt="image-20230424144432101" style="zoom:50%;" /><ul><li>说明：getServletConfig()和getServletInfo()这两个方法比较少用<ul><li>getServletInfo()：用于获取作者信息等，这些信息都不重要，所以方法体里写：return “” ，即可。</li><li>getServletConfig()：获取ServletConfig对象，而这个对象由web服务器创建，所以我们获取即可。<ul><li>怎么获取？<ul><li>init()方法的参数就是接收一个ServletConfig对象，所以我们在5个方法外面声明一个ServletConfig对象，然后在init()方法里写：this.config &#x3D; config 。最后在getServletConfig()方法里写：return config 即可。</li></ul></li></ul></li></ul></li></ul><hr><h3 id="F-Servlet体系结构"><a href="#F-Servlet体系结构" class="headerlink" title="F.Servlet体系结构"></a>F.Servlet体系结构</h3><h4 id="①引入-2"><a href="#①引入-2" class="headerlink" title="①引入"></a>①引入</h4><p>​开发中我们最常用的就是Servlet里的service方法，而其它方法都比较少用，但由于得继承servlet接口，因此我们不得不重写其它四个不常用的方法，这就比较麻烦。所以我们引入了HttpServlet类。</p><h4 id="②概述"><a href="#②概述" class="headerlink" title="②概述"></a>②概述</h4><p>​<img src="/imgs/image-20230424144441044.png" alt="image-20230424144441044" style="zoom:80%;" /></p><p>​说明：</p><ol><li>GenericServlet此类比较少使用</li><li>我们将来开发B&#x2F;S结构的web项目，都是针对HTTP协议，所以我们自定义Servlet，会继承HttpServlet。</li></ol><h4 id="③HttpServlet使用"><a href="#③HttpServlet使用" class="headerlink" title="③HttpServlet使用"></a>③HttpServlet使用</h4><ol><li><p>创建一个类，该类继承HttpServlet类。</p></li><li><p>重写HttpServlet类里的doGet方法和doPost方法。</p><ul><li>doGet方法：写Get请求方式的处理逻辑。</li><li>doPost方法：写Post请求方式的处理逻辑。</li></ul></li><li><p>在该类的上方写上@WebServlet(“该servlet的访问路径”)</p><p> <img src="/../imgs/image-20221114174552006-1682310001086.png" alt="image-20221114174552006"></p></li></ol><h4 id="④为什么HttpServlet里分doGet和doPost"><a href="#④为什么HttpServlet里分doGet和doPost" class="headerlink" title="④为什么HttpServlet里分doGet和doPost"></a>④为什么HttpServlet里分doGet和doPost</h4><p>​因为Http请求的方式主要有两种：get、post。而这两种请求中数据存放的位置都不一样，get中的数据放在请求行中，而post中的数据放在请求体中，所以得分开来处理。</p><h4 id="⑤HttpServlet原理"><a href="#⑤HttpServlet原理" class="headerlink" title="⑤HttpServlet原理"></a>⑤HttpServlet原理</h4><p>​获取请求方式，并根据不同的请求方式，调用不同的doXxx方法·。</p><hr><h3 id="G-Servlet-urlPattern配置"><a href="#G-Servlet-urlPattern配置" class="headerlink" title="G.Servlet urlPattern配置"></a>G.Servlet urlPattern配置</h3><p>​Servlet要想被访问，必须配置其访问路径（urlPattern）</p><ol><li><p>一个Servlet，可以配置多个urlPattern。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(urlPatterns = &#123;&quot;/demo1&quot;,&quot;demo2&quot;&#125;)</span></span><br></pre></td></tr></table></figure><p> 可以通过两个路径来访问该servlet。</p></li><li><p>urlPattern配置规则</p><ol><li><p>​</p><p> <img src="/../imgs/image-20221114201428340-1682310001086.png" alt="image-20221114201428340"></p><p> ​需要精确地写上访问路径才能访问到该servlet。路径的开头必须写：&#x2F;</p></li><li><p> <img src="/../imgs/image-20221114201451361-1682310001086.png" alt="image-20221114201451361"></p><p> 说明：* 是通配符，代表任意的意识。路径的开头必须写：&#x2F;</p></li><li><p> ​<img src="/../imgs/image-20221114201953933-1682310001086.png" alt="image-20221114201953933"></p><p> ​如果用这种写法，路径的开头不能写：&#x2F;</p></li><li><p>任意匹配（不使用）</p><p> <img src="/../imgs/image-20221114202714779-1682310001086.png" alt="image-20221114202714779"></p><p> 访问该servlet时，其访问路径可以随便写（即 “hehe” 的位置可以写任意的东西）。</p><p> 注意：</p><ul><li>当我们的项目中的Servlet配置了 “ &#x2F; ”，会覆盖掉tomcat中的DefaultServlet（该servlet在conf文件夹中的web.xml文件里），该Servlet是提供静态资源访问服务的，即：通过该servlet可以访问静态的页面，如果覆盖掉就访问不了静态的页面，所以我们不会使用这种配置方式。</li></ul></li></ol></li></ol><p><img src="/../imgs/image-20221114204459824-1682310001086.png" alt="image-20221114204459824"></p><hr><h3 id="H-XML配置方式编写Servlet"><a href="#H-XML配置方式编写Servlet" class="headerlink" title="H.XML配置方式编写Servlet"></a>H.XML配置方式编写Servlet</h3><p>​Servlet从3.0版本后开始支持使用注解配置（@WebServlet()），3.0版本前只支持XML配置文件的配置方式。</p><p>​步骤：</p><p>​1.编写Servlet类，该类继承HttpServlet类，重写doGet和doPost方法</p><p>​2.在web.xml中配置该Servlet （@WebServlet()等价于下面两步）</p><p>​①Servlet的全类名<img src="/../imgs/image-20221114210521838-1682310001086.png" alt="image-20221114210521838"></p><p>​②Servlet的访问路径<img src="/../imgs/image-20221114210646506-1682310001086.png" alt="image-20221114210646506"></p><p>​</p><hr><h2 id="⑤Request-amp-Response"><a href="#⑤Request-amp-Response" class="headerlink" title="⑤Request &amp; Response"></a>⑤Request &amp; Response</h2><h3 id="A-概述-2"><a href="#A-概述-2" class="headerlink" title="A.概述"></a>A.概述<img src="/../imgs/image-20221114213047329-1682310001086.png" alt="image-20221114213047329"></h3><p>​浏览器发送Http请求数据给web服务器（如：tomcat），tomcat对这些数据进行解析，解析完后将数据存放到request对象里，我们就可以通过request对象来获取请求数据（如：用户的名字和密码）进行相应的逻辑处理；通过response对象我们可以设置响应的数据，tomcat服务器再通过我们的response对象来获取相应的响应数据然后将响应数据发送给浏览器，浏览器再进行解析就可以呈现出信息了。</p><p>总结：</p><ul><li>Request：获取请求数据</li><li>Response：设置响应数据</li></ul><h3 id="B-Request"><a href="#B-Request" class="headerlink" title="B.Request"></a>B.Request</h3><h4 id="①Request继承体系"><a href="#①Request继承体系" class="headerlink" title="①Request继承体系"></a>①Request继承体系</h4><p>​<img src="/imgs/image-20230424144451628.png" alt="image-20230424144451628" style="zoom:80%;" /></p><ol><li><p>为什么RequestFacade是由Tomcat定义的？</p><p> 因为Tomcat需要解析请求数据，将数据封装为request对象，并且创建request对象传递到service方法中，而service方法又是由Tomcat自动调用的，所以RequestFacade是由Tomcat创建的。</p></li><li><p>使用request对象，查阅JavaEE API文档的HttpServletRequest接口。</p><p> request对象属于RequestFacade类，而RequestFacade类实现了HttpServletRequest接口。因此想要看request对象里的方法就去查JavaEE API文档的HttpServletRequest接口 即可。</p></li></ol><h4 id="②Request获取请求数据"><a href="#②Request获取请求数据" class="headerlink" title="②Request获取请求数据"></a>②Request获取请求数据</h4><p><img src="/../imgs/image-20221115142753168-1682310001086.png" alt="image-20221115142753168"></p><p>​以上方法直接通过request对象调用即可。如：</p><p><img src="/../imgs/image-20221115141652298-1682310001086.png" alt="image-20221115141652298"></p><p>​</p><h4 id="③通用方式获取请求参数"><a href="#③通用方式获取请求参数" class="headerlink" title="③通用方式获取请求参数"></a>③通用方式获取请求参数</h4><ul><li><p>引入</p><p>  doGet和doPost里除了获取参数的方式不一样外，其它的处理逻辑都一样，因此我们可以在doPost里调用doGet方法，然后doGet方法里使用通用方式获取请求参数，这样就可以节省代码了。</p></li><li><p>通用方式获取请求参数的方法：</p>  <img src="/imgs/image-20230424144502112.png" alt="image-20230424144502112" style="zoom:67%;" /><p>  ​最常用的就是getParameter()和getParameterValues()。</p></li><li><p>例子</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/servlet-demo2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo2</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//通用方法获取请求参数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//逻辑处理</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        doGet(req,resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="④IDEA模板创建Servlet"><a href="#④IDEA模板创建Servlet" class="headerlink" title="④IDEA模板创建Servlet"></a>④IDEA模板创建Servlet</h4><ul><li><p>引入</p><p>  我们创建Servlet时，先造一个类继承HttpServlet，再重写doGet和doPost，最后写上@WebServlet(“ \xxxx “)。所有的servlet都是按这样的步骤创建，如果不使用模板就会比较慢，所以引入模板创建的方式。</p></li><li><p>模板创建Servlet</p><ol><li><p>修改IDEA中原来Servlet的模板格式，不然的话在创建完Servlet之后仍需要手动修改比较麻烦。</p><p> <img src="/../imgs/image-20221115155357370-1682310001086.png" alt="image-20221115155357370"></p></li><li><p>调用模板</p><p> 右键 –&gt; new –&gt; Servlet –&gt; 写该Servlet的名字 –&gt; OK–&gt; 修改模板中的@WebServlet(“”)的访问路径。</p></li></ol></li></ul><h4 id="⑤请求参数中文乱码–POST解决方案"><a href="#⑤请求参数中文乱码–POST解决方案" class="headerlink" title="⑤请求参数中文乱码–POST解决方案"></a>⑤请求参数中文乱码–POST解决方案</h4><ul><li><p>引入</p><p>  当HTML页面以Post方式提交数据给Servlet时，Servlet中获取到的数据可能是乱码的。<br>  因为用通用方式获取Post方式提交的数据，其底层实际上调用了getReader()方法来获取数据，而该方法默认以ISO&#x2F;IEC 8859编码集读取数据的，如果HTML页面的编码方式不是ISO&#x2F;IEC 8859 ，就会导致数据乱码。</p></li><li><p>解决方案</p><p>  在获取数据之前设置字符输入流的编码集为HTML页面的编码集</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br></pre></td></tr></table></figure><p>  <img src="/../imgs/image-20221115165116748-1682310001086.png" alt="image-20221115165116748"></p></li></ul><h4 id="⑥请求参数中文乱码–GET解决方案"><a href="#⑥请求参数中文乱码–GET解决方案" class="headerlink" title="⑥请求参数中文乱码–GET解决方案"></a>⑥请求参数中文乱码–GET解决方案</h4><ul><li><p>引入</p>  <img src="/imgs/image-20230424144511731.png" alt="image-20230424144511731" style="zoom:67%;" /><p>  ​浏览器并不能识别中文，所以会以HTML页面指定的编码集写成URL编码的形式，然后将此URL编码再发送给web服务器（Tomcat），Tomcat收到后进行URL解码（使用的是ISO-8859-1编码集），这就导致了我们获取请求数据时会出现乱码。而URL编码的过程由浏览器自动完成，URL解码的过程由web服务器自动完成。</p><ol><li><p>URL编码</p><p> ①将字符串按照HTML页面指定的编码方式转换为二进制。</p><p> ②每个字节转换为2个16进制数并在前面加上%。</p><p> 如：将中文 “张三” 使用URL编码，得：</p><p> <img src="/imgs/image-20230424144520487.png" alt="image-20230424144520487"></p><p> ​在UTF-8中，一个中文字符对应三个字节。</p></li><li><p>Java中有工具类可以实现URL编码、解码</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;张三&quot;</span>;</span><br><span class="line"><span class="comment">//URL编码</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> URLEncoder.encode(str,<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line"><span class="comment">//URL解码</span></span><br><span class="line"><span class="type">String</span> <span class="variable">e</span> <span class="operator">=</span> URLDecoder.decode(s.<span class="string">&quot;utf-8&quot;</span>);</span><br></pre></td></tr></table></figure></li></ol></li><li><p>解决方案</p><ol><li>将获取到的请求数据进行编码：转换为字节数组。</li><li>将字节数组解码。</li></ol><p>  例子：</p><p>  <img src="/../imgs/image-20221115175112898-1682310001086.png" alt="image-20221115175112898"></p></li><li><p>其它说明：</p><ol><li>这种解决方式不仅适用于Get请求还适用于Post请求，因此该解决方案属于通用的解决方案。</li><li>Tomcat8.0之后，已将Get请求乱码问题解决，设置默认的编码方式为UTF-8。</li></ol></li></ul><hr><h4 id="⑦请求转发"><a href="#⑦请求转发" class="headerlink" title="⑦请求转发"></a>⑦请求转发</h4><p>- </p><pre><code>&lt;img src=&quot;/imgs/image-20230424144529765.png&quot; alt=&quot;image-20230424144529765&quot; style=&quot;zoom:67%;&quot; /&gt;</code></pre><ul><li><p>请求转发资源间共享数据</p><p>  使用Request对象里的方法：</p>  <img src="/imgs/image-20230424144538865.png" alt="image-20230424144538865" style="zoom:67%;" /><p>  如：</p><p>  <img src="/../imgs/image-20221115204258639-1682310001086.png" alt="image-20221115204258639"></p><p>  <img src="/../imgs/image-20221115204350487-1682310001086.png" alt="image-20221115204350487"></p></li><li><p>请求转发特点</p><ul><li>请求转发不会改变浏览器地址栏的路径。</li><li>请求转发只能发生在当前服务器的内部资源。</li><li>可以在转发的资源间使用request共享数据。</li></ul></li></ul><hr><h3 id="C-Response"><a href="#C-Response" class="headerlink" title="C.Response"></a>C.Response</h3><h4 id="①概述-2"><a href="#①概述-2" class="headerlink" title="①概述"></a>①概述</h4><ol><li><p>Response：使用response对象来设置响应数据，然后web服务器再从response对象中设置的数据中去取相应的数据，如何组成Htpp响应数据发送给浏览器。</p></li><li><p>Response的体系结构：</p><p> ​<img src="/imgs/image-20230424144545909.png" alt="image-20230424144545909" style="zoom:67%;" /></p></li><li><p>为什么ResponseFacade类需要Tomcat来造？</p><p> 因为Servlet接口中的service方法中的参数需要response对象，所以得造这个实现类。</p></li></ol><p></p><p>​</p><h4 id="②Response设置响应数据功能介绍"><a href="#②Response设置响应数据功能介绍" class="headerlink" title="②Response设置响应数据功能介绍"></a>②Response设置响应数据功能介绍</h4><p>​<img src="/imgs/image-20230424144715233.png" alt="image-20230424144715233" style="zoom:67%;" /></p><p>​以上方法都是通过response对象来调用。</p><p>​getWriter()和getOutputStream()的使用：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://blog.csdn.net/daqi1983/article/details/119605463</span><br></pre></td></tr></table></figure><h4 id="③Response完成重定向"><a href="#③Response完成重定向" class="headerlink" title="③Response完成重定向"></a>③Response完成重定向</h4><ol><li><p>重定向</p><p> <img src="/imgs/image-20230424144724173.png" alt="image-20230424144724173"></p><p> 当浏览器向资源A发送请求时，资源A说（请求响应）：“我处理不了，你找别人处理吧，那个人的位置是xxx”。然后浏览器就根据那个地址自动地去找资源B了。这就是重定向。</p></li><li><p>重定向实现</p><p> 在资源A里写：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">response.setStatus(<span class="number">302</span>); <span class="comment">//含义：我处理不了，你找别人处理吧</span></span><br><span class="line">response.setHeader(<span class="string">&quot;location&quot;</span>,<span class="string">&quot;该项目的访问路径/资源B的访问路径&quot;</span>); <span class="comment">//含义：那个人的位置是xxx</span></span><br></pre></td></tr></table></figure><p> 由于上面的代码很多部分都是固定写法，所以可以使用如下简化的方式写：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.sendRedirect(<span class="string">&quot;该项目的访问路径/资源B的访问路径&quot;</span>); <span class="comment">//该方法底层与旧的写法一样。</span></span><br></pre></td></tr></table></figure></li><li><p>重定向特点</p><ul><li>浏览器地址栏路径发生改变。因为浏览器发送了两次请求。</li><li>可以重定向到任意位置的资源（服务器内部、外部均可）。</li><li>由于重定向发送了两次请求，产生了两个不同的request对象，所以不能在多个资源间使用request共享数据。</li></ul></li></ol><h4 id="④路径问题"><a href="#④路径问题" class="headerlink" title="④路径问题"></a>④路径问题</h4><p>​<img src="/imgs/image-20230424144735256.png" alt="image-20230424144735256" style="zoom:80%;" /></p><p>​如何动态获取虚拟目录？</p><p>​使用request对象中的getContextPath()方法获取虚拟目录。如：</p><p>​<img src="/../imgs/image-20221116133115169-1682310001086.png" alt="image-20221116133115169"></p><hr><h4 id="⑤Response响应字符数据"><a href="#⑤Response响应字符数据" class="headerlink" title="⑤Response响应字符数据"></a>⑤Response响应字符数据</h4><ol><li><p>引入</p><p> 通过response对象设置响应数据，web服务器再从response对象里获取响应数据最后发送给客户端，客户端浏览器接收到数据再进行解析就能看到信息了。</p></li><li><p>Response响应字符数据—实现</p><p> ①调用response对象里的getWriter()方法获取字符输出流。</p><p> ②调用字符输出流里的write()方法。write()方法里不仅可以写普通的字符数据，还可以写HTML代码。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">writer.write(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">writer.write(<span class="string">&quot;&lt;h1&gt;aaa&lt;/h1&gt;&quot;</span>);</span><br></pre></td></tr></table></figure><p> ③如果输出的内容中包含中文或HTML代码就要进行响应设置。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);<span class="comment">//此行代码要写在获取字符输出流的前面</span></span><br></pre></td></tr></table></figure><p> ​因为①如果字符输出流的默认编码集是：ISO-8859-1，所以得改，不然中文显示出来会乱码。②浏览器对服务器发送过来的数据默认采用字符的形式进行解析，所以如果发送过来的是HTML代码就会解析不出来，因此得设置一下浏览器的解析方式为：text&#x2F;html。</p></li><li><p>细节点</p><ul><li>字符输入流不需要我们关闭，因为随着响应结束，response对象销毁，由服务器关闭。</li><li>setContentType()方法主要由两个功能：①设置字符输出流的编码集。②设置浏览器的解析方式。</li></ul></li></ol><hr><h4 id="⑥Response响应字节数据"><a href="#⑥Response响应字节数据" class="headerlink" title="⑥Response响应字节数据"></a>⑥Response响应字节数据</h4><p>​实现：</p><ol><li><p>读取想要被输出的字节数据（如：图片、音频、视频等）</p></li><li><p>获取response字节输出流。</p></li><li><p>将输入流中的数据复制到输出流中</p><ul><li><p>IOUtils工具类使用</p><ul><li><p>在pom.xml文件中导入依赖</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IOUtils.copy(输入流,输出流);</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>关闭输入流</p></li></ol><p>​例子：</p><p><img src="/../imgs/image-20221116153359263-1682310001086.png" alt="image-20221116153359263"></p><hr><h3 id="D-应用"><a href="#D-应用" class="headerlink" title="D.应用"></a>D.应用</h3><h4 id="①登录"><a href="#①登录" class="headerlink" title="①登录"></a>①登录</h4><p>​登录操作的流程图：</p><p><img src="/../imgs/image-20221117155148483-1682310001086.png" alt="image-20221117155148483"></p><p>​实现步骤：</p><ol><li><p>在webapp 下建个文件夹html（专门用来放HTML页面），在此文件中建一个登录页面 login.html。</p></li><li><p>在MySQL数据库里建一个数据库，再在数据库里建一张user表，在user表里添加一些数据。</p></li><li><p>Mapper代理开发（见笔记Mybatis –&gt; Mapper代理开发），编码的部分先不写。</p></li><li><p>在java文件夹下建一个包 com.zzc.web（用来放servlet），在此包下，建一个类，该类继承HttpServlet，并重写doGet和doPost方法。在doGet方法里：</p></li><li><p>使用request对象的getParameter()方法，获取请求数据。</p></li><li><p>写Mapper代理开发中的编码部分</p><p> <img src="/../imgs/image-20221117143153606-1682310001086.png" alt="image-20221117143153606"></p></li></ol><pre><code>3. 设置响应数据  ![image-20221117143316925](../imgs/image-20221117143316925-1682310001086.png)4. 修改login.html页面中表单的action为：“该项目的访问路径/该servlet的访问路径”。  如果该项目的访问路径为：/ 。该servlet的访问路径为：/servlet。则action应该为：/servlet。</code></pre><hr><h4 id="②注册"><a href="#②注册" class="headerlink" title="②注册"></a>②注册</h4><p><img src="/../imgs/image-20221117160313570-1682310001086.png" alt="image-20221117160313570"></p><p>​实习步骤：</p><ol><li><p>在webapp下的html文件中建一个注册界面（register,html）。</p></li><li><p>在映射接口UserMapper中添加方法</p><p> 这里使用了注解开发</p><p> <img src="/../imgs/image-20221117165650698-1682310001087.png" alt="image-20221117165650698"></p></li><li><p>在java.zzc.web下新建一个servlet，用于处理注册。</p><ol><li><p>使用request对象中的getParameter方法获取请求数据。</p></li><li><p>调用UserMapper中的selectByUserName根据用户名查询，返回User对象。</p><ol><li><p>建立数据库连接</p><p> <img src="/../imgs/image-20221117170325034-1682310001087.png" alt="image-20221117170325034"></p></li><li><p>根据用户名进行查询</p><p> <img src="/../imgs/image-20221117170408894-1682310001087.png" alt="image-20221117170408894"></p></li></ol></li><li><p>判断User对象是否为null</p><ol><li><p>为null：用户名不存在，调用UserMapper中的add方法添加用户。</p></li><li><p>不为null：用户名重复，返回 “用户名已存在”。</p><p> <img src="/../imgs/image-20221117171506104-1682310001087.png" alt="image-20221117171506104"></p></li></ol></li></ol></li></ol><h4 id="③代码优化"><a href="#③代码优化" class="headerlink" title="③代码优化"></a>③代码优化</h4><p>​每次建立数据库连接时，都会用到下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);java</span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br></pre></td></tr></table></figure><p>​这就会造成如下问题：</p><ol><li><p>代码重复   —&gt;  解决办法：将代码放到自己创建的工具类里</p></li><li><p>每创建一个SqlSessionFactory就会创建一个数据库连接池，如果多次创建SqlSessionFactory，就会造成资源浪费。 —&gt;  解决办法：静态代码块。</p><p> ​</p><p> 实现：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SqlSessionFactoryUtils</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">//静态代码块随着类的加载而自动执行，且只执行一次。</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line">            sqlSessionFactory = <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SqlSessionFactory <span class="title function_">getsqlSessionFactory</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="⑥JSP"><a href="#⑥JSP" class="headerlink" title="⑥JSP"></a>⑥JSP</h2><h3 id="A-概述-3"><a href="#A-概述-3" class="headerlink" title="A.概述"></a>A.概述</h3><h4 id="①引入-3"><a href="#①引入-3" class="headerlink" title="①引入"></a>①引入</h4><p>​我们知道servlet里可以写Java代码，然后也可以通过response对象调用getWriter()来获取输出流对象，输入流对象再调用write()方法，在write()方法里写HTML代码。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">writer.write(<span class="string">&quot;&lt;h1&gt;aaa&lt;/h1&gt;&quot;</span>);</span><br></pre></td></tr></table></figure><p>​在write()方法里写HTML代码不仅书写困难，而且不方便阅读。所以我们引入了JSP。</p><h4 id="②概念"><a href="#②概念" class="headerlink" title="②概念"></a>②概念</h4><ul><li><p>JSP：Java Server Pages，Java服务端页面。</p></li><li><p>JSP里既可以写：HMTL、CSS、JS等静态内容，又可以写Java代码的动态内容。这就很好地解决了引入中的问题。</p>  <img src="/imgs/image-20230424144749300.png" alt="image-20230424144749300" style="zoom:80%;" /></li><li><p>JSP &#x3D; Java + HTML</p></li></ul><p>​</p><hr><h3 id="B-JSP快速入门"><a href="#B-JSP快速入门" class="headerlink" title="B.JSP快速入门"></a>B.JSP快速入门</h3><ol><li><p>导入JSP依赖</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p> 为什么要设置<scope>provided</scope>？</p><p> ​将来项目需要打war包部署到tomcat文件夹的的webapps目录下运行，就要将jsp的jar包删掉，因为tomcat中自带了jsp的jar包，如果不删除的话会出错的。</p></li><li><p>创建JSP文件</p><p> webapp –&gt; 右键 –&gt; new –&gt; JSP&#x2F;JSPX</p></li><li><p>编写HTML标签 和 Java代码</p><p> <img src="/imgs/image-20230424144758983.png" alt="image-20230424144758983"></p><p> ​Java代码写在：&lt;% java代码 %&gt;，“ &lt;% java代码 %&gt; ”被称为JSP脚本。</p></li></ol><hr><h3 id="C-JSP原理"><a href="#C-JSP原理" class="headerlink" title="C.JSP原理"></a>C.JSP原理</h3><ul><li><p><strong>JSP本质上就是一个servlet</strong></p>  <img src="/imgs/image-20230424144806298.png" alt="image-20230424144806298" style="zoom:80%;" /><p>  ​JSP在被访问时，由JSP容器（Tomcat）将其转换为Java文件（Servlet），在由JSP容器（Tomcat）将其编译，最终对外提供服务的其实就是这个字节码文件。</p></li><li><p>JSP –&gt; Servlet是如何转换的？</p><p>  其实就是将JSP中的HTML代码写到 输出流（response调用getWrite()获取到的输出流）的write()方法里，然后将Java代码从JSP脚本中取出来，至此转换完成。</p><p>  ​</p></li></ul><p></p><hr><h3 id="D-JSP脚本"><a href="#D-JSP脚本" class="headerlink" title="D.JSP脚本"></a>D.JSP脚本</h3><h4 id="①概述-3"><a href="#①概述-3" class="headerlink" title="①概述"></a>①概述</h4><ul><li>JSP脚本用于在JSP页面内定义Java代码。</li><li>JSP脚本分类<ul><li>＜％…％＞：JSP转换为servlet时，内容会直接放到＿jspService() 方法之中。</li><li>＜％＝…％＞：JSP转换为servlet时，内容会放到out.print() 中，作为out.print() 的参数。<ul><li>out.print()方法的作用：就是将参数的内容输出到页面中。</li><li>out.print()该方法声明在＿jspService()方法中。</li></ul></li><li>＜％！…％＞：JSP转换为servlet时，内容会放到＿jspService() 方法之外，被类直接包含。即内容放到成员变量的位置，也就是说可以用来定义成员变量和成员方法。</li></ul></li></ul><p>​说明：①JSP脚本里不能写HTML代码，如果需要写可以采取将JSP脚本截断的方式来写。②HTML代码里可以写JSP脚本。详见练习。</p><p>​</p><h4 id="②练习"><a href="#②练习" class="headerlink" title="②练习"></a>②练习</h4><p>​从数据库中获取品牌信息，放到List集合里，然后遍历输出到页面。</p><p><img src="/../imgs/image-20221118114510135-1682310001087.png" alt="image-20221118114510135"></p><p>​实现步骤：</p><p><img src="/../imgs/image-20221118113531799-1682310001087.png" alt="image-20221118113531799"></p><p>​</p><p>​补充：</p><ol><li><p>如果在&lt;%%&gt;里使用System.out.println(“”)，输出结果会显示到IDEA的控制台中。</p></li><li><pre><code class="jsp"> &lt;% for (int i = 0;i &lt; users.size();i++)&#123;     User user = users.get(i); %&gt;     &lt;tr&gt;         &lt;td&gt;&lt;%=user.getUsername()%&gt;&lt;/td&gt;         &lt;td&gt;&lt;%=user.getPassword()%&gt;&lt;/td&gt;     &lt;/tr&gt; &lt;% &#125; %&gt; <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">上面的JSP代码经过tomcat的转换后变成Java文件（Servlet），其转换后的代码变成：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">for (int i = 0;i &lt; users.size();i++)&#123;</span><br><span class="line">User user = users.get(i);</span><br><span class="line"></span><br><span class="line">    out.write(&quot;\r\n&quot;);</span><br><span class="line">    out.write(&quot;                &lt;tr&gt;\r\n&quot;);</span><br><span class="line">    out.write(&quot;                    &lt;td&gt;&quot;);</span><br><span class="line">    out.print(user.getUsername());</span><br><span class="line">    out.write(&quot;&lt;/td&gt;\r\n&quot;);</span><br><span class="line">    out.write(&quot;                    &lt;td&gt;&quot;);</span><br><span class="line">    out.print(user.getPassword());</span><br><span class="line">    out.write(&quot;&lt;/td&gt;\r\n&quot;);</span><br><span class="line">    out.write(&quot;                &lt;/tr&gt;\r\n&quot;);</span><br><span class="line">    out.write(&quot;        &quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre></li></ol><hr><h3 id="E-JSP缺点"><a href="#E-JSP缺点" class="headerlink" title="E.JSP缺点"></a>E.JSP缺点</h3><p>​<img src="/imgs/image-20230424144816905.png" alt="image-20230424144816905" style="zoom:67%;" /></p><hr><h3 id="F-EL表达式"><a href="#F-EL表达式" class="headerlink" title="F.EL表达式"></a>F.EL表达式</h3><h4 id="①引入-4"><a href="#①引入-4" class="headerlink" title="①引入"></a>①引入</h4><p>​网页动态技术迭代到Servlet+JSP阶段时：Servlet负责逻辑处理，封装数据，将数据放到request对象里；JSP从request对象中获取数据，遍历展现数据。但JSP获取数据、遍历数据的操作也会涉及到Java代码，那怎么办呢？使用EL表达式实现获取数据的操作。</p><h4 id="②语法"><a href="#②语法" class="headerlink" title="②语法"></a>②语法</h4><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;表达式&#125;</span><br></pre></td></tr></table></figure><p>​如：</p><p>​${brands} ：获取<strong>域</strong>中存储的key为brands的数据</p><h4 id="③Java中的四大域对象"><a href="#③Java中的四大域对象" class="headerlink" title="③Java中的四大域对象"></a>③Java中的四大域对象</h4><ol><li><p>page：当前页面有效</p></li><li><p>request：当前请求有效</p></li><li><p>session：当前会话有效</p></li><li><p>application：当前应用有效</p><p> 上面四个域对象里都有设置共享数据 setAttribute() 和 获取共享数据 getAttribute()。</p></li></ol><p><img src="/imgs/image-20230424144828016.png" alt="image-20230424144828016"></p><p>​说明：EL表达式获取数据时，会依次从这4个域中寻找，直到找到为止。</p><h4 id="④例子"><a href="#④例子" class="headerlink" title="④例子"></a>④例子</h4><p>​Servlet：</p><p><img src="/../imgs/image-20221118171824134-1682310001087.png" alt="image-20221118171824134"></p><p>​JSP：</p><p><img src="/../imgs/image-20221118172008694-1682310001087.png" alt="image-20221118172008694"></p><p>​如果JSP识别不出EL表达式，则需要加上：&lt;%@page isELIgnored&#x3D;”false”%&gt;。这是因为jsp2.3以及以前的版本默认是不识别EL表达式的，也就是isELIgnored&#x3D;”true”,所以需要在页面加上一句话，isELIgnored&#x3D;”false”，2.4以及之后版本默认是识别EL表达式的。</p><p>​</p><hr><h3 id="G-JSTL标签"><a href="#G-JSTL标签" class="headerlink" title="G.JSTL标签"></a>G.JSTL标签</h3><h4 id="①引入-5"><a href="#①引入-5" class="headerlink" title="①引入"></a>①引入</h4><p>​网页动态技术迭代到Servlet+JSP阶段时：Servlet负责逻辑处理，封装数据，将数据放到request对象里；JSP从request对象中获取数据，遍历展现数据。但JSP获取数据、遍历数据的操作也会涉及到Java代码，那怎么办呢？使用EL表达式实现获取数据的操作，JSTL标签实现数据遍历。这就不会涉及到Java代码了。</p><h4 id="②概述-1"><a href="#②概述-1" class="headerlink" title="②概述"></a>②概述</h4><p>​JSTL：Jsp Standarded Tag Library（JSP标准标签库），使用标签取代JSP页面上的Java代码。</p><h4 id="③JSTL快速入门"><a href="#③JSTL快速入门" class="headerlink" title="③JSTL快速入门"></a>③JSTL快速入门</h4><ol><li><p>导入JSTL相关依赖</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>taglibs<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>standard<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在JSP页面上引入JSTL标签库</p> <figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%<span class="meta">@taglib</span> prefix=<span class="string">&quot;c&quot;</span> uri=<span class="string">&quot;http://java.sun.com/jsp/jstl/core&quot;</span> %&gt;</span><br></pre></td></tr></table></figure><p> prefix：用于定义JSTL标签的前缀，如：<img src="/../imgs/image-20221118180815292-1682310001087.png" alt="image-20221118180815292"></p></li><li><p>使用JSTL</p></li></ol><hr><h4 id="④if标签"><a href="#④if标签" class="headerlink" title="④if标签"></a>④if标签</h4><ul><li><p>语法</p>  <figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:<span class="keyword">if</span> test=<span class="string">&quot;表达式&quot;</span>&gt;</span><br><span class="line">写HTML标签等内容</span><br><span class="line">&lt;/c:<span class="keyword">if</span>&gt;</span><br></pre></td></tr></table></figure></li><li><p>说明</p><ol><li><p>if 标签里一定要有test属性。如果表达式为真，则执行 if 标签包裹起来的内容。</p></li><li><p>if 标签没有else，所以想要写只能再调用一次 if 标签</p> <figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:<span class="keyword">if</span> test=<span class="string">&quot;true&quot;</span>&gt;</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">&lt;/c:<span class="keyword">if</span>&gt;</span><br><span class="line">&lt;c:<span class="keyword">if</span> test=<span class="string">&quot;false&quot;</span>&gt;</span><br><span class="line"><span class="literal">false</span></span><br><span class="line">&lt;/c:<span class="keyword">if</span>&gt;</span><br></pre></td></tr></table></figure></li><li><p>如果表达式中想判断某个值是否符合要求</p> <figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--只能这样写 --&gt;</span><br><span class="line">&lt;c:<span class="keyword">if</span> test=<span class="string">&quot;$&#123;status == 1&#125;&quot;</span>&gt;</span><br><span class="line">&lt;h1&gt;你好！&lt;/h1&gt;</span><br><span class="line">&lt;/c:<span class="keyword">if</span>&gt;</span><br><span class="line">&lt;!--不能这样写 --&gt;</span><br><span class="line">&lt;c:<span class="keyword">if</span> test=<span class="string">&quot;$&#123;status&#125; == 1&quot;</span>&gt;</span><br><span class="line">&lt;h1&gt;你好！&lt;/h1&gt;</span><br><span class="line">&lt;/c:<span class="keyword">if</span>&gt;</span><br></pre></td></tr></table></figure></li></ol></li></ul><hr><h4 id="⑤foreach标签"><a href="#⑤foreach标签" class="headerlink" title="⑤foreach标签"></a>⑤foreach标签</h4><ul><li><p>forEach标签相当于forEach循环</p></li><li><p>语法</p>  <figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:forEach items=<span class="string">&quot;&quot;</span> <span class="keyword">var</span>=<span class="string">&quot;&quot;</span>&gt;</span><br><span class="line">循环内容</span><br><span class="line">&lt;/c:forEach&gt;</span><br></pre></td></tr></table></figure><p>  items：被循环的容器</p><p>  var：遍历产生的临时变量</p><p>  补充：该forEac标签里还有个varStatus属性</p></li><li><p>例子</p><p>  - </p><pre><code>  ![image-20221118212301836](../imgs/image-20221118212301836-1682310001087.png)  注意：当获取brand对象中的属性值时只能像上面这样写 “ brand.属性名 ”，因为将来其内部会将首字母大写再在前面加上get，这样就变成 “ brand.getId ” ，然后根据这个去方法名去找brand类里有没有这个方法。  </code></pre><ul><li><p>上面例子中的 brand.id 是指这条数据在数据库中的id，如果数据库中一共有4条数据，现在将id&#x3D;2的数据删掉，然后再按照上面的方式输出，将来显示的数据的序号就是不连续的，变为1，3，4。为了解决这个问题，我们可以使用varStatus这个属性，将代码改为：</p><p>  <img src="/../imgs/image-20221118215326339-1682310001087.png" alt="image-20221118215326339"></p><p>  <img src="/../imgs/image-20221118215449884-1682310001087.png" alt="image-20221118215449884"></p><p>  <img src="/../imgs/image-20221118215527310-1682310001087.png" alt="image-20221118215527310"></p></li></ul></li></ul><hr><h4 id="⑥普通的foreach标签"><a href="#⑥普通的foreach标签" class="headerlink" title="⑥普通的foreach标签"></a>⑥普通的foreach标签</h4><ul><li><p>语法</p>  <figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:forEach begin=<span class="string">&quot;&quot;</span> end=<span class="string">&quot;&quot;</span> step=<span class="string">&quot;&quot;</span> <span class="keyword">var</span>=<span class="string">&quot;&quot;</span>&gt;</span><br><span class="line">循环内容</span><br><span class="line">&lt;/c:forEach&gt;</span><br><span class="line"></span><br><span class="line">&lt;%-- 这个就是普通的<span class="keyword">for</span>循环 --%&gt;</span><br></pre></td></tr></table></figure><p>  begin：开始数</p><p>  end：结束数</p><p>  step：步长</p></li><li><p>例子</p><p>  <img src="/../imgs/image-20221118213100871-1682310001087.png" alt="image-20221118213100871"></p></li></ul><hr><h2 id="⑦网页动态技术迭代过程"><a href="#⑦网页动态技术迭代过程" class="headerlink" title="⑦网页动态技术迭代过程"></a>⑦网页动态技术迭代过程</h2><p>​<img src="/../imgs/image-20221118123958304-1682310001087.png" alt="image-20221118123958304"></p><ol><li><p>Servlet阶段：想写HTML代码得写在：通过response对象获取的输出流对象的write()方法里，这就比较麻烦。从而诞生了JSP技术。</p></li><li><p>JSP阶段：可以直接在JSP里写HTML代码和Java代码了，但问题是这样写也比较麻烦（Java代码得根据情况进行截断），也不利于阅读。</p></li><li><p>Servlet+JSP阶段：Servlet负责逻辑处理，封装数据，将数据放到request对象里；JSP从request对象中获取数据，遍历展现数据。</p><p> 但JSP获取数据、遍历数据的操作也会涉及到Java代码，那怎么办呢？</p><p> 使用EL表达式实现获取数据的操作，JSTL标签实现数据遍历。这就不会涉及到Java代码了。</p></li><li><p>Servlet+html+ajax阶段：现在流行的技术。</p></li></ol><p>​</p><hr><h2 id="⑧MVC模式和三层架构"><a href="#⑧MVC模式和三层架构" class="headerlink" title="⑧MVC模式和三层架构"></a>⑧MVC模式和三层架构</h2><h3 id="A-MVC模式"><a href="#A-MVC模式" class="headerlink" title="A.MVC模式"></a>A.MVC模式</h3><p><img src="/../imgs/image-20221119105325558-1682310001087.png" alt="image-20221119105325558"></p><h3 id="B-三层架构"><a href="#B-三层架构" class="headerlink" title="B.三层架构"></a>B.三层架构</h3><p><img src="/../imgs/image-20221119105309359-1682310001087.png" alt="image-20221119105309359"></p><h3 id="C-MVC模式和三层架构的区别"><a href="#C-MVC模式和三层架构的区别" class="headerlink" title="C.MVC模式和三层架构的区别"></a>C.MVC模式和三层架构的区别</h3><img src="/imgs/image-20230424144840939.png" alt="image-20230424144840939" style="zoom:80%;" /><p>​三层架构是MVC模式的落地实现。</p><hr>]]></content>
      
      
      <categories>
          
          <category> Java Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web核心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript</title>
      <link href="/2023/04/24/javascript/"/>
      <url>/2023/04/24/javascript/</url>
      
        <content type="html"><![CDATA[<h3 id="①概述"><a href="#①概述" class="headerlink" title="①概述"></a>①概述</h3><ul><li><p>JavaScript是一门跨平台、面向对象的脚本语言，来控制网页行为的，它能使网页可交互。</p><ul><li>脚本语言：即JavaScript属于解释运行语言。</li></ul></li><li><p>JavaScript和Java是完全不同的语言，不论是概念还是设计。但是基础语法类似。</p></li></ul><h3 id="②JavaScript引入方式"><a href="#②JavaScript引入方式" class="headerlink" title="②JavaScript引入方式"></a>②JavaScript引入方式</h3><h4 id="A-内部脚本"><a href="#A-内部脚本" class="headerlink" title="A.内部脚本"></a>A.内部脚本</h4><p><img src="/imgs/image-20221028111130935-1682308787353.png" alt="image-20221028111130935"></p><p>​例子：</p><p><img src="/imgs/image-20221028111251852-1682308787356.png" alt="image-20221028111251852"></p><h4 id="B-外部脚本"><a href="#B-外部脚本" class="headerlink" title="B.外部脚本"></a>B.外部脚本</h4><p><img src="/imgs/image-20221028111903213-1682308787357.png" alt="image-20221028111903213"></p><p>​例子：</p><p><img src="/imgs/image-20221028111935335-1682308787357.png" alt="image-20221028111935335"></p><p>​ </p><h3 id="③JavaScript基础语法"><a href="#③JavaScript基础语法" class="headerlink" title="③JavaScript基础语法"></a>③JavaScript基础语法</h3><h4 id="A-书写语法"><a href="#A-书写语法" class="headerlink" title="A.书写语法"></a>A.书写语法</h4><ol><li><p>JavaScript区分大小写：与Java一样，变量名、函数名以及其它一切东西都是区分大小写的。</p></li><li><p>每行结尾的分号可有可无，但还是写上比较规范。</p></li><li><p>注释：</p><ul><li>单行注释：&#x2F;&#x2F;注释内容</li><li>多行注释：与Java一样</li></ul></li><li><p>大括号代表代码块</p><p> 如：<img src="/imgs/image-20221028121931243-1682308787357.png" alt="image-20221028121931243"></p></li></ol><h4 id="B-输出语句"><a href="#B-输出语句" class="headerlink" title="B.输出语句"></a>B.输出语句</h4><ol><li><p>使用window.alert(“输出内容”)：将内容输出到警告框中。</p><p> 注：”window.”可以省略不写</p></li><li><p>使用document.write(“输出内容”)：将内容输出到HMTL页面当中。</p></li><li><p>使用console.log(“输出内容”)：将内容输出到浏览器的控制台中。</p><p> 注：我们需要在页面中按住F12 或 通过 “鼠标右击，检查” 点击控制台才能看到输出的内容 </p><p> <img src="/imgs/image-20221028122907123-1682308787357.png" alt="image-20221028122907123"></p></li></ol><h4 id="C-变量"><a href="#C-变量" class="headerlink" title="C.变量"></a>C.变量</h4><h5 id="①定义变量"><a href="#①定义变量" class="headerlink" title="①定义变量"></a>①定义变量</h5><p>​<code>变量的声明要写在script标签内</code></p><p>​<code>JavaScript是一门弱类型语言，变量可以存放不同类型的值。</code></p><ul><li><h6 id="ECMAScript6之前"><a href="#ECMAScript6之前" class="headerlink" title="ECMAScript6之前"></a>ECMAScript6之前</h6><p>  使用var关键字来声明变量。</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> test = <span class="number">20</span>;</span></span><br><span class="line"><span class="language-javascript">    test = <span class="string">&quot;张三&quot;</span>;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  var关键字的特点：</p><ol><li>声明的变量为全局变量。</li><li>同一个变量可以重复被定义。</li></ol></li><li><p>ECMAScript6之后</p><p>  新增了<code>let</code>关键字来定义变量。它的用法类似于var，但是所声明的变量，只在let关键字所在的代码块内有效，且不允许重复声明同一个变量。</p><p>  新增了<code>const</code>关键字，用来声明一个只读的常量。一旦声明，常量的值就不能改变。</p></li></ul><h5 id="②变量命名规则"><a href="#②变量命名规则" class="headerlink" title="②变量命名规则"></a>②变量命名规则</h5><p>​<img src="/imgs/image-20221028152434815-1682308787357.png" alt="image-20221028152434815"></p><p>​</p><h4 id="D-数据类型"><a href="#D-数据类型" class="headerlink" title="D.数据类型"></a>D.数据类型</h4><p>​JavaScript中数据类型分为 原始类型（相当于Java中的基本数据类型） 和 引用类型</p><ul><li><p>原始类型</p><p>  <img src="/imgs/image-20221028155428696-1682308787358.png" alt="image-20221028155428696"></p><ul><li>我们可以使用typeof运算符来获取当前变量存储的数据属于哪种数据类型，如：typeof age</li></ul></li><li><p>引用类型</p></li></ul><h4 id="E-运算符"><a href="#E-运算符" class="headerlink" title="E.运算符"></a>E.运算符</h4><h5 id="①概述-1"><a href="#①概述-1" class="headerlink" title="①概述"></a>①概述</h5><p>​<img src="/imgs/image-20230424120735870.png" alt="image-20230424120735870"></p><p>​说明：上面的运算符的应用与Java中的一样，除了 “&#x3D;&#x3D;” 和 “&#x3D;&#x3D;&#x3D;”</p><ul><li><p>&#x3D;&#x3D; 和 &#x3D;&#x3D;&#x3D; 的区别</p><ul><li>&#x3D;&#x3D;： （实际上就是比较其值是否一样，一样返回true，不一样返回false）<ol><li>先判断变量的类型是否一样，如果不一样，则进行类型转换。</li><li>再去比较其值。</li></ol></li><li>&#x3D;&#x3D;&#x3D;：<ol><li>判断变量的类型是否一样，如果不一样，直接返回false。</li><li>再去比较其值。</li></ol></li></ul></li></ul><h5 id="②类型转换"><a href="#②类型转换" class="headerlink" title="②类型转换"></a>②类型转换</h5><ol><li><p>其它类型转为number：</p><ul><li><p>string 转 number：按照字符串的字面值，转为数字；如果字面值不是数字，则转为NaN。</p><p>  一般使用parseInt()方法来将实现string 转 number</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> j = <span class="string">&quot;20&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(<span class="built_in">parseInt</span>(j) + <span class="number">1</span>); <span class="comment">//结果为：21。parseInt(j)：j的字面值为20，所以就转换为数字 20</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> k = <span class="string">&quot;abc&quot;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(<span class="built_in">parseInt</span>(k)); <span class="comment">//结果为：NaN</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>boolean 转 number： true 转为 1；false 转为 0</p></li></ul></li><li><p>其它类型转为boolean：</p><ul><li>number 转 boolean：0 和 NaN转为false，其它的数字转为true。</li><li>string 转 boolean：空字符串(即只有一对引号) 转为false，其它的字符串转为true。</li><li>null 转 boolean：转为false。</li><li>undefined 转 boolean：转为false。</li></ul></li></ol><h4 id="F-流程控制语句"><a href="#F-流程控制语句" class="headerlink" title="F.流程控制语句"></a>F.流程控制语句</h4><h5 id="①概述-2"><a href="#①概述-2" class="headerlink" title="①概述"></a>①概述</h5><p>​<img src="/imgs/image-20221028204104273-1682308787358.png" alt="image-20221028204104273"></p><p>​与Java中的流程控制一模一样。</p><h5 id="②例子"><a href="#②例子" class="headerlink" title="②例子"></a>②例子</h5><ul><li><p>switch</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> i = <span class="number">1</span>;</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">switch</span>(i)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">case</span> <span class="number">1</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">alert</span>(<span class="string">&quot;今天是星期一&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">break</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">case</span> <span class="number">2</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">alert</span>(<span class="string">&quot;今天是星期二&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">break</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">default</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">alert</span>(<span class="string">&quot;输入的信息有误&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">     &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>for</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> sum = <span class="number">0</span>;</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>;i &lt;= <span class="number">100</span>;i++)&#123;   <span class="comment">//输出 1 加到 100 的总和</span></span></span><br><span class="line"><span class="language-javascript">        sum += i;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(sum);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  一般for循环的初始条件都用let来声明，因为我们希望此初始变量只在for循环中使用。</p></li></ul><p>​</p><h4 id="G-函数"><a href="#G-函数" class="headerlink" title="G.函数"></a>G.函数</h4><p>​JavaScript中的函数就是Java中的函数，他们两是一样意思。但它们的声明方式不一样。</p><h5 id="①函数定义"><a href="#①函数定义" class="headerlink" title="①函数定义"></a>①函数定义</h5><ul><li>定义方式一：</li></ul><img src="/imgs/image-20230424120843803.png" alt="image-20230424120843803" style="zoom:67%;" /><ul><li><p>定义方式二：</p>  <img src="/imgs/image-20230424120857593.png" alt="image-20230424120857593" style="zoom:67%;" /><p>  直接写 “函数名(参数值)” 即可实现调用。</p></li></ul><h5 id="②函数特性"><a href="#②函数特性" class="headerlink" title="②函数特性"></a>②函数特性</h5><p>​在JavaScript中函数的调用只与函数名有关，即只通过函数名来确定调用的函数。因此函数A在声明时虽然只声明了两个参数，但调用的时候可以传递一个或两个以上的参数，这就是JavaScript中函数的特性，了解即可。</p><hr><h3 id="④JavaScript对象"><a href="#④JavaScript对象" class="headerlink" title="④JavaScript对象"></a>④JavaScript对象</h3><h4 id="A-Array数组对象"><a href="#A-Array数组对象" class="headerlink" title="A.Array数组对象"></a>A.Array数组对象</h4><h5 id="①数组的定义"><a href="#①数组的定义" class="headerlink" title="①数组的定义"></a>①数组的定义</h5><p><img src="/imgs/image-20221029154604329-1682308787359.png" alt="image-20221029154604329"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(arr);   <span class="comment">//结果为：1，2，3</span></span></span><br><span class="line"><span class="language-javascript">    arr[<span class="number">0</span>] = <span class="number">10</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(arr);   <span class="comment">//结果为：10，2，3</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="②数组的特点"><a href="#②数组的特点" class="headerlink" title="②数组的特点"></a>②数组的特点</h5><p>​JavaScript数组相当于Java中的集合，变长变类型</p><ul><li><p>变长</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span></span><br><span class="line"><span class="language-javascript">    arr[<span class="number">10</span>] = <span class="number">89</span>;   </span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//原本数组的长度为3，现在变成10。arr[3]到arr[8]的元素值为：空字符串,其数据类型为undefined类型。</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>变类型</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span></span><br><span class="line"><span class="language-javascript">    arr[<span class="number">1</span>] = <span class="string">&quot;hello&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(arr); <span class="comment">//结果为：1，hello，3</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="③属性和方法"><a href="#③属性和方法" class="headerlink" title="③属性和方法"></a>③属性和方法</h5><ul><li><p>属性</p><ul><li><p>length：获取数组中元素的个数</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(arr.<span class="property">length</span>);<span class="comment">//结果为3</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>还有其它的属性，见</p>  <figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.w3school.com.cn/jsref/jsref_obj_array.asp</span><br></pre></td></tr></table></figure></li></ul></li><li><p>方法</p><ul><li><p>push：往数组中添加元素</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span></span><br><span class="line"><span class="language-javascript">    arr.<span class="title function_">push</span>(<span class="number">4</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(arr);<span class="comment">//结果为:1,2,3,4</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>splice：删除&#x2F;添加数组中的元素</p><p>  语法：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array.splice(index, howmany, item1, ....., itemX)</span><br></pre></td></tr></table></figure><p>  <img src="/imgs/image-20221029163121470-1682308787359.png" alt="image-20221029163121470"></p><p>  例子：</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span></span><br><span class="line"><span class="language-javascript">    arr.<span class="title function_">splice</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(arr);  <span class="comment">//结果为：1，3，3</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>还有其它方法，这里不多介绍，详见：</p>  <figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.w3school.com.cn/jsref/jsref_splice.asp</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="B-String对象"><a href="#B-String对象" class="headerlink" title="B.String对象"></a>B.String对象</h4><p>​String对象即字符串对象</p><h5 id="①定义"><a href="#①定义" class="headerlink" title="①定义"></a>①定义</h5><p><img src="/imgs/image-20221029165848280-1682308787360.png" alt="image-20221029165848280"></p><h5 id="②属性、方法"><a href="#②属性、方法" class="headerlink" title="②属性、方法"></a>②属性、方法</h5><ul><li><p>属性</p><p>  length：获取字符串的长度</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> str = <span class="string">&quot;hello&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(str.<span class="property">length</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>方法</p><ul><li><p>charAt()：返回在指定位置的字符</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> str = <span class="string">&quot;abc&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(str.<span class="title function_">chartAt</span>(<span class="number">0</span>));<span class="comment">//a</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>IndexOf()：返回字符在数组中第一次出现的位置</p></li><li><p>trim()：去除字符串前后两端的空白字符</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> str = <span class="string">&quot; abc &quot;</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(str.<span class="title function_">trim</span>());<span class="comment">//abc</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>还有其它方法见</p>  <figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.w3school.com.cn/jsref/jsref_obj_string.asp</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="C-自定义对象"><a href="#C-自定义对象" class="headerlink" title="C.自定义对象"></a>C.自定义对象</h4><h5 id="①造对象"><a href="#①造对象" class="headerlink" title="①造对象"></a>①造对象</h5><p><img src="/imgs/image-20221029172936520-1682308787360.png" alt="image-20221029172936520"></p><p>​说明：JavaScript中造对象不需要先造其对应的类，直接造对象即可。</p><h5 id="②例子-1"><a href="#②例子-1" class="headerlink" title="②例子"></a>②例子</h5><p><img src="/imgs/image-20221029173422014-1682308787361.png" alt="image-20221029173422014"></p><hr><h3 id="⑤BOM对象"><a href="#⑤BOM对象" class="headerlink" title="⑤BOM对象"></a>⑤BOM对象</h3><h4 id="A-概述"><a href="#A-概述" class="headerlink" title="A.概述"></a>A.概述</h4><p>​<img src="/imgs/image-20230424120948587.png" alt="image-20230424120948587" style="zoom:80%;" /></p><h4 id="B-Window"><a href="#B-Window" class="headerlink" title="B.Window"></a>B.Window</h4><p>​Window：浏览器窗口对象</p><h5 id="①获取"><a href="#①获取" class="headerlink" title="①获取"></a>①获取</h5><p>​在JavaScript里window对象属于内置对象，直接使用即可。其中**window.**可以省略。</p><h5 id="②属性"><a href="#②属性" class="headerlink" title="②属性"></a>②属性</h5><p><img src="/imgs/image-20221029210121672-1682308787362.png" alt="image-20221029210121672"></p><h5 id="③方法"><a href="#③方法" class="headerlink" title="③方法"></a>③方法</h5><ol><li><p>alert()</p><p> 显示带有一段信息和一个确认按钮的警告框。如：</p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="title function_">alert</span>(<span class="string">&quot;hello&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p> <img src="/imgs/image-20230424121024855.png" alt="image-20230424121024855"></p></li><li><p>confirm()</p><p> 显示带有一段消息以及确认按钮和取消按钮的对话框。</p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">     <span class="title function_">confirm</span>(<span class="string">&quot;确认删除吗？&quot;</span>);   </span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//该方法会返回一个布偶值，如果用户点击确认，返回true，否则返回false。</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//我们可以通过该布偶值来进行相应的操作，如：</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> flag = <span class="title function_">confirm</span>(<span class="string">&quot;确认删除吗？&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">if</span> (flag)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">alert</span>(<span class="string">&quot;删除成功&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p> <img src="/imgs/image-20230424121042317.png" alt="image-20230424121042317"></p></li><li><p>定时器</p><ul><li><p>setTimeout(function,毫秒值)：在一定的时间间隔后执行一个function，只执行一次。</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">print</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">alert</span>(<span class="string">&quot;hhhh&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="built_in">setTimeout</span>(print,<span class="number">1000</span>); <span class="comment">//注意函数名后面不加括号</span></span></span><br><span class="line"><span class="language-javascript">    </span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//等价于</span></span></span><br><span class="line"><span class="language-javascript">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">alert</span>(<span class="string">&quot;hhhh&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;,<span class="number">1000</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>setInterval(function,毫秒值)：在一定的时间间隔后执行一个function，循环执行。可应用于图片的滚动播放。</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">print</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">alert</span>(<span class="string">&quot;111&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="built_in">setInterval</span>(print,<span class="number">3000</span>); <span class="comment">//3000毫秒 = 3秒 //注意函数名后面不加括号</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><h4 id="C-History"><a href="#C-History" class="headerlink" title="C.History"></a>C.History</h4><p>​<img src="/imgs/image-20230424121058369.png" alt="image-20230424121058369" style="zoom:80%;" /></p><h4 id="D-Location"><a href="#D-Location" class="headerlink" title="D.Location"></a>D.Location</h4><h5 id="①概述-3"><a href="#①概述-3" class="headerlink" title="①概述"></a>①概述</h5><p>​<img src="/imgs/image-20230424121115986.png" alt="image-20230424121115986" style="zoom: 80%;" /></p><h5 id="②应用"><a href="#②应用" class="headerlink" title="②应用"></a>②应用</h5><p>​A.显示当前页面URL</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="variable language_">document</span>.<span class="title function_">write</span>(location.<span class="property">href</span>);<span class="comment">//将当前页面的URL显示到网页中</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​B.跳转到下一个页面</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(<span class="string">&quot;要跳转了&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">location.<span class="property">href</span> = <span class="string">&quot;https://www.baidu.com&quot;</span>; <span class="comment">//当执行到此行代码时，就会跳转到百度</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​可以利用此功能实现用户登录成功后跳转到页面首页。</p><hr><h3 id="⑥DOM对象"><a href="#⑥DOM对象" class="headerlink" title="⑥DOM对象"></a>⑥DOM对象</h3><h4 id="A-概述-1"><a href="#A-概述-1" class="headerlink" title="A.概述"></a>A.概述</h4><h5 id="①什么是DOM"><a href="#①什么是DOM" class="headerlink" title="①什么是DOM"></a>①什么是DOM</h5><ul><li>DOM：Document Object Model 文档对象模型。该体系下包含如下对象：<ul><li>Document：整个文档对象</li><li>Element：元素对象(即标签对象)，在HTML DOM中，将每个HTML元素都封装为一个对象。</li><li>Attribute：属性对象</li><li>Text：文本对象</li><li>Comment：注释对象</li></ul></li></ul><h5 id="②DOM的作用"><a href="#②DOM的作用" class="headerlink" title="②DOM的作用"></a>②DOM的作用</h5><p>​<img src="/imgs/image-20230424121148122.png" alt="image-20230424121148122"></p><h4 id="B-获取Element对象"><a href="#B-获取Element对象" class="headerlink" title="B.获取Element对象"></a>B.获取Element对象</h4><p>​<code>注：Document对象可以直接使用</code></p><p><img src="/imgs/image-20230424121210750.png" alt="image-20230424121210750"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> id = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;id&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> divs = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;div&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> hoobby = <span class="variable language_">document</span>.<span class="title function_">getElementsByName</span>(<span class="string">&quot;hobby&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> clss = <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&quot;cls&quot;</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="C-HTML-Element对象的使用"><a href="#C-HTML-Element对象的使用" class="headerlink" title="C.HTML  Element对象的使用"></a>C.HTML  Element对象的使用</h4><h5 id="①img对象"><a href="#①img对象" class="headerlink" title="①img对象"></a>①img对象</h5><p>​该对象里有一个重要的属性：src，通过 src 我们就能修改图片了。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">&quot;img&quot;</span> <span class="attr">src</span>=<span class="string">&quot;1111.jpg&quot;</span>&gt;</span>;</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> img = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;img&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    img.<span class="property">src</span> = <span class="string">&quot;hhh.jpg&quot;</span>; </span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​</p><h5 id="②div对象"><a href="#②div对象" class="headerlink" title="②div对象"></a>②div对象</h5><p>​通过W3School网站我们发现该div对象里没有相应的属性和方法。而<strong>所有的DOM对象都继承于DOM Element对象</strong>，所以我们可以查看DOM Element对象就可以知道div对象可以有哪些属性和方法了。DOM Element对象里有两个比较重要的属性&#x2F;方法：innerHTML 属性、style 属性。</p><ul><li><p>innerHTML 、style</p><ol><li><p><strong>innerHTML</strong> 作用：设置元素内容；<strong>style</strong>作用：设置元素css样式</p></li><li><p>例子：</p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cls1&quot;</span>&gt;</span>我是谁？<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cls2&quot;</span>&gt;</span>你是谁？<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> cls1 = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;div&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        cls1[<span class="number">0</span>].<span class="property">innerHTML</span> = <span class="string">&quot;我是橙子&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> cls2 = <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&quot;cls2&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        cls2[<span class="number">0</span>].<span class="property">style</span>.<span class="property">color</span> = <span class="string">&quot;blue&quot;</span>; </span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//想修改css样式时，只要在style属性后面继续“.”选择相应css属性即可。</span></span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure> <img src="/imgs/image-20230424121316594.png" alt="image-20230424121316594" style="zoom:80%;" /></li></ol></li></ul><h5 id="③input-checkbox对象"><a href="#③input-checkbox对象" class="headerlink" title="③input checkbox对象"></a>③input checkbox对象</h5><ul><li><p>input checkbox对象中有一个比较重要的属性：checked。</p><ul><li>checked属性用于设置或返回 checkbox 是否应被选中。</li></ul></li><li><p>如：</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span>&gt;</span>电影</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span>&gt;</span>写代码</span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> hobby = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;input&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        hobby[<span class="number">0</span>].<span class="property">checked</span> = <span class="literal">true</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">alert</span>(hobby[<span class="number">1</span>].<span class="property">checked</span>);<span class="comment">//false</span></span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>  <img src="/imgs/image-20230424121327070.png" alt="image-20230424121327070" style="zoom:80%;" /></li></ul><p>​</p><p>​</p><h5 id="④其它对象"><a href="#④其它对象" class="headerlink" title="④其它对象"></a>④其它对象</h5><p>​当遇到其它对象时，我们通过W3School来查看该对象有哪些属性和方法，然后根据需要使用。</p><p>​如果查到该<code>对象没有相应的属性方法</code>，则去<code>看DOM Element对象</code>，因为所有的DOM对象都继承于DOM Element对象，所以我们可以查看DOM Element对象就可以知道该对象可以有哪些属性和方法了。<code>DOM Element对象里有两个比较重要的属性/方法：innerHTML 属性、style 属性。</code></p><img src="/imgs/image-20230424121425515.png" alt="image-20230424121425515" style="zoom:80%;" /><p>​W3School网址：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.w3school.com.cn/jsref/dom_obj_document.asp</span><br></pre></td></tr></table></figure><hr><h3 id="⑦事件监听"><a href="#⑦事件监听" class="headerlink" title="⑦事件监听"></a>⑦事件监听</h3><h4 id="A-概述-2"><a href="#A-概述-2" class="headerlink" title="A.概述"></a>A.概述</h4><ul><li>事件：发生在HTML元素上的“事情”。比如：<ul><li>按钮被点击</li><li>鼠标移动到元素上</li><li>按下键盘按键</li></ul></li><li>事件监听：当有事件发生时执行相应的代码。</li></ul><h4 id="B-事件绑定"><a href="#B-事件绑定" class="headerlink" title="B.事件绑定"></a>B.事件绑定</h4><p>​为了让事件和代码联系起来，我们需要事件绑定。</p><img src="/imgs/image-20230424121502228.png" alt="image-20230424121502228" style="zoom:80%;" /><p>​</p><h4 id="C-常见事件"><a href="#C-常见事件" class="headerlink" title="C.常见事件"></a>C.常见事件</h4><ol><li><p><strong>onblur</strong>：元素失去焦点，即当鼠标点击离开该元素时进行相应的操作</p><ul><li>应用：当输入结束输入框的输入时，元素就失去了焦点，我们就可以对用户输入的信息进行验证。</li></ul></li><li><p><strong>onchange</strong>：域的内容被改变</p></li><li><p><strong>onclick</strong>：当用户点击按钮时执行相应操作</p></li><li><p><strong>onfocus</strong>：元素获得焦点。当用户点击输入框时，该输入框就获得焦点，然后执行相应的代码。</p></li><li><p><strong>onmouseout</strong>：鼠标从某元素移开。</p><ul><li>应用：当鼠标从某个元素上移开时，修改其元素的背景色。</li></ul></li><li><p><strong>onmouseover</strong>：鼠标移动到某元素上</p></li><li><p><strong>onkeydown</strong>：某个键盘的键被按下时，执行相应操作</p><ul><li>应用：禁止用户在表单中输入数字。</li></ul></li><li><p><strong>onsubmit</strong>：当表单提交时执行相应操作。</p><ul><li><p>应用：当表单输入内容不合要求时，禁止用户提交表单。onsubmit：返回true，表单可以提交，返回false，则表单不能提交</p>  <img src="/imgs/image-20230424121511770.png" alt="image-20230424121511770" style="zoom:80%;" /></li></ul></li></ol><h3 id="⑧应用–表单验证"><a href="#⑧应用–表单验证" class="headerlink" title="⑧应用–表单验证"></a>⑧应用–表单验证</h3><ul><li><p>需求：</p>  <img src="/imgs/image-20230424121544349.png" alt="image-20230424121544349" style="zoom:80%;" />  </li><li><p>实现：</p>  <img src="/imgs/image-20230424121559566.png" alt="image-20230424121559566" style="zoom:80%;" /><p>  ​</p><p>  注：</p><ol><li><p>输入框失去焦点中的操作步骤（3）、（4）、（5）都是写在步骤（2）中的function里的。</p></li><li><p>功能二中的步骤（3）是写在步骤（2）中的function里的。</p></li><li><p>如果不会可看视频：</p> <figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.bilibili.com/video/BV1Qf4y1T7Hx/?p=83&amp;spm_id_from=pageDriver&amp;vd_source=9c398663599ac78b625d463b4ffc1ff5</span><br></pre></td></tr></table></figure></li></ol></li></ul><h3 id="⑨正则表达式"><a href="#⑨正则表达式" class="headerlink" title="⑨正则表达式"></a>⑨正则表达式</h3><h4 id="A-概念"><a href="#A-概念" class="headerlink" title="A.概念"></a>A.概念</h4><p>​正则表达式定义了字符串组成的规则。可用来判断某字符串是否满住正则表达式，根据正则表达式查找字符串等。</p><h4 id="B-定义"><a href="#B-定义" class="headerlink" title="B.定义"></a>B.定义</h4><p>​<img src="/imgs/image-20230424121613748.png" alt="image-20230424121613748" style="zoom:80%;" /></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> reg = <span class="regexp">/正则表达式/</span>;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="C-语法"><a href="#C-语法" class="headerlink" title="C.语法"></a>C.语法</h4><p>​<img src="/imgs/image-20230424121623369.png" alt="image-20230424121623369" style="zoom:80%;" /></p><h4 id="D-方法"><a href="#D-方法" class="headerlink" title="D.方法"></a>D.方法</h4><p>​正则表达式中有一个test(str)方法，用于判断指定字符串是否符合规则，返回true或false。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> reg = <span class="regexp">/^\w+$/</span>;</span></span><br><span class="line"><span class="language-javascript">    reg.<span class="title function_">test</span>(<span class="string">&quot;abc&quot;</span>);<span class="comment">//true</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="E-应用"><a href="#E-应用" class="headerlink" title="E.应用"></a>E.应用</h4><p>​对用户输入的表数据进行校验。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;#&quot;</span> <span class="attr">method</span>=<span class="string">&quot;get&quot;</span>&gt;</span></span><br><span class="line">        电话号码<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;tel&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> inputTel = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;tel&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        inputTel.<span class="property">onblur</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">           <span class="keyword">var</span> tel = inputTel.<span class="property">value</span>;</span></span><br><span class="line"><span class="language-javascript">           <span class="keyword">var</span> reg = <span class="regexp">/^1\d&#123;10&#125;$/</span>;</span></span><br><span class="line"><span class="language-javascript">           <span class="keyword">var</span> telCheck = reg.<span class="title function_">test</span>(tel);</span></span><br><span class="line"><span class="language-javascript">           <span class="keyword">if</span>(telCheck != <span class="literal">true</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">               <span class="title function_">alert</span>(<span class="string">&quot;输入的电话号码有误&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">           &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS</title>
      <link href="/2023/04/24/css/"/>
      <url>/2023/04/24/css/</url>
      
        <content type="html"><![CDATA[<h3 id="①概述"><a href="#①概述" class="headerlink" title="①概述"></a>①概述</h3><p>​CSS是用于美化页面的，其结合着HTML语言一起使用。CSS的使用涉及到三个方面：</p><ol><li>CSS导入方式</li><li>CSS选择器(要对哪个HTML标签进行操作)</li><li>CSS属性</li></ol><h3 id="②CSS导入方式"><a href="#②CSS导入方式" class="headerlink" title="②CSS导入方式"></a>②CSS导入方式</h3><h4 id="A-内联样式"><a href="#A-内联样式" class="headerlink" title="A.内联样式"></a>A.内联样式</h4><p>​开发中这种导入方式少用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;color:red&quot;</span>&gt;</span></span><br><span class="line">    Hello CSS</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​div属于HTML标签，使用style属性就能指定CSS的样式</p><h4 id="B-内部样式"><a href="#B-内部样式" class="headerlink" title="B.内部样式"></a>B.内部样式</h4><p>​开发中这种导入方式常用</p><p><img src="/../imgs/image-20221027180338864-1682308133292.png" alt="image-20221027180338864"></p><h4 id="C-外部样式"><a href="#C-外部样式" class="headerlink" title="C.外部样式"></a>C.外部样式</h4><p>​开发中这种导入方式常用</p><p><img src="/../imgs/image-20221027180618981-1682308133294.png" alt="image-20221027180618981"></p><p>link标签中的href属性是指要导入修饰p标签的CSS文件的位置，rel属性表明导入的文件属于CSS文件。</p><p><img src="/../imgs/image-20221027180949801-1682308133294.png" alt="image-20221027180949801"></p><p>​上面为选择器。</p><h3 id="③CSS选择器"><a href="#③CSS选择器" class="headerlink" title="③CSS选择器"></a>③CSS选择器</h3><p><img src="/../imgs/image-20221029110857398-1682308133294.png" alt="image-20221029110857398"></p><p>说明：</p><ul><li>标签中的class属性其值可以不唯一，即多个标签中的class属性值可以相同。</li><li>如果标签1和标签2的class属性值如都为cls，选择器为：”.cls{color:red}”。则这两个标签的字体都会变成红色。</li></ul><h3 id="④CSS属性"><a href="#④CSS属性" class="headerlink" title="④CSS属性"></a>④CSS属性</h3><p>​CSS属性即：键值对，如：color:red</p><p>​我们可以在CSS选择器中写多个CSS属性。</p><p>​具体的CSS属性见下链接，这里就不过多赘述，因为不是学习重点。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.w3school.com.cn/index.html</span><br></pre></td></tr></table></figure><p>​</p>]]></content>
      
      
      <categories>
          
          <category> Java Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>html</title>
      <link href="/2023/04/23/html/"/>
      <url>/2023/04/23/html/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是HTML"><a href="#什么是HTML" class="headerlink" title="什么是HTML"></a>什么是HTML</h3><p><img src="/imgs/image-20221007172246485-1682259484191.png" alt="image-20221007172246485"></p><h3 id="HTML快速入门"><a href="#HTML快速入门" class="headerlink" title="HTML快速入门"></a>HTML快速入门</h3><h4 id="A-概述"><a href="#A-概述" class="headerlink" title="A.概述"></a>A.概述</h4><ol><li><p>HTML文件以“ .htm ” 或 “ .html ” 为扩展名。</p></li><li><p>HTML结构标签</p><p> <img src="/imgs/image-20221007185522655-1682259484194.png" alt="image-20221007185522655"></p></li><li><p>HTML标签不区分大小写。</p></li><li><p>HTML标签的属性值用单引号 或 双引号 引起来。</p></li><li><p>HMTL语法松散(了解)</p></li></ol><h5 id="①第一个HTML程序"><a href="#①第一个HTML程序" class="headerlink" title="①第一个HTML程序"></a>①第一个HTML程序</h5><ol><li><p>新建文本文件，后缀名改为 .html</p></li><li><p>编写HTML结构标签</p></li><li><p>在<body>中定义文字</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;html快速入门&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">乾坤未定，你我皆是黑马~</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li></ol><p>​结果：</p><p><img src="/imgs/image-20221007190411713-1682259484194.png" alt="image-20221007190411713"></p><h5 id="②IDEA中写HTML"><a href="#②IDEA中写HTML" class="headerlink" title="②IDEA中写HTML"></a>②IDEA中写HTML</h5><ol><li><p>实现</p><p> 新建一个Java module —&gt; 将module 中的src 文件删除 —&gt; 在该module下建一个文件new directory 命名为html —&gt;</p><p> 选中刚才新建的文件，右键new HTML file ，选HTML 5 file —&gt; 完成</p></li><li><p>建好后的HTML文件标签解析：</p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--html版本标识。!DOCTYPE代表是HTML5版本--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--规定当前页面编码集--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p>​</p><p>​</p><h4 id="B-基础标签"><a href="#B-基础标签" class="headerlink" title="B.基础标签"></a>B.基础标签</h4><p>​<img src="/imgs/image-20221007200439725-1682259484194.png" alt="image-20221007200439725"></p><ul><li><p>补充：</p><ol><li><p><font>标签中有三个属性：face（设置字体，如：宋体）、size（设置字体大小）、color（设置字体颜色）。</p></li><li><p>HTML、CSS中如何表示颜色：</p><ul><li>英文单词：red,pink,blue</li><li>rgb(值1，值2，值3)：值的取值范围为0-255。rgb中的 r 表示红色，g 表示绿色，b 表示蓝色，然后通过不同的值来匹配出不同的颜色，如：rgb(255，0，0)表示红色</li><li>#值1值2值3，值的范围：00-FF（FF：即255），原理与rgb的表示方式一样。</li></ul></li><li><hr>标签中也可以设置颜色属性color。</li></ol></li><li><p>例子：</p><p>  <img src="/imgs/image-20221007200521193-1682259484195.png" alt="image-20221007200521193"></p></li></ul><p>​</p><h4 id="C-图片、音频、视频标签"><a href="#C-图片、音频、视频标签" class="headerlink" title="C.图片、音频、视频标签"></a>C.图片、音频、视频标签</h4><h5 id="①概述"><a href="#①概述" class="headerlink" title="①概述"></a>①概述</h5><p><img src="/imgs/image-20221007210035634-1682259484195.png" alt="image-20221007210035634"></p><p><img src="/imgs/image-20230423223700021.png" alt="image-20230423223700021"></p><p>​使用controls属性时，可以直接写属性名即可。</p><h5 id="②补充"><a href="#②补充" class="headerlink" title="②补充"></a>②补充</h5><ol><li><p>上面三个标签中都可以写height、width属性，其值可以写：数字、百分比</p><ul><li>写数字：其单位默认为px（像素）。</li><li>写百分比：其含义是占页面大小的百分之多少。</li></ul></li><li><p>资源路径：</p><ul><li><p>绝对路径：带盘符</p></li><li><p>相对路径：资源相对于当前HTML页面的位置。不懂？见下面视频链接。</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.bilibili.com/video/BV1Qf4y1T7Hx/?p=63&amp;spm_id_from=pageDriver&amp;vd_source=9c398663599ac78b625d463b4ffc1ff5</span><br></pre></td></tr></table></figure><p>  练习：    </p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./ 代表：当前目录   ./可以省略不写</span><br><span class="line">../ 代表上一级目录</span><br></pre></td></tr></table></figure><p>  <img src="/imgs/image-20221007233250664-1682259484195.png" alt="image-20221007233250664"></p></li></ul></li></ol><h4 id="D-超链接标签"><a href="#D-超链接标签" class="headerlink" title="D.超链接标签"></a>D.超链接标签</h4><h5 id="①概述-1"><a href="#①概述-1" class="headerlink" title="①概述"></a>①概述</h5><p>​<img src="/imgs/image-20230423223605819.png" alt="image-20230423223605819"></p><h5 id="②例子"><a href="#②例子" class="headerlink" title="②例子"></a>②例子</h5><p><img src="/imgs/image-20221008114926972-1682259484195.png" alt="image-20221008114926972"></p><p>​效果展示：</p><p>​<img src="/imgs/image-20221008115017510-1682259484195.png" alt="image-20221008115017510"></p><h4 id="E-列表标签"><a href="#E-列表标签" class="headerlink" title="E.列表标签"></a>E.列表标签</h4><h5 id="①概述-2"><a href="#①概述-2" class="headerlink" title="①概述"></a>①概述</h5><p>​<img src="/imgs/image-20221008115507910-1682259484195.png" alt="image-20221008115507910"></p><h5 id="②例子-1"><a href="#②例子-1" class="headerlink" title="②例子"></a>②例子</h5><p>​<img src="/imgs/image-20221008115529971-1682259484195.png" alt="image-20221008115529971"></p><h4 id="F-表格标签"><a href="#F-表格标签" class="headerlink" title="F.表格标签"></a>F.表格标签</h4><h5 id="①概述-3"><a href="#①概述-3" class="headerlink" title="①概述"></a>①概述</h5><ol><li><p><img src="/imgs/image-20230423223008528.png" alt="image-20230423223008528"></p><p>使用&lt; th &gt;标签后，字体会被加粗 和 居中显示，通常使用在表头。</p></li><li><p>各标签对应的属性：</p><p> <img src="/imgs/image-20221008122830924-1682259484196.png" alt="image-20221008122830924"></p><p> 如果cellspacing值为0，则单元格之间就没有空白，即单元格之间的边框就会合在一起。</p></li><li><p>补充说明：</p><p> <img src="/imgs/image-20221008123156143-1682259484196.png" alt="image-20221008123156143"></p><p> ​该表格的第三行是有四个单元格的，第四行是只有三个单元格的。</p></li></ol><h5 id="②例子-2"><a href="#②例子-2" class="headerlink" title="②例子"></a>②例子</h5><p><img src="/imgs/image-20221008123410654-1682259484196.png" alt="image-20221008123410654"></p><p>​实现的效果：</p><p><img src="/imgs/image-20221008123433251-1682259484196.png" alt="image-20221008123433251"></p><h4 id="G-布局标签"><a href="#G-布局标签" class="headerlink" title="G.布局标签"></a>G.布局标签</h4><p><img src="/imgs/image-20221008141924482-1682259484196.png" alt="image-20221008141924482"></p><h4 id="H-表单标签"><a href="#H-表单标签" class="headerlink" title="H.表单标签"></a>H.表单标签</h4><h5 id="①概述-4"><a href="#①概述-4" class="headerlink" title="①概述"></a>①概述</h5><p>​表单：在页面中主要负责数据采集功能，使用<from>标签定义表单。</p><p>​表单项(或表单元素)：不同类型的input元素、下拉列表、文本域等</p><h5 id="②form标签"><a href="#②form标签" class="headerlink" title="②form标签"></a>②form标签</h5><p>​form标签内有两个属性：</p><ul><li>action：规定当提交表单时向何处发送表单数据，URL。当action&#x3D;”#”，则代表表单提交到当前页面。<ul><li>注意：表单项数据要想被提交，则必须指定其name属性，属性值随便写。</li></ul></li><li>method：指定表单提交的方式。<ul><li>get：默认值<ul><li>请求参数会拼接在URL后边。不安全。</li><li>URL的长度是有限制的，大小为4KB。</li></ul></li><li>post：<ul><li>请求参数会在http请求协议的请求体中，因此对请求参数的大小没有限制。且安全些。</li></ul></li><li>请求参数：即表单项中用户输入的值。</li></ul></li></ul><h5 id="③表单项标签"><a href="#③表单项标签" class="headerlink" title="③表单项标签"></a>③表单项标签</h5><ol><li><p>概述</p><p> <img src="/imgs/image-20221008160648807-1682259484196.png" alt="image-20221008160648807"></p></li><li><p>练习</p></li></ol><ul><li><p>提交按钮</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;注册&quot;</span>&gt;</span> <span class="comment">&lt;!--可以通过value值来改变提交按钮上显示的文本 --&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>lable标签</p><p>该标签的功能是：只要点击表单项附近的文字，输入框就能提示输入。</p><p>解释：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;label&gt;文字&lt;/label&gt;</span><br></pre></td></tr></table></figure><p>​通过点击文件就能跳到相应的输入框中提示输入。但究竟要跳到哪个输入框呢？就要指定label标签中的for属性和那个输入框的id属性，这样label标签就能通过for属性来找到对应的输入框。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span> <span class="attr">id</span>=<span class="string">&quot;travel&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;travel&quot;</span>&gt;</span>旅游<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>单选框</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">性别：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;男&quot;</span>&gt;</span>男</span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;女&quot;</span>&gt;</span>女</span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="/imgs/image-20230423222315752.png" alt="image-20230423222315752"></p><p>如果两个单选框的name属性值不一样，就无法实现：多个只能选一个的功能。</p><p>如果不指定value值，提交表单时，其数据值就为：on，此值就没有意义了，所以得指定其值。</p></li><li><p>复选框</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span> 旅游</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>&gt;</span> 电影</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span> <span class="attr">value</span>=<span class="string">&quot;3&quot;</span>&gt;</span> 游戏</span><br></pre></td></tr></table></figure><p>  注意：①如果让复选框都属于爱好这个项目里，那就要要求name属性值都得一样。②每一个复选框都要指定其value值，不然提交表单的时候，数据就会显示为：on，这样数据就没有意义了。</p></li><li><p>提交文件</p><p>应用：上传用户头像等</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">头像：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>隐藏输入</p><p>应用：我们需要用户的id值，但不希望用户自己来输入，此时就可以使用隐藏输入来指定用户的id值了。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>下拉列表</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&#x27;city&#x27;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>北京<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">‘shanghai</span>&gt;</span>上海<span class="tag">&lt;/<span class="name">option</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!--如果option里有value，则提交时将提交value的值，而不是“上海” --&gt;</span>   </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>文本域</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">个人描述<span class="tag">&lt;<span class="name">textarea</span> <span class="attr">cols</span>=<span class="string">&quot;20&quot;</span> <span class="attr">rows</span>=<span class="string">&quot;5&quot;</span> <span class="attr">name</span>=<span class="string">&#x27;desc&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  cols：指定文本域中一行可以写多少个字。</p><p>  rows：指定文本域一共可以写多少行。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis</title>
      <link href="/2023/04/23/mybatis/"/>
      <url>/2023/04/23/mybatis/</url>
      
        <content type="html"><![CDATA[<h3 id="①概述"><a href="#①概述" class="headerlink" title="①概述"></a>①概述</h3><h4 id="A-MyBatis"><a href="#A-MyBatis" class="headerlink" title="A.MyBatis"></a>A.MyBatis</h4><ul><li>MyBatis是一款优秀的持久层框架，用于简化JDBC开发。</li><li>持久层：负责将数据保存到数据库的那一层代码。</li><li>框架：半成品软件，是一套可重复的、通用的、软件基础代码模型。在框架上构建软件会更加高效、规范、通用、可扩展。</li></ul><h4 id="B-JDBC缺点"><a href="#B-JDBC缺点" class="headerlink" title="B.JDBC缺点"></a>B.JDBC缺点</h4><ol><li>硬编码。即在注册驱动、获取连接时，变量值用的都是字符串，代表其值是固定的，不能改变，这就是硬编码。</li><li>操作繁琐。如：将数据装到对象中时。</li></ol><h4 id="C-MyBatis如何解决JDBC的缺点"><a href="#C-MyBatis如何解决JDBC的缺点" class="headerlink" title="C.MyBatis如何解决JDBC的缺点"></a>C.MyBatis如何解决JDBC的缺点</h4><ol><li>硬编码—&gt; 写在配置文件中</li><li>操作繁琐—&gt; 一行代码完，省去了设置值和转载数据的操作。</li></ol><p>​</p><h3 id="②快速入门"><a href="#②快速入门" class="headerlink" title="②快速入门"></a>②快速入门</h3><p>​从数据库中获取数据，然后将其放到一个对象中，再将对象放到一个集合中。</p><h4 id="A-实现步骤"><a href="#A-实现步骤" class="headerlink" title="A.实现步骤"></a>A.实现步骤</h4><p>​新建一个maven项目</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0.导入mybatis依赖，放到pom.xml文件中</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&lt;dependency&gt;</span></span><br><span class="line"><span class="comment">      &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span></span><br><span class="line"><span class="comment">      &lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span></span><br><span class="line"><span class="comment">      &lt;version&gt;3.5.7&lt;/version&gt;</span></span><br><span class="line"><span class="comment">&lt;/dependency&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.导入MySQL数据库驱动：mysql-connector-java-5.1.34.jar</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&lt;dependency&gt;</span></span><br><span class="line"><span class="comment">            &lt;groupId&gt;mysql&lt;/groupId&gt;</span></span><br><span class="line"><span class="comment">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span></span><br><span class="line"><span class="comment">            &lt;version&gt;5.1.34&lt;/version&gt;</span></span><br><span class="line"><span class="comment">        &lt;/dependency&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//2.编写MyBatis核心配置文件 ---&gt; 即：将JDBC中的连接信息写到配置文件中</span></span><br><span class="line"><span class="comment">//2.1在main文件夹下的resources文件中新建一个配置文件：mybatis-config.xml</span></span><br><span class="line"><span class="comment">//2.2在刚才的新建文件中写入配置信息：见补充信息①</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.编写sql映射文件 --&gt; 原来SQL语句是写在代码中的，现在将其写在一个配置文件中，这样可以统一管理SQL语句。</span></span><br><span class="line"><span class="comment">//3.1在main文件夹下的resources文件中新建一个文件：操作的数据库表表名Mapper.xml</span></span><br><span class="line"><span class="comment">//3.2将补充信息2中的配置信息复制到该文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4.加载MyBatis核心配置文件，获取SqlSessionFactory对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;..........&quot;</span>;</span><br><span class="line"><span class="comment">//resource：写MyBatis核心配置文件的路径(路径从resources文件夹下开始写)</span></span><br><span class="line"></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> </span><br><span class="line">    <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br><span class="line"><span class="comment">//SqlSessionFactory类的对象就相当于JDBC中的Connection类的对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//5.获取SqlSession对象</span></span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession(); <span class="comment">//相当于JDBC中获取执行SQL语句的对象。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//6.执行SQL语句</span></span><br><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> sqlSession.selectList(<span class="string">&quot;sql语句的标识&quot;</span>);<span class="comment">//SqlSession里还有其它的方法</span></span><br><span class="line"><span class="comment">//sql语句的标识：在配置sql映射文件中的时候，有定义该sql语句的namespace和id，两者用&quot;.&quot;连接起来。</span></span><br><span class="line"><span class="comment">//为什么要这么写呢？因为到时候会有很多的sql映射文件，一个sql文件里又可能有很多的sql语句，所以就用namespace和id来定位唯一一条sql语句。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//7.释放资源</span></span><br><span class="line">sqlSession.close();<span class="comment">//只要释放SqlSession类的对象的资源即可</span></span><br></pre></td></tr></table></figure><p>​</p><h5 id="补充信息①"><a href="#补充信息①" class="headerlink" title="补充信息①"></a>补充信息①</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">  <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">  <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--上面的东西不用管 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--driver 就相当于jdbc中的注册驱动操作 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--下面三行就是数据库的连接信息 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://127.0.0.1:3306/要连接的数据库?useSSL=false&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span>  <span class="comment">&lt;!--登录数据库的用户名 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1234&quot;</span>/&gt;</span>  <span class="comment">&lt;!--登录数据库的密码 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--resource：写sql映射文件的地址，用于加载sql映射文件的 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;操作的数据库表表名Mapper.xml&quot;</span>/&gt;</span></span><br><span class="line">      </span><br><span class="line">    <span class="comment">&lt;!--如果使用了Mapper代理的方式，就可以简化SQL映射文件的加载，如：</span></span><br><span class="line"><span class="comment"> &lt;package name = &#x27;写resources文件下存放sql映射文件的文件名&#x27;/&gt; </span></span><br><span class="line"><span class="comment"> 这样就可以一次性加载该文件夾下所有的sql映射文件。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​</p><h5 id="补充信息②"><a href="#补充信息②" class="headerlink" title="补充信息②"></a>补充信息②</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">  <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">  <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--上面的东西不用管 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectBlog&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;类的全类名&quot;</span>&gt;</span></span><br><span class="line">    select * from Blog where id = ....</span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--SQL语句要写在对应的标签中，如：上面8-10行代码 --&gt;</span>  </span><br><span class="line">  <span class="comment">&lt;!--可以在mapper标签中写多条sql语句 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​说明</p><ul><li><!--select id="该SQL语句的唯一标识，随便写只要不一样就行" resultType="规定该语句返回的类型，如果要将结果放到某个类中，就写那个类的全类名即可" --></li><li>mapper标签里的namespace：随便写一个即可，但要唯一。</li></ul><h4 id="B-解决视情况映射文件的警告提示"><a href="#B-解决视情况映射文件的警告提示" class="headerlink" title="B.解决视情况映射文件的警告提示"></a>B.解决视情况映射文件的警告提示</h4><ul><li>产生警告的原因：Idea和数据库没有建立连接，不识别表的信息。</li><li>解决方式：在Idea中配置MySQL数据库连接。具体操作，见网址：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://blog.csdn.net/weixin_59118991/article/details/124562952</span><br></pre></td></tr></table></figure><hr><h3 id="③Mapper代理开发"><a href="#③Mapper代理开发" class="headerlink" title="③Mapper代理开发"></a>③Mapper代理开发</h3><h4 id="A-引入"><a href="#A-引入" class="headerlink" title="A.引入"></a>A.引入</h4><p>​上面我们通过MyBatis实现了对MySQL数据库的操作，但在实现步骤6(执行sql语句)中还是会存在硬编码的问题，所以我们引入了Mapper代理开发。这种方式在实际开发中很常用。</p><h4 id="B-实现步骤"><a href="#B-实现步骤" class="headerlink" title="B.实现步骤"></a>B.实现步骤</h4><ol><li><p>在pom.xml文件中导入Mysql依赖、mybatis依赖（见笔记MyBatis快速入门）。</p></li><li><p>在main文件夹下的resources文件下建mybatis核心配置文件(mybatis-config.xml)。(mybatis核心配置文件的内容见笔记MyBatis快速入门)。</p></li><li><p>在main文件夹下的java文件中建两个包：com.zzc.mapper 、com.zzc.pojo，这两个包分别放Mapper接口和数据库表对应的类。</p><p> <img src="/../imgs/image-20221007160103501-1682258537176.png" alt="image-20221007160103501"></p></li><li><p>在resources文件夹下，创建SQL映射文件，文件名为：数据库表表名Mapper.xml。文件内容见：笔记MyBatis快速入门。</p></li><li><p><strong>定义与SQL映射文件同名的Mapper接口，并且将Mapper接口和SQL映射文件放置在同一目录下</strong>。</p><p> 1. </p>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在mapper包中放 “ 与SQL映射文件同名的Mapper接口 ”。</span><br></pre></td></tr></table></figure><p>  如何实现Mapper接口和SQL映射文件放置在同一目录下？前提SQL映射文件是放在main文件夹下的resources文件中。<br>   由于resources与java文件都是在同一个文件层级中，所以那个接口放在什么文件下，你就在resources文件下也建一个相同的文件层次来放SQL映射文件即可。使用new Directory的方式创建文件层级，<strong>但注意文件路径要用“ &#x2F; ”不能用“ . ”</strong> 。<br>  例子：Mapper接口放在了：<img src="/../imgs/image-20220926102308096-1682258537177.png" alt="image-20220926102308096"></p><p>   ​那配置文件UserMapper.xml应该放在哪？在resources下new Directory 命名为：com&#x2F;itheima&#x2F;mapper。然后将UserMapper.xml拖进这个文件里即可。</p></li><li><p><strong>设置SQL映射文件的namespace属性为Mapper接口全限定名</strong>，即：com.xxx.xxx.接口名。如按上面的例子来写，则为：com.itheima.mapper.UserMapper。</p></li><li><p><strong>在Mapper接口中定义方法，方法名就是SQL映射文件中SQL语句的id，并保持与sql语句中的参数类型和返回值类型一致。</strong>如果sql语句返回的是List<User>，则方法的放回值类型也是List<User>。</p></li><li><p><strong>修改MyBatis核心配置文件中的 <mapper resource=""/>，写上现在sql映射文件的地址。</strong></p><p> 文件地址默认从resources文件下开始写。如：sql映射文件放在resources文件夹下的com.zzc.mapper文件下。那就这样写：</p>   <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/zzc/mapper/ExeMapper.xml&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">&lt;!--如果使用了Mapper代理的方式，就可以简化SQL映射文件的加载，如：</span></span><br><span class="line"><span class="comment"> &lt;package name = &#x27;写resources文件下存放sql映射文件的文件名&#x27;/&gt; </span></span><br><span class="line"><span class="comment"> 这样就可以一次性加载该文件夾下所有的sql映射文件。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编码（按照MyBatis快速入门中的步骤4-7进行码，其中第6步替换为下面两步）</p><ol><li><p>通过SqlSession的getMapper方法获取 Mapper接口的代理对象。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mapper接口名 mapper = sqlSession.getMapper(Mapper接口名.class);</span><br></pre></td></tr></table></figure></li><li><p>通过Mapper接口的代理对象，调用Mapper接口中对应方法完成sql的执行。</p></li></ol></li><li><p>编写数据库表对应的类，并放在pojo包下。</p></li><li><p>看看数据库中该表的字段是否与表对应的类的属性名一致，不一致得使用resultMap标签（见笔记MyBatis练习–&gt; 查询–所有数据 —&gt; resultMap标签），不然会导致部分数据不能自动封装到对象中。</p></li><li><p>关闭资源</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlSession.close();</span><br></pre></td></tr></table></figure></li></ol><h4 id="C-实现原理"><a href="#C-实现原理" class="headerlink" title="C.实现原理"></a>C.实现原理</h4><ol><li>当我们通过SqlSession类的对象去调用getMapper(Mapper接口名.class)方法时，实际上就是找到了该接口，由于该接口的目录下还有其对应的SQL映射文件，因此也找到了该映射文件。</li><li>找到映射文件之后也就找到了SQL语句，那到底执行哪条sql呢？通过调用Mapper接口中的方法，通过该方法名我们就找到了sql的id，然后根据id在映射文件中找到具体的sql并执行。</li></ol><hr><h3 id="④MyBatis核心配置文件解释"><a href="#④MyBatis核心配置文件解释" class="headerlink" title="④MyBatis核心配置文件解释"></a>④MyBatis核心配置文件解释</h3><h4 id="A-environent标签"><a href="#A-environent标签" class="headerlink" title="A.environent标签"></a>A.environent标签</h4><ul><li><p>用于配置数据库连接信息，在<environents>标签中可以定义多个environent。</p></li><li><p>每个environent标签都有个id属性，用于标识此environent。</p></li><li><p>我们可以通过environents标签中的default属性来切换不同的environent。即将environent的id赋给default。</p></li><li><p><environent>标签里有个<transactionManager type="JDBC">标签，其作用是管理事务。不用管。</p></li><li><p><environent>标签里有个<dataSource type="POOLED">标签，不用管。</p></li><li><p>类型别名(typeAliases)</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span> = <span class="string">&quot;com.itheima.pojo&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  我们在写sql映射文件时，该文件的配置里需指定返回值的类型，该返回值类型需要使用全类名的方式表示，这样的写法会冗余些，所以我们可以使用类型别名的方式，将某个包下的类用该类的类名来代替全类名。如：</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--某个包com.zzc.pojo下有Person类，Man类 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span> = <span class="string">&quot;com.itheima.pojo&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--使用之后，就可以用person来代替com.zzc.pojo.Person,用Man来代替com.zzc.pojo.Man --&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>注意：配置各个标签时，需要遵循如下图先后顺序，不然报错。</p><ul><li><img src="/../imgs/image-20220926153642399-1682258537177.png" alt="image-20220926153642399"></li></ul></li></ul><h3 id="⑤MybatiX插件"><a href="#⑤MybatiX插件" class="headerlink" title="⑤MybatiX插件"></a>⑤MybatiX插件</h3><h4 id="A-功能介绍"><a href="#A-功能介绍" class="headerlink" title="A.功能介绍"></a>A.功能介绍</h4><p>​此插件可以帮我们快速地完成有些功能如：</p><p>​①</p><p>​<img src="/../imgs/image-20220928221305504-1682258537177.png" alt="image-20220928221305504"></p><p>​只要点击上图中的小鸟就可以跳到相应的SQL映射文件里对应的SQL语句。</p><p>​②映射文件对应的接口里，写下新的抽象方法，按 alt + 回车 ，选 “ mybatis…..”  ，就可以在对应的映射文件中创建相应的SQL语句。</p><p><img src="/../imgs/image-20221117182402031-1682258537177.png" alt="image-20221117182402031"></p><h4 id="B-插件安装"><a href="#B-插件安装" class="headerlink" title="B.插件安装"></a>B.插件安装</h4><p><img src="/../imgs/image-20220928222331498-1682258537177.png" alt="image-20220928222331498"></p><p><img src="/../imgs/image-20220928222432635-1682258537177.png" alt="image-20220928222432635"></p><h3 id="⑥MyBatis练习"><a href="#⑥MyBatis练习" class="headerlink" title="⑥MyBatis练习"></a>⑥MyBatis练习</h3><h4 id="A-查询–所有数据"><a href="#A-查询–所有数据" class="headerlink" title="A.查询–所有数据"></a>A.查询–所有数据</h4><h5 id="①引入"><a href="#①引入" class="headerlink" title="①引入"></a>①引入</h5><p>​MyBatis中，当数据库表的字段名称 和 实体类的属性名称 不一样，则不能自动封装数据。</p><h5 id="②解决方法"><a href="#②解决方法" class="headerlink" title="②解决方法"></a>②解决方法</h5><p>​使用<strong>resultMap</strong>标签</p><p>​<strong>实习步骤</strong>：</p><ol><li>在SQL映射文件中定义resultMap标签。</li><li>在select标签中，使用resultMap属性(其值为resultMap中的id值) 替换 原来的resultType属性。</li></ol><p>​补充：</p><p>​如果使用的是注解开发，则将上面步骤2中的操作替换为：在接口方法上使用@ResultMap(“写resultMap中的id值”)即可。</p><p><img src="/imgs/image-20230423221329390.png" alt="image-20230423221329390"></p><h5 id="③resultMap标签的结构"><a href="#③resultMap标签的结构" class="headerlink" title="③resultMap标签的结构"></a>③resultMap标签的结构</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;getEmpByIdMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;entity.Employee&quot;</span> &gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;st_id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;st_name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;st_sex&quot;</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;st_email&quot;</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​resultMap标签属性介绍：</p><ul><li>id：唯一标识该resultMap</li><li>type：写原来select标签中的resultType的值。</li><li>resultMap标签里有两个子标签：<ul><li><id column="..." property="..."/> 该标签用于完成主键字段的映射</li><li><result column="..." property="..."/> 该标签用于完成一般字段的映射</li></ul></li><li>上面两个标签中的 column 和 property<ul><li>column：表的列名</li><li>property：实体类的属性名</li></ul></li></ul><h4 id="B-查询–任意某个数据"><a href="#B-查询–任意某个数据" class="headerlink" title="B.查询–任意某个数据"></a>B.查询–任意某个数据</h4><p>​以根据Id来查找数据为例。</p><h5 id="①实现步骤"><a href="#①实现步骤" class="headerlink" title="①实现步骤"></a>①实现步骤</h5><ol><li><p>编写接口方法：Mapper接口</p><ul><li><p>参数为：id，结果为：Brand。</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Brand selectById(int id);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>编写SQL语句：SQL映射文件</p></li></ol><p><img src="/../imgs/image-20221004191005819-1682258537177.png" alt="image-20221004191005819"></p><p>​parameterType：用于设置参数类型，可以省略不写。</p><p>​#{id}的解释见：占位符。</p><h5 id="②参数占位符"><a href="#②参数占位符" class="headerlink" title="②参数占位符"></a>②参数占位符</h5><ol><li><p>参数占位符有两种：#{ } 和 ${ } </p><ul><li>#{形参名}：在编译时会将其替换为 ? ，将来自动设置参数值。目的是防止SQL注入。</li><li>${形参名}：在编译时直接将形参值替换掉${形参名}。会存在SQL注入问题。</li><li>使用时机：参数传递的时候，使用 #{形参名}；表名或列名不固定的情况下：${形参名}</li></ul></li><li><p>SQL语句中特殊字符处理，如：小于号“ &lt; ”，在xml文件中属于标签的开始符号。所以就得使用如下方法进行处理：</p><ul><li>转移字符(小于号对应的转移字符为：” &amp;lt “ )</li><li>CDATA区：<![CDATA[内容]]>。使用时直接打CD就会提示出这个CDATA区。</li></ul></li></ol><h4 id="C-查询–条件查询"><a href="#C-查询–条件查询" class="headerlink" title="C.查询–条件查询"></a>C.查询–条件查询</h4><h5 id="①多条件查询"><a href="#①多条件查询" class="headerlink" title="①多条件查询"></a>①多条件查询</h5><p>​<img src="/../imgs/image-20221005113009918-1682258537177.png" alt="image-20221005113009918"></p><p>​当多条件查询时，Mapper接口中的方法应该怎么写呢？有三种写法：</p><ol><li><p><strong>散装参数</strong>：使用@Param(“SQL中的参数占位符名称”)。如：</p><p> <img src="/../imgs/image-20221005113057692-1682258537178.png" alt="image-20221005113057692"></p><p> ​接口方法中的参数status 设置的是SQL语句中的status参数。</p></li><li><p><strong>实体类封装参数</strong>：需要保证SQL中的参数名 和 实体类属性名对应上。</p><p> <strong>其原理是</strong>：通过SQL中的参数名 来找实体类中是否有同名的属性名，有则调用该属性的get方法来获取其值。</p><p> <strong>例子</strong>：<img src="/../imgs/image-20221005113735701-1682258537178.png" alt="image-20221005113735701"></p></li><li><p><strong>map集合</strong>：需要保证SQL语句中的参数名 和 map集合的键的名称对应上。</p><p> 例子：<img src="/../imgs/image-20221005113935878-1682258537178.png" alt="image-20221005113935878"></p></li></ol><h5 id="②多条件的动态查询"><a href="#②多条件的动态查询" class="headerlink" title="②多条件的动态查询"></a>②多条件的动态查询</h5><ol><li><p><strong>问题引入</strong>：我们需要根据实际情况来动态编写我们的SQL语句。</p></li><li><p><strong>动态SQL语句的实现</strong>：添加相应的标签，如：</p><ul><li>if（用于判断参数是否有值，使用test属性进行条件判断）</li><li>choose (when, otherwise)</li><li>trim (where, set)</li><li>foreach</li></ul></li><li><p>应用例子：</p><p> <strong>if的应用</strong>：</p><p> <img src="/../imgs/image-20221005170413700-1682258537178.png" alt="image-20221005170413700"></p><p> ​当status !&#x3D; null 时，就会执行status &#x3D; #{status}这条SQL语句。</p><p> ​<strong>where的应用</strong>：</p><p> ​如果上图中的status为null，companyName !&#x3D; null，brandName !&#x3D; null。这样就会导致SQL语句变成：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">from</span> tb_brand</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">and</span> company_name <span class="keyword">like</span> #&#123;companyName&#125; <span class="keyword">and</span> brand_name <span class="keyword">like</span> #&#123;brandName&#125;</span><br></pre></td></tr></table></figure><p> ​这样的SQL语句会报错。</p><p> ​所以我们就可以使用<where>标签来代替where关键字，帮我们判断是否需要加连接关键字。如果需要加上，则会加上；如果不需要加上，则会帮我们删除掉。如：</p><p> <img src="/../imgs/image-20221005171330402-1682258537178.png" alt="image-20221005171330402"></p></li></ol><h5 id="③单条件的动态查询"><a href="#③单条件的动态查询" class="headerlink" title="③单条件的动态查询"></a>③单条件的动态查询</h5><ol><li><p>单条件的动态查询：从多个条件中选择一个。</p><p> ​例子：可以从多个条件中选择一个条件作为查询条件。</p></li><li><p><strong>实现</strong>：使用<choose>标签及其子标签<when>、<otherwise>。</p><ul><li><choose>相当于Java中的switch。</li><li><when>相当于Java中的case。</li><li><otherwise>相当于Java中的default。</li></ul></li><li><p>应用：</p><p> <img src="/../imgs/image-20221005211621505-1682258537178.png" alt="image-20221005211621505"></p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">from</span> tb_brand</span><br><span class="line"><span class="keyword">where</span> <span class="number">1</span> <span class="operator">=</span> <span class="number">1</span> </span><br><span class="line"><span class="comment">-- 下面与上面等价</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">from</span> tb_brand</span><br></pre></td></tr></table></figure></li></ol><h5 id="④Like模糊匹配"><a href="#④Like模糊匹配" class="headerlink" title="④Like模糊匹配"></a>④Like模糊匹配</h5><p>​like关键字后面跟着参数占位符时，该怎么实现模糊匹配呢？</p><p>​使用数据库中的concat函数，concat(‘%’,#{数据名,jdbcType&#x3D;数据在数据库中的数据类型},’%’)</p><p>​例子：</p><p>​Mapper下这样写：</p><p><img src="/imgs/image-20230423221434471.png" alt="image-20230423221434471"></p><p>​对应的接口这样写：</p><p><img src="/imgs/image-20230423221445722.png" alt="image-20230423221445722"></p><p>​例子还有：<a href="https://zhuanlan.zhihu.com/p/58297267">mybatis中使用like关键字拼接SQL - 知乎 (zhihu.com)</a></p><h4 id="D-添加数据"><a href="#D-添加数据" class="headerlink" title="D.添加数据"></a>D.添加数据</h4><h5 id="①实现步骤-1"><a href="#①实现步骤-1" class="headerlink" title="①实现步骤"></a>①实现步骤</h5><ol><li>编写接口方法：Mapper接口<ul><li>方法的参数：除了id之外的所有数据（因为id是自增的）</li><li>方法的返回值类型：void（因为我们可以通过是否抛异常，来判断是否添加成功）</li></ul></li><li>编写SQL语句：在SQL映射文件中使用<insert>标签</li></ol><h5 id="②注意"><a href="#②注意" class="headerlink" title="②注意"></a>②注意</h5><p>​<img src="/../imgs/image-20221006115241104-1682258537178.png" alt="image-20221006115241104"></p><h5 id="③应用例子"><a href="#③应用例子" class="headerlink" title="③应用例子"></a>③应用例子</h5><p><img src="/../imgs/image-20221006115120607-1682258537178.png" alt="image-20221006115120607"></p><h4 id="E-添加数据–主键返回"><a href="#E-添加数据–主键返回" class="headerlink" title="E.添加数据–主键返回"></a>E.添加数据–主键返回</h4><p>①引入</p><p>​在数据添加成功后，需要获取插入数据库数据的主键的值。</p><p>​如：添加订单项时，订单项中需要设置所属订单的id。</p><p>②实现</p><p>​在<insert>标签里添加其属性：useGeneratedKeys、keyProperty，如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span> = <span class="string">&quot;addOrder&quot;</span> <span class="attr">useGeneratedKeys</span> =<span class="string">&quot;true&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>useGeneratedKeys：该属性用来设置，是否使用 JDBC 提供的 getGenereatedKeys() 方法。如果设置为true，将获取数据库内部产生的主键并赋值到 keyProperty 属性设置的请求对象的属性中。如果不设置useGeneratedKeys属性，则默认值为false。</li><li>keyProperty：该属性的作用是将插入操作的返回值赋给 PO 类的某个属性，通常为主键对应的属性。如果是联合主键，可以将多个值用逗号隔开。</li></ul><h4 id="F-修改–全部字段"><a href="#F-修改–全部字段" class="headerlink" title="F.修改–全部字段"></a>F.修改–全部字段</h4><h5 id="①实现"><a href="#①实现" class="headerlink" title="①实现"></a>①实现</h5><ol><li>编写接口方法：Mapper接口<ul><li>方法的参数：所有数据</li><li>方法的返回值类型：可以是void（通过是否抛异常来判断是否修改成功），可以是int（通过返回受影响行数来判断是否修改成功）</li></ul></li><li>编写SQL语句：SQL映射文件中使用<update>标签</li></ol><h5 id="②例子"><a href="#②例子" class="headerlink" title="②例子"></a>②例子</h5><p>​<img src="/../imgs/image-20221006150422586-1682258537178.png" alt="image-20221006150422586"></p><h4 id="G-修改–动态字段"><a href="#G-修改–动态字段" class="headerlink" title="G.修改–动态字段"></a>G.修改–动态字段</h4><h5 id="①引入-1"><a href="#①引入-1" class="headerlink" title="①引入"></a>①引入</h5><p>​有时候用户并不需要修改所有的数据，只需要修改某一部分的数据，因此我们就需要用到动态SQL。</p><h5 id="②实现"><a href="#②实现" class="headerlink" title="②实现"></a>②实现</h5><ol><li>编写接口方法：Mapper接口<ul><li>方法的参数：部分数据，将数据封装到对象中</li><li>方法的返回值：void 或 int (返回受影响的行数)</li></ul></li><li>编写SQL语句：SQL映射文件</li></ol><h5 id="③例子"><a href="#③例子" class="headerlink" title="③例子"></a>③例子</h5><p>​<img src="/../imgs/image-20221006153319643-1682258537178.png" alt="image-20221006153319643"></p><p>​<set>标签的作用：</p><ol><li>去除SQL语句后面多余的 “ , ” ，使SQL语句语法正确。</li><li>当set后面没有对应的修改语句时，会自动将set关键字删除。</li></ol><h4 id="H-删除–一个数据"><a href="#H-删除–一个数据" class="headerlink" title="H.删除–一个数据"></a>H.删除–一个数据</h4><h5 id="①实现-1"><a href="#①实现-1" class="headerlink" title="①实现"></a>①实现</h5><ol><li>编写接口方法：Mapper接口<ul><li>方法的参数：id</li><li>方法的返回值类型：void</li></ul></li><li>编写SQL语句：SQL映射文件</li></ol><h5 id="②例子-1"><a href="#②例子-1" class="headerlink" title="②例子"></a>②例子</h5><p><img src="/../imgs/image-20221006155821062-1682258537179.png" alt="image-20221006155821062"></p><h4 id="I-删除–批量删除"><a href="#I-删除–批量删除" class="headerlink" title="I.删除–批量删除"></a>I.删除–批量删除</h4><h5 id="①实现-2"><a href="#①实现-2" class="headerlink" title="①实现"></a>①实现</h5><ol><li><p>编写接口方法：Mapper接口</p><ul><li>方法的参数：id数组（批量删除的数量较多，可以将其存储到一个数组中）</li><li>方法的返回值类型：void</li></ul></li><li><p>编写SQL语句：SQL映射文件</p><p> 形式一：</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteByIds&quot;</span>&gt;</span></span><br><span class="line">delete from tb_brand</span><br><span class="line">where id in</span><br><span class="line"><span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;数组名&quot;</span> <span class="attr">item</span>=<span class="string">&quot;id&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure><p> ​如果使用上面的这种形式，则Mapper接口中的方法需写成：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">deleteByIds</span><span class="params">(<span class="meta">@Param(&quot;数组名&quot;)</span> <span class="type">int</span>[] 数组名)</span>;</span><br></pre></td></tr></table></figure><p> 形式二：</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteByIds&quot;</span>&gt;</span></span><br><span class="line">delete from tb_brand</span><br><span class="line">where id in</span><br><span class="line"><span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;array&quot;</span> <span class="attr">item</span>=<span class="string">&quot;id&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--mybatis会将数组参数，封装为一个Map集合。该Map集合的名字为：arry。 --&gt;</span></span><br></pre></td></tr></table></figure><p> ​如果使用上面的这种形式，则Mapper接口中的方法需写成：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">deleteByIds</span><span class="params">(<span class="type">int</span>[] 数组名)</span>;</span><br></pre></td></tr></table></figure></li></ol><h5 id="②SQL映射文件解释"><a href="#②SQL映射文件解释" class="headerlink" title="②SQL映射文件解释"></a>②SQL映射文件解释</h5><p>​引入：如果要删除多个数据，我们可以这样写：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteByIds&quot;</span>&gt;</span></span><br><span class="line">delete from tb_brand</span><br><span class="line">where id in (?,?,?)</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​但这样写会存在一个问题：一个占位符? 代表一个参数，因此该SQL语句只能删除三条记录，也就是说其删除数据的数量是固定的。如何实现删除任意数量的数据呢？使用<foreach>标签</p><ul><li><foreach>标签： 该标签用于遍历数组的。标签里面有一些属性，如：<ul><li>collection：要遍历的数组名字 或 集合名字</li><li>item：表示集合中每一个元素进行迭代时的别名。</li><li>separator：表示在每次进行迭代之间以什么符号作为分隔符。</li><li>open：表示该语句以什么开始。open&#x3D;”(“，其效果相当于上面第三行代码中 in 后面的 “ ( “</li><li>close：表示该语句以什么结束。close&#x3D;”)”，其效果相当于上面第三行代码中 最后一个问号后面的 “ ) ”。</li></ul></li></ul><h3 id="⑦参数传递"><a href="#⑦参数传递" class="headerlink" title="⑦参数传递"></a>⑦参数传递</h3><p>​MyBatis 接口方法中可以接收各种各样的参数，MyBatis底层对于这些参数进行不同的封装处理方式。</p><h4 id="A-多个参数"><a href="#A-多个参数" class="headerlink" title="A.多个参数"></a>A.多个参数</h4><p>​当接收多个参数时：</p><p>​MyBatis会将参数封装为Map集合，其中value值为参数的值，一个参数将对应两个键名：arg 和 param。即：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">map.put(&quot;arg0&quot;,参数值1)</span><br><span class="line">map.put(&quot;param1&quot;,参数值1)</span><br><span class="line">map.put(&quot;arg0&quot;,参数值2)</span><br><span class="line">map.put(&quot;param1&quot;,参数值2)</span><br></pre></td></tr></table></figure><p>​因此我们可以在SQL语句中通过arg 或 param来获取参数的值，但这种方式不利于阅读，所以我们使用@Param注解来解决这个问题。@Param(“username”)，username将会替换掉Map集合中默认的arg键名。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map.put(&quot;username&quot;,参数值1)</span><br><span class="line">map.put(&quot;param1&quot;,参数值1)</span><br></pre></td></tr></table></figure><p>​因此我们在SQL语句中，可以通过username来获取参数值1。</p><h4 id="B-单个参数"><a href="#B-单个参数" class="headerlink" title="B.单个参数"></a>B.单个参数</h4><ul><li><p><strong>POJO类</strong>：直接使用，属性名 和 参数占位符名称 一致。</p><ul><li><p>POJO类：如有表 user ，与其对应的类 User 就被称为POJO类。</p></li><li><p>例子：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">select</span><span class="params">(User user)</span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>Map集合</strong>：直接使用，但键名 和 参数占位符名称 要一致，不然会出错</p><ul><li><p>例子：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">select</span><span class="params">(Map map)</span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>Collection</strong>：封装为Map集合，推荐使用@Param注解，替换Map集合中默认的arg键名。</p><ul><li>Collection封装为Map后，Collection集合作为value，其对应的键名有两个：arg0、collection，即在SQL语句中写arg0 或 collection 都可以获取到参数的值。</li></ul></li><li><p><strong>List</strong>：封装为Map集合，推荐使用@Param注解，替换Map集合中默认的arg键名。</p><ul><li>List封装为Map后，List集合作为value，其对应的键名有三个：arg0、collection、list，即在SQL语句中写arg0 或 collection  或 list 都可以获取到参数的值。</li></ul></li><li><p><strong>数组</strong>：封装为Map集合，推荐使用@Param注解，替换Map集合中默认的arg键名。</p><ul><li>数组封装为Map后，数组作为value，其对应的键名有两个：arg0、array，即在SQL语句中写arg0 或 array 都可以获取到参数的值。</li></ul></li><li><p><strong>其它类型</strong>：直接使用。</p></li></ul><h4 id="C-练习"><a href="#C-练习" class="headerlink" title="C.练习"></a>C.练习</h4><p>​<img src="/../imgs/image-20221006210550955-1682258537179.png" alt="image-20221006210550955"></p><p>​红色问号的地方应该写：user.username 、user.password。</p><p>​因为通过user就能获取到user对象，再通过对象调属性的方式就能得到对象相应的属性值。</p><h3 id="⑧注解开发"><a href="#⑧注解开发" class="headerlink" title="⑧注解开发"></a>⑧注解开发</h3><h4 id="A-什么是注解开发"><a href="#A-什么是注解开发" class="headerlink" title="A.什么是注解开发"></a>A.什么是注解开发</h4><p>​即将SQL语句写在注解中，然后注解写在Mapper接口的相应方法上面。</p><p><img src="/../imgs/image-20221006220820851-1682258537179.png" alt="image-20221006220820851"></p><p>​除了SQL语句编写的位置不一样外，其它的相关操作（如：SQL语句的执行）都与之前一样。</p><h4 id="B-四种注解"><a href="#B-四种注解" class="headerlink" title="B.四种注解"></a>B.四种注解</h4><ul><li>查询：@Select</li><li>添加：@Insert</li><li>修改：@Update</li><li>删除：@Delete</li></ul><h4 id="C-使用场景"><a href="#C-使用场景" class="headerlink" title="C.使用场景"></a>C.使用场景</h4><p>​当要完成简单的功能时，我们就可以使用注解开发。</p><p>​当要完成复杂的功能时，我们还是用配置文件来写SQL。</p>]]></content>
      
      
      <categories>
          
          <category> Java Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javaweb概述</title>
      <link href="/2023/04/23/javaweb%E6%A6%82%E8%BF%B0/"/>
      <url>/2023/04/23/javaweb%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="一、JavaWeb介绍"><a href="#一、JavaWeb介绍" class="headerlink" title="一、JavaWeb介绍"></a>一、JavaWeb介绍</h3><ol><li><p>web：能够通过浏览器访问的网站。</p></li><li><p>JavaWeb：用Java来开发网站</p></li><li><p>Web互联网系统的三大组成部分：</p><p> <img src="/../imgs/image-20220913105430987-1682257740401.png" alt="image-20220913105430987"></p></li><li><p>学习内容</p><p> <img src="/../imgs/image-20220913110518745-1682257740402.png" alt="image-20220913110518745"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaWeb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库</title>
      <link href="/2023/04/20/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2023/04/20/%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h2 id="基础部分"><a href="#基础部分" class="headerlink" title="基础部分"></a>基础部分</h2><h3 id="一、数据库概述"><a href="#一、数据库概述" class="headerlink" title="一、数据库概述"></a>一、数据库概述</h3><h4 id="1、相关概念"><a href="#1、相关概念" class="headerlink" title="1、相关概念"></a>1、相关概念</h4><ul><li>数据库：存储数据的仓库。简称：DB。</li><li>数据库管理系统：管理数据库的软件，即：可以对数据库中的数据进行增删改查、添加数据库等操作的软件。简称：DBMS。</li><li>SQL：操作和管理关系型数据库的编程语言。</li><li>关系型数据库(RDBMS)：用表进行数据存储的数据库就叫关系型数据库，该表称为二维表。</li></ul><h4 id="2、MySQL数据库安装"><a href="#2、MySQL数据库安装" class="headerlink" title="2、MySQL数据库安装"></a>2、MySQL数据库安装</h4><h5 id="A-下载"><a href="#A-下载" class="headerlink" title="A.下载"></a>A.下载</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://downloads.mysql.com/archives/community/</span><br></pre></td></tr></table></figure><p>​选择需要的版本和电脑位数进行下载，不要下载带debug<img src="/imgs/image-20220913153802678.png" alt="image-20220913153802678"></p><h5 id="B-安装"><a href="#B-安装" class="headerlink" title="B.安装"></a>B.安装</h5><ol><li>对下载好的安装包进行解压</li></ol><h5 id="C-配置"><a href="#C-配置" class="headerlink" title="C.配置"></a>C.配置</h5><h6 id="①配置环境变量"><a href="#①配置环境变量" class="headerlink" title="①配置环境变量"></a>①配置环境变量</h6><p>​a.复制当前MySQL的安装目录。</p><img src="/imgs/image-20230423204928910.png" alt="image-20230423204928910" style="zoom:80%;" /><p>​b.新建一个环境变量</p><p><img src="/imgs/image-20220913155201538.png" alt="image-20220913155201538"></p><img src="/imgs/image-20230423205118768.png" alt="image-20230423205118768" style="zoom: 67%;" /><p>​c.对系统变量中的Path进行编辑</p><p><img src="/imgs/image-20230423205144683.png" alt="image-20230423205144683"></p><h6 id="②配置配置文件信息"><a href="#②配置配置文件信息" class="headerlink" title="②配置配置文件信息"></a>②配置配置文件信息</h6><p>​a.在MySQL的安装目录下新建一个my.ini文件，文件内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[mysql]</span><br><span class="line">default-character-set=utf8</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">character-set-server=utf8</span><br><span class="line">default-storage-engine=INNODB</span><br><span class="line">sql_mode=STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION</span><br></pre></td></tr></table></figure><img src="/imgs/image-20230423205206465.png" alt="image-20230423205206465" style="zoom:67%;" /><p>​b.初始化MySQL</p><p>​在c盘下打开该文件：</p><p><img src="/imgs/image-20220913161859039.png" alt="image-20220913161859039"></p><p>​在该文件下输入：cmd，然后以管理员身份运行</p><p><img src="/imgs/image-20220913162003905.png" alt="image-20220913162003905"></p><p>​将下面的命令复制到cmd中并运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqld --initialize-insecure</span><br></pre></td></tr></table></figure><p>​c.注册MySQL服务</p><p>​复制下面命令，到刚才的cmd中，并运行，接着输入：net start mysql回车，启动MySQL。至此MySQL已经按照完成。</p><p><img src="/imgs/image-20220913163328013.png" alt="image-20220913163328013"></p><h5 id="D-修改MySQL默认的用户名和密码"><a href="#D-修改MySQL默认的用户名和密码" class="headerlink" title="D.修改MySQL默认的用户名和密码"></a>D.修改MySQL默认的用户名和密码</h5><p>​在刚才的cmd中，输入下面命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysqladmin -u root password 1234</span><br><span class="line">//其中root为用户名，1234为用户密码</span><br></pre></td></tr></table></figure><p>如果不懂可以看下面的网站：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://blog.csdn.net/weixin_43214644/article/details/126678750?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%E9%BB%91%E9%A9%ACMySQL%E9%85%8D%E7%BD%AE&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-5-126678750.142^v47^new_blog_pos_by_title,201^v3^add_ask&amp;spm=1018.2226.3001.4187</span><br></pre></td></tr></table></figure><h5 id="E-启动与停止"><a href="#E-启动与停止" class="headerlink" title="E.启动与停止"></a>E.启动与停止</h5><p>​在运行处输入：services.msc — &gt; 找到MySQL —&gt; 右键启动\停止</p><p><img src="/imgs/image-20220916104719913.png" alt="image-20220916104719913"></p><hr><h4 id="3、MySQL数据模型"><a href="#3、MySQL数据模型" class="headerlink" title="3、MySQL数据模型"></a>3、MySQL数据模型</h4><p>​<img src="/imgs/image-20220913172745180.png" alt="image-20220913172745180"></p><p>​在数据库管理系统中，我们可以创建多个数据库（就相当于在硬盘中创建多个文件夹），在数据库里我们可以创建多个数据表（就相当于在硬盘中的那个数据库文件夹下创建多个文件），表中又可以有多条数据（在硬盘中数据也相当于文件）。</p><h4 id="4、Navicat使用"><a href="#4、Navicat使用" class="headerlink" title="4、Navicat使用"></a>4、Navicat使用</h4><p>​Navicat是一款操作MySQL的图形化界面软件。</p><h5 id="A-使用"><a href="#A-使用" class="headerlink" title="A.使用"></a>A.使用</h5><p>​打开navicat点击左上角的连接，将navicat连接到电脑的MySQL。</p><p><img src="/imgs/image-20220914133237052.png" alt="image-20220914133237052"></p><h6 id="①新建数据库"><a href="#①新建数据库" class="headerlink" title="①新建数据库"></a>①新建数据库</h6><p>​<img src="/imgs/image-20220914140226747.png" alt="image-20220914140226747"></p><p>​对上面的图标右击，新建数据库，字符集选UTF-8。</p><h6 id="②修改表的数据"><a href="#②修改表的数据" class="headerlink" title="②修改表的数据"></a>②修改表的数据</h6><p>​选中要修改的表 –&gt; 右键 –&gt; 设计表 –&gt; 直接对要修改的内容进行修改即可</p><h6 id="③编写SQL语句"><a href="#③编写SQL语句" class="headerlink" title="③编写SQL语句"></a>③编写SQL语句</h6><p>​点击顶部中查询图标 –&gt; 新建查询 –&gt; 编写SQL语句 –&gt; 编写完，选中你要执行的语句，右键运行即可</p><h4 id="5、MySQL命名规范"><a href="#5、MySQL命名规范" class="headerlink" title="5、MySQL命名规范"></a>5、MySQL命名规范</h4><ol><li><p>只能使用这些命名：必须只能包含 A–Z, a–z, 0–9, _ 。</p></li><li><p>同一个MySQL软件中，数据库不能同名；同一个库中，表不能重名；同一个表中，字段不能重名</p></li><li><p>必须保证你的字段没有和保留字、数据库系统或常用方法冲突。如果坚持使用，请在SQL语句中使用&#96;（着重号）引起来。如：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#其中order使用``飘号，因为order和系统关键字或系统函数名等预定义标识符重名了</span><br><span class="line">CREATE TABLE `order`();</span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="二、SQL"><a href="#二、SQL" class="headerlink" title="二、SQL"></a>二、SQL</h3><p>​SQL是一门操作关系型数据库的编程语言。</p><h4 id="1、SQL通用语法"><a href="#1、SQL通用语法" class="headerlink" title="1、SQL通用语法"></a>1、SQL通用语法</h4><ul><li><p>SQL语句可以单行或多行书写，以分号结尾。</p></li><li><p>MySQL数据库的SQL语句不区分大小写，但建议关键字采用大写形式。</p></li><li><p>注释：</p><ul><li><p>单行注释：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 方式一:注意注释内容前的空格不要省略 */</span></span><br><span class="line"><span class="comment">-- 注释内容</span></span><br><span class="line"><span class="comment">/* 方式二：该方式是MySQL特有的方式*/</span></span><br><span class="line">#注释内容</span><br></pre></td></tr></table></figure></li><li><p>多行注释：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">注释内容</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="2、SQL分类"><a href="#2、SQL分类" class="headerlink" title="2、SQL分类"></a>2、SQL分类</h4><ul><li>DDL：定义数据库，表等</li><li>DML：对表中的数据进行增删改</li><li>DQL：对表中的数据进行查询</li><li>DCL：创建数据库用户、控制数据库的访问权限</li></ul><h4 id="3、DDL"><a href="#3、DDL" class="headerlink" title="3、DDL"></a>3、DDL</h4><h5 id="A-操作数据库"><a href="#A-操作数据库" class="headerlink" title="A.操作数据库"></a>A.操作数据库</h5><h6 id="①查询"><a href="#①查询" class="headerlink" title="①查询"></a>①查询</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW DATABASES;</span><br></pre></td></tr></table></figure><p>​查询当前数据库管理系统下有多少个数据库。MySQL自带四个数据库，分别为：</p><ul><li>information_schema（存储MySQL中的表和库信息，该数据库使用视图进行数据存储，而视图属于逻辑，所以在磁盘中没有对应的文件夹）</li><li>mysql（存储管理权限的数据库）</li><li>performance_schema（有关性能的数据库）</li><li>sys（与系统有关的数据库）</li></ul><h6 id="②创建数据库"><a href="#②创建数据库" class="headerlink" title="②创建数据库"></a>②创建数据库</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE [IF NOT EXISTS] 数据库名 [DEFAULT CHARSET 字符集] [COLLATE 排序规则];</span><br></pre></td></tr></table></figure><p>​说明：</p><ul><li>方括号为可选项</li><li>如果写了“IF NOT EXISTS”，则先判断要创建的数据库是否存在，不存在再执行创建操作。</li><li>DEFAULT CHARSET ：指定该数据库使用什么字符集（推荐使用utf8mb4），不写则使用默认的字符集</li><li>COLLATE：用于规定字符串的排序规则。<ul><li>MySQL8.0以下版本，默认的CHARSET是Latin1，默认的COLLATE是latin1_swedish_ci。</li><li>从mysql8.0开始，默认的CHARSET已经改为了utf8mb4，默认的COLLATE改为了utf8mb4_0900_ai_ci。</li></ul></li></ul><h6 id="③删除数据库"><a href="#③删除数据库" class="headerlink" title="③删除数据库"></a>③删除数据库</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP DATABASE [IF EXISTS] 数据库名;</span><br></pre></td></tr></table></figure><p>​说明：</p><ul><li>方括号为可选项</li><li>如果写了“IF EXISTS”，先判断要删除的数据库存不存在，存在再执行删除操作。</li></ul><h6 id="④使用数据库"><a href="#④使用数据库" class="headerlink" title="④使用数据库"></a>④使用数据库</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#要想对数据库里的数据进行操作，我们得先进入数据库里，使用如下命令：</span><br><span class="line">USE 数据库名;</span><br><span class="line"></span><br><span class="line">#查看当前使用的是哪个数据库</span><br><span class="line">SELECT DATABASE();</span><br></pre></td></tr></table></figure><h5 id="B-操作表"><a href="#B-操作表" class="headerlink" title="B.操作表"></a>B.操作表</h5><h6 id="①查询表"><a href="#①查询表" class="headerlink" title="①查询表"></a>①查询表</h6><p>​查询当前数据库下所有表名称：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW TABLES;</span><br></pre></td></tr></table></figure><p>​查询表的结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DESC 表名称;</span><br></pre></td></tr></table></figure><p>​查询指定表的建表语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW CREATE TABLE 表名;</span><br></pre></td></tr></table></figure><p>​注意：要想执行上述操作，得先进入相应的数据库中。</p><h6 id="②创建表"><a href="#②创建表" class="headerlink" title="②创建表"></a>②创建表</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名 (</span><br><span class="line">字段1 数据类型1 [COMMENT 字段1注释],</span><br><span class="line">字段2 数据类型2 [COMMENT 字段2注释],</span><br><span class="line">....</span><br><span class="line">字段n 数据类型n [COMMENT 字段n注释]</span><br><span class="line">)[COMMENT 表注释];</span><br><span class="line">-- 这里的注释要用单引号括起来。</span><br><span class="line">/* 字段就相当于表中的列 */</span><br></pre></td></tr></table></figure><p>​注意：最后一行末尾，不能加逗号。</p><h6 id="③删除表"><a href="#③删除表" class="headerlink" title="③删除表"></a>③删除表</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE [IF EXISTS] 表名;</span><br></pre></td></tr></table></figure><ul><li>括号内容为可选项。</li><li>如果选了IF EXISTS ，则先判断要删除的表是否存在，存在才进行删除操作。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TRUNCATE TABLE 表名;</span><br></pre></td></tr></table></figure><ul><li>删除指定表，并重新创建该表，原表中的结构保留了下来。</li><li>不建议使用。</li></ul><h6 id="④修改表"><a href="#④修改表" class="headerlink" title="④修改表"></a>④修改表</h6><p> a.向表中添加字段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 ADD 字段名 类型(长度) [COMMENT 注释] [约束];</span><br></pre></td></tr></table></figure><p>b.修改字段的数据类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 MODIFY 字段名 新数据类型(长度);</span><br></pre></td></tr></table></figure><p>c.修改字段名和字段类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 CHANGE 旧字段名 新字段名 数据类型(长度) [COMMENT 注释] [约束];</span><br></pre></td></tr></table></figure><p>d.修改字段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 DROP 字段名;</span><br></pre></td></tr></table></figure><p>e.修改表名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 RENAME TO 新表名;</span><br></pre></td></tr></table></figure><h4 id="4、DML"><a href="#4、DML" class="headerlink" title="4、DML"></a>4、DML</h4><p>​对表中的数据进行操作。</p><h5 id="A-添加数据"><a href="#A-添加数据" class="headerlink" title="A.添加数据"></a>A.添加数据</h5><p><img src="/imgs/image-20220914144613242.png" alt="image-20220914144613242"></p><p>​注意：</p><ul><li>插入数据时，字符串和日期型数据应该包含在引号当中。</li></ul><h5 id="B-修改数据"><a href="#B-修改数据" class="headerlink" title="B.修改数据"></a>B.修改数据</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE 表名 SET 列1 = 值1,列2 = 值2,... [WHERE 条件];</span><br></pre></td></tr></table></figure><p>​说明：</p><ul><li>修改语句中的条件语句为可选项，如果不加条件，则将所有数据都修改；添加，则修改符合条件的数据。</li></ul><h5 id="C-删除数据"><a href="#C-删除数据" class="headerlink" title="C.删除数据"></a>C.删除数据</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM 表名 [WHERE 条件];</span><br></pre></td></tr></table></figure><p>​说明：</p><ul><li>条件语句是可选项。如果不加条件语句，则将所有数据都删除。如果添加条件语句，则删除符合条件的数据。</li><li>删除的是一整行数据。</li><li>DELETE语句不能删除某一个字段的值(可以使用UPDATE)</li></ul><h4 id="5、DQL"><a href="#5、DQL" class="headerlink" title="5、DQL"></a>5、DQL</h4><p>​对表中的数据进行查询操作。</p><p>​查询语法：（编写时各关键字的顺序不能调换）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">字段列表</span><br><span class="line">FROM</span><br><span class="line">表名列表</span><br><span class="line">WHERE</span><br><span class="line">条件列表</span><br><span class="line">GROUP BY</span><br><span class="line">分组字段</span><br><span class="line">HAVING</span><br><span class="line">分组后条件</span><br><span class="line">ORDER BY</span><br><span class="line">排序字段</span><br><span class="line">LIMIT</span><br><span class="line">分页限定</span><br></pre></td></tr></table></figure><h5 id="A-基础查询"><a href="#A-基础查询" class="headerlink" title="A.基础查询"></a>A.基础查询</h5><h6 id="①查询多个字段"><a href="#①查询多个字段" class="headerlink" title="①查询多个字段"></a>①查询多个字段</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段1,字段2,字段3... FROM 表名;</span><br><span class="line">#如果想查询所有字段，则：</span><br><span class="line">SELECT * FROM 表名; -- 不建议使用，因为有些公司不给用</span><br></pre></td></tr></table></figure><h6 id="②去除重复记录"><a href="#②去除重复记录" class="headerlink" title="②去除重复记录"></a>②去除重复记录</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT 字段列表 FROM 表名;</span><br></pre></td></tr></table></figure><p>​<strong>注意</strong>：DISTINCT 需要放到所有列名的前面，不然会报错。</p><p><img src="/imgs/image-20220914154829174.png" alt="image-20220914154829174"></p><h6 id="③给字段起别名"><a href="#③给字段起别名" class="headerlink" title="③给字段起别名"></a>③给字段起别名</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段1 AS 别名1,字段2 AS 别名2,字段3... FROM 表名;</span><br><span class="line"># AS可以省略，但省略后原始字段名与别名之间得至少有一个空格的间距</span><br><span class="line"># 别名要用单引号包起来</span><br></pre></td></tr></table></figure><h5 id="B-条件查询-WHERE"><a href="#B-条件查询-WHERE" class="headerlink" title="B.条件查询(WHERE)"></a>B.条件查询(WHERE)</h5><h6 id="①格式"><a href="#①格式" class="headerlink" title="①格式"></a>①格式</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表名 WHERE 条件列表;</span><br></pre></td></tr></table></figure><h6 id="②SQL中的条件"><a href="#②SQL中的条件" class="headerlink" title="②SQL中的条件"></a>②SQL中的条件</h6><p><img src="/imgs/image-20220914163900598.png" alt="image-20220914163900598"></p><p>​<strong>说明</strong>：</p><ul><li>日期也可以比较大小，即可以使用：&gt;、&lt;、&gt;&#x3D;、between and等</li><li>null值的比较不能使用 &#x3D; 或  !&#x3D; 。需要使用 is 或 is not 进行比较。</li></ul><h6 id="③应用例子"><a href="#③应用例子" class="headerlink" title="③应用例子"></a>③应用例子</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#查询年龄大于等于20并且小于等于30的学生信息</span><br><span class="line">SELECT * FROM student WHERE age &gt;= 20 AND age &lt;= 30;-- 方式一：</span><br><span class="line">SELECT * FROM student WHERE age BETWEEN 20 AND 30;-- 方式二，包含20、30</span><br><span class="line"></span><br><span class="line">#查询入学日期在&#x27;1998-09-01&#x27; 到 &#x27;1999-09-01&#x27;之间的学生信息</span><br><span class="line">SELECT * FROM student WHERE hire_date BETWEEN &#x27;1998-09-01&#x27; AND &#x27;1999-09-01&#x27;;</span><br><span class="line">SELECT * FROM student WHERE hire_date &gt;= &#x27;1998-09-01&#x27; AND hire_date &lt;= &#x27;1999-09-01&#x27;;</span><br><span class="line"></span><br><span class="line">#查询年龄等于18岁或者年龄等于20岁或者年龄等于22岁的学生信息</span><br><span class="line">SELECT * FROM student WHERE age =18 OR age = 20 OR age = 22;</span><br><span class="line">SELECT * FROM student WHERE age IN (18,20,22);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/imgs/image-20220914171639743.png" alt="image-20220914171639743"></p><h5 id="C-排序查询-ORDER-BY"><a href="#C-排序查询-ORDER-BY" class="headerlink" title="C.排序查询(ORDER BY)"></a>C.排序查询(ORDER BY)</h5><h6 id="①格式-1"><a href="#①格式-1" class="headerlink" title="①格式"></a>①格式</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表名 ORDER BY 排序字段名1 [排序方式1],排序字段名2 [排序方式2] …;</span><br></pre></td></tr></table></figure><p>​按照给定的字段进行排序。排序方式有两种：ASC(升序)、DESC(降序)。当没有显示指明用哪种排序方式时，默认采用ASC。</p><h6 id="②说明"><a href="#②说明" class="headerlink" title="②说明"></a>②说明</h6><p>​如果有多个排序条件，当前边的条件值一样时，才会根据第二条件进行排序。</p><h5 id="D-分组查询-GROUP-BY"><a href="#D-分组查询-GROUP-BY" class="headerlink" title="D.分组查询(GROUP BY)"></a>D.分组查询(GROUP BY)</h5><h6 id="①聚合函数"><a href="#①聚合函数" class="headerlink" title="①聚合函数"></a>①聚合函数</h6><p>​<strong>概念</strong>：将一列数据作为一个整体，进行纵向计算</p><p>​<strong>格式</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 聚合函数名(列名) FROM 表;</span><br></pre></td></tr></table></figure><p>​<strong>聚合函数分类</strong>：</p><p><img src="/imgs/image-20220914180110753.png" alt="image-20220914180110753"></p><p>​<strong>注意</strong>：<strong>null 值不参与所有聚合函数运算</strong></p><p>​<strong>说明</strong>：</p><ol><li><p>COUNT()：括号里只能放<strong>主键</strong> 或 ***** ，不然统计出来的数据不准确。</p><p> COUNT(*)的含义：计算该表中有多少行数据。</p></li></ol><h6 id="②分组查询"><a href="#②分组查询" class="headerlink" title="②分组查询"></a>②分组查询</h6><p>​<strong>概念</strong>：根据某个字段A进行分组，字段值相同的将被分到一起。</p><p>​<strong>格式</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表名 [WHERE 分组前条件限定] GROUP BY 分组字段名 [HAVING 分组后条件过滤];</span><br><span class="line">/*</span><br><span class="line">HVAING 里只能使用：</span><br><span class="line">常数、聚合函数、GROUP BY指定的列名</span><br><span class="line">如果使用其它东西会报错</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>​<strong>注意</strong>：分组后，查询的字段为聚合函数和分组字段，查询其他字段无任何意义。</p><p>​<strong>WHERE 和 HAVING区别</strong>：</p><ul><li>执行时机不一样：WHERE是分组之前进行限定，不满足WHERE条件，则不参与分组，而HAVING是分组之后对结果进行过滤。</li><li>判断的条件不一样：WHERE里不能写聚合函数，HAVING可以。<ul><li>因为执行顺序为：WHERE &gt; 聚合函数 &gt; HAVING</li></ul></li></ul><h5 id="E-分页查询-LIMIT"><a href="#E-分页查询-LIMIT" class="headerlink" title="E.分页查询(LIMIT)"></a>E.分页查询(LIMIT)</h5><h6 id="①语法"><a href="#①语法" class="headerlink" title="①语法"></a>①语法</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表名 LIMIT  起始索引 , 查询条目数;</span><br></pre></td></tr></table></figure><h6 id="②说明-1"><a href="#②说明-1" class="headerlink" title="②说明"></a>②说明</h6><ul><li>起始索引：从0开始，表中第一条数据的索引为0。</li><li>起始索引 &#x3D; （当前页码数 - 1）* 每页显示的条数。</li><li>如果查询的是第一页数据，起始索引可以省略。</li><li>如果查询条目数大于实际表中的条目数，是不会报错的。</li><li>limit是MySQL特有的关键字。<ul><li>Oracle分页查询使用rownumber。</li><li>SQLServer分页查询使用top。</li></ul></li></ul><h5 id="F-DQL语句执行顺序"><a href="#F-DQL语句执行顺序" class="headerlink" title="F.DQL语句执行顺序"></a>F.DQL语句执行顺序</h5><img src="C:\Users\橙子\AppData\Roaming\Typora\typora-user-images\image-20220916215902346.png" alt="image-20220916215902346" style="zoom: 67%;" /><h4 id="6、DCL"><a href="#6、DCL" class="headerlink" title="6、DCL"></a>6、DCL</h4><h5 id="①概念"><a href="#①概念" class="headerlink" title="①概念"></a>①概念</h5><ol><li><p>DCL是用来管理用户和数据库访问权限的SQL语句。即：用来规定哪些用户可以访问数据库服务器了，用户可以访问哪个数据库。</p></li><li><p>MySQL中我们用 “用户名” 和 主机地址 来唯一标识一个用户。主机地址规定了当前用户只能通过哪个地址来访问当前服务器。如：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Host: localhost ;user： root</span><br><span class="line">//代表root用户只能通过localhost这个主机地址来访问当前数据库服务器。</span><br></pre></td></tr></table></figure></li></ol><h5 id="②DCL–管理用户"><a href="#②DCL–管理用户" class="headerlink" title="②DCL–管理用户"></a>②DCL–管理用户</h5><p>作用：规定哪些用户可以登录当前数据库管理系统。</p><h6 id="a-查询用户"><a href="#a-查询用户" class="headerlink" title="a.查询用户"></a>a.查询用户</h6><p>​查看当前数据库管理系统有哪些用户及其用户信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">USE mysql;</span><br><span class="line">SELECT * FROM user;</span><br></pre></td></tr></table></figure><h6 id="b-创建用户"><a href="#b-创建用户" class="headerlink" title="b.创建用户"></a>b.创建用户</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER &#x27;用户名&#x27;@&#x27;主机名&#x27; IDENTIFIED BY &#x27;用户密码&#x27;;</span><br><span class="line">-- 如果想让用户在任意主机上访问到当前数据库，主机名里写 % 即可。</span><br></pre></td></tr></table></figure><p>​注意：用户创建完后可以访问数据库管理系统，但只能访问information_schema这个数据库。</p><h6 id="c-修改用户密码"><a href="#c-修改用户密码" class="headerlink" title="c.修改用户密码"></a>c.修改用户密码</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER USER &#x27;用户名&#x27;@&#x27;主机名&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;新密码&#x27;;</span><br></pre></td></tr></table></figure><h6 id="d-删除用户"><a href="#d-删除用户" class="headerlink" title="d.删除用户"></a>d.删除用户</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP USER &#x27;用户名&#x27;@&#x27;主机名&#x27;;</span><br></pre></td></tr></table></figure><h5 id="③DCL–权限控制"><a href="#③DCL–权限控制" class="headerlink" title="③DCL–权限控制"></a>③DCL–权限控制</h5><p>​作用：在用户登录数据库管理系统后，他们对数据库中的表有哪些操作权限。</p><p>​MySQL中常见的权限：</p><p><img src="/imgs/image-20220917122022874.png" alt="image-20220917122022874"></p><p><strong>USAGE</strong>：连接（登录）权限，建立一个用户，就会自动授予其usage权限。该权限只能用于数据库登录，不能执行任何操作，且该权限不能被回收，即使使用REVOKE也不能删除用户权限。</p><h6 id="a-查询用户拥有的权限"><a href="#a-查询用户拥有的权限" class="headerlink" title="a.查询用户拥有的权限"></a>a.查询用户拥有的权限</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SHOW GRANTS FOR &#x27;用户名&#x27;@&#x27;主机&#x27;;</span><br><span class="line">/*</span><br><span class="line">如果查询的结果为：GRANT USAGE ON *.* TO &#x27;用户名&#x27;@&#x27;主机&#x27;</span><br><span class="line">代表该用户只有登录数据库管理系统的权限。</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h6 id="b-授予权限"><a href="#b-授予权限" class="headerlink" title="b.授予权限"></a>b.授予权限</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GRANT 权限列表 ON 数据库名.表名 TO &#x27;用户名&#x27;@&#x27;主机名&#x27;;</span><br></pre></td></tr></table></figure><h6 id="c-撤销权限"><a href="#c-撤销权限" class="headerlink" title="c.撤销权限"></a>c.撤销权限</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REVOKE 权限列表 ON 数据库名.表名 FROM &#x27;用户名&#x27;@&#x27;主机名&#x27;;</span><br></pre></td></tr></table></figure><h6 id="d-补充"><a href="#d-补充" class="headerlink" title="d.补充"></a>d.补充</h6><ol><li><p>多个权限之间，使用逗号分隔。</p></li><li><p>授权时，数据库名和表名可以使用 * 进行通配，* 的含义是：所有。如：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GRANT 权限列表 ON *.* TO &#x27;用户名&#x27;@&#x27;主机名&#x27;;-- 所有数据库下的所有表</span><br><span class="line">GRANT 权限列表 ON 数据库名.* TO &#x27;用户名&#x27;@&#x27;主机名&#x27;;-- 某个数据库下的所有表</span><br></pre></td></tr></table></figure></li></ol><h4 id="7、数据库中的数据类型"><a href="#7、数据库中的数据类型" class="headerlink" title="7、数据库中的数据类型"></a>7、数据库中的数据类型</h4><h5 id="A-数值类型"><a href="#A-数值类型" class="headerlink" title="A.数值类型"></a>A.数值类型</h5><table><thead><tr><th align="center">在Java中的对应</th><th align="center">数据类型</th><th align="center">大小</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">byte</td><td align="center">TINYINT</td><td align="center">1 byte</td><td align="center">小整数值</td></tr><tr><td align="center">short</td><td align="center">SMALLINT</td><td align="center">2 byte</td><td align="center">大整数值</td></tr><tr><td align="center"></td><td align="center">MEDIUMINT</td><td align="center">3 byte</td><td align="center">大整数值</td></tr><tr><td align="center">int</td><td align="center">INT或INTEGER</td><td align="center">4 byte</td><td align="center">大整数值</td></tr><tr><td align="center">Long</td><td align="center">BIGINT</td><td align="center">8 byte</td><td align="center">极大整数值</td></tr><tr><td align="center">float</td><td align="center">FLOAT(M,D)</td><td align="center">4byte</td><td align="center">单精度浮点数值</td></tr><tr><td align="center">double</td><td align="center">DOUBLE(M,D)</td><td align="center">8 byte</td><td align="center">双精度浮点数值</td></tr><tr><td align="center"></td><td align="center">DECIMAL(M,D)</td><td align="center"></td><td align="center">小数值</td></tr></tbody></table><p>​说明：</p><ul><li><p>DECIMAL是以字符串的形式存储的，以保证存储更高精度的数据</p></li><li><p>DOUBLE、FLOAT、DOUBLE：在使用该类数据类型时，要指明其总长度M和小数点后保留的位数D</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">score DOUBLE(5,2);</span><br><span class="line">/* 数据总长度为5，小数点后保留2位 */</span><br></pre></td></tr></table></figure></li><li><p>补充：数值型数据可以选择有符号和无符号的形式，它们的区别是：表示的数字范围不一样。<img src="/imgs/image-20220916133428507.png" alt="image-20220916133428507"></p><p>  要想使用无符号（不包括负数部分），需要在数据类型后面加上UNSIGNED。</p></li></ul><h5 id="B-日期时间类型"><a href="#B-日期时间类型" class="headerlink" title="B.日期时间类型"></a>B.日期时间类型</h5><table><thead><tr><th align="center">数据类型</th><th align="center">大小</th><th align="center">范围</th><th align="center">格式</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">DATE</td><td align="center">3</td><td align="center">1000-01-01 至 9999-12-31</td><td align="center">YYYY-MM-DD</td><td align="center">年月日</td></tr><tr><td align="center">TIME</td><td align="center">3</td><td align="center">-838：59：59 至 838：59：59</td><td align="center">HH:MM:SS</td><td align="center">时分秒</td></tr><tr><td align="center">YEAR</td><td align="center">1</td><td align="center">1901 至 2155</td><td align="center">YYYY</td><td align="center">年份</td></tr><tr><td align="center">DATETIME</td><td align="center">8</td><td align="center"></td><td align="center">YYYY-MM-DD HH:MM:SS</td><td align="center">年月日时分秒</td></tr><tr><td align="center">TIMESTAMP</td><td align="center">4</td><td align="center">1970-01-01 00:00:00 至 2038-01-19 03:14:07</td><td align="center">YYYY-MM-DD HH:MM:SS</td><td align="center">时间戳</td></tr></tbody></table><p>​说明：</p><ul><li><p>TIMESTAMP：少用，当某个字段声明为这种数据类型时，如果没有赋值，系统就会赋默认的时间值。</p><ul><li><p>给DATE类型数据赋值时，用单引号将数据括起来，年月日之间用“ - ”隔开，如：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;1949-10-1&#x27;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h5 id="C-字符串类型"><a href="#C-字符串类型" class="headerlink" title="C.字符串类型"></a>C.字符串类型</h5><p><img src="/imgs/image-20220914100827037.png" alt="image-20220914100827037"></p><p>​最常用的是CHAR、VARCHAR。赋值时，数据用单引号或双引号括起来。</p><h6 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h6><p>​①使用CHAR、VARCHAR时都得指明其最大的存放长度，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name CHAR(10);/* 最多存放10个汉字或10个字母 */</span><br><span class="line">name VARCHAR(10);/* 最多存放10个汉字或10个字母 */</span><br></pre></td></tr></table></figure><p>​②CHAR与VARCHAR的不同</p><ul><li>CAHR：不会根据实际存放数据的大小来决定最终存放空间大小，如：存放数据“张三”，其分配的空间仍为10个字符。其占用2个字符，剩余空间用空格补齐。</li><li>VARCHAR：会根据实际存放数据的大小来决定最终存放空间大小，存放数据“张三”，其分配的空间为2个字符。</li></ul><p>​③总结：</p><ul><li>CHAR：存储性能高，浪费空间。</li><li>VARCHAR：存储性能低，节约空间。</li><li>如果字符串的大小确定，我们使用CHAR；不确定，则使用VARCHAR。</li></ul><hr><h3 id="三、函数"><a href="#三、函数" class="headerlink" title="三、函数"></a>三、函数</h3><h4 id="①概念-1"><a href="#①概念-1" class="headerlink" title="①概念"></a>①概念</h4><p>​函数：与Java中的函数是一个意思</p><h4 id="②MySQL中常见的内置函数"><a href="#②MySQL中常见的内置函数" class="headerlink" title="②MySQL中常见的内置函数"></a>②MySQL中常见的内置函数</h4><h5 id="A-字符串函数"><a href="#A-字符串函数" class="headerlink" title="A.字符串函数"></a>A.字符串函数</h5><p><img src="/imgs/image-20220917133534020.png" alt="image-20220917133534020"></p><p>​注意</p><ol><li>SUBSTRING函数中的起始位置是从1开始的，不是从0开始。</li><li>LPAD(str,n,pad)：如果str的长度大于len指定的值，则截取str到len指定的长度。</li><li>RPAD(str,n,pad)：同理。</li></ol><h6 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#由于业务需求变更，企业员工的工号，统一为5位，目前不足5位数的全部在前面补0。比如：1号员工的工号应该为：00001。</span><br><span class="line">UPDATE emp SET workno = lpad(workno,5,&#x27;0&#x27;);</span><br></pre></td></tr></table></figure><h5 id="B-数值函数"><a href="#B-数值函数" class="headerlink" title="B.数值函数"></a>B.数值函数</h5><p><img src="/imgs/image-20220917141038649.png" alt="image-20220917141038649"></p><h6 id="①补充"><a href="#①补充" class="headerlink" title="①补充"></a>①补充</h6><ol><li><p>向上取整：只要有小数，其结果就为：去除小数后再加1。</p></li><li><p>向下取整：只要有小数，其结果就为：取整数部分。</p></li></ol><h6 id="②例子"><a href="#②例子" class="headerlink" title="②例子"></a>②例子</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#随机生成一个六位的数</span><br><span class="line">SELECT LPAD(FLOOR(RAND() * 1000000),6,&#x27;0&#x27;);</span><br></pre></td></tr></table></figure><h5 id="C-日期函数"><a href="#C-日期函数" class="headerlink" title="C.日期函数"></a>C.日期函数</h5><p><img src="/imgs/image-20220917144159996.png" alt="image-20220917144159996"></p><h6 id="①说明"><a href="#①说明" class="headerlink" title="①说明"></a>①说明</h6><ol><li><p>DATE_ADD(date,INTERVAL expr type)：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">INTERVAL 是固定写法</span><br><span class="line">expr：添加的值，值为正数，代表日期向前移，负数表示日期向后移；</span><br><span class="line">type：添加值的类型，可以为DAY、MONTH、YEAR、hour、minute、second。</span><br><span class="line">*/</span><br><span class="line">#在当前时间上加上天</span><br><span class="line">SELECT DATE_ADD(NOW(),INTERVAL 7 DAY);</span><br></pre></td></tr></table></figure></li><li><p>datediff(date1,date2)：返回的是这两个日期之间相差的天数，其实现方式是：用date1 - date2。</p></li></ol><h6 id="②补充"><a href="#②补充" class="headerlink" title="②补充"></a>②补充</h6><ul><li><p>DATE_FORMAT(日期,表达式)</p><ul><li><p>用于格式化日期，返回用户想要的日期格式。</p></li><li><p>表达式为：</p>  <img src="/imgs/image-20230423204614405.png" alt="image-20230423204614405" style="zoom:80%;" /></li><li><p>例子：</p><ul><li><img src="/imgs/image-20230423204633980.png" alt="image-20230423204633980" style="zoom:80%;" /></li><li><img src="/imgs/image-20230423204649320.png" alt="image-20230423204649320" style="zoom:80%;" /></li></ul></li></ul></li></ul><h5 id="D-流程函数"><a href="#D-流程函数" class="headerlink" title="D.流程函数"></a>D.流程函数</h5><p><img src="/imgs/image-20220917164820707.png" alt="image-20220917164820707"></p><p>​说明：</p><ol><li><p>IF(value,t,f)：value为条件表达式。类似于三元运算符。</p></li><li><p>IFNULL(value1,value2)：value1为NULL，返回value2，注意：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IFNULL(&#x27;&#x27;,123);-- value1的值不是NULL</span><br></pre></td></tr></table></figure></li><li><p>上表中的第三个函数类似于多重if。</p></li><li><p>上表中的第四个函数类似于switch…case…。</p></li></ol><p>练习：</p><p>​①</p><p><img src="/imgs/image-20220917172207506.png" alt="image-20220917172207506"></p><p>​②根据不同的分数段来输出不同的等级</p><p><img src="/imgs/image-20220917172349007.png" alt="image-20220917172349007"></p><h3 id="四、约束"><a href="#四、约束" class="headerlink" title="四、约束"></a>四、约束</h3><h4 id="①概念-2"><a href="#①概念-2" class="headerlink" title="①概念"></a>①概念</h4><p>​约束是作用在字段上的，用于对字段的值加以限制。</p><h4 id="②约束的分类"><a href="#②约束的分类" class="headerlink" title="②约束的分类"></a>②约束的分类</h4><ul><li>非空约束(限制该字段的数据不能为NULL)</li><li>唯一约束(保证该字段的所有数据都是唯一、不可重复的)</li><li>主键约束(主键是一行数据的唯一标识，要求非空且唯一)</li><li>检查约束（MySQL不支持检查约束，我们需要在Java中进行检查约束）</li><li>默认约束(保存数据时，如果未指定该字段的值，则采用默认值)</li><li>外键约束(用来让两张表的数据之间建立连接)</li></ul><p>​补充说明：</p><ol><li>一个字段可以有多个约束，它们之间<strong>用空格隔开</strong>。</li><li>约束使用在创建表的时候，写在每个字段的数据类型后面。</li></ol><h5 id="A-主键约束"><a href="#A-主键约束" class="headerlink" title="A.主键约束"></a>A.主键约束</h5><p>​关键字：<strong>PRIMARY KEY</strong></p><p>​说明：</p><ol><li>被声明为PRIMARY KEY的字段，该字段的值只能是非空且唯一的。</li><li>一张表中只能有一个主键。</li></ol><h5 id="B-唯一约束"><a href="#B-唯一约束" class="headerlink" title="B.唯一约束"></a>B.唯一约束</h5><p>​关键字：<strong>UNIQUE</strong></p><p>​说明：被声明为UNIQUE的字段，其值不能重复，最多只有一个非空记录。</p><h5 id="C-非空约束"><a href="#C-非空约束" class="headerlink" title="C.非空约束"></a>C.非空约束</h5><p>​关键字：<strong>NOT NULL</strong></p><p>​说明：被声明为NOT NULL的字段，其值不能为NULL，即必须有值。</p><h5 id="D-默认约束"><a href="#D-默认约束" class="headerlink" title="D.默认约束"></a>D.默认约束</h5><p>​关键字：<strong>DEFAULT</strong></p><p>​说明：被声明为DEFAULT的字段，如果没有给其赋值，其值为默认值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE student(</span><br><span class="line">    name VARCHAR(4), </span><br><span class="line">score int DEFAULT 0</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO student (name) VALUES (&#x27;Tom&#x27;);-- Tom的成绩默认值为0</span><br><span class="line">INSERT INTO student (name，score) VALUES (&#x27;Jack&#x27;,NULL);-- Jack的成绩为NULL，不是0</span><br></pre></td></tr></table></figure><h5 id="E-检查约束-MySQL8-0-16版本之后出现"><a href="#E-检查约束-MySQL8-0-16版本之后出现" class="headerlink" title="E.检查约束(MySQL8.0.16版本之后出现)"></a>E.检查约束(MySQL8.0.16版本之后出现)</h5><p>​保证字段值满足某一个或多个条件。</p><p>​关键字为：CHECK</p><p>​格式为：CHECK(检查条件)</p><h5 id="F-外键约束"><a href="#F-外键约束" class="headerlink" title="F.外键约束"></a>F.外键约束</h5><h6 id="①作用"><a href="#①作用" class="headerlink" title="①作用"></a>①作用</h6><p>​让表与表之间产生物理上的关系。</p><h6 id="②添加约束"><a href="#②添加约束" class="headerlink" title="②添加约束"></a>②添加约束</h6><ul><li><p>建表时添加约束</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">   列名 数据类型,</span><br><span class="line">   …</span><br><span class="line">   [CONSTRAINT] [外键名称] FOREIGN KEY(外键列名) REFERENCES 主表(主表列名) ON DELETE 行为 ON UPDATE 行为</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>在已有的表基础上添加约束</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 建完表后添加外键约束</span><br><span class="line">ALTER TABLE 表名 ADD [CONSTRAINT 外键名称] FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称) ON UPDATE 行为 ON DELETE 行为;</span><br></pre></td></tr></table></figure><p>  行为：</p><p>  <img src="/imgs/image-20220917202626617.png" alt="image-20220917202626617"></p><p>  其中：NO ACTION和RESTRICT为<strong>默认</strong>设置。</p></li></ul><h6 id="③删除约束"><a href="#③删除约束" class="headerlink" title="③删除约束"></a>③删除约束</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 DROP FOREIGN KEY 外键名称;</span><br></pre></td></tr></table></figure><h6 id="④说明"><a href="#④说明" class="headerlink" title="④说明"></a>④说明</h6><ol><li><p>创建(CREATE)表时就指定外键约束的话，先创建主表，再创建从表。</p></li><li><p>当主表的记录被从表参照时，主表的记录将不允许删除，如果要删除数据，需要先删除从表中依赖该记录的数据，然后才可以删除主表的数据。</p></li></ol><h4 id="③-自增长操作"><a href="#③-自增长操作" class="headerlink" title="③.自增长操作"></a>③.自增长操作</h4><p>​关键字：AUTO_INCREMENT</p><p>​使用要求：被修饰的字段必须是数字类型 且 字段值满足唯一性。</p><p>​举例：</p><p>​当没有指定值 或 赋为NULL 时，都会采用自增的方式进行赋值，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE test(</span><br><span class="line">id INT PRIMARY KEY auto_increment,</span><br><span class="line">name VARCHAR(4) NOT NULL</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">INSERT INTO test (name) VALUES (&#x27;Tom&#x27;);</span><br><span class="line">INSERT INTO test (id,name) VALUES (NULL,&#x27;Jack&#x27;);</span><br><span class="line">INSERT INTO test (id,name) VALUES (NULL,&#x27;Mary&#x27;);</span><br><span class="line"></span><br><span class="line">SELECT * FROM test;</span><br></pre></td></tr></table></figure><p>​<img src="/imgs/image-20220915120547387.png" alt="image-20220915120547387"></p><h3 id="五、多表查询"><a href="#五、多表查询" class="headerlink" title="五、多表查询"></a>五、多表查询</h3><h4 id="①多表关系"><a href="#①多表关系" class="headerlink" title="①多表关系"></a>①多表关系</h4><h5 id="A-概述"><a href="#A-概述" class="headerlink" title="A.概述"></a>A.概述</h5><p>​表与表之间主要有三种关系：一对多、多对多、一对一</p><h5 id="B-一对多"><a href="#B-一对多" class="headerlink" title="B.一对多"></a>B.一对多</h5><p>​案例：部门 与 员工的关系</p><p>​实现：在多的一方建立外键，指向一的一方的主键。</p><h5 id="C-多对多"><a href="#C-多对多" class="headerlink" title="C.多对多"></a>C.多对多</h5><p>​案列：学生 与 课程的关系</p><p>​关系：一个学生可以选修多门课程，一门课程也可以供多个学生选择。</p><p>​实现：建立第三张中间表，中间表至少包含两个外键，分别为关联两方主键。</p><p><img src="/imgs/image-20220918102554074.png" alt="image-20220918102554074"></p><h5 id="D-一对一"><a href="#D-一对一" class="headerlink" title="D.一对一"></a>D.一对一</h5><p>​案例：用户 与 用户详情的关系</p><p>​关系：一对一关系，<strong>多用于单表拆分</strong>，将一张表的基础字段放在一张表中，其它详情字段放在另一张表中，以提升效率。</p><p>​实现：在任意一方加入外键，关联另一方的主键，并且设置外键为唯一的(UNIQUE)。</p><h4 id="②多表查询分类"><a href="#②多表查询分类" class="headerlink" title="②多表查询分类"></a>②多表查询分类</h4><p>​多表查询：两张表之间不要求一定存在物理上的联系，换句话说，即使两张表之间没有物理上的联系也可以做多表查询。</p><ol><li>连接查询<ul><li><strong>内连接</strong>：相当于查询A表、B表交集部分数据</li><li><strong>外连接</strong><ol><li>左外连接：查询左表所有数据，以及两张表交集部分数据</li><li>右外连接：查询右表所有数据，以及两张表交集部分数据</li></ol></li><li><strong>自连接</strong>：当前表与自身的连接查询，连接必须使用表别名</li></ul></li><li><strong>子查询</strong></li></ol><hr><h4 id="③内连接"><a href="#③内连接" class="headerlink" title="③内连接"></a>③内连接</h4><p>内连接：对两张表做笛卡尔积，然后再根据WHERE中的条件消除没有意义的笛卡尔积，得到表A，最后再对表A进行其它操作。</p><h5 id="A-内连接查询语法"><a href="#A-内连接查询语法" class="headerlink" title="A.内连接查询语法"></a>A.内连接查询语法</h5><h6 id="①隐式内连接"><a href="#①隐式内连接" class="headerlink" title="①隐式内连接"></a>①隐式内连接</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表1,表2 WHERE 条件;</span><br></pre></td></tr></table></figure><h6 id="②显示内连接"><a href="#②显示内连接" class="headerlink" title="②显示内连接"></a>②显示内连接</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表1 [INNER] JOIN 表2 ON 连接条件;</span><br><span class="line"># INNER关键字可以省略，省不省略结果都一样。</span><br></pre></td></tr></table></figure><p>​</p><h5 id="B-补充"><a href="#B-补充" class="headerlink" title="B.补充"></a>B.补充</h5><ol><li>当表明比较长是，我们可以给表起别名，使用关键字AS(AS可以省略，省略后原表名与别名之间要有空格)。使用表别名之后，就不能再用原表名去调用相应的字段了。</li></ol><h4 id="④外连接"><a href="#④外连接" class="headerlink" title="④外连接"></a>④外连接</h4><h5 id="A-外连接查询语法"><a href="#A-外连接查询语法" class="headerlink" title="A.外连接查询语法"></a>A.外连接查询语法</h5><h6 id="①左外连接"><a href="#①左外连接" class="headerlink" title="①左外连接"></a>①左外连接</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表1 LEFT [OUTER] JOIN 表2 ON 条件...; </span><br></pre></td></tr></table></figure><p>​进行左外连接时，表1作为主表，表2作为副表。表1与表2进行笛卡尔积，根据ON后面的条件消除掉无用的数据，当副表中的数据没有和主表中的数据匹配上，副表自动模拟出NULL与之匹配。</p><h6 id="②右外连接"><a href="#②右外连接" class="headerlink" title="②右外连接"></a>②右外连接</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表1 RIGHT [OUTER] JOIN 表2 ON 条件...; </span><br></pre></td></tr></table></figure><p>​进行右外连接时，表2作为主表，表1作为副表。表1与表2进行笛卡尔积，根据ON后面的条件消除掉无用的数据，当副表中的数据没有和主表中的数据匹配上，副表自动模拟出NULL与之匹配。</p><h5 id="B-说明"><a href="#B-说明" class="headerlink" title="B.说明"></a>B.说明</h5><ol><li>语法中的OUTER关键字可以省略，省略后结果不变。</li><li>左外连接和右外连接可以相互转换。卡发中常用左外连接。</li></ol><h4 id="⑤自连接"><a href="#⑤自连接" class="headerlink" title="⑤自连接"></a>⑤自连接</h4><h5 id="A-自连接查询语法"><a href="#A-自连接查询语法" class="headerlink" title="A.自连接查询语法"></a>A.自连接查询语法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表A 别名A JOIN 表A 别名B ON 条件...;</span><br></pre></td></tr></table></figure><h5 id="B-说明-1"><a href="#B-说明-1" class="headerlink" title="B.说明"></a>B.说明</h5><ol><li><p>自连接必须指明表的别名，不然报错。</p></li><li><p>可以使用 内连接 或 外连接 实现自连接如：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#由于表1和表2都是同一张表，所以这里的内连接也就属于自连接了。</span><br><span class="line">SELECT a.name,b.name FROM emp AS a ,emp AS b WHERE a.maragerid = b.id;</span><br><span class="line"></span><br><span class="line">#由于表1和表2都是同一张表，所以这里的外连接也就属于自连接了。</span><br><span class="line">SELECT a.name,b.name FROM emp AS a LEFT JOIN emp AS b ON a.maragerid = b.id;</span><br></pre></td></tr></table></figure></li></ol><h4 id="⑥联合查询"><a href="#⑥联合查询" class="headerlink" title="⑥联合查询"></a>⑥联合查询</h4><h5 id="A-概念"><a href="#A-概念" class="headerlink" title="A.概念"></a>A.概念</h5><p>​联合查询：把多次查询的结果合并起来，形成一个新的查询结果集。即：把结果B直接跟在结果A的后面，形成一个新的结果。</p><h5 id="B-联合查询语法"><a href="#B-联合查询语法" class="headerlink" title="B.联合查询语法"></a>B.联合查询语法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT 字段列表 FROM 表A.....</span><br><span class="line">UNION [ALL]</span><br><span class="line">SELECT 字段列表 FROM 表B...;</span><br></pre></td></tr></table></figure><p>​说明：</p><ol><li>如果UNION后面加上ALL，则代表不对合并之后的结果集进行去重。不加ALL，代表对合并后的结果集进行去重。</li></ol><h5 id="C-联合查询的前提条件"><a href="#C-联合查询的前提条件" class="headerlink" title="C.联合查询的前提条件"></a>C.联合查询的前提条件</h5><p>​对于联合查询的多张表的列数必须保持一致，字段类型也需要保持一致。不然报错。</p><h4 id="⑦子查询"><a href="#⑦子查询" class="headerlink" title="⑦子查询"></a>⑦子查询</h4><h5 id="A-概述-1"><a href="#A-概述-1" class="headerlink" title="A.概述"></a>A.概述</h5><ol><li>子查询：SQL语句中嵌套SELECT语句，称为嵌套查询，又称子查询。</li><li>子查询可以出现的位置：<strong>WHERE</strong>之后，<strong>FROM</strong>之后，<strong>SELECT</strong>之后。</li><li>根据子查询结果不同，分为：<ul><li>标量子查询(子查询结果为单个值)</li><li>列子查询(子查询结果为一列)</li><li>行子查询(子查询结果为一行)</li><li>表子查询(子查询结果为多行多列)</li></ul></li></ol><h5 id="B-标量子查询"><a href="#B-标量子查询" class="headerlink" title="B.标量子查询"></a>B.标量子查询</h5><h6 id="①概念-3"><a href="#①概念-3" class="headerlink" title="①概念"></a>①概念</h6><p>​子查询返回的结果是单个值(数字、字符串、日期等)，这种子查询称为：标量子查询。</p><p>​对子查询结果的常用的操作符为：&#x3D;、&lt;&gt; 、&gt; 、&lt; 、&gt;&#x3D; 、&lt;&#x3D;</p><h6 id="②例子-1"><a href="#②例子-1" class="headerlink" title="②例子"></a>②例子</h6><p><img src="/imgs/image-20220919165348118.png" alt="image-20220919165348118"></p><h5 id="C-列子查询"><a href="#C-列子查询" class="headerlink" title="C.列子查询"></a>C.列子查询</h5><h6 id="①概念-4"><a href="#①概念-4" class="headerlink" title="①概念"></a>①概念</h6><p>​子查询返回的结果是一列(一列里可以有多行)，这种子查询称为列子查询。</p><h6 id="②操作符"><a href="#②操作符" class="headerlink" title="②操作符"></a>②操作符</h6><p>​使用如下操作符来操作列子查询返回的结果：</p><p><img src="/imgs/image-20220919172845463.png" alt="image-20220919172845463"></p><h6 id="③例子"><a href="#③例子" class="headerlink" title="③例子"></a>③例子</h6><p>​①</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#查询比 财务部 所有人工资都高的员工信息</span><br><span class="line">-- 1.查询出财务部的部门ID</span><br><span class="line">SELECT id FROM dept WHERE name = &#x27;财务部&#x27;;</span><br><span class="line">-- 2.查询出财务部所有人的工资</span><br><span class="line">SELECT salary FROM emp WHERE dept_id = (SELECT id FROM dept WHERE name = &#x27;财务部&#x27;);</span><br><span class="line">-- 3.查询比 财务部 所有人工资都高的员工信息</span><br><span class="line">SELECT * FROM emp WHERE salary &gt; ALL (SELECT salary FROM emp WHERE dept_id = (SELECT id FROM dept WHERE name = &#x27;财务部&#x27;));</span><br></pre></td></tr></table></figure><p>​②</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#查询比 研发部 其中任意一个人工资高的员工信息</span><br><span class="line">SELECT * FROM emp WHERE salary &gt; SOME (SELECT salary FROM emp WHERE dept_id = (SELECT id FROM dept WHERE name = &#x27;研发部&#x27;));</span><br></pre></td></tr></table></figure><h5 id="D-行子查询"><a href="#D-行子查询" class="headerlink" title="D.行子查询"></a>D.行子查询</h5><h6 id="①概念-5"><a href="#①概念-5" class="headerlink" title="①概念"></a>①概念</h6><p>​子查询返回的结果是一行(一行中可以有多列)，这种子查询称为：行子查询。</p><h6 id="②操作符-1"><a href="#②操作符-1" class="headerlink" title="②操作符"></a>②操作符</h6><p>​对行子查询结果进行操作的操作符有：&#x3D;、&lt;&gt;、IN、NOT IN</p><h6 id="③例子-1"><a href="#③例子-1" class="headerlink" title="③例子"></a>③例子</h6><p>​查询与 “张无忌” 的薪资及直属领导相同的员工信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#1.先查询张无忌的薪资就直属领导</span><br><span class="line">SELECT salary,managerid FROM emp WHERE name = &#x27;张无忌&#x27;;-- 查询到了一行数据,salary = 12000,managerid = 1</span><br><span class="line"></span><br><span class="line">#2.查询与“张无忌”的薪资及直属领导相同的员工信息</span><br><span class="line">SELECT * FROM emp WHERE salary = 12000 AND managerid = 1;</span><br><span class="line"></span><br><span class="line">#如何将1、2中的SQL合成一个SQL</span><br><span class="line">SELECT * FROM emp WHERE (salary,managerid) = (12000,1);-- 与第四行等价</span><br><span class="line"></span><br><span class="line">#(12000,1)是由第一行语句得来的，所以可以用第一行语句替换掉(12000,1)</span><br><span class="line">#最终结果为：</span><br><span class="line">SELECT * FROM emp WHERE (salary,managerid) = (SELECT salary,managerid FROM emp WHERE name = &#x27;张无忌&#x27;;);</span><br></pre></td></tr></table></figure><h5 id="E-表子查询"><a href="#E-表子查询" class="headerlink" title="E.表子查询"></a>E.表子查询</h5><h6 id="①概念-6"><a href="#①概念-6" class="headerlink" title="①概念"></a>①概念</h6><p>​子查询返回的结果是多行多列，即返回一张表。这种子查询称为表子查询。</p><p>​表子查询常写在FROM的后面，将子查询得到的表作为临时表对其再进行相应的查询操作。</p><h6 id="②操作符-2"><a href="#②操作符-2" class="headerlink" title="②操作符"></a>②操作符</h6><p>​对于表子查询返回的结果我们可以使用下面的操作符进行处理：IN</p><h6 id="③例子-2"><a href="#③例子-2" class="headerlink" title="③例子"></a>③例子</h6><p>​①查询与 “鹿杖客” ，“宋远桥”的职位和薪资相同的员工信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#1.查询 “鹿杖客” ，“宋远桥”的职位和薪资</span><br><span class="line">SELECT job,salary FROM emp WHERE name = &#x27;鹿杖客”&#x27; OR name = &#x27;宋远桥&#x27;;-- 返回职位、薪资表</span><br><span class="line">#2查询与 “鹿杖客” ，“宋远桥”的职位和薪资相同的员工信息</span><br><span class="line"></span><br><span class="line">SELECT * FROM emp WHERE (job,salary) IN (SELECT job,salary FROM emp WHERE name = &#x27;鹿杖客”&#x27; OR name = &#x27;宋远桥&#x27;);</span><br><span class="line">-- 只要job和salary满足第二行代码得到的表中的其中一条数据，就会被SELECT</span><br></pre></td></tr></table></figure><p>​</p><p>​②查询入职日期是“2006-01-01” 之后的员工信息，及其部门信息。这里的子查询是放在FROM后面的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#1.先查询入职日期是“2006-01-01”之后的员工信息</span><br><span class="line">SELECT * FROM emp WHERE entrydate &gt; &#x27;2006-01-01&#x27;;</span><br><span class="line">#2.查询这部分员工，对应的部门信息</span><br><span class="line">SELECT e.*,d.* FROM (SELECT * FROM emp WHERE entrydate &gt; &#x27;2006-01-01&#x27;) AS e LEFT JOIN dept AS d ON e.dept_id = d.id;</span><br></pre></td></tr></table></figure><h4 id="⑧多表查询总结"><a href="#⑧多表查询总结" class="headerlink" title="⑧多表查询总结"></a>⑧多表查询总结</h4><p>​多表查询的重点是找到连接条件，通过连接条件就可以消除无用的笛卡尔积。然后再对得到的数据进行查询即可。</p><h3 id="六、事务"><a href="#六、事务" class="headerlink" title="六、事务"></a>六、事务</h3><h4 id="①事务简介"><a href="#①事务简介" class="headerlink" title="①事务简介"></a>①事务简介</h4><h5 id="A-引入"><a href="#A-引入" class="headerlink" title="A.引入"></a>A.引入</h5><p>​假如转账操作需要执行以下三个步骤：（张三向李四转账）</p><p>​1.查询张三账户余额</p><p>​2.张三账户余额 - 1000</p><p>​3.李四账户余额 +1000</p><p>​当上述步骤都正常执行时，就成功完成一次转账任务。但如果执行到步骤2时，系统出现了异常，导致步骤3不能继续执行，这时候就会造成数据的不完整性。为了避免出现这种情况，我们引入了“事务”这一概念。将上述操作放到事务中，当任意一个步骤出现异常时，剩下的步骤不会执行，然后将之前临时修改过的数据都恢复原样（这一过程被称为：回滚事务）。只有当上述步骤都正常执行时，系统才会将临时修改的数据提交，这样才真正把数据库中的数据修改。这样就可以保证数据的正确性和完整性。</p><h5 id="B-概念"><a href="#B-概念" class="headerlink" title="B.概念"></a>B.概念</h5><p>​事务：是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p><h5 id="C-说明"><a href="#C-说明" class="headerlink" title="C.说明"></a>C.说明</h5><p>​在MySQL中，事务是默认自动提交的，也就是说，当执行一条DML语句，MySQL会立即隐式的提交事务。</p><h4 id="②事务操作"><a href="#②事务操作" class="headerlink" title="②事务操作"></a>②事务操作</h4><h5 id="A-方式一"><a href="#A-方式一" class="headerlink" title="A.方式一"></a>A.方式一</h5><h6 id="①语法-1"><a href="#①语法-1" class="headerlink" title="①语法"></a>①语法</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SELECT @@autocommit;-- 查看当前窗口事务的提交方式</span><br><span class="line">#1.设置事务提交方式为手动提交，如果设置1，则代表自动提交事务</span><br><span class="line">SET @@autocommit = 0;</span><br><span class="line"></span><br><span class="line">#2.下面写需要被包在事务里的操作,如：更新操作等</span><br><span class="line">UPDATE .....;</span><br><span class="line"></span><br><span class="line">#3.</span><br><span class="line">COMMIT;-- 提交事务</span><br><span class="line">ROLLBACK;-- 回滚事务</span><br></pre></td></tr></table></figure><h6 id="②说明-2"><a href="#②说明-2" class="headerlink" title="②说明"></a>②说明</h6><ul><li>SET @@autocommit &#x3D; 0;当执行完这条语句之后，事务的提方式变为手动提交，只要没执行COMMIT就不会对数据库中的数据进行修改。其作用范围是：当前窗口有效。</li><li>当执行操作都没有出现异常时，我们才去执行COMMIT，将数据写到数据库中。</li><li>当执行操作出现异常时，我们需要使用ROLLBACK来撤回之前执行相应的操作，此时数据库中的数据并没有被改变。</li></ul><h5 id="B-方式二"><a href="#B-方式二" class="headerlink" title="B.方式二"></a>B.方式二</h5><h6 id="①语法-2"><a href="#①语法-2" class="headerlink" title="①语法"></a>①语法</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#1.</span><br><span class="line">START TRANSACTION;-- 或者写 BEGIN</span><br><span class="line"></span><br><span class="line">#2.下面写需要被包在事务里的操作,如：更新操作等</span><br><span class="line">UPDATE .....;</span><br><span class="line"></span><br><span class="line">#3.</span><br><span class="line">COMMIT;-- 提交事务</span><br><span class="line">ROLLBACK;-- 回滚事务</span><br></pre></td></tr></table></figure><h6 id="②说明-3"><a href="#②说明-3" class="headerlink" title="②说明"></a>②说明</h6><ul><li>这种方式并没有修改事务提交的方式</li><li>当选中第2部分的代码进行执行时，涉及到的数据并没有立即写到数据库中，而是等到执行COMMIT时才会对涉及到的数据写到数据库中。</li><li>当执行操作都没有出现异常时，我们才去执行COMMIT，将数据写到数据库中。</li><li>当执行操作出现异常时，我们需要使用ROLLBACK来撤回之前执行相应的操作，此时数据库中的数据并没有被改变。</li></ul><h4 id="③事务四大特性-ACID"><a href="#③事务四大特性-ACID" class="headerlink" title="③事务四大特性(ACID)"></a>③事务四大特性(ACID)</h4><ol><li>原子性(Atomicity)：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。</li><li>一致性(Consistency)：事务完成时，必须使所有的数据都保持一致状态。如：转账中，两人账户的总钱数是不变的。</li><li>隔离性(Isolation)：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。如：有两并发事务A、B，它们之间不会相互影响。</li><li>持久性(Duration)：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</li></ol><h4 id="④并发事务问题"><a href="#④并发事务问题" class="headerlink" title="④并发事务问题"></a>④并发事务问题</h4><p>​当多个事务共同访问同一个数据库或数据库中的同一张表时，就可能出现并发事务问题。具体的问题有：脏读、不可重复读、幻读</p><h5 id="A-脏读"><a href="#A-脏读" class="headerlink" title="A.脏读"></a>A.脏读</h5><p>​脏读：一个事务读到另一个事务还没有提交的数据。</p><p>​如下图：事务A对数据库中的数据进DB行查询操作，然后对数据进行更新操作，此时事务B也进来对数据库DB进行查询操作，事务B就能读到事务A还没提交的数据了。</p><p><img src="/imgs/image-20220920174038881.png" alt="image-20220920174038881"></p><p>​</p><h5 id="B-不可重复读"><a href="#B-不可重复读" class="headerlink" title="B.不可重复读"></a>B.不可重复读</h5><p>​不可重复读：一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读。</p><p>​如下图：事务B在事务A执行第三步操作之前，对数据进行了修改并提交了事务，此时事务A再读取同一条数据时，数据的内容就发生了改变了。</p><p><img src="/imgs/image-20220920174923913.png" alt="image-20220920174923913"></p><h5 id="C-幻读"><a href="#C-幻读" class="headerlink" title="C.幻读"></a>C.幻读</h5><p>​幻读：一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在，好像出现了“幻影”。</p><p>​如下图：事务A在执行步骤一时，发现数据库DB中没有所查询的记录，然后就执行步骤2来添加数据。但在事务A添加数据之前事务B添加了事务A所要查询的数据并提交事务，这样就会导致事务A在插入数据时失败，然后事务A又对该数据进行查询，发现并没有该数据存在。</p><p><img src="/imgs/image-20220920180611632.png" alt="image-20220920180611632"></p><h4 id="⑤事务隔离级别"><a href="#⑤事务隔离级别" class="headerlink" title="⑤事务隔离级别"></a>⑤事务隔离级别</h4><h5 id="A-引入-1"><a href="#A-引入-1" class="headerlink" title="A.引入"></a>A.引入</h5><p>​为了解决并发事务中的问题，我们引入了事务隔离级别来处理。</p><h5 id="B-事务隔离级别"><a href="#B-事务隔离级别" class="headerlink" title="B.事务隔离级别"></a>B.事务隔离级别</h5><p><img src="/imgs/image-20220920205433460.png" alt="image-20220920205433460"></p><p>​说明：</p><ol><li>×：代表不会出现。</li><li>Serializable的隔离级别最高，但性能最差，Read uncommitted的隔离级别最低，性能最好。</li><li>Repeatable Read是MySQL默认的事务隔离级别，而Oracle数据库的默认事务隔离级别为Read committed。</li><li>当事务的隔离级别为Serializable时，有两个并发事务A、B，事务A正在操作数据库当中的student表，此时事务B也想操作student表，但事务B不能操作，只能等事务A操作完student表之后才能操作。</li></ol><p>​</p><h5 id="C-相关操作"><a href="#C-相关操作" class="headerlink" title="C.相关操作"></a>C.相关操作</h5><h6 id="①查看事务隔离级别"><a href="#①查看事务隔离级别" class="headerlink" title="①查看事务隔离级别"></a>①查看事务隔离级别</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT @@TRANSACTION_ISOLATION;</span><br></pre></td></tr></table></figure><h6 id="②设置事务隔离级别"><a href="#②设置事务隔离级别" class="headerlink" title="②设置事务隔离级别"></a>②设置事务隔离级别</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET [SESSION|GLOBAL] TRANSACTION ISOLATION LEVEL &#123;READ UNCOMMITTED|READ COMMITTED|REPEATABLE READ|SERIALIZABLE&#125;</span><br></pre></td></tr></table></figure><p>​说明</p><ul><li>SESSION：设置事务的隔离级别只在当前窗口有效。</li><li>GLOBAL：设置事务的隔离级别的有效范围为：全部窗口。</li><li>一般我们会使用默认的隔离级别。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDBC</title>
      <link href="/2023/04/20/jdbc/"/>
      <url>/2023/04/20/jdbc/</url>
      
        <content type="html"><![CDATA[<h3 id="一、JDBC简介"><a href="#一、JDBC简介" class="headerlink" title="一、JDBC简介"></a>一、JDBC简介</h3><h4 id="①JDBC概念"><a href="#①JDBC概念" class="headerlink" title="①JDBC概念"></a>①JDBC概念</h4><ul><li>JDBC就是使用Java语言操作关系型数据库的一套API。</li></ul><h4 id="②JDBC本质"><a href="#②JDBC本质" class="headerlink" title="②JDBC本质"></a>②JDBC本质</h4><ul><li>SUN公司定义的一套操作所有关系型数据库的规则，即接口。</li><li>各个数据库厂商去实现这套接口，提供数据库驱动jar包。</li><li>我们可以使用这套(JDBC)编程，真正执行的代码是驱动jar包中的实现类。</li></ul><h4 id="③JDBC好处"><a href="#③JDBC好处" class="headerlink" title="③JDBC好处"></a>③JDBC好处</h4><ul><li>各数据库厂商使用相同的接口，Java代码不需要针对不同数据库分别开发。</li><li>可随时替换底层数据库，访问数据库的Java代码基本不变。</li></ul><h4 id="④补充"><a href="#④补充" class="headerlink" title="④补充"></a>④补充</h4><p>​当我们需要使用不同的数据库时，我们只需要导入不同的数据库驱动jar包即可。</p><img src="/imgs/image-20230423202509764.png" alt="image-20230423202509764" style="zoom: 67%;" /><hr><h3 id="二、JDBC快速入门"><a href="#二、JDBC快速入门" class="headerlink" title="二、JDBC快速入门"></a>二、JDBC快速入门</h3><p>​通过JDBC来连接数据库。</p><h4 id="①实现步骤"><a href="#①实现步骤" class="headerlink" title="①实现步骤"></a>①实现步骤</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0.导入驱动jar包</span></span><br><span class="line">mysql-connector-java-<span class="number">5.1</span><span class="number">.34</span>.jar</span><br><span class="line"><span class="comment">//1.注册驱动</span></span><br><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);<span class="comment">//&quot;com.mysql.jdbc.Driver&quot;是固定的</span></span><br><span class="line"><span class="comment">//2.获取连接</span></span><br><span class="line"><span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(url,username,password);</span><br><span class="line"><span class="comment">//3.定义SQL语句</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update...&quot;</span>;</span><br><span class="line"><span class="comment">//4.获取执行SQL对象</span></span><br><span class="line"><span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> conn.createStatement();</span><br><span class="line"><span class="comment">//5.执行SQL</span></span><br><span class="line">stmt.execuleUpdate(sql);<span class="comment">//返回受影响的行数，</span></span><br><span class="line"><span class="comment">//6.处理返回结果</span></span><br><span class="line"><span class="comment">//7.释放资源 </span></span><br><span class="line">stmt.close();</span><br><span class="line">conn.close();</span><br><span class="line"><span class="comment">//如果使用到了如下类的对象，就把这些对象的资源释放掉</span></span><br><span class="line"><span class="comment">//Connection、Statement、PreparedStatement、ResultSet</span></span><br></pre></td></tr></table></figure><h4 id="②实现步骤的说明"><a href="#②实现步骤的说明" class="headerlink" title="②实现步骤的说明"></a>②实现步骤的说明</h4><ul><li>注册驱动：说明接下来使用的是哪个驱动。即说明接下来使用的是哪个数据库提供的JDBC接口实现类。</li><li>getConnection(url,username,password)：<ul><li>url：jdbc:mysql:&#x2F;&#x2F;数据库管理系统所在主机的地址(或域名)：3306&#x2F;连接的是数据库管理系统下的哪个数据库。例子：jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;db1。</li><li>username、password：登录数据库管理系统时的用户名和密码。</li></ul></li><li>执行SQL：将SQL语句发送给数据库，让数据库处理这些SQL语句。</li></ul><h4 id="③JDBC-API详解"><a href="#③JDBC-API详解" class="headerlink" title="③JDBC  API详解"></a>③JDBC  API详解</h4><h5 id="A-DriverManager"><a href="#A-DriverManager" class="headerlink" title="A.DriverManager"></a>A.DriverManager</h5><h6 id="①概述"><a href="#①概述" class="headerlink" title="①概述"></a>①概述</h6><p>​DriverManager属于工具类，该类的两个主要功能是：注册驱动、获取数据库连接。</p><h6 id="②注册驱动"><a href="#②注册驱动" class="headerlink" title="②注册驱动"></a>②注册驱动</h6><ul><li><p>实现原理：</p><p>  ​按照JDBC中的实现步骤，我们用Class.forName(“com.mysql.jdbc.Driver”)来注册驱动。该代码底层实现原理是：</p><p>  ​Driver是一个类，该类中有一个静态代码块，静态代码块中调用了DriverManager类中的静态方法registerDriver()，该方法就是用来注册驱动的。</p><p>  ​所以当通过反射来加载Driver类时，同时也执行了Driver类中的静态代码块，也就调用了registerDriver()来注册驱动了。</p></li><li><p>提示：</p><p>  ​如果使用的是MySQL 5之后的驱动jar包，那么就可以省略注册驱动的步骤。</p></li></ul><h6 id="③获取连接"><a href="#③获取连接" class="headerlink" title="③获取连接"></a>③获取连接</h6><p>​调用DriverManager类中的静态方法getConnection(String url,String user,String password)，该方法返回的是一个Connection类的对象。</p><p>​<strong>细节</strong>：</p><ul><li><p>如果连接的是本机MySQL服务器(即地址为127.0.0.1)，并且MySQL服务默认端口是3306，则url可以简写为：jdbc:mysql:&#x2F;&#x2F;&#x2F;数据库名称</p></li><li><p>当我们执行该语句后，运行结果中会显示一个警告：建议以安全的方式连接数据库(SSL)，但这种连接方式会使性能降低，一般不使用。为了不出现这个警告，我们可以在url的最后面加上：?useSSL&#x3D; fasle即可。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://127.0.0.1:3306/db1?useSSL=false&quot;</span>;</span><br></pre></td></tr></table></figure></li></ul><h5 id="B-Connection"><a href="#B-Connection" class="headerlink" title="B.Connection"></a>B.Connection</h5><h6 id="①作用"><a href="#①作用" class="headerlink" title="①作用"></a>①作用</h6><p>​获取执行SQL的对象、管理事务。</p><h6 id="②获取执行SQL对象"><a href="#②获取执行SQL对象" class="headerlink" title="②获取执行SQL对象"></a>②获取执行SQL对象</h6><ol><li>普通执行SQL对象</li></ol>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Statement <span class="title function_">createStatement</span><span class="params">()</span></span><br></pre></td></tr></table></figure><ol start="2"><li>预编译SQL的执行SQL对象：防止SQL注入</li></ol>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PreparedStatement <span class="title function_">prepareStatement</span><span class="params">(sql)</span></span><br><span class="line"><span class="comment">//关闭资源时，记得把PreparedStatement对象也关闭掉</span></span><br></pre></td></tr></table></figure><ol start="3"><li>执行存储过程的对象（少用，了解即可）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CallableStatement prepareCall(sql)</span><br></pre></td></tr></table></figure><h6 id="③事务管理"><a href="#③事务管理" class="headerlink" title="③事务管理"></a>③事务管理</h6><ul><li><p>概述：</p><p>  <img src="/imgs/image-20220921154856156.png" alt="image-20220921154856156"></p><p>  Conncetion中也有三个方法来管理事务，它们分别对应着MySQL中的事务管理的三个步骤。</p><p>  <img src="/imgs/image-20220921155103081.png" alt="image-20220921155103081"></p></li><li><p>使用：</p><p>  开启事务的代码写在执行SQL之前，提交事务的代码写在“处理事务返回的结果”的后面，然后将开启事务到提交事务之间的代码用try包起来，在catch里写回滚事务的代码。</p></li></ul><h5 id="C-Statement"><a href="#C-Statement" class="headerlink" title="C.Statement"></a>C.Statement</h5><h6 id="①作用-1"><a href="#①作用-1" class="headerlink" title="①作用"></a>①作用</h6><p>​执行SQL语句</p><h6 id="②相关方法"><a href="#②相关方法" class="headerlink" title="②相关方法"></a>②相关方法</h6><ol><li><p>int executeUpdate(sql)</p><p> 该方法执行的是DML、DDL语句<br> 返回值：<br>  ①DML语句受影响的行数，我们可以根据返回的行数来判断，该SQL是否执行成功<br> ②DDL语句执行后，执行成功也可能返回0，如：创建数据库或创建表执行成功了，受影响行数也为0</p></li><li><p>ResultSet executeQuery(sql)</p><p> 该方法执行的是DQL语句<br> 返回值：ResultSet结果集对象</p></li></ol><p><code>注意</code>：关闭资源时，记得把ResultSet对象资源也得关闭。</p><h5 id="D-ResultSet"><a href="#D-ResultSet" class="headerlink" title="D.ResultSet"></a>D.ResultSet</h5><h6 id="①概述-1"><a href="#①概述-1" class="headerlink" title="①概述"></a>①概述</h6><p>​ResultSet中存储了通过executeQuery(sql)查询得到的结果。(说明：这里的sql特指DQL语句)</p><p>​由于DQL语句查询得到的结果为：一个数据 或 一行数据 或 一张表</p><p>​所以实际上，ResultSet中存储的是一个数据 或 一行数据 或 一张表。</p><h6 id="②获取查询结果"><a href="#②获取查询结果" class="headerlink" title="②获取查询结果"></a>②获取查询结果</h6><ul><li>boolean next()<ul><li>作用：①将光标从当前位置向下移动一行。(光标的初始位置为：表头) ②判断当前行是否为有效行。</li><li>返回值：<ul><li>true：有效行，代表当前行有数据。</li><li>false：无效行，代表当前行没有数据。</li></ul></li></ul></li><li>xxx getXxx(参数)<ul><li>作用：获取数据</li><li>Xxx：数据类型；如：int getInt(参数)</li><li>参数：二选一<ul><li>①int：列的编号，从1开始。</li><li>②String：列的名称</li></ul></li></ul></li></ul><h6 id="③练习"><a href="#③练习" class="headerlink" title="③练习"></a>③练习</h6><p>​查询account账户表数据，封装为Account对象中，并存储到ArrayList集合中。</p><h5 id="E-PreparedStatement"><a href="#E-PreparedStatement" class="headerlink" title="E.PreparedStatement"></a>E.PreparedStatement</h5><h6 id="①概述-2"><a href="#①概述-2" class="headerlink" title="①概述"></a>①概述</h6><p>​PreparedStatement是一个接口，其继承Statement类。</p><p>​其作用：执行SQL语句，并且能够预防SQL注入。</p><h6 id="②SQL注入"><a href="#②SQL注入" class="headerlink" title="②SQL注入"></a>②SQL注入</h6><p>​SQL注入是通过操作输入来修改事先定义好的SQL语句，用以达到执行代码对服务器进行攻击的方法。</p><p>​如：在登录输入密码时，写入一段SQL代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#如现登录的用户名为张三，其密码为123</span><br><span class="line">SELECT * FROM user_login WHERE name = &#x27;张三&#x27; AND password = &#x27;123&#x27;;-- 如果查询到数据，就代表该用户存在且密码正确，登录成功</span><br><span class="line"></span><br><span class="line">#如果我在输入密码时写了作用的SQL语句：&#x27; or &#x27;1&#x27; = &#x27;1&#x27;</span><br><span class="line">SELECT * FROM user_login WHERE name = &#x27;张三&#x27; AND password = &#x27;&#x27; or &#x27;1&#x27; = &#x27;1&#x27;;</span><br><span class="line">-- 此时用户输入的密码就改变了原来查询语句的面貌，导致WHERE后面的条件永远成立，select就能查询到数据，代表着登录成功了。这就是SQL注入。</span><br></pre></td></tr></table></figure><p>​</p><h6 id="③解决SQL注入"><a href="#③解决SQL注入" class="headerlink" title="③解决SQL注入"></a>③解决SQL注入</h6><p>​<strong>实现步骤</strong>：</p><ol><li><p>获取PreparedStatement对象，用Connection类的对象去调用prepareStatement(sql)方法</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> con.prepareStatement(sql);</span><br></pre></td></tr></table></figure><p> 注意：sql语句中的参数值，使用 “ ? ” 占位符代替，如：</p><p> sql可以为增删改查操作。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from user where username = ? and password = ?&quot;</span>;</span><br></pre></td></tr></table></figure></li><li><p>设置参数。通过PreparedStatement类的对象去调用setXxx(参数1,参数2)去给 “ ? ”赋值。</p><p> 说明：</p><ul><li>Xxx：数据类型；如：setInt(参数1，参数2)</li><li>参数：<ul><li>参数1：? 的位置。第一个?的位置为1。</li><li>参数2：? 的值。</li></ul></li></ul></li><li><p>执行SQL。通过PreparedStatement类的对象调用execuleUpdate()或executeQuery()来执行SQL语句。注意：不用再向这两个方法传递SQL语句。</p></li></ol><h6 id="④解决SQL注入的原理"><a href="#④解决SQL注入的原理" class="headerlink" title="④解决SQL注入的原理"></a>④解决SQL注入的原理</h6><p>​当我们通过setXxx方法来设置占位符 “?” 的值时，会对设置的值进行校验，如果其中涉及到了一些SQL关键字或单引号等会对其进行转移操作，即将这些变成字符串。这样就不会产生SQL注入了。</p><h6 id="⑤PreparedStatement原理"><a href="#⑤PreparedStatement原理" class="headerlink" title="⑤PreparedStatement原理"></a>⑤PreparedStatement原理</h6><ul><li><strong>PreparedStatement的好处</strong><ol><li>预编译SQL，性能提高。</li><li>防止SQL注入：将敏感字符进行转义。</li><li>PreparedStatement<strong>预编译功能默认是关闭的</strong>，<strong>需要我们手动开启</strong>，在获取数据库连接时，在url后面加上“<strong>useServerPrepStmts &#x3D; true</strong>”，<strong>并且在这段代码前加上 &amp; 和前面的内容连起来</strong>。</li></ol></li><li><strong>PreparedStatement原理</strong><ol><li>在获取PreparedStatement对象时，将SQL语句发送给MySQL服务器进行检查，编译(这些步骤很耗时)。</li><li>执行SQL时就不用再进行检查和预编译了，速度更快。</li><li>如果SQL语句的模板一样，则只需要进行一次检查和预编译。</li></ol></li><li><strong>PreparedStatement比以普通的方式执行SQL快在哪里？</strong><ol><li>普通的方式进行SQL：其在执行SQL时才将SQL语句发送给数据库进行检查和编译，最后才真正执行。比预编译耗时。</li><li>普通的方式进行SQL：需要对每一条SQL语句进行检查和编译，预编译的话，只要模板相同就只执行一次检查和编译，节省了时间。</li></ol></li></ul><hr><h4 id="④数据库连接池"><a href="#④数据库连接池" class="headerlink" title="④数据库连接池"></a>④数据库连接池</h4><h5 id="A-概述"><a href="#A-概述" class="headerlink" title="A.概述"></a>A.概述</h5><ol><li>数据库连接池：是个容器，负责分配、管理数据库连接。</li><li>它允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个。—&gt; 资源复用、提高响应效率</li><li>释放空间时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏。—&gt; 避免数据库连接遗漏</li></ol><p>​<strong>好处</strong>：</p><ul><li>资源复用</li><li>提高响应效率</li><li>避免数据库连接遗漏</li></ul><p>​</p><h5 id="B-数据库连接池实现"><a href="#B-数据库连接池实现" class="headerlink" title="B.数据库连接池实现"></a>B.数据库连接池实现</h5><h6 id="①概述-3"><a href="#①概述-3" class="headerlink" title="①概述"></a>①概述</h6><ol><li><p>官方(SUN公司)提供了数据库连接池的标准接口DataSource，该接口由第三方组织实现。</p><ul><li><p>该接口的功能是：获取数据库连接，该接口中有一个方法：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection getConnection()</span><br></pre></td></tr></table></figure></li></ul></li><li><p>常见的数据库连接池：DBCP、C3P0、Druid</p><ul><li>Druid：是阿里巴巴开源的数据库连接池项目。其功能强大，性能优秀。</li></ul></li></ol><h6 id="②Druid使用步骤"><a href="#②Druid使用步骤" class="headerlink" title="②Druid使用步骤"></a>②Druid使用步骤</h6><ol><li><p>导入jar包：druid-1.1.12.jar</p></li><li><p>定义配置文件，文件的后缀为properties。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">driverClassName = com.mysql.jdbc.Driver<span class="comment">//注册数据库驱动，使用哪个数据库就注册哪个数据库驱动</span></span><br><span class="line">url = jdbc:mysql:<span class="comment">//数据库管理系统所在主机的地址(或域名)：3306/连接的是数据库管理系统下的哪个数据库。例子：jdbc:mysql://127.0.0.1:3306/db1。</span></span><br><span class="line">username = 登录数据库的用户</span><br><span class="line">password = 密码</span><br><span class="line">initialSize = <span class="number">5</span> <span class="comment">//初始化连接数量</span></span><br><span class="line">maxActive = <span class="number">10</span> <span class="comment">//最大连接数</span></span><br><span class="line">maxWait = <span class="number">3000</span> <span class="comment">//最大等待时间，单位为毫秒</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//还有其它参数可以设置</span></span><br></pre></td></tr></table></figure></li><li><p>加载配置文件</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Properties</span> <span class="variable">prop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();<span class="comment">//创建配置文件对象</span></span><br><span class="line">prop.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;配置文件的路径&quot;</span>));<span class="comment">//加载配置文件</span></span><br></pre></td></tr></table></figure></li><li><p>获取数据库连接池对象</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DataSource</span> <span class="variable">ds</span> <span class="operator">=</span> DruidDataSourcrFactory.createDataSourcr(prop);<span class="comment">//该方法会抛异常</span></span><br></pre></td></tr></table></figure></li><li><p>获取数据库连接</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> ds.getConnection();</span><br></pre></td></tr></table></figure></li><li><p>获取连接之后，就定义SQL，获取执行SQL的对象，执行SQL，释放资源。</p></li></ol><p>​</p><h6 id="③元视图操作的方法（即遍历Map）"><a href="#③元视图操作的方法（即遍历Map）" class="headerlink" title="③元视图操作的方法（即遍历Map）"></a>③元视图操作的方法（即遍历Map）</h6><ul><li>Set <strong>keySet</strong>()：返回所有key构成的Set集合</li><li>Collection <strong>values</strong>()：返回所有value构成的Collection集合</li><li>Set <strong>entrySet</strong>()：返回所有key-value对构成的Set集合</li></ul><p>map没有iterator方法，遍历时可以用以上方法得到set或者Collection，再用他们的iterator方法，即可实现遍历。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">HashMap</span> <span class="variable">map1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map1.put(<span class="string">&quot;aa&quot;</span>,<span class="number">2</span>);</span><br><span class="line">        map1.put(<span class="string">&quot;cc&quot;</span>,<span class="number">3</span>);</span><br><span class="line">        map1.put(<span class="string">&quot;bb&quot;</span>,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历map1当中的key</span></span><br><span class="line">        <span class="type">Set</span> <span class="variable">keySet</span>  <span class="operator">=</span> map1.keySet();</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> keySet.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历map1当中的value</span></span><br><span class="line">        <span class="type">Collection</span> <span class="variable">collection</span> <span class="operator">=</span> map1.values();</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator1</span> <span class="operator">=</span> collection.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator1.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator1.next());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历map1当中的key-value对，方式一：</span></span><br><span class="line">        <span class="type">Set</span> <span class="variable">entrySet</span> <span class="operator">=</span> map1.entrySet();</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator2</span> <span class="operator">=</span> entrySet.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator2.hasNext())&#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> iterator2.next();</span><br><span class="line">            <span class="comment">//取出来的数据都是Entry类型</span></span><br><span class="line">            Map.Entry entry= (Map.Entry)o;</span><br><span class="line">            System.out.println(entry.getKey() + <span class="string">&quot;--&quot;</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//遍历map1当中的key-value对，方式二：</span></span><br><span class="line">    <span class="type">Set</span> <span class="variable">keySet1</span> <span class="operator">=</span> map1.keySet();</span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator3</span> <span class="operator">=</span> keySet1.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator3.hasNext())&#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">key</span> <span class="operator">=</span> iterator3.next();</span><br><span class="line">            <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> map1.get(key);</span><br><span class="line"></span><br><span class="line">            System.out.println(key + <span class="string">&quot;==&quot;</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/imgs/image-20220829170603182.png" alt="image-20220829170603182"></p><p>遍历的应用：将Map中的一条条数据取出来放到数据库中</p><h6 id="④常用方法总结"><a href="#④常用方法总结" class="headerlink" title="④常用方法总结"></a>④常用方法总结</h6><p><img src="/imgs/image-20220829171040578.png" alt="image-20220829171040578"></p><h5 id="M-Collections工具类"><a href="#M-Collections工具类" class="headerlink" title="M.Collections工具类"></a>M.Collections工具类</h5><p>Collections：操作Collection、Map的工具类</p><h6 id="①反转"><a href="#①反转" class="headerlink" title="①反转"></a>①反转</h6><p>**reverse(List)**：反转List中元素的顺序，该方法没有返回值</p><h6 id="②排序"><a href="#②排序" class="headerlink" title="②排序"></a>②排序</h6><ol><li>shuffle(List)：对List集合元素进行随机排序，该方法没有返回值</li><li>sort(List)：调用List元素里的comparTO方法对指定的List集合元素进行自然排序（即按升序排序）。</li><li>sort(List,Comparator)：根据指定的Comparator产生的顺序对List集合元素进行排序</li><li>swap(List,int,int)：将指定 list 集合中的 i 处元素和 j 处元素进行交换</li></ol><h6 id="③求最值"><a href="#③求最值" class="headerlink" title="③求最值"></a>③求最值</h6><ol><li>Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素。自然排序：调用的是集合中元素所在类的compareTo方法。</li><li>Object max(Collection，Comparator)：根据 Comparator 指定的顺序，返回给定集合中的最大元素</li><li>Object min(Collection)：根据元素的自然顺序，返回给定集合中的最小元素。自然排序：调用的是集合中元素所在类的compareTo方法。</li><li>Object min(Collection，Comparator)</li></ol><h6 id="④计算某元素出现的次数"><a href="#④计算某元素出现的次数" class="headerlink" title="④计算某元素出现的次数"></a>④计算某元素出现的次数</h6><p>**int frequency(Collection，Object)**：返回指定集合中指定元素的出现次数</p><h6 id="⑤复制"><a href="#⑤复制" class="headerlink" title="⑤复制"></a>⑤复制</h6><p>**void copy(List dest,List src)**：将src中的内容复制到dest中 </p><p><img src="/imgs/image-20220829204754982.png" alt="image-20220829204754982"></p><h6 id="⑥替换"><a href="#⑥替换" class="headerlink" title="⑥替换"></a>⑥替换</h6><p>**boolean replaceAll(List list，Object oldVal，Object newVal)**：使用新值替换List 对象的所有旧值</p><h6 id="⑦将线程不安全的集合变成线程安全集合"><a href="#⑦将线程不安全的集合变成线程安全集合" class="headerlink" title="⑦将线程不安全的集合变成线程安全集合"></a>⑦将线程不安全的集合变成线程安全集合</h6><p>Collections类中提供了多个synchronizedXxx( )方法，该方法可使将指定集合包装成线程安全的集合，从而可以解决多线程并发访问集合时的线程安全问题，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();<span class="comment">//list存在线程不安全问题</span></span><br><span class="line"><span class="comment">//返回的list1即为线程安全的List</span></span><br><span class="line"><span class="type">List</span> <span class="variable">list1</span> <span class="operator">=</span> Collections.synchronizedList(list);</span><br></pre></td></tr></table></figure><p>当多个线程共同操作list1时，就不再发生线程安全问题。</p><hr><h4 id="6、泛型"><a href="#6、泛型" class="headerlink" title="6、泛型"></a>6、泛型</h4><h5 id="A-引入"><a href="#A-引入" class="headerlink" title="A.引入"></a>A.引入</h5><p>​我们可以往集合中存放任何的数据类型，这其实是集合的一个缺点，就比如：用集合去存储学生的成绩，在添加数据的时候对数据的类型并没有要求，所以可以添加除int以外的类型数据，这并不是我们希望的，因此我们就引入了泛型。其作用是：表明该集合只能存放泛型中声明的数据类型，不能存放其他数据类型。</p><p>​泛型是jdk5.0的新特性。</p><h5 id="B-在集合中使用泛型"><a href="#B-在集合中使用泛型" class="headerlink" title="B.在集合中使用泛型"></a>B.在集合中使用泛型</h5><ol><li><p>集合接口或集合类在jdk5.0时都修改为带泛型的结构。 —&gt;前提。如果没有在定义接口或类时声明为带泛型的结构，那么接口内或类内就不能使用泛型。</p></li><li><p>在实例化集合类时，可以指明具体的泛型类型（只能写类 类型，不能写基本数据类型，要想用基本数据类型—&gt;包装类）</p></li><li><p>指明完以后，在集合类或接口中凡是定义类或接口时，内部结构（如：方法、构造器、属性等）使用到类的泛型的位置，都指定为实例化的泛型类型。如：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">&quot;hhhhh&quot;</span>);<span class="comment">//此时add方法中的参数变为(String s1),不再是(Object obj)</span></span><br></pre></td></tr></table></figure></li><li><p>如果实例化时，没有指明泛型的类型（即没使用泛型时）。默认类型为 Java.lang.Object 类型。</p></li></ol><h6 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h6><ol><li><p>如果集合中使用泛型声明为Integer，则使用add方法时，仍可以这么写：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list1.add(<span class="number">12</span>);<span class="comment">//仍可以写12</span></span><br></pre></td></tr></table></figure></li><li><p>集合、比较器（Comparable、Comparator）都可以使用泛型</p></li><li><p>添加了泛型之后，集合的遍历操作与原来的操作一样，直接调用对应的方法，然后“alt + enter”自动补充即可。生成的代码会有点不同（21行代码）</p></li></ol>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    list.add(<span class="string">&quot;hhhhh&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;123&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//**********************************</span></span><br><span class="line">    HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">&quot;Tom&quot;</span>,<span class="number">12</span>);</span><br><span class="line">    map.put(<span class="string">&quot;Jerry&quot;</span>,<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entrySet = map.entrySet();</span><br><span class="line">    Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iterator1 = entrySet.iterator();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (iterator1.hasNext())&#123;</span><br><span class="line">        Map.Entry&lt;String, Integer&gt; entry = iterator1.next();</span><br><span class="line">        <span class="comment">//现在不用将next方法得到的对象强转为Entry类型</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">        System.out.println(key + <span class="string">&quot;---&quot;</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <img src="/imgs/image-20220830170745289.png" alt="image-20220830170745289"></p><h5 id="C-自定义泛型结构–泛型类"><a href="#C-自定义泛型结构–泛型类" class="headerlink" title="C.自定义泛型结构–泛型类"></a>C.自定义泛型结构–泛型类</h5><p>​自定义泛型结构有：泛型类、泛型接口、泛型方法</p><h6 id="①实现方式"><a href="#①实现方式" class="headerlink" title="①实现方式"></a>①实现方式</h6><p>​在类名后面加上”<T>“即可，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&lt;T&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​如果定义了泛型类，实例化没有指明类的泛型，则认为此泛型类型为Object类型。要求：如果定义了类是带泛型的，建议在实例化时要指明类的类型。  </p><h6 id="②继承关系中的泛型"><a href="#②继承关系中的泛型" class="headerlink" title="②继承关系中的泛型"></a>②继承关系中的泛型</h6><p>​如果父类为泛型类，则子类有两种情况：</p><p>​情况1：子类明确父类中泛型的类型，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&lt;T&gt;&#123;</span><br><span class="line">    String name;</span><br><span class="line">    T order;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将父类中的泛型明确为String，此时属性order的类型为String</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Man</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&lt;String&gt;&#123;<span class="comment">//Man就不属于泛型类，那么Man再实例化的时候就不能写泛型，只能像普通的类那样实例化</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​情况2：子类也无法确定父类中的泛型具体是哪种类 类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&lt;T&gt;&#123;</span><br><span class="line">    String name;</span><br><span class="line">    T order;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Man</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Person</span>&lt;T&gt;&#123;<span class="comment">//Man属于泛型类</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Man&lt;String&gt; m = <span class="keyword">new</span> <span class="title class_">Man</span>&lt;&gt;();<span class="comment">//此时order为String类型</span></span><br></pre></td></tr></table></figure><p>​</p><h6 id="③细节说明"><a href="#③细节说明" class="headerlink" title="③细节说明"></a>③细节说明</h6><ol><li><p>泛型类可能有多个参数，此时应将多个参数一起放在尖括号内。比如：&lt;E1,E2,E3&gt;。实例化时应都要指明其具体的泛型类型。</p></li><li><p>泛型类的构造器如下：public GenericClass(){}。而下面是错误的：public GenericClass&lt; E&gt;(){}</p></li><li><p>泛型不同的引用不能相互赋值。</p><p> <img src="/imgs/image-20220831102630840.png" alt="image-20220831102630840"></p><p> 因为赋值之后，list1指向的是list2堆空间中的对象，当调用list1的add方法时添加的是String类型数据，而list2里只能存Integer类型数据，这就发生了冲突，所以不能赋值。</p></li><li><p>在普通的静态方法中不能使用类的泛型。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(T order)</span>&#123;<span class="comment">//报错</span></span><br><span class="line">System.out.println(order);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 因为泛型类型是在创建对象的时候再确定的，而静态方法是在类的加载的时候就加载的，这时候就需要用到这里的泛型数据，而泛型类型没确定，就不行。</p></li><li><p>异常体系结构下的类，不能是泛型类。</p></li><li><p>try-catch，catch后面的小括号里不能使用泛型。</p></li><li><p>如果用泛型造个数组，得这样写：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误:</span></span><br><span class="line">T[] arr1 = <span class="keyword">new</span> <span class="title class_">T</span>[<span class="number">10</span>];</span><br><span class="line"><span class="comment">//正确</span></span><br><span class="line">T[] arr = (T[]) <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">10</span>];<span class="comment">//只能往该数组里存放T或T的子类数据</span></span><br></pre></td></tr></table></figure></li><li><p>继承关系中的泛型详解</p><p> <img src="/imgs/image-20220831105827121.png" alt="image-20220831105827121"></p><p> <img src="/imgs/image-20220831110112288.png" alt="image-20220831110112288"></p><p> <strong>A、B是子类自己的泛型</strong></p></li></ol><h6 id="④应用"><a href="#④应用" class="headerlink" title="④应用"></a>④应用</h6><ol><li>当类中的某个属性的类型不确定时，就可以使用泛型类，如：</li></ol>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&lt;T&gt;&#123;</span><br><span class="line">String name;</span><br><span class="line">    T personT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>对数据库中的表进行操作的类中可以声明为泛型类，因为该类可能操作不同的表，每个表又不同，所以就用泛型，让子类去继承该类时再明确泛型类型（即明确操作的是哪种表）。</p></li><li></li></ol><hr><h5 id="D-自定义泛型结构–泛型接口"><a href="#D-自定义泛型结构–泛型接口" class="headerlink" title="D.自定义泛型结构–泛型接口"></a>D.自定义泛型结构–泛型接口</h5><h6 id="①实现方式-1"><a href="#①实现方式-1" class="headerlink" title="①实现方式"></a>①实现方式</h6><p>​在接口名后面加上“<T>“即可，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Dog</span>&lt;T&gt;&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="E-自定义泛型结构–泛型方法"><a href="#E-自定义泛型结构–泛型方法" class="headerlink" title="E.自定义泛型结构–泛型方法"></a>E.自定义泛型结构–泛型方法</h5><h6 id="①定义"><a href="#①定义" class="headerlink" title="①定义"></a>①定义</h6><p>​泛型方法：在方法中出现了泛型的结构，泛型参数与类的泛型参数没有任何关系。换句话说，泛型方法属于的类是不是泛型类都没有关系。</p><h6 id="②格式"><a href="#②格式" class="headerlink" title="②格式"></a>②格式</h6><p>​在返回值类型前加上“<T>”即可。</p><h6 id="③使用"><a href="#③使用" class="headerlink" title="③使用"></a>③使用</h6><p>​调用泛型方法时，往该泛型方法中传递的参数的类型决定了该泛型方法泛型的类型。</p><h6 id="④注意"><a href="#④注意" class="headerlink" title="④注意"></a>④注意</h6><p>​泛型方法，可以声明为静态的。原因：泛型参数是在调用方法时确实的，并非在实例化时确定。</p><h5 id="F-泛型在继承方面的体现"><a href="#F-泛型在继承方面的体现" class="headerlink" title="F.泛型在继承方面的体现"></a>F.泛型在继承方面的体现</h5><p>①</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//虽然类A是类B的父类，但是G&lt;A&gt; 和 G&lt;B&gt;二者不具备字父类关系，二者是并列关系。G可以是任意的数据类型，如：集合</span></span><br><span class="line">ArrayList&lt;Person&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">ArrayList&lt;Man&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Man&gt;();</span><br><span class="line">list = list1;<span class="comment">//不具备子父类关系，不能相互赋值</span></span><br></pre></td></tr></table></figure><p>②</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类A是类B的父类父接口，A&lt;G&gt; 是 B&lt;G&gt;的父类或父接口，泛型的类型要一样</span></span><br><span class="line">HashSet&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">LinkedHashSet&lt;String&gt; set1 = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">set = set1;<span class="comment">//存在子父类关系，可以赋值</span></span><br></pre></td></tr></table></figure><h5 id="E-通配符的使用"><a href="#E-通配符的使用" class="headerlink" title="E.通配符的使用"></a>E.通配符的使用</h5><h6 id="①定义-1"><a href="#①定义-1" class="headerlink" title="①定义"></a>①定义</h6><p>​通配符：?</p><p>类A是类B的父类，G<A> 和 G<B> 是并列关系，二者共同的父类是：G&lt;?&gt;</p><h6 id="②应用例子"><a href="#②应用例子" class="headerlink" title="②应用例子"></a>②应用例子</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span>&#123;</span><br><span class="line">    ArrayList&lt;Person&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    ArrayList&lt;Man&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">12</span>));</span><br><span class="line">    printList(list);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历集合</span></span><br><span class="line"><span class="comment">//把ArrayList&lt;?&gt;替换为List&lt;?&gt;也行</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printList</span><span class="params">(ArrayList&lt;?&gt; list)</span>&#123;</span><br><span class="line">    Iterator&lt;?&gt; iterator = list.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="③使用-1"><a href="#③使用-1" class="headerlink" title="③使用"></a>③使用</h6><p>A.对于List&lt;?&gt;就不能向其内部添加数据，除了添加null之外。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;?&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list2.add(<span class="string">&quot;sf&quot;</span>);<span class="comment">//报错</span></span><br></pre></td></tr></table></figure><p>B.允许读取List&lt;?&gt;的对象list2中的元素，读取的数据类型为Object类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Person&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">12</span>));</span><br><span class="line">List&lt;?&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list2 = list;</span><br><span class="line">System.out.println(list2.get(<span class="number">0</span>));<span class="comment">//Person&#123;name=&#x27;Tom&#x27;, age=12&#125;</span></span><br></pre></td></tr></table></figure><h6 id="④有限制条件的通配符"><a href="#④有限制条件的通配符" class="headerlink" title="④有限制条件的通配符"></a>④有限制条件的通配符</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有限制条件的通配符：</span></span><br><span class="line">? <span class="keyword">extends</span> <span class="title class_">A</span></span><br><span class="line">? <span class="built_in">super</span> A</span><br></pre></td></tr></table></figure><p>G&lt;? extends A&gt; 可以作为G<A>和G<B>的父类，其中B是A的子类。extends相当于 “&lt;&#x3D;”，G为带泛型的任意一种数据类型，如：集合</p><p>G&lt;? superA&gt; 可以作为G<A>和G<B>的父类，，其中B是A的父类。super相当于 “&gt;&#x3D;”，G为带泛型的任意一种数据类型，如：集合</p><p><strong>A</strong>.对于G&lt;? extends A&gt;声明的对象，我们是可以获取该对象里的数据的，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Person&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">12</span>));</span><br><span class="line">List&lt;? <span class="keyword">extends</span> <span class="title class_">Person</span>&gt; list2 = <span class="literal">null</span>;</span><br><span class="line">list2 = list;</span><br><span class="line">System.out.println(list2.get(<span class="number">0</span>));<span class="comment">//Person&#123;name=&#x27;Tom&#x27;, age=12&#125;</span></span><br></pre></td></tr></table></figure><p>对于G&lt;? superA&gt; 声明的对象也一样可以获取该对象里的数据。</p><p><strong>B</strong>.</p><p>对于**G&lt;? extends A&gt;**声明的对象，我们不能对其进行添加数据操作，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Person&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">12</span>));</span><br><span class="line">List&lt;? <span class="keyword">extends</span> <span class="title class_">Person</span>&gt; list2 = <span class="literal">null</span>;</span><br><span class="line">list2 = list;</span><br><span class="line"><span class="comment">//报错</span></span><br><span class="line">list2.add();<span class="comment">//无论括号里放什么数据都会报错</span></span><br></pre></td></tr></table></figure><p>对于<strong>G&lt;? super A&gt;</strong> 声明的对象，我们可以对其进行添加数据的操作，但只能添加类A或类A的子类的数据，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Person&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;? <span class="built_in">super</span> Person&gt; list3 = <span class="literal">null</span>;</span><br><span class="line">list3 = list;</span><br><span class="line">list3.add(<span class="keyword">new</span> <span class="title class_">Man</span>());</span><br></pre></td></tr></table></figure><h6 id="⑤其他"><a href="#⑤其他" class="headerlink" title="⑤其他"></a>⑤其他</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &lt;T extend Person&gt;&#123;</span><br><span class="line">    T order;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里的T只能取Person类或Person类的子类</span></span><br><span class="line"><span class="comment">//如果Person是一个接口，那T只能是该接口的实现类</span></span><br></pre></td></tr></table></figure><hr><h4 id="7、IO流"><a href="#7、IO流" class="headerlink" title="7、IO流"></a>7、IO流</h4><h5 id="A-File类的使用"><a href="#A-File类的使用" class="headerlink" title="A.File类的使用"></a>A.File类的使用</h5><h6 id="①概述-4"><a href="#①概述-4" class="headerlink" title="①概述"></a>①概述</h6><ul><li>File类的一个对象，代表一个文件或一个文件目录（俗称：文件夹）</li><li>File类声明在java.io包下</li></ul><p>​</p><h6 id="②预备知识"><a href="#②预备知识" class="headerlink" title="②预备知识"></a>②预备知识</h6><p>​<strong>路径</strong>：</p><ul><li><p>相对路径：相较于某个路径下，指明的路径，如：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>绝对路径：包含盘符在内的文件或文件目录的路径</p></li></ul><p>说明：</p><ol><li><p><strong>IDEA</strong>中：如果大家开发使用JUnit中的单元测试方法测试，相对路径即为当前Module下。如果大家使用main()测试，相对路径即为当前的Project下。</p></li><li><p><strong>Eclipse</strong>中：不管使用单元测试方法还是使用mian()测试，相对路径都是当前的Project下。</p></li><li><p>如何准确的写出文件路径？</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.获取当前代码所在路径</span></span><br><span class="line">System.out.println(System.getProperty(<span class="string">&quot;user.dir&quot;</span>));</span><br><span class="line"><span class="comment">//2.打开显示的路径，在此路径下找到要找的文件</span></span><br><span class="line"><span class="comment">//3.复制找到文件的路径，但不包括1中显示的路径。</span></span><br><span class="line"><span class="comment">//4.完成</span></span><br></pre></td></tr></table></figure></li></ol><p>​<strong>路径分隔符和系统的关系</strong></p><ul><li>windows和DOS系统默认使用“ \ ” 来表示</li><li>UNIX和URL使用“ &#x2F; ” 来表示</li><li>补充：Java中路径分隔符用两个 “ \ ” 表示，目的是区分Java中的转译符” \ “</li></ul><h6 id="③如何实例化"><a href="#③如何实例化" class="headerlink" title="③如何实例化"></a>③如何实例化</h6><p>​有以下几种构造器：</p><p>​A.<strong>File(String filePath)</strong></p><p>​filePath：可以是相对路径，也可以是绝对路径</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(hello.txt);</span><br><span class="line"><span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(D:\\hello.txt);</span><br><span class="line"><span class="comment">//此时造了两个File对象，还没涉及到对文件进行操作，所以填入的文件不存在也没事。</span></span><br></pre></td></tr></table></figure><p>​B.<strong>File(String parentPath,String childPath)</strong></p><p>​parentPath：该文件或文件夹的上一级目录</p><p>​childPath：该文件夹名或文件名</p><p>​C.<strong>File(File parentFile,String childPath)</strong></p><p>​parentFile：该文件或文件夹的上一级目录</p><p>​childPath：该文件夹名或文件名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\java\\exer&quot;</span>);</span><br><span class="line"><span class="type">File</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(f1,<span class="string">&quot;file.txt&quot;</span>);</span><br><span class="line"><span class="comment">//该file.txt文件的绝对路径为：D:\java\exer\file.txt</span></span><br></pre></td></tr></table></figure><h5 id="B-File类的常用方法"><a href="#B-File类的常用方法" class="headerlink" title="B.File类的常用方法"></a>B.File类的常用方法</h5><p>​以下方法是内存层面的调用，还没涉及到硬盘层面的调用。</p><h6 id="①获取相应信息"><a href="#①获取相应信息" class="headerlink" title="①获取相应信息"></a>①获取相应信息</h6><ul><li><p>**public String getAbsolutePath()**：获取绝对路径</p></li><li><p><strong>public String getPath()</strong> ：获取路径，显示的是你声明对象时指明的路径</p></li><li><p><strong>public String getName()</strong> ：获取名称</p></li><li><p>**public String getParent()**：获取上层文件目录路径。若无，返回null</p></li><li><p><strong>public long length()</strong> ：获取文件长度（即：字节数）。不能获取目录的长度。 只有真实存在的文件才能获取到长度，不然返回默认值：0。</p></li><li><p><strong>public long lastModified()</strong> ：获取最后一次的修改时间，毫秒值。只有真实存在的文件或文件目录才返回相应的值，否则返回默认值：0。</p><p>  下面两个方法适用于文件目录：（<strong>且指定的目录要真实存在，不然报错</strong>）</p></li><li><p><strong>public String[] list()</strong> ：获取指定目录下的所有文件或者文件目录的名称数组</p></li><li><p><strong>public File[] listFiles()</strong> ：获取指定目录下的所有文件或者文件目录的File数组（绝对路径）</p></li></ul><h6 id="②重命名功能"><a href="#②重命名功能" class="headerlink" title="②重命名功能"></a>②重命名功能</h6><p>​**public boolean renameTo(File dest)**：把文件重命名为指定的文件路径</p><p>​比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"><span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\java\\hi.txt&quot;</span>);</span><br><span class="line">file1.renameTo(file2);</span><br><span class="line"><span class="comment">//要想保证返回true，需要file1在硬盘中是存在的，且file2不能在硬盘中存在</span></span><br></pre></td></tr></table></figure><p>​<strong>说明</strong>：</p><ol><li>file1、file2中的路径是相对路径、还是绝对路径，都没有关系。</li><li>运行的效果是：根据file2的路径在硬盘中创建相应的文件，然后把hello.txt里的内容复制到file2的那个文件里，最后hello.txt文件被删除。</li></ol><h6 id="③判断功能"><a href="#③判断功能" class="headerlink" title="③判断功能"></a>③判断功能</h6><ul><li>**public boolean isDirectory()**：判断是否是文件目录</li><li><strong>public boolean isFile()</strong> ：判断是否是文件</li><li><strong>public boolean exists()</strong> ：判断硬盘上是否存在该文件或文件目录</li><li><strong>public boolean canRead()</strong> ：判断是否可读</li><li><strong>public boolean canWrite()</strong> ：判断是否可写</li><li><strong>public boolean isHidden()</strong> ：判断是否隐藏</li></ul><p>如果在硬盘中没有该文件或文件目录，这些方法都会返回默认值：false</p><h6 id="④在硬盘中创建对应的文件或文件目录"><a href="#④在硬盘中创建对应的文件或文件目录" class="headerlink" title="④在硬盘中创建对应的文件或文件目录"></a>④在硬盘中创建对应的文件或文件目录</h6><ul><li><strong>public boolean createNewFile()</strong> ：创建文件。若文件存在，则不创建，返回false。该方法本身会报异常，我们需要对其进行throws或try-catch-finally</li><li><strong>public boolean mkdir()</strong> ：创建文件目录。如果此文件目录存在，就不创建了。如果此文件目录的上层目录不存在，也不创建。 </li><li><strong>public boolean mkdirs()</strong> ：创建文件目录。如果上层文件目录不存在，一并创建。</li></ul><h6 id="⑤删除硬盘中的文件或文件目录"><a href="#⑤删除硬盘中的文件或文件目录" class="headerlink" title="⑤删除硬盘中的文件或文件目录"></a>⑤删除硬盘中的文件或文件目录</h6><ul><li>**public boolean delete()**：删除文件或者文件夹</li></ul><p>注意：Java中的删除不走回收站。 要删除一个文件目录，请注意该文件目录内不能包含文件或者文件目录。</p><h6 id="⑥总结"><a href="#⑥总结" class="headerlink" title="⑥总结"></a>⑥总结</h6><ol><li>File类中涉及到关于文件或文件目录的创建、删除、重命名、获取修改时间、获取文件大小等方法，并未涉及到写入或读取文件内容的操作。如果需要读取或写入文件内容，必须使用IO流来完成。</li><li>后续File类的对象常作为参数传递到流的构造器中，指明要读取或写入的文件。</li></ol><h5 id="C-IO流原理"><a href="#C-IO流原理" class="headerlink" title="C.IO流原理"></a>C.IO流原理</h5><h6 id="①概述-5"><a href="#①概述-5" class="headerlink" title="①概述"></a>①概述</h6><ul><li><p>I&#x2F;O即：Input&#x2F;Output。数据从一个地方传送到另一个地方，就形成数据流，但我们通常不叫数据流，而是叫I&#x2F;O流。</p></li><li><p>输入：读取外部数据（磁盘、光盘等存储设备的数据）到程序（内存）中。</p><p>  输出：将程序（内存）数据输出到磁盘、光盘等存储设备中。</p></li></ul><h6 id="②流的分类"><a href="#②流的分类" class="headerlink" title="②流的分类"></a>②流的分类</h6><ul><li><p>按操作数据单位不同分为：字节流(8 bit)，字符流(16 bit)。</p><ul><li>字节流：一个字节一个字节地存储数据，存的是二进制数据。适用于：非文本文件，如：照片、视频等。</li><li>字符流：读取的是一个一个字符（char），存的也是一个一个char(字符)，适用于从文本文件中读取数据。</li></ul></li><li><p>按数据流的流向不同分为：输入流，输出流。</p></li><li><p>按流的角色的不同分为：节点流，处理流。</p><ul><li>节点流：直接作用在文件上的流叫节点流，即：可以直接处理File对象的流。</li><li>处理流：作用在已有流基础上的流叫处理流</li></ul><p>  <img src="/imgs/image-20220902142927450.png" alt="image-20220902142927450"></p></li></ul><h6 id="③四个抽象基类"><a href="#③四个抽象基类" class="headerlink" title="③四个抽象基类"></a>③四个抽象基类</h6><p>​Java的IO流共涉及40多个类，这些类都是从如下4个抽象基类派生的。（基类：基础类的意思）。</p><p>​InputStream、OutputStream属于操作字节流的类，Reader、Writer属于操作字符流的类。</p><p><img src="/imgs/image-20220902144531195.png" alt="image-20220902144531195"></p><p>​</p><h6 id="④IO流体系结构"><a href="#④IO流体系结构" class="headerlink" title="④IO流体系结构"></a>④IO流体系结构</h6><p><img src="/imgs/image-20220902153228642.png" alt="image-20220902153228642"></p><p>​注：第二行中的流属于节点流，第二行及以后的流属于处理流。蓝色标注的流属于重点学习和掌握的。</p><p>​简化版：</p><p><img src="/imgs/image-20220902154142103.png" alt="image-20220902154142103"></p><p>​补充：除了RandomAccessFile不是由四个基类派生而来的，其他的流都是由四个派生基类继承来的。</p><h5 id="E-节点流的使用"><a href="#E-节点流的使用" class="headerlink" title="E.节点流的使用"></a>E.节点流的使用</h5><h6 id="①如何从硬盘读入数据"><a href="#①如何从硬盘读入数据" class="headerlink" title="①如何从硬盘读入数据"></a>①如何从硬盘读入数据</h6><p>​<strong>实现步骤：</strong></p><p>​(读数据和写数据的操作步骤都是下面的4步，由于使用的流不一样，步骤2会不同；是读还是写，导致步骤3不一样，其他地方都一样)</p><ol><li><p>造File类的对象，指明要操作的文件。文件一定要存在。</p></li><li><p>根据需要选择具体的流，然后造流的对象，File类的对象作为参数传到流的构造器中。</p></li><li><p>数据的读入，用流的对象取调用read方法。read()：返回读入的一个字符，如果到达文件末尾，返回-1。</p></li><li><p>流的关闭操作。流的对象调用close()方法</p><p> <strong>注意：</strong></p></li></ol><ul><li>造流的对象和调用read方法时，都会抛异常，因此需要用try-catach-finally来处理。用try将这些代码包起来。快捷键：选中需要抱起来的代码   –&gt; alt+shift+z –&gt; try-catch-finally</li><li>调用close()方法时，也会抛异常。首先将关闭流的操作放在finally里（因为流声明完，不再使用时，不关闭会出现内存泄漏，使用<strong>必须关闭</strong>），然后再将close操作用try-catch-finally包起来，最后在close这行代码的上面加上判断语句（判断当前流的对象是否为null）。</li><li>读入的文件一定要存在，否则就会报FileNotFoundException</li></ul><p>​<strong>如何形象理解上面的三个实现步骤：</strong></p><p>​比如我们需要从一个水池里取水，怎么取呢？首先我们得知道水池的位置（即造File对象的步骤），然后我们就要造水管了(即：造流的对象)，但水管具体要安装在哪，我们就需要把File类的对象传到流的构造器中告诉它水管安装在哪，然后就开闸放水（即调用read方法）。</p><h6 id="②读入：read方法"><a href="#②读入：read方法" class="headerlink" title="②读入：read方法"></a>②读入：read方法</h6><ol><li>**read()**：每次读取一个char或一个byte数据，如果到达文件末尾，返回-1。</li><li><strong>read(char[] a)</strong> \ <strong>read(byte[] a)<strong>：将文件当中的内容读到数组a当中，每次读的长度为数组的长度，下一次读取时将原有的内容覆盖掉，而不是将数组中原有的内容先清除掉再添加。该方法返回的是，放入数组中字符\字节的个数，当返回-1时，代表读取完毕。</strong>数组a的长度一般为1024</strong>。如：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(file);</span><br><span class="line"><span class="type">char</span>[] a = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> length;</span><br><span class="line"><span class="keyword">while</span>((length = fr.read(a)) != -<span class="number">1</span>)&#123;<span class="comment">//read会抛异常，需要try-catch-finally，这里省略。</span></span><br><span class="line">    <span class="comment">//方式一：</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; length;i++)&#123;</span><br><span class="line">        System.out.print(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//方式二：</span></span><br><span class="line">    <span class="comment">//String str = new String(a,0,length);//从数组a的0索引处开始取length个数据</span></span><br><span class="line">    <span class="comment">//System.out.print(str);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="③从内存写入数据到硬盘"><a href="#③从内存写入数据到硬盘" class="headerlink" title="③从内存写入数据到硬盘"></a>③从内存写入数据到硬盘</h6><p>​<strong>实现步骤</strong>：</p><ol><li>造File类的对象，指明要写入到的文件</li><li>根据需要选择具体的流，然后造流的对象，File类的对象作为参数传到流的构造器中。</li><li>数据的写入，用流的对象调用write()方法。</li><li>流的关闭操作。流的对象调用close()方法</li></ol><p>​<strong>说明</strong>：</p><ul><li>输出操作，对应的File可以不存在。并不会报异常。File的上级目录一定要存在，不然报错。</li><li>File对应的硬盘中的文件如果不存在，在输出的过程中，会自动创建此文件。</li><li>File对应的硬盘中的文件如果存在：<ul><li>如果流使用的构造器是：FileWriter(file,false) &#x2F; FileWriter(file)：对原有文件的覆盖。 &#x2F;&#x2F;第2个参数是指是否能追加内容</li><li>如果流使用的构造器是：FileWriter(file,true)：不会对原有文件覆盖，而是在原有文件基础上追加内容。</li></ul></li></ul><h6 id="④写出：write方法"><a href="#④写出：write方法" class="headerlink" title="④写出：write方法"></a>④写出：write方法</h6><p>​**write(String s)**：将字符串s写入到硬盘中</p><p>​**write(char[] a,int index,length)**：从数组a中索引为index的位置开始取长度为：length的数据写入到硬盘中。</p><h6 id="⑤注意"><a href="#⑤注意" class="headerlink" title="⑤注意"></a>⑤注意</h6><ol><li>对于文本文件（.txt，.java，.c，.cpp），使用字符流（ Reader、Writer）处理。字符流不能处理字节数据。</li><li>）对于非文本文件（.jpg，.mp3，.mp4，.avi，.doc，.ppt，……）使用字节流（InputStream、OutputStream）处理。用字节流去实现文本文件的复制是没问题的，但在复制过程中对内容进行输出就可能出现乱码。</li></ol><h6 id="⑥补充"><a href="#⑥补充" class="headerlink" title="⑥补充"></a>⑥补充</h6><p>​节点流的构造器除了有放File类对象的构造器，还有放String的构造器。</p><p>​放String的构造器，以FileReader为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"><span class="comment">//传的是该文件的相对路径或绝对路径。</span></span><br><span class="line"><span class="comment">//这种声明方式实际上也是造了一个File类的对象，然后将此对象放到FileReader构造器中。</span></span><br></pre></td></tr></table></figure><h5 id="F-缓冲流"><a href="#F-缓冲流" class="headerlink" title="F. 缓冲流"></a>F. 缓冲流</h5><h6 id="①概述-6"><a href="#①概述-6" class="headerlink" title="①概述"></a>①概述</h6><p>​缓冲流属于处理流的一种。处理流：对现有流进行包装的流，其作用在现有流上。</p><p>​缓冲流：提高流的读写效率，开发中常用缓冲流。</p><p><img src="/imgs/image-20220903130413372.png" alt="image-20220903130413372"></p><h6 id="②缓冲流的使用"><a href="#②缓冲流的使用" class="headerlink" title="②缓冲流的使用"></a>②缓冲流的使用</h6><p>​<strong>用缓冲流实现读写操作，实现步骤</strong>：</p><ol><li>造File类对象，指明要读入 (或写入)的文件</li><li>造相应的节点流的对象，把File类的对象作为参数传递到节点流的构造器中</li><li>根据节点流的类型选择对应的缓冲流并造其对象，把上面节点流的对象作为参数传递到缓冲流的构造器中。</li><li>用缓冲流的对象调用read()方法（或write()方法）。</li><li>流的关闭。要求：先关外层的流，再关内层的流。同一层的流，先关哪个都行。<ul><li>说明：关闭外层流的同时，内层流也会自动的进行关闭。关于内层流的关闭，我们可以省略。</li></ul></li></ol><p>​注意：</p><ul><li>造流的对象、调用read()、调用write()都会抛异常，所以要用try-catch-finally来处理。将步骤1-4用try包起来。流的关闭操作放在finally里。</li></ul><p>​<strong>以上实现步骤的形象理解</strong>：</p><p>​我们需要从一个池子中快速地把水抽出来。首先，我们得知道水池的位置（即造File类的对象，指明池子的位置），然后由于缓冲流是作用在现有流的基础上，所以得造节点流的对象（就相当于造了根水管），接着把File类的对象传到节点流的构造器中（即指明水管安装的位置），再接着造缓冲流的对象（相当于弄了台增压水泵），把节点流的对象作为参数传递到缓冲流的构造器中（相当于告诉增压水泵安装到哪根水管）。这些步骤执行完后，用缓冲流的对象调用read()方法（或write()方法）。</p><h6 id="③readLine"><a href="#③readLine" class="headerlink" title="③readLine()"></a>③readLine()</h6><p>​<strong>BufferedReader</strong>中提供了一个**readLine()**方法，该方法每次从文件中读取一行数据，并以String的形式返回。当读到文件末尾时，返回null。</p><p>​注意：</p><ul><li>该方法提高流的对象调用</li><li>该方法返回的内容不包含换行符。如果想换行，可以用流的对象调用newLine()，实现换行操作。</li></ul><h6 id="④为什么缓冲流能提高速度"><a href="#④为什么缓冲流能提高速度" class="headerlink" title="④为什么缓冲流能提高速度"></a>④为什么缓冲流能提高速度</h6><p>​缓冲流内部提供了一个大小为8192个字节（8kb）的缓冲区，每次从文件中读取的数据都会先放在缓冲区中，当存放的容量达到8192时，就会调用flush()方法将缓冲区中的内容写出到另一个文件并清空缓冲区。这样就减少了与文件的交互次数，从而提高了读写效率。</p><h5 id="G-转换流"><a href="#G-转换流" class="headerlink" title="G.转换流"></a>G.转换流</h5><h6 id="①概述-7"><a href="#①概述-7" class="headerlink" title="①概述"></a>①概述</h6><ul><li><p>转换流是处理流中的一种。</p></li><li><p>转换流：提供了在字节流和字符流之间的转换。</p></li><li><p>Java中提供了两个转换流：</p><ul><li>InputStreamReader：将一个字节的输入流转换为字符的输入流</li><li>OutputStreamWriter：将一个字符的输出流转换为字节的输出流</li><li>上面两个流属于字符流</li><li>这两个流<strong>只能操作文本文件。</strong></li></ul></li><li><p>解码：字节、字节数组 —&gt; 字符数组、字符串</p><p>  编码：字符数组、字符串 —&gt; 字节、字节数组</p></li></ul><h6 id="②InputStreamReader"><a href="#②InputStreamReader" class="headerlink" title="②InputStreamReader"></a>②InputStreamReader</h6><p>​InputStreamReader的使用，实现了字节的输入流到字符的输入流的转换</p><p>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;dbcp.txt&quot;</span>);</span><br><span class="line"><span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(fis);<span class="comment">//使用系统默认的字符集</span></span><br><span class="line"><span class="comment">//InputStreamReader isr = new InputStreamReader(fis,&quot;UTF-8&quot;);//参数2指明了字符集，集体使用哪个字符集，取决于文件dbcp.txt保存时使用的字符集</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>[] cbuf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"><span class="keyword">while</span>((len = isr.read(cbuf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(cbuf,<span class="number">0</span>,len);</span><br><span class="line">    System.out.print(str);</span><br><span class="line">&#125;</span><br><span class="line">isr.close();</span><br><span class="line"><span class="comment">//注意：此代码还没有用try-catch-finally进行异常处理</span></span><br></pre></td></tr></table></figure><h6 id="②OutputStreamWriter"><a href="#②OutputStreamWriter" class="headerlink" title="②OutputStreamWriter"></a>②OutputStreamWriter</h6><p><img src="/imgs/image-20220903214413204.png" alt="image-20220903214413204"></p><p>上述过程的代码实现：</p><p><img src="/imgs/image-20220903214048047.png" alt="image-20220903214048047"></p><p>​注意：上面代码并没有用try-catch-finally处理异常，自己写的时候要补上。</p><h5 id="H-字符集"><a href="#H-字符集" class="headerlink" title="H.字符集"></a>H.字符集</h5><h6 id="①编码表"><a href="#①编码表" class="headerlink" title="①编码表"></a>①编码表</h6><p>​计算机只能识别二进制数据，早期由来是电信号。为了方便应用计算机，让它可以识别各个国家的文字。就将各个国家的文字用数字来表示，并一一对应，形成一张表。这就是编码表。</p><h6 id="②常见编码表"><a href="#②常见编码表" class="headerlink" title="②常见编码表"></a>②常见编码表</h6><ul><li>ASCII：美国标准信息交换码。 用一个字节的7位可以表示。</li><li>ISO8859-1：拉丁码表。欧洲码表用一个字节的8位表示。</li><li>GB2312：中国的中文编码表。最多两个字节编码所有字符。兼容了ASCII，因为ASCII用一个字节就可以表示，不用用两个字节表示，这样可以节省空间。<ul><li>那怎么识别是一个字节表示一个字符还是两个字节表示一个字符呢？看字节中最左边的那位，如果是1，则表示它还有一个字节，即两个字节表示一个字符；如果是0，则一个字节表示一个字符。GBK也采用这种方式识别。</li></ul></li><li>GBK：中国的中文编码表升级，融合了更多的中文文字符号。最多两个字节编码。兼容了ASCII。</li><li>Unicode：国际标准码，融合了目前人类使用的所有字符。为每个字符分配唯一的字符码。所有的文字都用两个字节来表示。</li><li>UTF-8：变长的编码方式，可用1-4个字节来表示一个字符。（中文用3个字节存储。）UTF-8是Unicode的一种具体实现。</li></ul><h6 id="③启示"><a href="#③启示" class="headerlink" title="③启示"></a>③启示</h6><p>​客户端、浏览器  &lt;—&gt; 后台 &lt;—-&gt; 数据库</p><p>​为了保证不乱码，这三个部分都要统一字符集。 </p><h5 id="I-标准输入、输出流-了解"><a href="#I-标准输入、输出流-了解" class="headerlink" title="I.标准输入、输出流(了解)"></a>I.标准输入、输出流(了解)</h5><ul><li>标准输入、输出流是处理流中的一种。</li><li>in、out是System里的两个属性。</li><li>System.in和System.out分别代表了系统标准的输入和输出。</li><li>System.in：默认从键盘输入，字节流；System.out：默认从控制台（显示器）输出。</li><li>通过System类的setIn(InputStream is)，setOut(PrintStream ps)方法重新指定输入和输出的流。PrintStream是OutputStream的子类。</li></ul><h5 id="J-打印流-了解"><a href="#J-打印流-了解" class="headerlink" title="J.打印流(了解)"></a>J.打印流(了解)</h5><ul><li>打印流是处理流中的一种。</li><li>实现将基本数据类型的数据格式转化为字符串输出。</li><li>打印流：PrintStream（字节输出流）和PrintWriter（字符输出流）。</li><li>它们提供了一系列重载的print()和println()方法，用于多种数据类型的输出。为什么我们能通过print()就能接收不同类型的数据并输出，是因为调用了PrintStream中重载的print \ println方法。</li><li>System.out返回的是PrintStream的实例</li></ul><h6 id="①把控制台中输出的内容保存到文件"><a href="#①把控制台中输出的内容保存到文件" class="headerlink" title="①把控制台中输出的内容保存到文件"></a>①把控制台中输出的内容保存到文件</h6><p>​步骤：</p><ol><li>创建FileOutputStream的对象，构造器中放File类的对象或直接放文件的路径。（指明要写入的文件）</li><li>因为打印流属于处理流，创建PrintStream类的对象时，将FileOutputStream的对象放进去构造器中。</li><li>用 if 判断打印流的对象是否为null，不为null，则System.setOut(打印流对象);</li><li>接下来写你想写的内容。</li><li>流的关闭操作。</li></ol><p>注意：要用try-catch-finally将1-4包起来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">PrintStream</span> <span class="variable">pw</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;h.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//指明写入到的文件</span></span><br><span class="line">        pw = <span class="keyword">new</span> <span class="title class_">PrintStream</span>(fr,<span class="literal">true</span>);</span><br><span class="line">  <span class="comment">//创建打印输出流，设置为自动刷新模式（写入换行或&#x27;\n&#x27;时都会刷新输出缓冲区）</span></span><br><span class="line">        <span class="keyword">if</span> (pw != <span class="literal">null</span>)&#123;</span><br><span class="line">            System.setOut(pw);</span><br><span class="line">            <span class="comment">//把标准输出流（控制台输出）改成输出到指定文件</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="number">123</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pw != <span class="literal">null</span>)</span><br><span class="line">            pw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="K-数据流-了解"><a href="#K-数据流-了解" class="headerlink" title="K.数据流(了解)"></a>K.数据流(了解)</h5><h6 id="①概述-8"><a href="#①概述-8" class="headerlink" title="①概述"></a>①概述</h6><ul><li>数据流属于处理流的一种。</li><li>数据流：DataInputStream 和 DataOutputStream</li><li>分别“套接”在 InputStream 和 OutputStream 子类的流上。</li><li>数据流的作用：读取或写出基本数据类型的变量或字符串</li></ul><h6 id="②数据流中的方法"><a href="#②数据流中的方法" class="headerlink" title="②数据流中的方法"></a>②数据流中的方法</h6><p><img src="/imgs/image-20220904144442549.png" alt="image-20220904144442549"></p><h6 id="③数据流的使用"><a href="#③数据流的使用" class="headerlink" title="③数据流的使用"></a>③数据流的使用</h6><p>​练习：将内存中的字符串、基本数据类型的变量写出到文件中。</p><p>​注意：下面代码中并没用try-catch-finally对异常进行处理，写的时候要补上。</p><p>​打开写出的数据文件，里面乱码是正常的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//1.创建数据流的对象，DataOutputStream的构造器需要传一个OutputStream子类的对象</span></span><br><span class="line">    <span class="type">DataOutputStream</span> <span class="variable">dis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;data.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.写入操作</span></span><br><span class="line">    dis.writeUTF(<span class="string">&quot;Tom&quot;</span>);<span class="comment">//writeUTF(String s):写入字符串</span></span><br><span class="line">    dis.flush();<span class="comment">//调用flush()将内存中的数据写入到文件中</span></span><br><span class="line">    dis.writeInt(<span class="number">12</span>);</span><br><span class="line">    dis.flush();</span><br><span class="line">    dis.writeBoolean(<span class="literal">true</span>);</span><br><span class="line">    dis.flush();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//流的关闭</span></span><br><span class="line">    dis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p><p>​练习：将文件中存储的基本数据类型变量和字符串读取到内存中，然后再保存在变量中。</p><p>​注意：面代码中并没用try-catch-finally对异常进行处理，写的时候要补上。</p><p>​读数据的时候要与写数据时的顺序一样，不然报异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//1.造数据流的对象，其构造器中需要出入InputStream子类的对象</span></span><br><span class="line">    <span class="type">DataInputStream</span> <span class="variable">dis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;data.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.写数据的操作</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> dis.readUTF();</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> dis.readInt();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">c</span> <span class="operator">=</span> dis.readBoolean();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;name:&quot;</span> + s + <span class="string">&quot;ID:&quot;</span> + i + <span class="string">&quot;是否男&quot;</span> + c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.流的关闭</span></span><br><span class="line">    dis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="L-对象流"><a href="#L-对象流" class="headerlink" title="L.对象流"></a>L.对象流</h5><h6 id="①概述-9"><a href="#①概述-9" class="headerlink" title="①概述"></a>①概述</h6><p>​<strong>对象流</strong>：用于存储和读取<strong>基本数据类型</strong>数据或<strong>对象</strong>的处理流。它的强大之处是可以把Java中的对象写入到数据源（如：文件）中，也能把对象从数据源中还原回来。</p><p>​<strong>序列化</strong>：将内存中的Java对象保存到磁盘中或通过网络传输出去。使用ObjectOutputStream实现</p><p>​<strong>逆序列化</strong>：将磁盘文件中的对象还原为内存中的一个Java对象。使用ObjectInputStream实现</p><p>​<strong>对象流</strong>：<strong>ObjectInputStream</strong>、<strong>ObjectOutputStream</strong>，属于处理流的一种</p><p>​<strong>对象能序列化、逆序列化的前提是其所在类必须是可序列化的。</strong></p><p>​</p><h6 id="②对象序列化机制"><a href="#②对象序列化机制" class="headerlink" title="②对象序列化机制"></a>②对象序列化机制</h6><p>​允许把内存中的Java对象转换成平台无关的二进制流，从而允许把这种二进制流持久地保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点（序列化）。当其它程序获取了这种二进制流，就可以恢复成原来的Java对象（逆序列化）。</p><p>​实际上对象序列化机制就是描述了一下序列化和逆序列化。</p><h6 id="③对象流的使用"><a href="#③对象流的使用" class="headerlink" title="③对象流的使用"></a>③对象流的使用</h6><p>​A.ObjectOutputStream的使用</p><p>​实现步骤：</p><ol><li><p>造ObjectOutputStream对象。</p><p> 但该构造器需要传OutputStream的子类，因此造FileOutputStream的对象放进去。将要写入的文件放到FileOutputStream构造器中。</p></li><li><p>调用writeObject(要写入的对象)，将对象写入文件中</p></li><li><p>流的关闭</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.造ObjectOutputStream对象</span></span><br><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;object.dat&quot;</span>));</span><br><span class="line"><span class="comment">//2.写入数据</span></span><br><span class="line">oos.writeObject(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;123&quot;</span>));</span><br><span class="line">oos.flush();</span><br><span class="line"><span class="comment">//关闭流</span></span><br><span class="line">oos.close();</span><br></pre></td></tr></table></figure><p>注意：上面代码存在异常，需要try-catch-finally进行异常处理</p><p>​B.ObjectInputStream的使用</p><p>​实现步骤：</p><ol><li><p>造ObjectInputStream对象。</p><p> 但该构造器需要传InputStream的子类，因此造FileInputStream的对象放进去。将要读入的文件放到FileInputStream构造器中。</p></li><li><p>调用readObject()，从文件中读取对象</p></li><li><p>流的关闭</p></li></ol><p>​注意：上面代码存在异常，需要try-catch-finally进行异常处理</p><h6 id="④自定义类可序列化"><a href="#④自定义类可序列化" class="headerlink" title="④自定义类可序列化"></a>④自定义类可序列化</h6><p>​要想自定义类能够保存在磁盘或从磁盘读出到内存，该对象所在类必须是可序列化的。具体实现步骤为：</p><ol><li><p>需要实现接口：Serializable</p></li><li><p>当前类提供一个全局常量：serialVersionUID，该常量为Long型，值可以为随意的一个值。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1234567L</span>;</span><br></pre></td></tr></table></figure></li><li><p>除当前类需要实现Serializable接口外，还必须保证其内部所有属性也是可序列化的。（基本数据类型、String：本身就已经是可序列化）</p></li><li><p>补充：ObjectOutputStream和ObjectInputStream不能序列化static和transient修饰的成员变量。即：被这两个关键字修饰的属性其值是不能被保存到文件中的，当我们用ObjectInputStream去读这些属性时，读出来的是默认值。</p></li></ol><p>​为什么需要serialVersionUID？用于表识该对象属于哪个类。如果没有显示使用serialVersionUID，系统会根据类中的细节自动生成一个serialVersionUID，序列化的时候就把当时的serialVersionUID也存到磁盘中了；逆序列化的时候就拿着这个serialVersionUID去比对，如果修改了当前类的内容，类的serialVersionUID就会发生改变，此时对象中的serialVersionUID与类的serialVersionUID就对不上了，就会导致对象还原不回去。因此我们需要显示指明serialVersionUID。</p><hr><h5 id="M-随机存取文件流（了解）"><a href="#M-随机存取文件流（了解）" class="headerlink" title="M.随机存取文件流（了解）"></a>M.随机存取文件流（了解）</h5><h6 id="①概述-10"><a href="#①概述-10" class="headerlink" title="①概述"></a>①概述</h6><ul><li>RandomAccessFile直接继承于Java.lang.Object类，它没有继承那四个抽象基类。</li><li>RandomAccessFile实现了DataInput、DataOutput这两个接口，因此它既可以作为一个输入流，又可以作为一个输出流。</li></ul><h6 id="②RandomAccessFile的使用"><a href="#②RandomAccessFile的使用" class="headerlink" title="②RandomAccessFile的使用"></a>②RandomAccessFile的使用</h6><p>​<strong>构造器</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">RandomAccessFile</span><span class="params">(File file,String mode)</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">RandomAccessFile</span><span class="params">(String name,String mode)</span></span><br><span class="line"><span class="comment">//name:指明要写入或读入的文件，可以写文件的相对路径或文件的绝对路径（其本质上还是造了一个File类的对象）</span></span><br><span class="line"><span class="comment">//mode:指定RandomAccessFile的访问模式：见下图，普通的写操作选rw就行</span></span><br></pre></td></tr></table></figure><p><img src="/imgs/image-20220905141403405.png" alt="image-20220905141403405"></p><p>​使用例子：（注：下面代码没有用try-catch-finally对异常进行处理，写的时候要补上）<img src="/imgs/image-20220905142709003.png" alt="image-20220905142709003"></p><p>​虽然此类既可以是输入流，也可以是输出流。对于读写操作，我们还是得造两个对象来分别处理读操作、写操作。</p><h6 id="③说明"><a href="#③说明" class="headerlink" title="③说明"></a>③说明</h6><ul><li>进行写出操作时，如果该文件不存在，就会造一个新的文件。<ul><li>如果文件存在，则会对原有文件内容进行覆盖。（默认情况下，从头覆盖）</li></ul></li><li>write()：该方法实现的效果为对文件内容的覆盖（在文件原本存在的情况下）</li></ul><h6 id="④方法"><a href="#④方法" class="headerlink" title="④方法"></a>④方法</h6><ol><li><p>seek(long pos)：该方法的作用是将指针调到文件中角标为pos的位置，角标从0开始。<img src="/imgs/image-20220905150208025.png" alt="image-20220905150208025"></p><p> 从角标为3的位置开始对文件内容进行覆盖。</p><p> 如果想在文件末尾进行添加数据，则将pos设置为当前文件的大小（调用File类中的length方法即可），再使用write方法。</p></li></ol><h6 id="⑤应用"><a href="#⑤应用" class="headerlink" title="⑤应用"></a>⑤应用</h6><p>​该类可应用于文件的断点续传操作。</p><h5 id="N-NIO-2中Path、Paths、Files类的使用（了解）"><a href="#N-NIO-2中Path、Paths、Files类的使用（了解）" class="headerlink" title="N.NIO.2中Path、Paths、Files类的使用（了解）"></a>N.NIO.2中Path、Paths、Files类的使用（了解）</h5><h6 id="①理解"><a href="#①理解" class="headerlink" title="①理解"></a>①理解</h6><ul><li>Java NIO (New IO，Non-Blocking IO)是从Java 1.4版本开始引入的一套新的IO API，可以替代标准的Java IO API。NIO与原来的IO有同样的作用和目的，但是使用的方式完全不同，NIO支持面向缓冲区的(IO是面向流的)、基于通道的IO操作。NIO将以更加高效的方式进行文件的读写操作。</li><li>随着 JDK 7 的发布，Java对NIO进行了极大的扩展，增强了对文件处理和文件系统特性的支持，以至于我们称他们为 NIO.2。</li></ul><h6 id="②Path"><a href="#②Path" class="headerlink" title="②Path"></a>②Path</h6><p>​<strong>引入</strong>：</p><p>​早期的Java只提供了一个File类来访问文件系统，但File类的功能比较有限，所提供的方法性能也不高。而且，大多数方法在出错时仅返回失败，并不会提供异常信息。NIO. 2为了弥补这种不足，引入了Path接口。<strong>实际上，Path可以看成是File类的升级版本，实际引用的资源也可以不存在。</strong></p><p><img src="/imgs/image-20220905160945668.png" alt="image-20220905160945668"></p><p>​Path中的常用方法：</p><p><img src="/imgs/image-20220905161408689.png" alt="image-20220905161408689"></p><h6 id="③Paths"><a href="#③Paths" class="headerlink" title="③Paths"></a>③Paths</h6><p>​Paths是一个类，用于创建Path对象的。</p><p>​Paths类提供的静态get()方法用来获取Path对象</p><p><img src="/imgs/image-20220905161318974.png" alt="image-20220905161318974"></p><h6 id="④Files"><a href="#④Files" class="headerlink" title="④Files"></a>④Files</h6><p>​用于操作文件或文件目录的工具类</p><p>​常用方法：</p><p><img src="/imgs/image-20220905161649470.png" alt="image-20220905161649470"><img src="/imgs/image-20220905161705595.png" alt="image-20220905161705595"></p><h5 id="O-ByteArrayOutputStream"><a href="#O-ByteArrayOutputStream" class="headerlink" title="O.ByteArrayOutputStream"></a>O.ByteArrayOutputStream</h5><h6 id="①概述-11"><a href="#①概述-11" class="headerlink" title="①概述"></a>①概述</h6><p>​该流可用于存储字节流数据，并将字符流数据保存到 byte[ ] 数组中。如：</p><h6 id="②toString"><a href="#②toString" class="headerlink" title="②toString()"></a>②toString()</h6><p>​该方法可以将ByteArrayOutputStream底层中的 byte[ ] 转换为字符串</p><h6 id="③getBytes"><a href="#③getBytes" class="headerlink" title="③getBytes()"></a>③getBytes()</h6><p>​该方法属于String类中的方法，可以将字符串转换为一个byte数组</p><h6 id="④例子"><a href="#④例子" class="headerlink" title="④例子"></a>④例子</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//h.txt文件中存放了abc,现在想将此文件中的英文字母全转为大写再输出到文件uph.txt中</span></span><br><span class="line"><span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;h.txt&quot;</span>);</span><br><span class="line"><span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line"><span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造器不需要形参</span></span><br><span class="line"><span class="keyword">while</span>((len = fis.read(buffer)) != <span class="literal">null</span>)&#123;</span><br><span class="line">    baos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">toUpperCase</span> <span class="operator">=</span> baos.toString().toUpperCase();</span><br><span class="line"></span><br><span class="line"><span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;uph.txt&quot;</span>);</span><br><span class="line"><span class="comment">//因为fos属于字节流，只能向里面添加字节流数据，因此需要将字符串转换为byte数组再写入到文件中</span></span><br><span class="line">fos.write(toUpperCase.getBytes());</span><br></pre></td></tr></table></figure><h4 id="8、网络编程"><a href="#8、网络编程" class="headerlink" title="8、网络编程"></a>8、网络编程</h4><h5 id="①网络编程概述"><a href="#①网络编程概述" class="headerlink" title="①网络编程概述"></a>①网络编程概述</h5><h6 id="A-网络编程的目的"><a href="#A-网络编程的目的" class="headerlink" title="A.网络编程的目的"></a>A.网络编程的目的</h6><ul><li>直接或间接地通过网络协议与其它计算机实现数据交换，进行通讯。</li></ul><h6 id="B-网络编程中有两个主要的问题"><a href="#B-网络编程中有两个主要的问题" class="headerlink" title="B.网络编程中有两个主要的问题"></a>B.网络编程中有两个主要的问题</h6><ol><li><p>如何准确地定位网络上一台或多台主机；定位主机上的特定的应用。</p><ul><li>IP：区分主机。</li><li>端口号：区分一个主机上不同的应用程序。</li></ul></li><li><p>找到主机后如何可靠高效地进行数据传输。</p><p> 一定的规则（即网络通信协议，有两套参考模型）：</p><ul><li>OSI参考模型：模型过于理想化，未能在因特网上广泛推广。</li><li>TCP&#x2F;IP参考模型：事实上的国际标准。</li></ul><p> <img src="/imgs/image-20220905205609057.png" alt="image-20220905205609057"></p><p> 层与层之间是可以进行数据传输的，如：</p></li></ol><p><img src="/imgs/image-20220905205705818.png" alt="image-20220905205705818"></p><p>​</p><h6 id="C-通信要素1–IP和端口号"><a href="#C-通信要素1–IP和端口号" class="headerlink" title="C.通信要素1–IP和端口号"></a>C.通信要素1–IP和端口号</h6><p>​<strong>IP</strong>：</p><ul><li><p>Java中用InetAddress类来表示IP，一个具体的InetAddress对象就是一个具体的IP地址。</p></li><li><p>IP分类：IPV4 和 IPV6；公网地址(万维网使用)和私有地址(局域网使用)</p></li><li><p>域名：如：<a href="http://www.baidu.com、www.vip.com等,本质上对应着一个ip地址./">www.baidu.com、www.vip.com等，本质上对应着一个IP地址。</a></p><ul><li>当我们在网站中输入一个域名时，先会去找主机host下是否有这个域名存在，没有则发送给域名解析服务器（DNS），让其解析域名并向主机返回该域名对应的IP地址，主机就拿着这个IP地址去访问相应的网站了。</li></ul></li><li><p>本机IP地址：127.0.0.1 ；对应的域名为：Localhost</p></li><li><p>实例化 InetAddress 两个方法：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.getByName（String host）</span></span><br><span class="line"><span class="type">InetAddress</span> <span class="variable">inet</span> <span class="operator">=</span> InetAddress.getByName(String host);<span class="comment">//返回的是对应域名或IP的对象。注意：该方法会抛异常，我们需要try-catch-finally</span></span><br><span class="line"><span class="comment">//host可以是具体的一个IP地址或域名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.getLocalHost（）</span></span><br><span class="line"><span class="type">InetAddress</span> <span class="variable">inet1</span> <span class="operator">=</span> InetAddress.getLocalHost();<span class="comment">//获取本机的IP地址</span></span><br></pre></td></tr></table></figure><p>  两个常用方法：获取域名getHostName()，获取IP地址getHostAddress()</p></li></ul><p>​<strong>端口号</strong>：</p><ul><li>端口号用来标识正在计算机上运行的进程（程序）；不同的进程有不同的端口号。被规定为一个 16 位的整数 0~65535。</li><li>端口号分类（了解）<ul><li>公认端口：0~1023。被预先定义的服务通信占用（如：HTTP占用端口80，FTP占用端口21，Telnet占用端口23）</li><li>注册端口：1024~49151。分配给用户进程或应用程序。（如：Tomcat占用端口8080，MySQL占用端口3306，Oracle占用端口1521等）。</li><li>动态&#x2F;私有端口：49152~65535。</li></ul></li><li>端口号与IP地址的组合得出一个网络套接字：Socket。</li></ul><h6 id="D-通信要素2–网络协议"><a href="#D-通信要素2–网络协议" class="headerlink" title="D.通信要素2–网络协议"></a>D.通信要素2–网络协议</h6><p>​<strong>引入</strong>：我们知道了IP和端口号后，就可以进行数据传输了，但怎么传涉及到了网络协议。</p><p>​<strong>TCP</strong></p><ul><li><p>使用TCP协议前，须先建立TCP连接，形成传输数据通道。</p></li><li><p>传输前，采用“三次握手”方式，点对点通信，是可靠的。</p></li><li><p>TCP协议进行通信的两个应用进程：客户端、服务端。</p></li><li><p>在连接中可进行大数据量的传输。</p></li><li><p>传输完毕，需释放已建立的连接，效率低（相较于UDP）。</p></li><li><p><strong>三次握手</strong></p><p>  <img src="/imgs/20201108194729168.png" alt="在这里插入图片描述"></p><p>  形象理解：<br>  A：你在吗，我是A<br>  B：我在呢，我是B<br>  A：你在就行跟你说个事，我是A</p><ul><li>“<strong>四次挥手</strong>”</li></ul></li></ul><p><img src="/imgs/20201108201307379.png" alt="在这里插入图片描述"></p><p>​“四次挥手”即终止TCP连接。</p><p>​形象理解：像结婚要双方同意才可以。A向B请求断开连接，B反馈。B再向A请求断开连接，A再反馈。两方都断开才是真正的断开。</p><p>​<strong>UDP</strong>：</p><ul><li>将数据、源、目的封装成数据包，<strong>不需要建立连接</strong>。</li><li>每个数据报的大小限制在64K内 。数据比较大时，需要分多个包发送。</li><li>发送不管对方是否准备好，接收方收到也不确认，故是<strong>不可靠</strong>的。</li><li>发送数据结束时无需释放资源，开销小，速度快。</li></ul><h5 id="②TCP网络编程"><a href="#②TCP网络编程" class="headerlink" title="②TCP网络编程"></a>②TCP网络编程</h5><h6 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h6><ul><li>创建Socket对象，指明服务器端的IP和端口号。</li><li>用Socket对象调用getOutputStream()方法，获取一个输出流。用于给客户端发送信息。</li><li>拿着输出流调用write()进行数据输出操作。</li><li>Socket、流的关闭。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">client</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//1.创建Socket对象，指明服务器端的IP与端口号</span></span><br><span class="line"><span class="type">InetAddress</span> <span class="variable">inet</span> <span class="operator">=</span>InetAddress.getByName(<span class="string">&quot;127.0.0.1);//服务端的IP地址</span></span><br><span class="line"><span class="string">Socket socket=new Socket(inet,8899);//端口号8899</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//2.获取一个输出流，用于输出数据</span></span><br><span class="line"><span class="string">OutputStream os=socket.getOutputStream();</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//3.写出数据</span></span><br><span class="line"><span class="string">os.write(&quot;</span>你好，我是客户端<span class="string">&quot;);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//4.资源关闭</span></span><br><span class="line"><span class="string">os.close();</span></span><br><span class="line"><span class="string">socket.close();</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>​注意：上面代码存在异常，需要用try-catch-finally对其进行异常处理</p><h6 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h6><ul><li>创建服务器端的ServerSocket，指明服务器的端口号。</li><li>用上面创建的对象去调用accept()，接收来自客户端的socket。</li><li>用获取到的socket对象去调用getInputStream()，获取输入流。</li><li>用流的对象去调用read()方法，进行相应的读操作。</li><li>关闭ServerSocket、socket、流</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务端</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">server</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//1.创建Socket对象，指明自己的端口号</span></span><br><span class="line">ServerSocket s=<span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8899</span>);</span><br><span class="line"><span class="comment">//2.调用accept()表示接收来自于客户端的socket</span></span><br><span class="line">Socket socket=s.acept();</span><br><span class="line"><span class="comment">//3.获取输入流</span></span><br><span class="line">InputStream is=socket.getInputStream();</span><br><span class="line"></span><br><span class="line"><span class="comment">//不建议这样写，一个中文3个字节，5太小，两个中文时，第二个字被分开存会出现乱码</span></span><br><span class="line"><span class="comment">/*byte[] buffer=new byte[5];</span></span><br><span class="line"><span class="comment">int len;</span></span><br><span class="line"><span class="comment">while((len=is.read(buffer))!=-1)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">String str=new String(buffer,0,len);</span></span><br><span class="line"><span class="comment">System.out.print(str);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//建议如下写：</span></span><br><span class="line"><span class="comment">//4.读取输入流中的数据</span></span><br><span class="line">ByteArrayOutputStream baos=<span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();<span class="comment">//这时写入的内容在ByteArrayOutputStream的数组里，不会每5个就还原，而是等所有的输完后整体转换，所以不会出现乱码。</span></span><br><span class="line"><span class="type">byte</span>[] buffer=<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> len;</span><br><span class="line"><span class="keyword">while</span>((len=is.read(buffer))!=-<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">baos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">&#125;</span><br><span class="line">System.out.print(baos.toString());</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.资源关闭</span></span><br><span class="line">baos.close();</span><br><span class="line">is.close();</span><br><span class="line">socket.close();</span><br><span class="line">ss.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​上面代码会抛异常，我们需要用try把除关闭操作外的代码包起来，将关闭操作的代码放到finally里。</p><h5 id="③UDP网络编程（了解）"><a href="#③UDP网络编程（了解）" class="headerlink" title="③UDP网络编程（了解）"></a>③UDP网络编程（了解）</h5><p>（1）类 DatagramSocket 和 DatagramPacket 实现了基于 UDP 协议网络程序。</p><p>（2）UDP数据报通过数据报套接字 DatagramSocket 发送和接收，系统不保证UDP数据报一定能够安全送到目的地，也不能确定什么时候可以抵达。</p><p>（3）DatagramPacket 对象封装了UDP数据报，在数据报中包含了发送端的IP地址和端口号以及接收端的IP地址和端口号。</p><p>（4）UDP协议中每个数据报都给出了完整的地址信息，因此无须建立发送方和接收方的连接。如同发快递包裹一样。</p><h5 id="④URL编程"><a href="#④URL编程" class="headerlink" title="④URL编程"></a>④URL编程</h5><h6 id="A-URL"><a href="#A-URL" class="headerlink" title="A.URL"></a>A.URL</h6><p>​<strong>URL</strong>：统一资源定位符，它表示 Internet 上某一资源的地址。</p><p>​<strong>URL的基本结构由5部分组成</strong>：</p><pre><code> &lt;传输协议&gt;://&lt;主机名&gt;:&lt;端口号&gt;/&lt;文件名&gt;#片段名?参数列表   </code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/examples/beauty.jpg?usernam=Tom</span><br><span class="line">协议   主机名    端口号 资源地址            参数列表 </span><br><span class="line">主机名：相当于IP </span><br></pre></td></tr></table></figure><p>​</p><h6 id="B-实例化URL对象"><a href="#B-实例化URL对象" class="headerlink" title="B.实例化URL对象"></a>B.实例化URL对象</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://localhost:8080/examples/beauty.jpg?usernam=Tom&quot;</span>);</span><br></pre></td></tr></table></figure><h6 id="C-常用方法"><a href="#C-常用方法" class="headerlink" title="C.常用方法"></a>C.常用方法</h6><p><img src="/imgs/image-20220906181630928.png" alt="image-20220906181630928"></p><h6 id="D-用于"><a href="#D-用于" class="headerlink" title="D.用于"></a>D.用于</h6><p>编程实现对网络资源的获取并进行保存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://localhost:8080/examples/beauty.jpg?usernam=Tom&quot;</span>);</span><br><span class="line">        <span class="comment">//下面两行代码获取与服务器的连接</span></span><br><span class="line">        <span class="type">HttpURLConnection</span> <span class="variable">connection</span> <span class="operator">=</span> (HttpURLConnection) url.openConnection();</span><br><span class="line">        connection.connect();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取到连接后就可以将网站中的资源读取进来了</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">stream</span> <span class="operator">=</span> connection.getInputStream();</span><br><span class="line">        <span class="comment">//下面就是对流的读取操作（略）</span></span><br><span class="line">        <span class="comment">//关闭流</span></span><br><span class="line"><span class="comment">//关闭与服务器的连接</span></span><br><span class="line">        connection.disconnection();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​上面代码要用try-catch-finally进行处理</p><h4 id="9、反射"><a href="#9、反射" class="headerlink" title="9、反射"></a>9、反射</h4><p>本节重点：红色字部分+笔记⑤体会反射的动态性+笔记⑦调用运行时类的指定结构+笔记⑥中的重点关注</p><img src="C:\Users\橙子\AppData\Roaming\Typora\typora-user-images\image-20220908170508164.png" alt="image-20220908170508164" style="zoom: 50%;" /><h5 id="①引入"><a href="#①引入" class="headerlink" title="①引入"></a>①引入</h5><p>​后端运行起来后，当前端发送一个登录操作的URL给后端时，后端就会根据登录来造登录的对象，再通过对象调用相应方法实现登录操作；前端发送注册操作的URL给后端，后端就造注册的对象，再调用相应方法实现注册。我们运行时才知道造哪个类的对象，这就需要用到反射了。</p><h5 id="②反射概述"><a href="#②反射概述" class="headerlink" title="②反射概述"></a>②反射概述</h5><h6 id="A-Java是准动态语言"><a href="#A-Java是准动态语言" class="headerlink" title="A.Java是准动态语言"></a>A.Java是准动态语言</h6><p>​反射具有动态的特性，从而让Java有了一定的动态性，所以Java属于准动态语言。</p><h6 id="B-反射提供的功能"><a href="#B-反射提供的功能" class="headerlink" title="B.反射提供的功能"></a>B.反射提供的功能</h6><ul><li>在运行时判断任意一个对象所属的类</li><li>在运行时构造任意一个类的对象</li><li>在运行时判断任意一个类所具有的成员变量和方法</li><li>在运行时获取泛型信息</li><li>在运行时调用任意一个对象的成员变量和方法</li><li>在运行时处理注解</li><li>生成动态代理</li></ul><h6 id="C-相关主要API"><a href="#C-相关主要API" class="headerlink" title="C.相关主要API"></a>C.相关主要API</h6><ul><li>java.lang.Class:代表一个类</li><li>java.lang.reflect.Method:代表类的方法</li><li>java.lang.reflect.Field:代表类的成员变量</li><li>java.lang.reflect.Constructor:代表类的构造器</li></ul><p>注：如果用到了最后三个API，需要导包</p><h5 id="③关于java-lang-Class类的理解"><a href="#③关于java-lang-Class类的理解" class="headerlink" title="③关于java.lang.Class类的理解"></a>③关于java.lang.Class类的理解</h5><p>​任何的反射操作都要先造Class类的对象，所以Class类被称为反射源。</p><h6 id="A-类的加载过程"><a href="#A-类的加载过程" class="headerlink" title="A.类的加载过程"></a>A.类的加载过程</h6><p>​程序经过javac.exe命令后，会生成一个或多个字节码文件（.class结尾，一个类对应一个字节码文件）。<br>​接着使用java.exe命令对某个字节码文件进行解释运行。相当于将某个字节码文件加载到内存中。此过程就称为<strong>类的加载</strong>。加载到内存中的类，称为<strong>运行时类</strong>，此运行时类，就作为<strong>class的一个实例</strong>。</p><p>​换句话说，<strong>Class的实例就对应着一个运行时类</strong>。</p><h6 id="B-获取Class的实例的方式（前三种方式需要掌握）"><a href="#B-获取Class的实例的方式（前三种方式需要掌握）" class="headerlink" title="B.获取Class的实例的方式（前三种方式需要掌握）"></a>B.获取Class的实例的方式（前三种方式需要掌握）</h6><p>​Class是一个泛型类，在声明时可以指明其泛型类型，指明后就可以在后续操作中不用强转。</p><ol><li><p>方式一：调用运行时类的属性：.class</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz1</span> <span class="operator">=</span> Person.class;</span><br></pre></td></tr></table></figure></li><li><p>方式二：通过运行时类的对象，调用getClass()</p></li></ol>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz2</span> <span class="operator">=</span> p1.getClass();</span><br><span class="line"><span class="comment">//getClass()：获取该对象是由哪个类造的</span></span><br></pre></td></tr></table></figure><ol start="3"><li>方式三：调用Class的静态方法：forName(String classPath)</li></ol>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz3</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.atguigu.java.Person&quot;</span>);</span><br><span class="line"><span class="comment">//该方法会抛异常</span></span><br><span class="line"><span class="comment">//这种创建方式体现了反射的动态性</span></span><br></pre></td></tr></table></figure><p>  classPath：被称为全类名，即：写出该类是属于哪个包下的类</p><p>  这种方式在开发中<strong>使用频率最高</strong>。</p><ol start="4"><li><p>方式四(了解)：使用类的加载器：ClassLoader</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader classLoaser = </span><br><span class="line">当前写代码的类的类名.class.getClassLoader();</span><br><span class="line">Class clazz4 = classLoader.loadClass(&quot;要加载的类的全类名&quot;);</span><br></pre></td></tr></table></figure></li></ol><h6 id="C-注意"><a href="#C-注意" class="headerlink" title="C.注意"></a>C.注意</h6><p>​以上四个Class类的对象都是指向同一个运行时类（Person）。</p><h6 id="D-补充（了解）"><a href="#D-补充（了解）" class="headerlink" title="D.补充（了解）"></a>D.补充（了解）</h6><p>​<img src="/imgs/image-20220908121533209.png" alt="image-20220908121533209"></p><p>​例子：</p><p><img src="/imgs/image-20220908121637256.png" alt="image-20220908121637256"></p><h6 id="E-类的加载器"><a href="#E-类的加载器" class="headerlink" title="E.类的加载器"></a>E.类的加载器</h6><p>​类的加载器的作用：将class文件字节码内容加载到内存中，然后在堆中生成一个Class类的实例。</p><p>​<strong>类的加载器的分类</strong>：（了解）</p><ul><li><p>(Bootstap Classloader)<strong>引导类加载器</strong>：是JVM自带的类加载器，负责Java平台核心库，用来装载核心类库中的类。该加载器无法直接获取。</p></li><li><p>(Extension Classloader)<strong>扩展类加载器</strong>：负责jre&#x2F;lib&#x2F;ext目录下的jar包或 –D java.ext.dirs 指定目录下的jar包装入工作库。jar包：将class文件打包</p></li><li><p>(System Classloader)<strong>系统类加载器</strong>：负责加载自定义类</p><h5 id="④创建运行时类的对象"><a href="#④创建运行时类的对象" class="headerlink" title="④创建运行时类的对象"></a>④创建运行时类的对象</h5><p>  用<strong>Class</strong>类的对象去调用<strong>newIstance()<strong>方法（</strong>该方法会抛异常</strong>），该方法内部调用了运行时类的空参构造器。要想此方法正常的创建运行时类的对象，要求：</p><ul><li>运行时类必须提供空参的构造器</li><li>空参的构造器的权限修饰符要大于private。通常，设置为public。</li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;<span class="comment">//clazz指向了方法区中的Person类，因此造对象的时候也只能造Person类的对象，不能造其他类的对象。</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> (Person)o;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果在创建Class类的对象时指明泛型类型，就可以省略第3行代码</span></span><br><span class="line">Class&lt;Person&gt; clazz1 = Person.class;</span><br><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> clazz1.newInstance();<span class="comment">//直接返回Person类的对象。</span></span><br></pre></td></tr></table></figure><p>  ​如果想调用带参数的构造器也是可以的，表不过通常都是调用空参的构造器。</p><h5 id="⑤体会反射的动态性"><a href="#⑤体会反射的动态性" class="headerlink" title="⑤体会反射的动态性"></a>⑤体会反射的动态性</h5>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> num=<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">3</span>);</span><br><span class="line">String classPath=<span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">switch</span>(num)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">classPath=<span class="string">&quot;java.util.Date&quot;</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">classPath=<span class="string">&quot;java.lang.Object&quot;</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">classPath=<span class="string">&quot;com.attang.java.Person&quot;</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">Object obj=getInstance(classPath);</span><br><span class="line">System.out.println(obj);</span><br><span class="line"></span><br><span class="line">Public Object <span class="title function_">getInstance</span><span class="params">(String classPath)</span></span><br><span class="line">&#123;</span><br><span class="line">Class clazz=Class.forName(classPath);</span><br><span class="line"><span class="keyword">return</span> class.newInstance();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  ​<strong>只有在运行时才能确定造的是哪个对象。</strong></p><h5 id="⑥获取运行时类的完整结构（了解）"><a href="#⑥获取运行时类的完整结构（了解）" class="headerlink" title="⑥获取运行时类的完整结构（了解）"></a>⑥获取运行时类的完整结构（了解）</h5><h6 id="A-获取属性结构"><a href="#A-获取属性结构" class="headerlink" title="A.获取属性结构"></a>A.获取属性结构</h6><p>  ​通过Class类的对象去调用。</p><p>  ​getFields()：获取当前运行时类及其父类中声明为public访问权限的属性。</p><p>  ​getDeclaredFields()：获取当前运行时类中声明的所有属性。（不包括父类中声明的属性）</p><p>  ​拿到一个属性后，我们还可以获取当前属性的数据类型、权限修饰符、属性名等信息。</p><h6 id="B-获取方法结构"><a href="#B-获取方法结构" class="headerlink" title="B.获取方法结构"></a>B.获取方法结构</h6><p>  ​通过Class类的对象去调用。</p><p>  ​getMethods()：获取当前运行时类及其所有父类中声明为public权限的方法</p><p>  ​getDeclaredMethods()：获取当前运行时类中声明的所有方法。（不包含父类中声明的方法）</p><p>  ​获取到具体的一个方法之后，我们可以接着获取该方法的权限修饰符、返回值类型、方法名、形参列表、注解、抛出异常类型。</p><h6 id="C-获取构造器结构"><a href="#C-获取构造器结构" class="headerlink" title="C.获取构造器结构"></a>C.获取构造器结构</h6><p>  ​通过Class类的对象去调用。</p><p>  ​getConstructors()：获取当前运行时类中声明为public的构造器。（不包括父类中的构造器）</p><p>  ​getDeclaredConstructors()：获取当前运行时类中声明的所有构造器。（不包括父类中的构造器）</p><h6 id="D-获取运行时类的父类"><a href="#D-获取运行时类的父类" class="headerlink" title="D.获取运行时类的父类"></a>D.获取运行时类的父类</h6><p>  ​通过Class类的对象去调用。</p><p>  ​getSuperclass()：获取当前运行类的父类</p><p>  ​getGenericSuperclass()：获取当前运行类的父类（带泛型的父类）</p><h6 id="E-获取当前运行时类的父类的泛型"><a href="#E-获取当前运行时类的父类的泛型" class="headerlink" title="E.获取当前运行时类的父类的泛型"></a>E.获取当前运行时类的父类的泛型</h6>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line"><span class="type">Type</span> <span class="variable">genericSuperclass</span> <span class="operator">=</span> clazz.getGenericSuperclass();</span><br><span class="line"><span class="type">ParameterizedType</span> <span class="variable">paramType</span> <span class="operator">=</span> (ParameterizedType)genericSuperclass;</span><br><span class="line">Type[] actualTypeArguments = paramType.getActualTypeArguments();</span><br><span class="line">System.out.print(actualTypeArguments[<span class="number">0</span>].getTypeName());</span><br></pre></td></tr></table></figure><h6 id="F-获取当前运行时类实现的接口"><a href="#F-获取当前运行时类实现的接口" class="headerlink" title="F.获取当前运行时类实现的接口"></a>F.获取当前运行时类实现的接口</h6><p>  ​通过Class类的对象去调用。</p><p>  ​getInterfaces()：获取当前运行时类实现的接口（不包括父类的接口，要想获取父类实现的接口，就先得获取父类，再接着调用getInterfaces()）</p><h6 id="G-获取当前运行时类所在的包"><a href="#G-获取当前运行时类所在的包" class="headerlink" title="G.获取当前运行时类所在的包"></a>G.获取当前运行时类所在的包</h6><p>  ​通过Class类的对象去调用。</p><p>  ​getPackage()：获取当前运行时类所在的包</p><h6 id="H-获取运行时类声明的注解"><a href="#H-获取运行时类声明的注解" class="headerlink" title="H.获取运行时类声明的注解"></a>H.获取运行时类声明的注解</h6><p>  ​通过Class类的对象去调用。</p><p>  ​getAnnotations()：读取当前运行时类的注解</p><h6 id="需要重点了解的是"><a href="#需要重点了解的是" class="headerlink" title="需要重点了解的是"></a>需要重点了解的是</h6><p>  ​E、F、H</p><hr><h5 id="⑦调用运行时类的指定结构"><a href="#⑦调用运行时类的指定结构" class="headerlink" title="⑦调用运行时类的指定结构"></a>⑦调用运行时类的指定结构</h5><p>  ​这里我们重点关注：属性、方法、构造器</p><h6 id="A-如何操作运行时类中指定的属性"><a href="#A-如何操作运行时类中指定的属性" class="headerlink" title="A.如何操作运行时类中指定的属性"></a>A.如何操作运行时类中指定的属性</h6><p>  ​实现步骤：</p><ol><li>造Class类的对象</li><li>创建运行时类的对象</li><li>用Class类的对象去调用getDeclaredField(String fieldName)，获取运行时类中指定变量名的属性（注意：<strong>获取不了父类中的属性</strong>）</li><li>用获取到的属性调用setAccessible(true)方法，保证当前属性是可访问的（如果不调用该方法，就不能对声明为private的属性进行赋值或获取操作）</li><li>用获取到的属性调用set(Object obj,Object value)实现赋值操作，调用get(Object   obj)实现获取属性值操作。其中：obj为要对哪个对象进行操作，value：属性值要设置多少</li></ol><p>  补充：<strong>如果获取的是静态的属性</strong>，则将步骤2去掉，步骤5中的obj写null或“当前运行时类.class”</p><p>  ​代码实现：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="comment">//1.声明Class类的对象</span></span><br><span class="line">    Class&lt;Person&gt; clazz = (Class&lt;Person&gt;) Class.forName(<span class="string">&quot;com.zzc.javatest.Person&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.创建运行时类的对象</span></span><br><span class="line">    <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.获取运行时类中指定变量名的属性</span></span><br><span class="line">    <span class="type">Field</span> <span class="variable">des</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.对获取到的属性进行赋值或获取操作</span></span><br><span class="line">    des.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    des.set(person,<span class="number">1001</span>);</span><br><span class="line">    System.out.println(des.get(person));</span><br><span class="line">    </span><br><span class="line"> <span class="comment">//第三行代码为什么需要强转？因为该forName方法本身返回的是Class&lt;?&gt;类型数据，而clazz是Class&lt;Person&gt;类型，所有就需要强转。Class&lt;?&gt;是Class&lt;Person&gt;的父类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="B-如何操作运行时类中指定的方法"><a href="#B-如何操作运行时类中指定的方法" class="headerlink" title="B.如何操作运行时类中指定的方法"></a>B.如何操作运行时类中指定的方法</h6><p>  ​<strong>调用非静态的方法</strong>：</p><p>  ​实现步骤：</p><ol><li>造Class的实例</li><li>造运行时类的对象</li><li>用Class类的对象去调用getDeclareMethod(String methodName,方法的形参列表)，参数1：指明获取的方法的名称，参数2：指明获取的方法的形参列表，没有就不用写，有则这样写：“数据类型.class”</li><li>用获取到的方法调用setAccessible(true)，保证当前方法是可访问的</li><li>调用方法的invoke()：参数1：方法的调用者，参数2：实参，invoke()的返回值即为对应类中调用的方法的返回值。如果没有返回值，则返回的是null。</li></ol>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="comment">//1.</span></span><br><span class="line">    Class&lt;Person&gt; clazz = (Class&lt;Person&gt;) Class.forName(<span class="string">&quot;com.zzc.javatest.Person&quot;</span>);</span><br><span class="line">    <span class="comment">//2.</span></span><br><span class="line">    <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line">    <span class="comment">//3.</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">show</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;show&quot;</span>);</span><br><span class="line">    <span class="comment">//4.</span></span><br><span class="line">    show.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">//5.</span></span><br><span class="line">    show.invoke(person);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  ​<strong>调用静态的方法</strong>：</p><p>  ​<strong>实现步骤</strong>：</p><ol><li>造Class的实例</li><li>用Class类的对象去调用getDeclareMethod(String methodName,方法的形参列表)，参数1：指明获取的方法的名称，参数2：指明获取的方法的形参列表，没有就不用写</li><li>用获取到的方法调用setAccessible(true)，保证当前方法是可访问的</li><li>调用方法的invoke()：参数1：null或“当前运行时类.class”，参数2：实参，invoke()的返回值即为对应类中调用的方法的返回值。如果没有返回值，则返回的是null。</li></ol><h6 id="C-如何调用运行时类中指定的构造器"><a href="#C-如何调用运行时类中指定的构造器" class="headerlink" title="C.如何调用运行时类中指定的构造器"></a>C.如何调用运行时类中指定的构造器</h6><p>  ​<strong>实现步骤</strong>：</p><ol><li>造Class的实例</li><li>用Class的对象去调用getDeclaredConstructor()：参数：指明构造器的参数列表，写参数的时候要这样写：“数据类型.class”。该方法会抛异常。</li><li>用获取到的构造器去调用setAccessible(true)，保证此构造器是可访问的</li><li>调用此构造器创建运行时类的对象，使用newInstance(实参)</li></ol>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="comment">//1.</span></span><br><span class="line">    Class&lt;Person&gt; clazz = (Class&lt;Person&gt;) Class.forName(<span class="string">&quot;com.zzc.javatest.Person&quot;</span>);</span><br><span class="line">    <span class="comment">//2.</span></span><br><span class="line">    Constructor&lt;Person&gt; constructor = clazz.getDeclaredConstructor(String.class, <span class="type">int</span>.class);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.</span></span><br><span class="line">    constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">//4.</span></span><br><span class="line">    <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> constructor.newInstance(<span class="string">&quot;Tom&quot;</span>, <span class="number">12</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="⑧反射应用–动态代理"><a href="#⑧反射应用–动态代理" class="headerlink" title="⑧反射应用–动态代理"></a>⑧反射应用–动态代理</h5><h6 id="①概述-12"><a href="#①概述-12" class="headerlink" title="①概述"></a>①概述</h6><p>  ​<strong>代理模式</strong>：通过代理类的对象来间接调用被代理类中的方法。</p><p>  ​<strong>代理模式的具体实现</strong>：代理类和被代理类都实现同一个（堆）接口，然后通过代理类的对象来调用方法，如：show()方法，当调用该方法时，实际上调用的是被代理类里的show()方法。从而实现间接操作被代理中的方法。</p><p>  ​<strong>动态代理</strong>：接口、被代理类要先造好，而代理类是动态创建。</p><h6 id="②静态代理实现"><a href="#②静态代理实现" class="headerlink" title="②静态代理实现"></a>②静态代理实现</h6><p>  ​见：笔记12、面向对象中的其他关键字 —&gt; interface –&gt; ⑦</p><h6 id="③动态代理实现"><a href="#③动态代理实现" class="headerlink" title="③动态代理实现"></a>③动态代理实现</h6><p>  ​基础阶段先了解，到框架部分再深入</p><hr><h4 id="10、Java8的一些新特性"><a href="#10、Java8的一些新特性" class="headerlink" title="10、Java8的一些新特性"></a>10、Java8的一些新特性</h4><h5 id="①概述-13"><a href="#①概述-13" class="headerlink" title="①概述"></a>①概述</h5><p>  ​java8：</p><ul><li>速度更快</li><li>代码更少(增加了新的语法：Lambda 表达式)</li><li>强大的 Stream API</li><li>便于并行</li><li>最大化减少空指针异常：Optional</li><li>Nashorn引擎，允许在JVM上运行JS应用</li></ul><h5 id="②Lambda表达式"><a href="#②Lambda表达式" class="headerlink" title="②Lambda表达式"></a>②Lambda表达式</h5><h6 id="A-Lambda表达式的举例"><a href="#A-Lambda表达式的举例" class="headerlink" title="A.Lambda表达式的举例"></a>A.Lambda表达式的举例</h6>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(o1,o2) -&gt; Integer.compare(o1,o2);</span><br></pre></td></tr></table></figure><h6 id="B-格式"><a href="#B-格式" class="headerlink" title="B.格式"></a>B.格式</h6><p>  ​-&gt; ：Lambda操作符 或 箭头操作符</p><p>  ​操作符左边：Lambda形参列表（其实就是接口中的抽象方法的形参列表）</p><p>  ​操作符右边：Lambda体（其实就是重写的抽象方法的方法体）</p><h6 id="C-Lambda表达式的使用"><a href="#C-Lambda表达式的使用" class="headerlink" title="C.Lambda表达式的使用"></a>C.Lambda表达式的使用</h6><p>  ​Lambda表达式的本质：函数式接口的匿名实现类的对象。</p><p>  ​总结：</p><ol><li>操作符左边：Lambda形参列表的参数类型可以省略（类型推断）；如果Lambda形参列表只有一个参数，其一对（）也可以省略。</li><li>操作符右边：Lambda体应该使用一对{ }包裹：如果Lambda体只有一条执行语句（可能是return语句），可以省略这一对{}和return关键字（如果省略{ }，则return必须一起省略）。</li></ol><h6 id="D-注意"><a href="#D-注意" class="headerlink" title="D.注意"></a>D.注意</h6><p>  ​Lambda表达式使用前提是：只能使用在接口，且该接口只能是函数式接口（即该接口里只有一个抽象方法）</p><h6 id="E-应用场景"><a href="#E-应用场景" class="headerlink" title="E.应用场景"></a>E.应用场景</h6><p>  ​当函数式接口要创建一个匿名实现类的对象时，我们就可以使用Lambda表达式了。</p><hr><h5 id="③函数式接口"><a href="#③函数式接口" class="headerlink" title="③函数式接口"></a>③函数式接口</h5><h6 id="A-定义"><a href="#A-定义" class="headerlink" title="A.定义"></a>A.定义</h6><p>  ​接口中只有一个抽象方法的接口，称为函数式接口。</p><p>  ​我们可以在一个接口上使用 @FunctionalInterface 注解，这样做可以检查它是否是一个函数式接口。</p><h6 id="B-Java内置四大核心函数式接口"><a href="#B-Java内置四大核心函数式接口" class="headerlink" title="B.Java内置四大核心函数式接口"></a>B.Java内置四大核心函数式接口</h6><p>  <img src="/imgs/image-20220910134838862.png" alt="image-20220910134838862"></p><p>  <img src="/imgs/image-20220910142024000.png" alt="image-20220910142024000"></p><p>  ​以后当见到上面的函数式接口时，我们都可以使用Lambda表达式来造函数式接口的实现类对象。</p><h6 id="C-如何使用给定的函数式接口"><a href="#C-如何使用给定的函数式接口" class="headerlink" title="C.如何使用给定的函数式接口"></a>C.如何使用给定的函数式接口</h6><p>  ​如果我们开发中需要定义一个函数式接口，首先看看在已有的jdk提供的函数式接口是否提供了能满足需求的函数式接口。如果有，则直接调用即可，不需要自己再定义了。</p><hr><h5 id="④方法引用"><a href="#④方法引用" class="headerlink" title="④方法引用"></a>④方法引用</h5><h6 id="A-使用情景"><a href="#A-使用情景" class="headerlink" title="A.使用情景"></a>A.使用情景</h6><p>  ​当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用。即：当Lambda体中只有一条语句，且这条语句是：通过对象或类调用了某个方法，像这种情况，我们就可以考虑使用方法引用了，具体能不能使用得看方法引用的使用规则。</p><p>  ​方法引用，本质上就是Lambda表达式，而Lambda表达式作为函数式接口的实例。所以方法引用，也就是函数式接口的实例。</p><h6 id="B-格式-1"><a href="#B-格式-1" class="headerlink" title="B.格式"></a>B.格式</h6><p>  ​格式：类（或对象） :: 方法名</p><p>  ​具体可以分成如下三种情况：</p><ol><li><p>对象 :: 非静态方法</p></li><li><p>类 :: 静态方法</p></li><li><p>类 :: 非静态方法</p><p> 以上的方法只写方法名，不用写形参</p></li></ol><h6 id="C-方法引用使用规则"><a href="#C-方法引用使用规则" class="headerlink" title="C.方法引用使用规则"></a>C.方法引用使用规则</h6><ul><li>当Lambda体中调用的方法的形参列表和返回值类型与接口中的抽象方法的形参列表和返回值类型相同时，我们就可以使用格式中情况1或情况2来写方法引用，具体选哪个？<ul><li>当Lambda体中调用的方法为静态方法，则使用格式中的情况2来写方法引用。</li><li>当Lambda体中调用的方法为非静态方法，则使用格式中的情况1来写方法引用。</li></ul></li><li>当Lambda体中调用的方法属于非静态时，选择情况1还是选择情况3呢？<ul><li>当抽象方法中的形参为两个（t1,t2），而Lambda体中调用的方法的形参只有一个（t2）而t1作为方法引用的方法的调用者时，我们选择格式中的情况3。</li><li>当抽象方法中的形参为一个（t1），而Lambda体中调用的方法的形参为0个，而t1作为方法引用的方法的调用者时，我们选择格式中的情况3。</li></ul></li></ul><h6 id="D-具体举例"><a href="#D-具体举例" class="headerlink" title="D.具体举例"></a>D.具体举例</h6><p>  ​①对象 :: 非静态方法</p><p>  ​例一：</p><p>  ​<img src="/imgs/2021011516393733.png" alt="在这里插入图片描述"></p><p>  ​例二：</p><p>  <img src="/imgs/20210115165554334.png" alt="在这里插入图片描述"></p><p>  ​②类::静态方法名</p><p>  ​例一：</p><p>  <img src="/imgs/20210115170257876.png" alt="在这里插入图片描述"></p><p>  ​例二：</p><p>  <img src="/imgs/20210115170516947.png" alt="在这里插入图片描述"></p><p>  ​③类::实例方法名</p><p>  ​第一个参数作为方法的调用者。</p><p>  ​例一：</p><p>  <img src="/imgs/20210115171750232.png" alt="在这里插入图片描述"></p><p>  ​例二：</p><p>  <img src="/imgs/20210115171858864.png" alt="在这里插入图片描述"></p><p>  ​最后一句写错了，是pre2</p><p>  ​例三：</p><p>  <img src="/imgs/20210115172037108.png" alt="在这里插入图片描述"></p><hr><h5 id="⑤构造器引用"><a href="#⑤构造器引用" class="headerlink" title="⑤构造器引用"></a>⑤构造器引用</h5><h6 id="A-概述-1"><a href="#A-概述-1" class="headerlink" title="A.概述"></a>A.概述</h6><p>  ​如果Lambda体中只有一条语句且该语句属于创建对象的语句，那么就可以考虑使用构造器引用，具体能不能使用得看看是否符合构造器引用规则。</p><h6 id="B-格式-2"><a href="#B-格式-2" class="headerlink" title="B.格式"></a>B.格式</h6><p>  ​类名 :: new</p><h6 id="C-构造器引用规则"><a href="#C-构造器引用规则" class="headerlink" title="C.构造器引用规则"></a>C.构造器引用规则</h6><p>  ​函数式接口的抽象方法的形参列表和构造器的形参列表一致。抽象方法的返回值类型即为构造器所属的类的类型。</p><h6 id="D-例子"><a href="#D-例子" class="headerlink" title="D.例子"></a>D.例子</h6><p>  ​例一：</p><p>  <img src="/imgs/20210115172827686.png" alt="在这里插入图片描述"></p><p>  ​例二：</p><p>  <img src="/imgs/20210115172800444.png" alt="在这里插入图片描述"></p><p>  ​例三：</p><p>  <img src="/imgs/20210115172940482.png" alt="在这里插入图片描述"></p><hr><h5 id="⑥数组引用（？）"><a href="#⑥数组引用（？）" class="headerlink" title="⑥数组引用（？）"></a>⑥数组引用（？）</h5><p>  ​当Lambda体中只有一条语句且该语句属于创建数组的语句，像这种情况，我们就可以使用数组引用。</p><h6 id="A-格式"><a href="#A-格式" class="headerlink" title="A.格式"></a>A.格式</h6><p>  ​数组类型[ ] :: new</p><h6 id="B-使用"><a href="#B-使用" class="headerlink" title="B.使用"></a>B.使用</h6><p>  ​大家可以把数组看做是一个特殊的类，则写法与构造器引用一致。</p><p>  <img src="/imgs/20210115173412647.png" alt="在这里插入图片描述"></p><hr><h4 id="11、Java8新特性—Stream-API"><a href="#11、Java8新特性—Stream-API" class="headerlink" title="11、Java8新特性—Stream API"></a>11、Java8新特性—Stream API</h4><h5 id="A-概述-2"><a href="#A-概述-2" class="headerlink" title="A.概述"></a>A.概述</h5><ol><li><p>Stream是用来对集合中的数据进行计算操作的API，与CPU打交道</p><p> 集合关注的是数据的存储，与内存打交道</p></li><li><p>为什么需要Stream API？</p><p> 通常像MySQL这些数据库属于强关系数据库，对数据的过滤操作（如：查询大于3的数据）都是在数据库中完成的，而像Radis、MongDB这些弱关系数据库，则需要在Java层面实现数据的过滤操作。</p></li><li><p><strong>注意</strong></p><ul><li>Stream 自己不会存储元素。</li><li>Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。</li><li>Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。</li></ul></li><li><p><strong>Stream执行流程</strong></p><p> ①Stream的实例化</p><p> ②一系列的中间操作（过滤、映射….）</p><p> ③终止操作</p></li><li><p><strong>说明</strong></p><ul><li>中间操作：一个中间操作链，对数据源的数据进行处理</li><li>终止操作(终端操作) ：一旦执行终止操作，就执行中间操作链，并产生结果。之后，<strong>Stram对象就不能再被使用。如果还想执行操作，得重新造Stream对象</strong>。</li></ul></li></ol><h5 id="B-Stream实例化"><a href="#B-Stream实例化" class="headerlink" title="B.Stream实例化"></a>B.Stream实例化</h5><h6 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h6><p>  ​<strong>通过集合创建</strong></p><p>  ​<strong>A</strong>.调用集合Collection中默认方法stream()来实例化</p><p>  ​①先造Collection的实现类的对象</p><p>  ​②通过上面造的对象调用stream()方法，该方法返回一个顺序流（读取到的数据顺序与集合中存储数据的顺序一样）</p><p>  ​<strong>B</strong>.调用集合Collection中默认方法parallelStream()来实例化</p><p>  ​①先造Collection的实现类的对象</p><p>  ​②通过上面造的对象调用stream()方法，该方法返回一个并行流。（相当于用多个线程同时对集合中的数据进行读取）</p><h6 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h6><p>  ​<strong>通过数组</strong></p><p>  ​调用<strong>Arrays</strong>里的静态方法**stream()**，把数组放到方法的形参中，返回一个stream对象</p><h6 id="方式三"><a href="#方式三" class="headerlink" title="方式三"></a>方式三</h6><p>  ​通过Stream的of()方法，通过显示值创建一个流，它可以接收任意数量任意类型的参数。</p><p>  ​public static&lt; T &gt; Stream&lt; T &gt; of(T… values) : 返回一个流</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream = Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>  ​该方法适用于：<strong>现造现用</strong>的情况</p><h6 id="方法四（了解）"><a href="#方法四（了解）" class="headerlink" title="方法四（了解）"></a>方法四（了解）</h6><p>  ​创建无限流</p><p>  ​可以使用静态方法 Stream.iterate() 和 Stream.generate(), 创建无限流。</p><hr><h5 id="C-中间操作–筛选与切片"><a href="#C-中间操作–筛选与切片" class="headerlink" title="C.中间操作–筛选与切片"></a>C.中间操作–筛选与切片</h5><h6 id="①filter-Predicate-p"><a href="#①filter-Predicate-p" class="headerlink" title="①filter(Predicate p)"></a>①filter(Predicate p)</h6><p>  ​该方法的作用：从集合中排除某些元素，返回一个新的Stream对象</p><p>  ​实现：</p><p>  ​①用Stream的对象去调用filter()方法</p><p>  ​②在该方法的形参里放Predicate接口的匿名实现类的对象（可以选择用Lambda表达式表示）</p><p>  ​③在Predicate 接口的抽象方法test里写具体的过滤操作</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list1.add(<span class="number">1</span>);</span><br><span class="line">    list1.add(<span class="number">2</span>);</span><br><span class="line">    list1.add(<span class="number">3</span>);</span><br><span class="line">    list1.add(<span class="number">4</span>);</span><br><span class="line"><span class="comment">//1.Stream的实例化</span></span><br><span class="line">    Stream&lt;Integer&gt; stream = list1.stream();</span><br><span class="line"><span class="comment">//2.调用filter</span></span><br><span class="line">    stream.filter(<span class="keyword">new</span> <span class="title class_">Predicate</span>&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(Integer integer)</span> &#123;</span><br><span class="line">            <span class="comment">//3.写过滤条件</span></span><br><span class="line">            <span class="keyword">return</span> integer &gt; <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).forEach(System.out::println);</span><br><span class="line">    <span class="comment">//上面的写法可以改成用Lambda表达式写</span></span><br><span class="line"> <span class="comment">//stream.filter(integer -&gt; integer &gt; 2).forEach(System.out::println);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//运行结果为：3 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="②limit-n"><a href="#②limit-n" class="headerlink" title="②limit(n)"></a>②limit(n)</h6><p>  ​截断流，使其元素不超过给定数量。即：从容器的开始端读取n个数据。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stream.limit(<span class="number">3</span>).forEach(System.out::println);<span class="comment">//1，2，3</span></span><br></pre></td></tr></table></figure><h6 id="③skip-n"><a href="#③skip-n" class="headerlink" title="③skip(n)"></a>③skip(n)</h6><p>  ​跳过元素，返回一个扔掉了前n个元素的流。若流中元素不足n个，则返回一个空流。与limit(n)互补。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stream.skip(<span class="number">3</span>).forEach(System.out::println);<span class="comment">//4</span></span><br></pre></td></tr></table></figure><h6 id="④distinct"><a href="#④distinct" class="headerlink" title="④distinct()"></a>④distinct()</h6><p>  ​筛选，通过流所生成元素的hasCode() 和 equals() 去除重复元素</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list1.add(<span class="number">1</span>);</span><br><span class="line">list1.add(<span class="number">2</span>);</span><br><span class="line">list1.add(<span class="number">3</span>);</span><br><span class="line">list1.add(<span class="number">4</span>);</span><br><span class="line">list1.add(<span class="number">4</span>);</span><br><span class="line">Stream&lt;Integer&gt; stream = list1.stream();</span><br><span class="line">stream.distinct().forEach(System.out::println);<span class="comment">//1，2，3，4</span></span><br></pre></td></tr></table></figure><h5 id="D-中间操作–映射"><a href="#D-中间操作–映射" class="headerlink" title="D.中间操作–映射"></a>D.中间操作–映射</h5><h6 id="①map-Function-f"><a href="#①map-Function-f" class="headerlink" title="①map(Function f)"></a>①map(Function f)</h6><p>  ​map(Function f)：依次遍历Stream里的每一个元素，然后按照映射规则对元素进行操作。</p><p>  ​实现：</p><p>  ​①Stream对象调用map方法，往map方法的形参中传入实现Function接口的实现类的对象。</p><p>  ​②在Function接口的抽象方法中写映射的规则</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"> list1.add(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line"> list1.add(<span class="string">&quot;bb&quot;</span>);</span><br><span class="line"> list1.add(<span class="string">&quot;cc&quot;</span>);</span><br><span class="line"> Stream&lt;String&gt; stream = list1.stream();</span><br><span class="line"> stream.map(<span class="keyword">new</span> <span class="title class_">Function</span>&lt;String, Object&gt;() &#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> Object <span class="title function_">apply</span><span class="params">(String string)</span> &#123;</span><br><span class="line">         <span class="comment">//映射规则</span></span><br><span class="line">         <span class="keyword">return</span> string.toUpperCase();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;).forEach(System.out::println);</span><br><span class="line"><span class="comment">//将6-12行代码用Lambda表达式表示</span></span><br><span class="line"><span class="comment">//stream.map(str -&gt; str.toUpperCase()).forEach(System.out::println);</span></span><br><span class="line"><span class="comment">//运行结果：AA,BB,CC</span></span><br></pre></td></tr></table></figure><h6 id="②flatMap-Function-f-不会"><a href="#②flatMap-Function-f-不会" class="headerlink" title="②flatMap(Function f)     不会"></a>②flatMap(Function f)     不会</h6><p>  ​将流中的每个值都换成另一个流，然后把所有流连接成一个流</p><h5 id="E-中间操作–排序"><a href="#E-中间操作–排序" class="headerlink" title="E.中间操作–排序"></a>E.中间操作–排序</h5><p>  ​对集合或数组中的元素进行排序操作</p><h6 id="①sorted-自然排序"><a href="#①sorted-自然排序" class="headerlink" title="①sorted()  自然排序"></a>①sorted()  自然排序</h6><p>  ​使用要求：集合中的元素或数组中的元素所在类要实现Comparable接口。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    ArrayList&lt;Person&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">12</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jerry&quot;</span>,<span class="number">22</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jack&quot;</span>,<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    list.stream().sorted().forEach(System.out::println);</span><br><span class="line">    <span class="comment">//sorted方法实际上调用的是Person类里的compareTo方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="②sorted-Comparator-com-定制排序"><a href="#②sorted-Comparator-com-定制排序" class="headerlink" title="②sorted(Comparator com)  定制排序"></a>②sorted(Comparator com)  定制排序</h6><p>  ​参数里放实现了Comparator接口的实现类的对象</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    ArrayList&lt;Person&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">12</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jerry&quot;</span>,<span class="number">22</span>));</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jack&quot;</span>,<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//定制排序</span></span><br><span class="line">    list.stream().sorted(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Person&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Person o1, Person o2)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> o1.getName().compareTo(o2.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//如果使用Lambda表达式则这样写：</span></span><br><span class="line"><span class="comment">//list.stream().sorted(((o1, o2) -&gt; o1.getName().compareTo(o2.getName()))).forEach(System.out::println);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="F-终结操作–匹配与查找"><a href="#F-终结操作–匹配与查找" class="headerlink" title="F.终结操作–匹配与查找"></a>F.终结操作–匹配与查找</h5><h6 id="①allMatch-Predicate-p"><a href="#①allMatch-Predicate-p" class="headerlink" title="①allMatch(Predicate p)"></a>①allMatch(Predicate p)</h6><ul><li>判断集合中或数组中的元素是否都满足Predicate接口中抽象方法里的操作，只有都返回true，allMatch才返回true。</li><li>匹配规则写在Predicate接口中的抽象方法里。</li></ul><h6 id="②anyMatch-Predicate-p"><a href="#②anyMatch-Predicate-p" class="headerlink" title="②anyMatch(Predicate p)"></a>②anyMatch(Predicate p)</h6><ul><li>判断集合或数组中的元素是否满足Predicate接口中的抽象方法里的匹配规则，只要有一个元素满足，则返回true。</li><li>匹配规则写在Predicate接口中的抽象方法里。</li></ul><h6 id="③noneMatch-Predicate-p"><a href="#③noneMatch-Predicate-p" class="headerlink" title="③noneMatch(Predicate p)"></a>③noneMatch(Predicate p)</h6><ul><li>检查数组或集合中是否没有匹配的元素，返回布偶值。</li><li>匹配规则写在Predicate接口中的抽象方法里。</li></ul><h6 id="④findFirst"><a href="#④findFirst" class="headerlink" title="④findFirst()"></a>④findFirst()</h6><ul><li>返回当前Stream里的第一个元素。</li></ul><h6 id="⑤findAny"><a href="#⑤findAny" class="headerlink" title="⑤findAny()"></a>⑤findAny()</h6><ul><li>返回当前流中的任意一个元素。</li></ul><h6 id="⑥count"><a href="#⑥count" class="headerlink" title="⑥count()"></a>⑥count()</h6><ul><li>返回流中元素的个数。</li></ul><h6 id="⑦max-Comparator-c"><a href="#⑦max-Comparator-c" class="headerlink" title="⑦max(Comparator c)"></a>⑦max(Comparator c)</h6><ul><li>返回流中最大值，将比较的规则写在Comparator接口里的抽象方法中。</li><li>Comparator属于函数式接口，可以使用Lambda表达式。</li></ul><h6 id="⑧min-Comparator-c"><a href="#⑧min-Comparator-c" class="headerlink" title="⑧min(Comparator c)"></a>⑧min(Comparator c)</h6><ul><li>返回流中最小值，将比较的规则写在Comparator接口里的抽象方法中。</li><li>Comparator属于函数式接口，可以使用Lambda表达式。</li></ul><h6 id="⑨forEach-Consumer-c"><a href="#⑨forEach-Consumer-c" class="headerlink" title="⑨forEach(Consumer c)"></a>⑨forEach(Consumer c)</h6><ul><li><p>内部迭代，通常这样写：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">forEach(System.out::print);<span class="comment">//对流中的元素进行遍历输出</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="G-终结操作–规约"><a href="#G-终结操作–规约" class="headerlink" title="G.终结操作–规约"></a>G.终结操作–规约</h5><p>  ​规约：即求和操作</p><h6 id="①reduce-T-identity-BinaryOperator"><a href="#①reduce-T-identity-BinaryOperator" class="headerlink" title="①reduce(T identity,BinaryOperator)"></a>①reduce(T identity,BinaryOperator)</h6><p>  ​将流中的元素反复累加起来，得到一个值。相当于求和操作。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算1-10的自然数的和</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>);</span><br><span class="line">    <span class="comment">//reduce里的第一个参数为：累加的初始值</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">reduce</span> <span class="operator">=</span> list.stream().reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line">    <span class="comment">//Integer::sum含义：调用Integer里的sum方法</span></span><br><span class="line">    System.out.println(reduce);<span class="comment">//55</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="②reduce-BinaryOperator"><a href="#②reduce-BinaryOperator" class="headerlink" title="②reduce(BinaryOperator)"></a>②reduce(BinaryOperator)</h6><p>  ​将流中元素反复累加起来，得到一个值，返回Optional<T>。与上面的一样，只是少了一个参数identity来指定累加的初始值。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算1-10的自然数的和</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">Integer</span> <span class="variable">reduce</span> <span class="operator">=</span> list.stream().reduce(Integer::sum);</span><br><span class="line">    <span class="comment">//Integer::sum含义：调用Integer里的sum方法</span></span><br><span class="line">    System.out.println(reduce);<span class="comment">//55</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="H-终结操作–收集"><a href="#H-终结操作–收集" class="headerlink" title="H.终结操作–收集"></a>H.终结操作–收集</h5><h6 id="①collect-Collector-c"><a href="#①collect-Collector-c" class="headerlink" title="①collect(Collector c)"></a>①collect(Collector c)</h6><p>  ​<strong>方法作用</strong>：将Stream里的数据存储到集合（List、Map、set）中，并返回对应集合的对象。</p><p>  ​Collector是接口，我们使用Collectors中的静态方法来返回一个Collector实现类的对象。</p><p>  ​如果想将Stream里的数据放到：</p><ul><li>放到List中，将“Collectors.toList()”放到形参中即可</li><li>放到Set中，将“Collectors.toSet()”放到形参中即可</li><li>放到Map中2，将“Collectors.toMap()”放到形参中即可</li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>);</span><br><span class="line">    List&lt;Integer&gt; list1 = list.stream().filter(i -&gt; i &gt; <span class="number">5</span>).collect(Collectors.toList());</span><br><span class="line">    System.out.println(list1);<span class="comment">//[6, 7, 8, 9, 10]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="12、Java8新特性—Optional类"><a href="#12、Java8新特性—Optional类" class="headerlink" title="12、Java8新特性—Optional类"></a>12、Java8新特性—Optional类</h4><h5 id="①概述-14"><a href="#①概述-14" class="headerlink" title="①概述"></a>①概述</h5><p>  ​为了避免出现空指针异常的情况，我们引入了Optional类。 </p><p>  ​Optional&lt; T t &gt; 类(java.util.Optional) 是一个容器类，它可以将 t 的地址值赋给Optional的属性value，代表这个值存在。或者仅仅保存null，表示这个值不存在。原来用 null 表示一个值不存在，现在 Optional 可以更好的表达这个概念。并且可以避免空指针异常。</p><h5 id="②Optional类的方法"><a href="#②Optional类的方法" class="headerlink" title="②Optional类的方法"></a>②Optional类的方法</h5><h6 id="A-创建Optional类对象的方法"><a href="#A-创建Optional类对象的方法" class="headerlink" title="A.创建Optional类对象的方法"></a>A.创建Optional类对象的方法</h6><p>  ​→ Optional.of(T t) : 封装数据 t 生成Optional对象，并将数据 t 的地址值赋给Optional内部的value。要求 t 非空，否则报错  </p><p>  ​→ Optional.empty() : 创建了一个Optional对象，但其内部的value &#x3D; null。</p><p>  ​→ **Optional.ofNullable(T t)**：封装数据 t 并将数据 t 的地址值赋给Optional内部的value，生成Optional对象。不要求 t 非空。 </p><h6 id="B-常用方法"><a href="#B-常用方法" class="headerlink" title="B.常用方法"></a>B.常用方法</h6><ol><li><p><strong>T orElse(T t1)</strong>      —-&gt; 该方法与ofNullable(T t)搭配使用</p><ul><li>该方法通过Optional类的对象去调用，Optional内部封装的value值或 t1</li><li>如果的当前的Optional对象内部封装的 value 是非空的，则返回此value值 。<ul><li>如果内部的 value 是空的，则返回orElse()方法中的参数 t1 。</li></ul></li></ul></li><li><p>T get()    ——&gt; 该方法与of(T t)搭配使用</p><ul><li>该方法通过Optional类的对象去调用。</li><li>如果Optional封装的数据value为空，则get()报错。否则，value不为空时，返回value。</li></ul> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    Optional&lt;String&gt; optionalS = Optional.ofNullable(s);</span><br><span class="line">    System.out.println(optionalS.get());<span class="comment">//hello</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>boolean isPresent()</p><ul><li>该方法通过Optional类的对象去调用。</li><li>判断当前的Optional对象内部封装的 value 是否有值，有值返回true。</li></ul></li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDBC </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
